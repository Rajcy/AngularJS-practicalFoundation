From: =?gb2312?B?0tHTySBJbnRlcm5ldCBFeHBsb3JlciAxMSCxo7Tm?=
Subject: 
Date: Wed, 16 Aug 2017 17:42:33 +0800
MIME-Version: 1.0
Content-Type: text/html;
	charset="gb2312"
Content-Transfer-Encoding: quoted-printable
Content-Location: https://code.angularjs.org/1.6.5/angular.js
X-MimeOLE: Produced By Microsoft MimeOLE

<!DOCTYPE HTML>
<!DOCTYPE html PUBLIC "" ""><HTML><HEAD><META content=3D"IE=3D11.0000"=20
http-equiv=3D"X-UA-Compatible">

<META http-equiv=3D"Content-Type" content=3D"text/html; =
charset=3Dgb2312">
<META name=3D"GENERATOR" content=3D"MSHTML 11.00.10570.1001"></HEAD>
<BODY>
<PRE>/**=0A=
 * @license AngularJS v1.6.5=0A=
 * (c) 2010-2017 Google, Inc. http://angularjs.org=0A=
 * License: MIT=0A=
 */=0A=
(function(window) {'use strict';=0A=
=0A=
/* exported=0A=
  minErrConfig,=0A=
  errorHandlingConfig,=0A=
  isValidObjectMaxDepth=0A=
*/=0A=
=0A=
var minErrConfig =3D {=0A=
  objectMaxDepth: 5=0A=
};=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.errorHandlingConfig=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Configure several aspects of error handling in AngularJS if used as a =
setter or return the=0A=
 * current configuration if used as a getter. The following options are =
supported:=0A=
 *=0A=
 * - **objectMaxDepth**: The maximum depth to which objects are =
traversed when stringified for error messages.=0A=
 *=0A=
 * Omitted or undefined options will leave the corresponding =
configuration values unchanged.=0A=
 *=0A=
 * @param {Object=3D} config - The configuration object. May only =
contain the options that need to be=0A=
 *     updated. Supported keys:=0A=
 *=0A=
 * * `objectMaxDepth`  **{Number}** - The max depth for stringifying =
objects. Setting to a=0A=
 *   non-positive or non-numeric value, removes the max depth limit.=0A=
 *   Default: 5=0A=
 */=0A=
function errorHandlingConfig(config) {=0A=
  if (isObject(config)) {=0A=
    if (isDefined(config.objectMaxDepth)) {=0A=
      minErrConfig.objectMaxDepth =3D =
isValidObjectMaxDepth(config.objectMaxDepth) ? config.objectMaxDepth : =
NaN;=0A=
    }=0A=
  } else {=0A=
    return minErrConfig;=0A=
  }=0A=
}=0A=
=0A=
/**=0A=
 * @private=0A=
 * @param {Number} maxDepth=0A=
 * @return {boolean}=0A=
 */=0A=
function isValidObjectMaxDepth(maxDepth) {=0A=
  return isNumber(maxDepth) &amp;&amp; maxDepth &gt; 0;=0A=
}=0A=
=0A=
/**=0A=
 * @description=0A=
 *=0A=
 * This object provides a utility for producing rich Error messages =
within=0A=
 * Angular. It can be called as follows:=0A=
 *=0A=
 * var exampleMinErr =3D minErr('example');=0A=
 * throw exampleMinErr('one', 'This {0} is {1}', foo, bar);=0A=
 *=0A=
 * The above creates an instance of minErr in the example namespace. The=0A=
 * resulting error will have a namespaced error code of example.one.  The=0A=
 * resulting error will replace {0} with the value of foo, and {1} with =
the=0A=
 * value of bar. The object is not restricted in the number of arguments =
it can=0A=
 * take.=0A=
 *=0A=
 * If fewer arguments are specified than necessary for interpolation, =
the extra=0A=
 * interpolation markers will be preserved in the final string.=0A=
 *=0A=
 * Since data will be parsed statically during a build step, some =
restrictions=0A=
 * are applied with respect to how minErr instances are created and =
called.=0A=
 * Instances should have names of the form namespaceMinErr for a minErr =
created=0A=
 * using minErr('namespace') . Error codes, namespaces and template =
strings=0A=
 * should all be static strings, not variables or general expressions.=0A=
 *=0A=
 * @param {string} module The namespace to use for the new minErr =
instance.=0A=
 * @param {function} ErrorConstructor Custom error constructor to be =
instantiated when returning=0A=
 *   error from returned function, for cases when a particular type of =
error is useful.=0A=
 * @returns {function(code:string, template:string, ...templateArgs): =
Error} minErr instance=0A=
 */=0A=
=0A=
function minErr(module, ErrorConstructor) {=0A=
  ErrorConstructor =3D ErrorConstructor || Error;=0A=
  return function() {=0A=
    var code =3D arguments[0],=0A=
      template =3D arguments[1],=0A=
      message =3D '[' + (module ? module + ':' : '') + code + '] ',=0A=
      templateArgs =3D sliceArgs(arguments, 2).map(function(arg) {=0A=
        return toDebugString(arg, minErrConfig.objectMaxDepth);=0A=
      }),=0A=
      paramPrefix, i;=0A=
=0A=
    message +=3D template.replace(/\{\d+\}/g, function(match) {=0A=
      var index =3D +match.slice(1, -1);=0A=
=0A=
      if (index &lt; templateArgs.length) {=0A=
        return templateArgs[index];=0A=
      }=0A=
=0A=
      return match;=0A=
    });=0A=
=0A=
    message +=3D '\nhttp://errors.angularjs.org/1.6.5/' +=0A=
      (module ? module + '/' : '') + code;=0A=
=0A=
    for (i =3D 0, paramPrefix =3D '?'; i &lt; templateArgs.length; i++, =
paramPrefix =3D '&amp;') {=0A=
      message +=3D paramPrefix + 'p' + i + '=3D' + =
encodeURIComponent(templateArgs[i]);=0A=
    }=0A=
=0A=
    return new ErrorConstructor(message);=0A=
  };=0A=
}=0A=
=0A=
/* We need to tell ESLint what variables are being exported */=0A=
/* exported=0A=
  angular,=0A=
  msie,=0A=
  jqLite,=0A=
  jQuery,=0A=
  slice,=0A=
  splice,=0A=
  push,=0A=
  toString,=0A=
  minErrConfig,=0A=
  errorHandlingConfig,=0A=
  isValidObjectMaxDepth,=0A=
  ngMinErr,=0A=
  angularModule,=0A=
  uid,=0A=
  REGEX_STRING_REGEXP,=0A=
  VALIDITY_STATE_PROPERTY,=0A=
=0A=
  lowercase,=0A=
  uppercase,=0A=
  manualLowercase,=0A=
  manualUppercase,=0A=
  nodeName_,=0A=
  isArrayLike,=0A=
  forEach,=0A=
  forEachSorted,=0A=
  reverseParams,=0A=
  nextUid,=0A=
  setHashKey,=0A=
  extend,=0A=
  toInt,=0A=
  inherit,=0A=
  merge,=0A=
  noop,=0A=
  identity,=0A=
  valueFn,=0A=
  isUndefined,=0A=
  isDefined,=0A=
  isObject,=0A=
  isBlankObject,=0A=
  isString,=0A=
  isNumber,=0A=
  isNumberNaN,=0A=
  isDate,=0A=
  isError,=0A=
  isArray,=0A=
  isFunction,=0A=
  isRegExp,=0A=
  isWindow,=0A=
  isScope,=0A=
  isFile,=0A=
  isFormData,=0A=
  isBlob,=0A=
  isBoolean,=0A=
  isPromiseLike,=0A=
  trim,=0A=
  escapeForRegexp,=0A=
  isElement,=0A=
  makeMap,=0A=
  includes,=0A=
  arrayRemove,=0A=
  copy,=0A=
  simpleCompare,=0A=
  equals,=0A=
  csp,=0A=
  jq,=0A=
  concat,=0A=
  sliceArgs,=0A=
  bind,=0A=
  toJsonReplacer,=0A=
  toJson,=0A=
  fromJson,=0A=
  convertTimezoneToLocal,=0A=
  timezoneToOffset,=0A=
  startingTag,=0A=
  tryDecodeURIComponent,=0A=
  parseKeyValue,=0A=
  toKeyValue,=0A=
  encodeUriSegment,=0A=
  encodeUriQuery,=0A=
  angularInit,=0A=
  bootstrap,=0A=
  getTestability,=0A=
  snake_case,=0A=
  bindJQuery,=0A=
  assertArg,=0A=
  assertArgFn,=0A=
  assertNotHasOwnProperty,=0A=
  getter,=0A=
  getBlockNodes,=0A=
  hasOwnProperty,=0A=
  createMap,=0A=
  stringify,=0A=
=0A=
  NODE_TYPE_ELEMENT,=0A=
  NODE_TYPE_ATTRIBUTE,=0A=
  NODE_TYPE_TEXT,=0A=
  NODE_TYPE_COMMENT,=0A=
  NODE_TYPE_DOCUMENT,=0A=
  NODE_TYPE_DOCUMENT_FRAGMENT=0A=
*/=0A=
=0A=
////////////////////////////////////=0A=
=0A=
/**=0A=
 * @ngdoc module=0A=
 * @name ng=0A=
 * @module ng=0A=
 * @installation=0A=
 * @description=0A=
 *=0A=
 * # ng (core module)=0A=
 * The ng module is loaded by default when an AngularJS application is =
started. The module itself=0A=
 * contains the essential components for an AngularJS application to =
function. The table below=0A=
 * lists a high level breakdown of each of the services/factories, =
filters, directives and testing=0A=
 * components available within this core module.=0A=
 *=0A=
 * &lt;div doc-module-components=3D"ng"&gt;&lt;/div&gt;=0A=
 */=0A=
=0A=
var REGEX_STRING_REGEXP =3D /^\/(.+)\/([a-z]*)$/;=0A=
=0A=
// The name of a form control's ValidityState property.=0A=
// This is used so that it's possible for internal tests to create mock =
ValidityStates.=0A=
var VALIDITY_STATE_PROPERTY =3D 'validity';=0A=
=0A=
=0A=
var hasOwnProperty =3D Object.prototype.hasOwnProperty;=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.lowercase=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @deprecated=0A=
 * sinceVersion=3D"1.5.0"=0A=
 * removeVersion=3D"1.7.0"=0A=
 * Use =
[String.prototype.toLowerCase](https://developer.mozilla.org/docs/Web/Jav=
aScript/Reference/Global_Objects/String/toLowerCase) instead.=0A=
 *=0A=
 * @description Converts the specified string to lowercase.=0A=
 * @param {string} string String to be converted to lowercase.=0A=
 * @returns {string} Lowercased string.=0A=
 */=0A=
var lowercase =3D function(string) {return isString(string) ? =
string.toLowerCase() : string;};=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.uppercase=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @deprecated=0A=
 * sinceVersion=3D"1.5.0"=0A=
 * removeVersion=3D"1.7.0"=0A=
 * Use =
[String.prototype.toUpperCase](https://developer.mozilla.org/docs/Web/Jav=
aScript/Reference/Global_Objects/String/toUpperCase) instead.=0A=
 *=0A=
 * @description Converts the specified string to uppercase.=0A=
 * @param {string} string String to be converted to uppercase.=0A=
 * @returns {string} Uppercased string.=0A=
 */=0A=
var uppercase =3D function(string) {return isString(string) ? =
string.toUpperCase() : string;};=0A=
=0A=
=0A=
var manualLowercase =3D function(s) {=0A=
  /* eslint-disable no-bitwise */=0A=
  return isString(s)=0A=
      ? s.replace(/[A-Z]/g, function(ch) {return =
String.fromCharCode(ch.charCodeAt(0) | 32);})=0A=
      : s;=0A=
  /* eslint-enable */=0A=
};=0A=
var manualUppercase =3D function(s) {=0A=
  /* eslint-disable no-bitwise */=0A=
  return isString(s)=0A=
      ? s.replace(/[a-z]/g, function(ch) {return =
String.fromCharCode(ch.charCodeAt(0) &amp; ~32);})=0A=
      : s;=0A=
  /* eslint-enable */=0A=
};=0A=
=0A=
=0A=
// String#toLowerCase and String#toUpperCase don't produce correct =
results in browsers with Turkish=0A=
// locale, for this reason we need to detect this case and redefine =
lowercase/uppercase methods=0A=
// with correct but slower alternatives. See =
https://github.com/angular/angular.js/issues/11387=0A=
if ('i' !=3D=3D 'I'.toLowerCase()) {=0A=
  lowercase =3D manualLowercase;=0A=
  uppercase =3D manualUppercase;=0A=
}=0A=
=0A=
=0A=
var=0A=
    msie,             // holds major version number for IE, or NaN if UA =
is not IE.=0A=
    jqLite,           // delay binding since jQuery could be loaded =
after us.=0A=
    jQuery,           // delay binding=0A=
    slice             =3D [].slice,=0A=
    splice            =3D [].splice,=0A=
    push              =3D [].push,=0A=
    toString          =3D Object.prototype.toString,=0A=
    getPrototypeOf    =3D Object.getPrototypeOf,=0A=
    ngMinErr          =3D minErr('ng'),=0A=
=0A=
    /** @name angular */=0A=
    angular           =3D window.angular || (window.angular =3D {}),=0A=
    angularModule,=0A=
    uid               =3D 0;=0A=
=0A=
// Support: IE 9-11 only=0A=
/**=0A=
 * documentMode is an IE-only property=0A=
 * http://msdn.microsoft.com/en-us/library/ie/cc196988(v=3Dvs.85).aspx=0A=
 */=0A=
msie =3D window.document.documentMode;=0A=
=0A=
=0A=
/**=0A=
 * @private=0A=
 * @param {*} obj=0A=
 * @return {boolean} Returns true if `obj` is an array or array-like =
object (NodeList, Arguments,=0A=
 *                   String ...)=0A=
 */=0A=
function isArrayLike(obj) {=0A=
=0A=
  // `null`, `undefined` and `window` are not array-like=0A=
  if (obj =3D=3D null || isWindow(obj)) return false;=0A=
=0A=
  // arrays, strings and jQuery/jqLite objects are array like=0A=
  // * jqLite is either the jQuery or jqLite constructor function=0A=
  // * we have to check the existence of jqLite first as this method is =
called=0A=
  //   via the forEach method when constructing the jqLite object in the =
first place=0A=
  if (isArray(obj) || isString(obj) || (jqLite &amp;&amp; obj instanceof =
jqLite)) return true;=0A=
=0A=
  // Support: iOS 8.2 (not reproducible in simulator)=0A=
  // "length" in obj used to prevent JIT error (gh-11508)=0A=
  var length =3D 'length' in Object(obj) &amp;&amp; obj.length;=0A=
=0A=
  // NodeList objects (with `item` method) and=0A=
  // other objects with suitable length characteristics are array-like=0A=
  return isNumber(length) &amp;&amp;=0A=
    (length &gt;=3D 0 &amp;&amp; ((length - 1) in obj || obj instanceof =
Array) || typeof obj.item =3D=3D=3D 'function');=0A=
=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.forEach=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Invokes the `iterator` function once for each item in `obj` =
collection, which can be either an=0A=
 * object or an array. The `iterator` function is invoked with =
`iterator(value, key, obj)`, where `value`=0A=
 * is the value of an object property or an array element, `key` is the =
object property key or=0A=
 * array element index and obj is the `obj` itself. Specifying a =
`context` for the function is optional.=0A=
 *=0A=
 * It is worth noting that `.forEach` does not iterate over inherited =
properties because it filters=0A=
 * using the `hasOwnProperty` method.=0A=
 *=0A=
 * Unlike ES262's=0A=
 * =
[Array.prototype.forEach](http://www.ecma-international.org/ecma-262/5.1/=
#sec-15.4.4.18),=0A=
 * providing 'undefined' or 'null' values for `obj` will not throw a =
TypeError, but rather just=0A=
 * return the value provided.=0A=
 *=0A=
   ```js=0A=
     var values =3D {name: 'misko', gender: 'male'};=0A=
     var log =3D [];=0A=
     angular.forEach(values, function(value, key) {=0A=
       this.push(key + ': ' + value);=0A=
     }, log);=0A=
     expect(log).toEqual(['name: misko', 'gender: male']);=0A=
   ```=0A=
 *=0A=
 * @param {Object|Array} obj Object to iterate over.=0A=
 * @param {Function} iterator Iterator function.=0A=
 * @param {Object=3D} context Object to become context (`this`) for the =
iterator function.=0A=
 * @returns {Object|Array} Reference to `obj`.=0A=
 */=0A=
=0A=
function forEach(obj, iterator, context) {=0A=
  var key, length;=0A=
  if (obj) {=0A=
    if (isFunction(obj)) {=0A=
      for (key in obj) {=0A=
        if (key !=3D=3D 'prototype' &amp;&amp; key !=3D=3D 'length' =
&amp;&amp; key !=3D=3D 'name' &amp;&amp; obj.hasOwnProperty(key)) {=0A=
          iterator.call(context, obj[key], key, obj);=0A=
        }=0A=
      }=0A=
    } else if (isArray(obj) || isArrayLike(obj)) {=0A=
      var isPrimitive =3D typeof obj !=3D=3D 'object';=0A=
      for (key =3D 0, length =3D obj.length; key &lt; length; key++) {=0A=
        if (isPrimitive || key in obj) {=0A=
          iterator.call(context, obj[key], key, obj);=0A=
        }=0A=
      }=0A=
    } else if (obj.forEach &amp;&amp; obj.forEach !=3D=3D forEach) {=0A=
        obj.forEach(iterator, context, obj);=0A=
    } else if (isBlankObject(obj)) {=0A=
      // createMap() fast path --- Safe to avoid hasOwnProperty check =
because prototype chain is empty=0A=
      for (key in obj) {=0A=
        iterator.call(context, obj[key], key, obj);=0A=
      }=0A=
    } else if (typeof obj.hasOwnProperty =3D=3D=3D 'function') {=0A=
      // Slow path for objects inheriting Object.prototype, =
hasOwnProperty check needed=0A=
      for (key in obj) {=0A=
        if (obj.hasOwnProperty(key)) {=0A=
          iterator.call(context, obj[key], key, obj);=0A=
        }=0A=
      }=0A=
    } else {=0A=
      // Slow path for objects which do not have a method =
`hasOwnProperty`=0A=
      for (key in obj) {=0A=
        if (hasOwnProperty.call(obj, key)) {=0A=
          iterator.call(context, obj[key], key, obj);=0A=
        }=0A=
      }=0A=
    }=0A=
  }=0A=
  return obj;=0A=
}=0A=
=0A=
function forEachSorted(obj, iterator, context) {=0A=
  var keys =3D Object.keys(obj).sort();=0A=
  for (var i =3D 0; i &lt; keys.length; i++) {=0A=
    iterator.call(context, obj[keys[i]], keys[i]);=0A=
  }=0A=
  return keys;=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * when using forEach the params are value, key, but it is often useful =
to have key, value.=0A=
 * @param {function(string, *)} iteratorFn=0A=
 * @returns {function(*, string)}=0A=
 */=0A=
function reverseParams(iteratorFn) {=0A=
  return function(value, key) {iteratorFn(key, value);};=0A=
}=0A=
=0A=
/**=0A=
 * A consistent way of creating unique IDs in angular.=0A=
 *=0A=
 * Using simple numbers allows us to generate 28.6 million unique ids =
per second for 10 years before=0A=
 * we hit number precision issues in JavaScript.=0A=
 *=0A=
 * Math.pow(2,53) / 60 / 60 / 24 / 365 / 10 =3D 28.6M=0A=
 *=0A=
 * @returns {number} an unique alpha-numeric string=0A=
 */=0A=
function nextUid() {=0A=
  return ++uid;=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * Set or clear the hashkey for an object.=0A=
 * @param obj object=0A=
 * @param h the hashkey (!truthy to delete the hashkey)=0A=
 */=0A=
function setHashKey(obj, h) {=0A=
  if (h) {=0A=
    obj.$$hashKey =3D h;=0A=
  } else {=0A=
    delete obj.$$hashKey;=0A=
  }=0A=
}=0A=
=0A=
=0A=
function baseExtend(dst, objs, deep) {=0A=
  var h =3D dst.$$hashKey;=0A=
=0A=
  for (var i =3D 0, ii =3D objs.length; i &lt; ii; ++i) {=0A=
    var obj =3D objs[i];=0A=
    if (!isObject(obj) &amp;&amp; !isFunction(obj)) continue;=0A=
    var keys =3D Object.keys(obj);=0A=
    for (var j =3D 0, jj =3D keys.length; j &lt; jj; j++) {=0A=
      var key =3D keys[j];=0A=
      var src =3D obj[key];=0A=
=0A=
      if (deep &amp;&amp; isObject(src)) {=0A=
        if (isDate(src)) {=0A=
          dst[key] =3D new Date(src.valueOf());=0A=
        } else if (isRegExp(src)) {=0A=
          dst[key] =3D new RegExp(src);=0A=
        } else if (src.nodeName) {=0A=
          dst[key] =3D src.cloneNode(true);=0A=
        } else if (isElement(src)) {=0A=
          dst[key] =3D src.clone();=0A=
        } else {=0A=
          if (!isObject(dst[key])) dst[key] =3D isArray(src) ? [] : {};=0A=
          baseExtend(dst[key], [src], true);=0A=
        }=0A=
      } else {=0A=
        dst[key] =3D src;=0A=
      }=0A=
    }=0A=
  }=0A=
=0A=
  setHashKey(dst, h);=0A=
  return dst;=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.extend=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Extends the destination object `dst` by copying own enumerable =
properties from the `src` object(s)=0A=
 * to `dst`. You can specify multiple `src` objects. If you want to =
preserve original objects, you can do so=0A=
 * by passing an empty object as the target: `var object =3D =
angular.extend({}, object1, object2)`.=0A=
 *=0A=
 * **Note:** Keep in mind that `angular.extend` does not support =
recursive merge (deep copy). Use=0A=
 * {@link angular.merge} for this.=0A=
 *=0A=
 * @param {Object} dst Destination object.=0A=
 * @param {...Object} src Source object(s).=0A=
 * @returns {Object} Reference to `dst`.=0A=
 */=0A=
function extend(dst) {=0A=
  return baseExtend(dst, slice.call(arguments, 1), false);=0A=
}=0A=
=0A=
=0A=
/**=0A=
* @ngdoc function=0A=
* @name angular.merge=0A=
* @module ng=0A=
* @kind function=0A=
*=0A=
* @description=0A=
* Deeply extends the destination object `dst` by copying own enumerable =
properties from the `src` object(s)=0A=
* to `dst`. You can specify multiple `src` objects. If you want to =
preserve original objects, you can do so=0A=
* by passing an empty object as the target: `var object =3D =
angular.merge({}, object1, object2)`.=0A=
*=0A=
* Unlike {@link angular.extend extend()}, `merge()` recursively descends =
into object properties of source=0A=
* objects, performing a deep copy.=0A=
*=0A=
* @deprecated=0A=
* sinceVersion=3D"1.6.5"=0A=
* This function is deprecated, but will not be removed in the 1.x =
lifecycle.=0A=
* There are edge cases (see {@link angular.merge#known-issues known =
issues}) that are not=0A=
* supported by this function. We suggest=0A=
* using [lodash's merge()](https://lodash.com/docs/4.17.4#merge) instead.=0A=
*=0A=
* @knownIssue=0A=
* This is a list of (known) object types that are not handled correctly =
by this function:=0A=
* - [`Blob`](https://developer.mozilla.org/docs/Web/API/Blob)=0A=
* - =
[`MediaStream`](https://developer.mozilla.org/docs/Web/API/MediaStream)=0A=
* - =
[`CanvasGradient`](https://developer.mozilla.org/docs/Web/API/CanvasGradi=
ent)=0A=
* - AngularJS {@link $rootScope.Scope scopes};=0A=
*=0A=
* @param {Object} dst Destination object.=0A=
* @param {...Object} src Source object(s).=0A=
* @returns {Object} Reference to `dst`.=0A=
*/=0A=
function merge(dst) {=0A=
  return baseExtend(dst, slice.call(arguments, 1), true);=0A=
}=0A=
=0A=
=0A=
=0A=
function toInt(str) {=0A=
  return parseInt(str, 10);=0A=
}=0A=
=0A=
var isNumberNaN =3D Number.isNaN || function isNumberNaN(num) {=0A=
  // eslint-disable-next-line no-self-compare=0A=
  return num !=3D=3D num;=0A=
};=0A=
=0A=
=0A=
function inherit(parent, extra) {=0A=
  return extend(Object.create(parent), extra);=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.noop=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * A function that performs no operations. This function can be useful =
when writing code in the=0A=
 * functional style.=0A=
   ```js=0A=
     function foo(callback) {=0A=
       var result =3D calculateResult();=0A=
       (callback || angular.noop)(result);=0A=
     }=0A=
   ```=0A=
 */=0A=
function noop() {}=0A=
noop.$inject =3D [];=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.identity=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * A function that returns its first argument. This function is useful =
when writing code in the=0A=
 * functional style.=0A=
 *=0A=
   ```js=0A=
   function transformer(transformationFn, value) {=0A=
     return (transformationFn || angular.identity)(value);=0A=
   };=0A=
=0A=
   // E.g.=0A=
   function getResult(fn, input) {=0A=
     return (fn || angular.identity)(input);=0A=
   };=0A=
=0A=
   getResult(function(n) { return n * 2; }, 21);   // returns 42=0A=
   getResult(null, 21);                            // returns 21=0A=
   getResult(undefined, 21);                       // returns 21=0A=
   ```=0A=
 *=0A=
 * @param {*} value to be returned.=0A=
 * @returns {*} the value passed in.=0A=
 */=0A=
function identity($) {return $;}=0A=
identity.$inject =3D [];=0A=
=0A=
=0A=
function valueFn(value) {return function valueRef() {return value;};}=0A=
=0A=
function hasCustomToString(obj) {=0A=
  return isFunction(obj.toString) &amp;&amp; obj.toString !=3D=3D =
toString;=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.isUndefined=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Determines if a reference is undefined.=0A=
 *=0A=
 * @param {*} value Reference to check.=0A=
 * @returns {boolean} True if `value` is undefined.=0A=
 */=0A=
function isUndefined(value) {return typeof value =3D=3D=3D 'undefined';}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.isDefined=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Determines if a reference is defined.=0A=
 *=0A=
 * @param {*} value Reference to check.=0A=
 * @returns {boolean} True if `value` is defined.=0A=
 */=0A=
function isDefined(value) {return typeof value !=3D=3D 'undefined';}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.isObject=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Determines if a reference is an `Object`. Unlike `typeof` in =
JavaScript, `null`s are not=0A=
 * considered to be objects. Note that JavaScript arrays are objects.=0A=
 *=0A=
 * @param {*} value Reference to check.=0A=
 * @returns {boolean} True if `value` is an `Object` but not `null`.=0A=
 */=0A=
function isObject(value) {=0A=
  // http://jsperf.com/isobject4=0A=
  return value !=3D=3D null &amp;&amp; typeof value =3D=3D=3D 'object';=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * Determine if a value is an object with a null prototype=0A=
 *=0A=
 * @returns {boolean} True if `value` is an `Object` with a null =
prototype=0A=
 */=0A=
function isBlankObject(value) {=0A=
  return value !=3D=3D null &amp;&amp; typeof value =3D=3D=3D 'object' =
&amp;&amp; !getPrototypeOf(value);=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.isString=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Determines if a reference is a `String`.=0A=
 *=0A=
 * @param {*} value Reference to check.=0A=
 * @returns {boolean} True if `value` is a `String`.=0A=
 */=0A=
function isString(value) {return typeof value =3D=3D=3D 'string';}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.isNumber=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Determines if a reference is a `Number`.=0A=
 *=0A=
 * This includes the "special" numbers `NaN`, `+Infinity` and =
`-Infinity`.=0A=
 *=0A=
 * If you wish to exclude these then you can use the native=0A=
 * =
[`isFinite'](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Refe=
rence/Global_Objects/isFinite)=0A=
 * method.=0A=
 *=0A=
 * @param {*} value Reference to check.=0A=
 * @returns {boolean} True if `value` is a `Number`.=0A=
 */=0A=
function isNumber(value) {return typeof value =3D=3D=3D 'number';}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.isDate=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Determines if a value is a date.=0A=
 *=0A=
 * @param {*} value Reference to check.=0A=
 * @returns {boolean} True if `value` is a `Date`.=0A=
 */=0A=
function isDate(value) {=0A=
  return toString.call(value) =3D=3D=3D '[object Date]';=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.isArray=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Determines if a reference is an `Array`. Alias of Array.isArray.=0A=
 *=0A=
 * @param {*} value Reference to check.=0A=
 * @returns {boolean} True if `value` is an `Array`.=0A=
 */=0A=
var isArray =3D Array.isArray;=0A=
=0A=
/**=0A=
 * @description=0A=
 * Determines if a reference is an `Error`.=0A=
 * Loosely based on https://www.npmjs.com/package/iserror=0A=
 *=0A=
 * @param {*} value Reference to check.=0A=
 * @returns {boolean} True if `value` is an `Error`.=0A=
 */=0A=
function isError(value) {=0A=
  var tag =3D toString.call(value);=0A=
  switch (tag) {=0A=
    case '[object Error]': return true;=0A=
    case '[object Exception]': return true;=0A=
    case '[object DOMException]': return true;=0A=
    default: return value instanceof Error;=0A=
  }=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.isFunction=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Determines if a reference is a `Function`.=0A=
 *=0A=
 * @param {*} value Reference to check.=0A=
 * @returns {boolean} True if `value` is a `Function`.=0A=
 */=0A=
function isFunction(value) {return typeof value =3D=3D=3D 'function';}=0A=
=0A=
=0A=
/**=0A=
 * Determines if a value is a regular expression object.=0A=
 *=0A=
 * @private=0A=
 * @param {*} value Reference to check.=0A=
 * @returns {boolean} True if `value` is a `RegExp`.=0A=
 */=0A=
function isRegExp(value) {=0A=
  return toString.call(value) =3D=3D=3D '[object RegExp]';=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * Checks if `obj` is a window object.=0A=
 *=0A=
 * @private=0A=
 * @param {*} obj Object to check=0A=
 * @returns {boolean} True if `obj` is a window obj.=0A=
 */=0A=
function isWindow(obj) {=0A=
  return obj &amp;&amp; obj.window =3D=3D=3D obj;=0A=
}=0A=
=0A=
=0A=
function isScope(obj) {=0A=
  return obj &amp;&amp; obj.$evalAsync &amp;&amp; obj.$watch;=0A=
}=0A=
=0A=
=0A=
function isFile(obj) {=0A=
  return toString.call(obj) =3D=3D=3D '[object File]';=0A=
}=0A=
=0A=
=0A=
function isFormData(obj) {=0A=
  return toString.call(obj) =3D=3D=3D '[object FormData]';=0A=
}=0A=
=0A=
=0A=
function isBlob(obj) {=0A=
  return toString.call(obj) =3D=3D=3D '[object Blob]';=0A=
}=0A=
=0A=
=0A=
function isBoolean(value) {=0A=
  return typeof value =3D=3D=3D 'boolean';=0A=
}=0A=
=0A=
=0A=
function isPromiseLike(obj) {=0A=
  return obj &amp;&amp; isFunction(obj.then);=0A=
}=0A=
=0A=
=0A=
var TYPED_ARRAY_REGEXP =3D /^\[object =
(?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Arra=
y]$/;=0A=
function isTypedArray(value) {=0A=
  return value &amp;&amp; isNumber(value.length) &amp;&amp; =
TYPED_ARRAY_REGEXP.test(toString.call(value));=0A=
}=0A=
=0A=
function isArrayBuffer(obj) {=0A=
  return toString.call(obj) =3D=3D=3D '[object ArrayBuffer]';=0A=
}=0A=
=0A=
=0A=
var trim =3D function(value) {=0A=
  return isString(value) ? value.trim() : value;=0A=
};=0A=
=0A=
// Copied from:=0A=
// =
http://docs.closure-library.googlecode.com/git/local_closure_goog_string_=
string.js.source.html#line1021=0A=
// Prereq: s is a string.=0A=
var escapeForRegexp =3D function(s) {=0A=
  return s=0A=
    .replace(/([-()[\]{}+?*.$^|,:#&lt;!\\])/g, '\\$1')=0A=
    // eslint-disable-next-line no-control-regex=0A=
    .replace(/\x08/g, '\\x08');=0A=
};=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.isElement=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Determines if a reference is a DOM element (or wrapped jQuery =
element).=0A=
 *=0A=
 * @param {*} value Reference to check.=0A=
 * @returns {boolean} True if `value` is a DOM element (or wrapped =
jQuery element).=0A=
 */=0A=
function isElement(node) {=0A=
  return !!(node &amp;&amp;=0A=
    (node.nodeName  // We are a direct element.=0A=
    || (node.prop &amp;&amp; node.attr &amp;&amp; node.find)));  // We =
have an on and find method part of jQuery API.=0A=
}=0A=
=0A=
/**=0A=
 * @param str 'key1,key2,...'=0A=
 * @returns {object} in the form of {key1:true, key2:true, ...}=0A=
 */=0A=
function makeMap(str) {=0A=
  var obj =3D {}, items =3D str.split(','), i;=0A=
  for (i =3D 0; i &lt; items.length; i++) {=0A=
    obj[items[i]] =3D true;=0A=
  }=0A=
  return obj;=0A=
}=0A=
=0A=
=0A=
function nodeName_(element) {=0A=
  return lowercase(element.nodeName || (element[0] &amp;&amp; =
element[0].nodeName));=0A=
}=0A=
=0A=
function includes(array, obj) {=0A=
  return Array.prototype.indexOf.call(array, obj) !=3D=3D -1;=0A=
}=0A=
=0A=
function arrayRemove(array, value) {=0A=
  var index =3D array.indexOf(value);=0A=
  if (index &gt;=3D 0) {=0A=
    array.splice(index, 1);=0A=
  }=0A=
  return index;=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.copy=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Creates a deep copy of `source`, which should be an object or an =
array.=0A=
 *=0A=
 * * If no destination is supplied, a copy of the object or array is =
created.=0A=
 * * If a destination is provided, all of its elements (for arrays) or =
properties (for objects)=0A=
 *   are deleted and then all elements/properties from the source are =
copied to it.=0A=
 * * If `source` is not an object or array (inc. `null` and =
`undefined`), `source` is returned.=0A=
 * * If `source` is identical to `destination` an exception will be =
thrown.=0A=
 *=0A=
 * &lt;br /&gt;=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 *   Only enumerable properties are taken into account. Non-enumerable =
properties (both on `source`=0A=
 *   and on `destination`) will be ignored.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * @param {*} source The source that will be used to make a copy.=0A=
 *                   Can be any type, including primitives, `null`, and =
`undefined`.=0A=
 * @param {(Object|Array)=3D} destination Destination into which the =
source is copied. If=0A=
 *     provided, must be of the same type as `source`.=0A=
 * @returns {*} The copy or updated `destination`, if `destination` was =
specified.=0A=
 *=0A=
 * @example=0A=
  &lt;example module=3D"copyExample" name=3D"angular-copy"&gt;=0A=
    &lt;file name=3D"index.html"&gt;=0A=
      &lt;div ng-controller=3D"ExampleController"&gt;=0A=
        &lt;form novalidate class=3D"simple-form"&gt;=0A=
          &lt;label&gt;Name: &lt;input type=3D"text" =
ng-model=3D"user.name" /&gt;&lt;/label&gt;&lt;br /&gt;=0A=
          &lt;label&gt;Age:  &lt;input type=3D"number" =
ng-model=3D"user.age" /&gt;&lt;/label&gt;&lt;br /&gt;=0A=
          Gender: &lt;label&gt;&lt;input type=3D"radio" =
ng-model=3D"user.gender" value=3D"male" /&gt;male&lt;/label&gt;=0A=
                  &lt;label&gt;&lt;input type=3D"radio" =
ng-model=3D"user.gender" value=3D"female" =
/&gt;female&lt;/label&gt;&lt;br /&gt;=0A=
          &lt;button ng-click=3D"reset()"&gt;RESET&lt;/button&gt;=0A=
          &lt;button ng-click=3D"update(user)"&gt;SAVE&lt;/button&gt;=0A=
        &lt;/form&gt;=0A=
        &lt;pre&gt;form =3D {{user | json}}&lt;/pre&gt;=0A=
        &lt;pre&gt;master =3D {{master | json}}&lt;/pre&gt;=0A=
      &lt;/div&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"script.js"&gt;=0A=
      // Module: copyExample=0A=
      angular.=0A=
        module('copyExample', []).=0A=
        controller('ExampleController', ['$scope', function($scope) {=0A=
          $scope.master =3D {};=0A=
=0A=
          $scope.reset =3D function() {=0A=
            // Example with 1 argument=0A=
            $scope.user =3D angular.copy($scope.master);=0A=
          };=0A=
=0A=
          $scope.update =3D function(user) {=0A=
            // Example with 2 arguments=0A=
            angular.copy(user, $scope.master);=0A=
          };=0A=
=0A=
          $scope.reset();=0A=
        }]);=0A=
    &lt;/file&gt;=0A=
  &lt;/example&gt;=0A=
 */=0A=
function copy(source, destination, maxDepth) {=0A=
  var stackSource =3D [];=0A=
  var stackDest =3D [];=0A=
  maxDepth =3D isValidObjectMaxDepth(maxDepth) ? maxDepth : NaN;=0A=
=0A=
  if (destination) {=0A=
    if (isTypedArray(destination) || isArrayBuffer(destination)) {=0A=
      throw ngMinErr('cpta', 'Can\'t copy! TypedArray destination cannot =
be mutated.');=0A=
    }=0A=
    if (source =3D=3D=3D destination) {=0A=
      throw ngMinErr('cpi', 'Can\'t copy! Source and destination are =
identical.');=0A=
    }=0A=
=0A=
    // Empty the destination object=0A=
    if (isArray(destination)) {=0A=
      destination.length =3D 0;=0A=
    } else {=0A=
      forEach(destination, function(value, key) {=0A=
        if (key !=3D=3D '$$hashKey') {=0A=
          delete destination[key];=0A=
        }=0A=
      });=0A=
    }=0A=
=0A=
    stackSource.push(source);=0A=
    stackDest.push(destination);=0A=
    return copyRecurse(source, destination, maxDepth);=0A=
  }=0A=
=0A=
  return copyElement(source, maxDepth);=0A=
=0A=
  function copyRecurse(source, destination, maxDepth) {=0A=
    maxDepth--;=0A=
    if (maxDepth &lt; 0) {=0A=
      return '...';=0A=
    }=0A=
    var h =3D destination.$$hashKey;=0A=
    var key;=0A=
    if (isArray(source)) {=0A=
      for (var i =3D 0, ii =3D source.length; i &lt; ii; i++) {=0A=
        destination.push(copyElement(source[i], maxDepth));=0A=
      }=0A=
    } else if (isBlankObject(source)) {=0A=
      // createMap() fast path --- Safe to avoid hasOwnProperty check =
because prototype chain is empty=0A=
      for (key in source) {=0A=
        destination[key] =3D copyElement(source[key], maxDepth);=0A=
      }=0A=
    } else if (source &amp;&amp; typeof source.hasOwnProperty =3D=3D=3D =
'function') {=0A=
      // Slow path, which must rely on hasOwnProperty=0A=
      for (key in source) {=0A=
        if (source.hasOwnProperty(key)) {=0A=
          destination[key] =3D copyElement(source[key], maxDepth);=0A=
        }=0A=
      }=0A=
    } else {=0A=
      // Slowest path --- hasOwnProperty can't be called as a method=0A=
      for (key in source) {=0A=
        if (hasOwnProperty.call(source, key)) {=0A=
          destination[key] =3D copyElement(source[key], maxDepth);=0A=
        }=0A=
      }=0A=
    }=0A=
    setHashKey(destination, h);=0A=
    return destination;=0A=
  }=0A=
=0A=
  function copyElement(source, maxDepth) {=0A=
    // Simple values=0A=
    if (!isObject(source)) {=0A=
      return source;=0A=
    }=0A=
=0A=
    // Already copied values=0A=
    var index =3D stackSource.indexOf(source);=0A=
    if (index !=3D=3D -1) {=0A=
      return stackDest[index];=0A=
    }=0A=
=0A=
    if (isWindow(source) || isScope(source)) {=0A=
      throw ngMinErr('cpws',=0A=
        'Can\'t copy! Making copies of Window or Scope instances is not =
supported.');=0A=
    }=0A=
=0A=
    var needsRecurse =3D false;=0A=
    var destination =3D copyType(source);=0A=
=0A=
    if (destination =3D=3D=3D undefined) {=0A=
      destination =3D isArray(source) ? [] : =
Object.create(getPrototypeOf(source));=0A=
      needsRecurse =3D true;=0A=
    }=0A=
=0A=
    stackSource.push(source);=0A=
    stackDest.push(destination);=0A=
=0A=
    return needsRecurse=0A=
      ? copyRecurse(source, destination, maxDepth)=0A=
      : destination;=0A=
  }=0A=
=0A=
  function copyType(source) {=0A=
    switch (toString.call(source)) {=0A=
      case '[object Int8Array]':=0A=
      case '[object Int16Array]':=0A=
      case '[object Int32Array]':=0A=
      case '[object Float32Array]':=0A=
      case '[object Float64Array]':=0A=
      case '[object Uint8Array]':=0A=
      case '[object Uint8ClampedArray]':=0A=
      case '[object Uint16Array]':=0A=
      case '[object Uint32Array]':=0A=
        return new source.constructor(copyElement(source.buffer), =
source.byteOffset, source.length);=0A=
=0A=
      case '[object ArrayBuffer]':=0A=
        // Support: IE10=0A=
        if (!source.slice) {=0A=
          // If we're in this case we know the environment supports =
ArrayBuffer=0A=
          /* eslint-disable no-undef */=0A=
          var copied =3D new ArrayBuffer(source.byteLength);=0A=
          new Uint8Array(copied).set(new Uint8Array(source));=0A=
          /* eslint-enable */=0A=
          return copied;=0A=
        }=0A=
        return source.slice(0);=0A=
=0A=
      case '[object Boolean]':=0A=
      case '[object Number]':=0A=
      case '[object String]':=0A=
      case '[object Date]':=0A=
        return new source.constructor(source.valueOf());=0A=
=0A=
      case '[object RegExp]':=0A=
        var re =3D new RegExp(source.source, =
source.toString().match(/[^/]*$/)[0]);=0A=
        re.lastIndex =3D source.lastIndex;=0A=
        return re;=0A=
=0A=
      case '[object Blob]':=0A=
        return new source.constructor([source], {type: source.type});=0A=
    }=0A=
=0A=
    if (isFunction(source.cloneNode)) {=0A=
      return source.cloneNode(true);=0A=
    }=0A=
  }=0A=
}=0A=
=0A=
=0A=
// eslint-disable-next-line no-self-compare=0A=
function simpleCompare(a, b) { return a =3D=3D=3D b || (a !=3D=3D a =
&amp;&amp; b !=3D=3D b); }=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.equals=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Determines if two objects or two values are equivalent. Supports =
value types, regular=0A=
 * expressions, arrays and objects.=0A=
 *=0A=
 * Two objects or values are considered equivalent if at least one of =
the following is true:=0A=
 *=0A=
 * * Both objects or values pass `=3D=3D=3D` comparison.=0A=
 * * Both objects or values are of the same type and all of their =
properties are equal by=0A=
 *   comparing them with `angular.equals`.=0A=
 * * Both values are NaN. (In JavaScript, NaN =3D=3D NaN =3D&gt; false. =
But we consider two NaN as equal)=0A=
 * * Both values represent the same regular expression (In JavaScript,=0A=
 *   /abc/ =3D=3D /abc/ =3D&gt; false. But we consider two regular =
expressions as equal when their textual=0A=
 *   representation matches).=0A=
 *=0A=
 * During a property comparison, properties of `function` type and =
properties with names=0A=
 * that begin with `$` are ignored.=0A=
 *=0A=
 * Scope and DOMWindow objects are being compared only by identify =
(`=3D=3D=3D`).=0A=
 *=0A=
 * @param {*} o1 Object or value to compare.=0A=
 * @param {*} o2 Object or value to compare.=0A=
 * @returns {boolean} True if arguments are equal.=0A=
 *=0A=
 * @example=0A=
   &lt;example module=3D"equalsExample" name=3D"equalsExample"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
      &lt;div ng-controller=3D"ExampleController"&gt;=0A=
        &lt;form novalidate&gt;=0A=
          &lt;h3&gt;User 1&lt;/h3&gt;=0A=
          Name: &lt;input type=3D"text" ng-model=3D"user1.name"&gt;=0A=
          Age: &lt;input type=3D"number" ng-model=3D"user1.age"&gt;=0A=
=0A=
          &lt;h3&gt;User 2&lt;/h3&gt;=0A=
          Name: &lt;input type=3D"text" ng-model=3D"user2.name"&gt;=0A=
          Age: &lt;input type=3D"number" ng-model=3D"user2.age"&gt;=0A=
=0A=
          &lt;div&gt;=0A=
            &lt;br/&gt;=0A=
            &lt;input type=3D"button" value=3D"Compare" =
ng-click=3D"compare()"&gt;=0A=
          &lt;/div&gt;=0A=
          User 1: &lt;pre&gt;{{user1 | json}}&lt;/pre&gt;=0A=
          User 2: &lt;pre&gt;{{user2 | json}}&lt;/pre&gt;=0A=
          Equal: &lt;pre&gt;{{result}}&lt;/pre&gt;=0A=
        &lt;/form&gt;=0A=
      &lt;/div&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"script.js"&gt;=0A=
        angular.module('equalsExample', =
[]).controller('ExampleController', ['$scope', function($scope) {=0A=
          $scope.user1 =3D {};=0A=
          $scope.user2 =3D {};=0A=
          $scope.compare =3D function() {=0A=
            $scope.result =3D angular.equals($scope.user1, $scope.user2);=0A=
          };=0A=
        }]);=0A=
    &lt;/file&gt;=0A=
  &lt;/example&gt;=0A=
 */=0A=
function equals(o1, o2) {=0A=
  if (o1 =3D=3D=3D o2) return true;=0A=
  if (o1 =3D=3D=3D null || o2 =3D=3D=3D null) return false;=0A=
  // eslint-disable-next-line no-self-compare=0A=
  if (o1 !=3D=3D o1 &amp;&amp; o2 !=3D=3D o2) return true; // NaN =
=3D=3D=3D NaN=0A=
  var t1 =3D typeof o1, t2 =3D typeof o2, length, key, keySet;=0A=
  if (t1 =3D=3D=3D t2 &amp;&amp; t1 =3D=3D=3D 'object') {=0A=
    if (isArray(o1)) {=0A=
      if (!isArray(o2)) return false;=0A=
      if ((length =3D o1.length) =3D=3D=3D o2.length) {=0A=
        for (key =3D 0; key &lt; length; key++) {=0A=
          if (!equals(o1[key], o2[key])) return false;=0A=
        }=0A=
        return true;=0A=
      }=0A=
    } else if (isDate(o1)) {=0A=
      if (!isDate(o2)) return false;=0A=
      return simpleCompare(o1.getTime(), o2.getTime());=0A=
    } else if (isRegExp(o1)) {=0A=
      if (!isRegExp(o2)) return false;=0A=
      return o1.toString() =3D=3D=3D o2.toString();=0A=
    } else {=0A=
      if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) ||=0A=
        isArray(o2) || isDate(o2) || isRegExp(o2)) return false;=0A=
      keySet =3D createMap();=0A=
      for (key in o1) {=0A=
        if (key.charAt(0) =3D=3D=3D '$' || isFunction(o1[key])) continue;=0A=
        if (!equals(o1[key], o2[key])) return false;=0A=
        keySet[key] =3D true;=0A=
      }=0A=
      for (key in o2) {=0A=
        if (!(key in keySet) &amp;&amp;=0A=
            key.charAt(0) !=3D=3D '$' &amp;&amp;=0A=
            isDefined(o2[key]) &amp;&amp;=0A=
            !isFunction(o2[key])) return false;=0A=
      }=0A=
      return true;=0A=
    }=0A=
  }=0A=
  return false;=0A=
}=0A=
=0A=
var csp =3D function() {=0A=
  if (!isDefined(csp.rules)) {=0A=
=0A=
=0A=
    var ngCspElement =3D (window.document.querySelector('[ng-csp]') ||=0A=
                    window.document.querySelector('[data-ng-csp]'));=0A=
=0A=
    if (ngCspElement) {=0A=
      var ngCspAttribute =3D ngCspElement.getAttribute('ng-csp') ||=0A=
                    ngCspElement.getAttribute('data-ng-csp');=0A=
      csp.rules =3D {=0A=
        noUnsafeEval: !ngCspAttribute || =
(ngCspAttribute.indexOf('no-unsafe-eval') !=3D=3D -1),=0A=
        noInlineStyle: !ngCspAttribute || =
(ngCspAttribute.indexOf('no-inline-style') !=3D=3D -1)=0A=
      };=0A=
    } else {=0A=
      csp.rules =3D {=0A=
        noUnsafeEval: noUnsafeEval(),=0A=
        noInlineStyle: false=0A=
      };=0A=
    }=0A=
  }=0A=
=0A=
  return csp.rules;=0A=
=0A=
  function noUnsafeEval() {=0A=
    try {=0A=
      // eslint-disable-next-line no-new, no-new-func=0A=
      new Function('');=0A=
      return false;=0A=
    } catch (e) {=0A=
      return true;=0A=
    }=0A=
  }=0A=
};=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @module ng=0A=
 * @name ngJq=0A=
 *=0A=
 * @element ANY=0A=
 * @param {string=3D} ngJq the name of the library available under =
`window`=0A=
 * to be used for angular.element=0A=
 * @description=0A=
 * Use this directive to force the angular.element library.  This should =
be=0A=
 * used to force either jqLite by leaving ng-jq blank or setting the =
name of=0A=
 * the jquery variable under window (eg. jQuery).=0A=
 *=0A=
 * Since angular looks for this directive when it is loaded (doesn't =
wait for the=0A=
 * DOMContentLoaded event), it must be placed on an element that comes =
before the script=0A=
 * which loads angular. Also, only the first instance of `ng-jq` will be =
used and all=0A=
 * others ignored.=0A=
 *=0A=
 * @example=0A=
 * This example shows how to force jqLite using the `ngJq` directive to =
the `html` tag.=0A=
 ```html=0A=
 &lt;!doctype html&gt;=0A=
 &lt;html ng-app ng-jq&gt;=0A=
 ...=0A=
 ...=0A=
 &lt;/html&gt;=0A=
 ```=0A=
 * @example=0A=
 * This example shows how to use a jQuery based library of a different =
name.=0A=
 * The library name must be available at the top most 'window'.=0A=
 ```html=0A=
 &lt;!doctype html&gt;=0A=
 &lt;html ng-app ng-jq=3D"jQueryLib"&gt;=0A=
 ...=0A=
 ...=0A=
 &lt;/html&gt;=0A=
 ```=0A=
 */=0A=
var jq =3D function() {=0A=
  if (isDefined(jq.name_)) return jq.name_;=0A=
  var el;=0A=
  var i, ii =3D ngAttrPrefixes.length, prefix, name;=0A=
  for (i =3D 0; i &lt; ii; ++i) {=0A=
    prefix =3D ngAttrPrefixes[i];=0A=
    el =3D window.document.querySelector('[' + prefix.replace(':', =
'\\:') + 'jq]');=0A=
    if (el) {=0A=
      name =3D el.getAttribute(prefix + 'jq');=0A=
      break;=0A=
    }=0A=
  }=0A=
=0A=
  return (jq.name_ =3D name);=0A=
};=0A=
=0A=
function concat(array1, array2, index) {=0A=
  return array1.concat(slice.call(array2, index));=0A=
}=0A=
=0A=
function sliceArgs(args, startIndex) {=0A=
  return slice.call(args, startIndex || 0);=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.bind=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Returns a function which calls function `fn` bound to `self` (`self` =
becomes the `this` for=0A=
 * `fn`). You can supply optional `args` that are prebound to the =
function. This feature is also=0A=
 * known as [partial =
application](http://en.wikipedia.org/wiki/Partial_application), as=0A=
 * distinguished from [function =
currying](http://en.wikipedia.org/wiki/Currying#Contrast_with_partial_fun=
ction_application).=0A=
 *=0A=
 * @param {Object} self Context which `fn` should be evaluated in.=0A=
 * @param {function()} fn Function to be bound.=0A=
 * @param {...*} args Optional arguments to be prebound to the `fn` =
function call.=0A=
 * @returns {function()} Function that wraps the `fn` with all the =
specified bindings.=0A=
 */=0A=
function bind(self, fn) {=0A=
  var curryArgs =3D arguments.length &gt; 2 ? sliceArgs(arguments, 2) : =
[];=0A=
  if (isFunction(fn) &amp;&amp; !(fn instanceof RegExp)) {=0A=
    return curryArgs.length=0A=
      ? function() {=0A=
          return arguments.length=0A=
            ? fn.apply(self, concat(curryArgs, arguments, 0))=0A=
            : fn.apply(self, curryArgs);=0A=
        }=0A=
      : function() {=0A=
          return arguments.length=0A=
            ? fn.apply(self, arguments)=0A=
            : fn.call(self);=0A=
        };=0A=
  } else {=0A=
    // In IE, native methods are not functions so they cannot be bound =
(note: they don't need to be).=0A=
    return fn;=0A=
  }=0A=
}=0A=
=0A=
=0A=
function toJsonReplacer(key, value) {=0A=
  var val =3D value;=0A=
=0A=
  if (typeof key =3D=3D=3D 'string' &amp;&amp; key.charAt(0) =3D=3D=3D =
'$' &amp;&amp; key.charAt(1) =3D=3D=3D '$') {=0A=
    val =3D undefined;=0A=
  } else if (isWindow(value)) {=0A=
    val =3D '$WINDOW';=0A=
  } else if (value &amp;&amp;  window.document =3D=3D=3D value) {=0A=
    val =3D '$DOCUMENT';=0A=
  } else if (isScope(value)) {=0A=
    val =3D '$SCOPE';=0A=
  }=0A=
=0A=
  return val;=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.toJson=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Serializes input into a JSON-formatted string. Properties with =
leading $$ characters will be=0A=
 * stripped since angular uses this notation internally.=0A=
 *=0A=
 * @param {Object|Array|Date|string|number|boolean} obj Input to be =
serialized into JSON.=0A=
 * @param {boolean|number} [pretty=3D2] If set to true, the JSON output =
will contain newlines and whitespace.=0A=
 *    If set to an integer, the JSON output will contain that many =
spaces per indentation.=0A=
 * @returns {string|undefined} JSON-ified string representing `obj`.=0A=
 * @knownIssue=0A=
 *=0A=
 * The Safari browser throws a `RangeError` instead of returning `null` =
when it tries to stringify a `Date`=0A=
 * object with an invalid date value. The only reliable way to prevent =
this is to monkeypatch the=0A=
 * `Date.prototype.toJSON` method as follows:=0A=
 *=0A=
 * ```=0A=
 * var _DatetoJSON =3D Date.prototype.toJSON;=0A=
 * Date.prototype.toJSON =3D function() {=0A=
 *   try {=0A=
 *     return _DatetoJSON.call(this);=0A=
 *   } catch(e) {=0A=
 *     if (e instanceof RangeError) {=0A=
 *       return null;=0A=
 *     }=0A=
 *     throw e;=0A=
 *   }=0A=
 * };=0A=
 * ```=0A=
 *=0A=
 * See https://github.com/angular/angular.js/pull/14221 for more =
information.=0A=
 */=0A=
function toJson(obj, pretty) {=0A=
  if (isUndefined(obj)) return undefined;=0A=
  if (!isNumber(pretty)) {=0A=
    pretty =3D pretty ? 2 : null;=0A=
  }=0A=
  return JSON.stringify(obj, toJsonReplacer, pretty);=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.fromJson=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Deserializes a JSON string.=0A=
 *=0A=
 * @param {string} json JSON string to deserialize.=0A=
 * @returns {Object|Array|string|number} Deserialized JSON string.=0A=
 */=0A=
function fromJson(json) {=0A=
  return isString(json)=0A=
      ? JSON.parse(json)=0A=
      : json;=0A=
}=0A=
=0A=
=0A=
var ALL_COLONS =3D /:/g;=0A=
function timezoneToOffset(timezone, fallback) {=0A=
  // Support: IE 9-11 only, Edge 13-15+=0A=
  // IE/Edge do not "understand" colon (`:`) in timezone=0A=
  timezone =3D timezone.replace(ALL_COLONS, '');=0A=
  var requestedTimezoneOffset =3D Date.parse('Jan 01, 1970 00:00:00 ' + =
timezone) / 60000;=0A=
  return isNumberNaN(requestedTimezoneOffset) ? fallback : =
requestedTimezoneOffset;=0A=
}=0A=
=0A=
=0A=
function addDateMinutes(date, minutes) {=0A=
  date =3D new Date(date.getTime());=0A=
  date.setMinutes(date.getMinutes() + minutes);=0A=
  return date;=0A=
}=0A=
=0A=
=0A=
function convertTimezoneToLocal(date, timezone, reverse) {=0A=
  reverse =3D reverse ? -1 : 1;=0A=
  var dateTimezoneOffset =3D date.getTimezoneOffset();=0A=
  var timezoneOffset =3D timezoneToOffset(timezone, dateTimezoneOffset);=0A=
  return addDateMinutes(date, reverse * (timezoneOffset - =
dateTimezoneOffset));=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @returns {string} Returns the string representation of the element.=0A=
 */=0A=
function startingTag(element) {=0A=
  element =3D jqLite(element).clone().empty();=0A=
  var elemHtml =3D jqLite('&lt;div&gt;').append(element).html();=0A=
  try {=0A=
    return element[0].nodeType =3D=3D=3D NODE_TYPE_TEXT ? =
lowercase(elemHtml) :=0A=
        elemHtml.=0A=
          match(/^(&lt;[^&gt;]+&gt;)/)[1].=0A=
          replace(/^&lt;([\w-]+)/, function(match, nodeName) {return =
'&lt;' + lowercase(nodeName);});=0A=
  } catch (e) {=0A=
    return lowercase(elemHtml);=0A=
  }=0A=
=0A=
}=0A=
=0A=
=0A=
/////////////////////////////////////////////////=0A=
=0A=
/**=0A=
 * Tries to decode the URI component without throwing an exception.=0A=
 *=0A=
 * @private=0A=
 * @param str value potential URI component to check.=0A=
 * @returns {boolean} True if `value` can be decoded=0A=
 * with the decodeURIComponent function.=0A=
 */=0A=
function tryDecodeURIComponent(value) {=0A=
  try {=0A=
    return decodeURIComponent(value);=0A=
  } catch (e) {=0A=
    // Ignore any invalid uri component.=0A=
  }=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * Parses an escaped url query string into key-value pairs.=0A=
 * @returns {Object.&lt;string,boolean|Array&gt;}=0A=
 */=0A=
function parseKeyValue(/**string*/keyValue) {=0A=
  var obj =3D {};=0A=
  forEach((keyValue || '').split('&amp;'), function(keyValue) {=0A=
    var splitPoint, key, val;=0A=
    if (keyValue) {=0A=
      key =3D keyValue =3D keyValue.replace(/\+/g,'%20');=0A=
      splitPoint =3D keyValue.indexOf('=3D');=0A=
      if (splitPoint !=3D=3D -1) {=0A=
        key =3D keyValue.substring(0, splitPoint);=0A=
        val =3D keyValue.substring(splitPoint + 1);=0A=
      }=0A=
      key =3D tryDecodeURIComponent(key);=0A=
      if (isDefined(key)) {=0A=
        val =3D isDefined(val) ? tryDecodeURIComponent(val) : true;=0A=
        if (!hasOwnProperty.call(obj, key)) {=0A=
          obj[key] =3D val;=0A=
        } else if (isArray(obj[key])) {=0A=
          obj[key].push(val);=0A=
        } else {=0A=
          obj[key] =3D [obj[key],val];=0A=
        }=0A=
      }=0A=
    }=0A=
  });=0A=
  return obj;=0A=
}=0A=
=0A=
function toKeyValue(obj) {=0A=
  var parts =3D [];=0A=
  forEach(obj, function(value, key) {=0A=
    if (isArray(value)) {=0A=
      forEach(value, function(arrayValue) {=0A=
        parts.push(encodeUriQuery(key, true) +=0A=
                   (arrayValue =3D=3D=3D true ? '' : '=3D' + =
encodeUriQuery(arrayValue, true)));=0A=
      });=0A=
    } else {=0A=
    parts.push(encodeUriQuery(key, true) +=0A=
               (value =3D=3D=3D true ? '' : '=3D' + =
encodeUriQuery(value, true)));=0A=
    }=0A=
  });=0A=
  return parts.length ? parts.join('&amp;') : '';=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * We need our custom method because encodeURIComponent is too =
aggressive and doesn't follow=0A=
 * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set =
(pchar) allowed in path=0A=
 * segments:=0A=
 *    segment       =3D *pchar=0A=
 *    pchar         =3D unreserved / pct-encoded / sub-delims / ":" / "@"=0A=
 *    pct-encoded   =3D "%" HEXDIG HEXDIG=0A=
 *    unreserved    =3D ALPHA / DIGIT / "-" / "." / "_" / "~"=0A=
 *    sub-delims    =3D "!" / "$" / "&amp;" / "'" / "(" / ")"=0A=
 *                     / "*" / "+" / "," / ";" / "=3D"=0A=
 */=0A=
function encodeUriSegment(val) {=0A=
  return encodeUriQuery(val, true).=0A=
             replace(/%26/gi, '&amp;').=0A=
             replace(/%3D/gi, '=3D').=0A=
             replace(/%2B/gi, '+');=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * This method is intended for encoding *key* or *value* parts of query =
component. We need a custom=0A=
 * method because encodeURIComponent is too aggressive and encodes stuff =
that doesn't have to be=0A=
 * encoded per http://tools.ietf.org/html/rfc3986:=0A=
 *    query         =3D *( pchar / "/" / "?" )=0A=
 *    pchar         =3D unreserved / pct-encoded / sub-delims / ":" / "@"=0A=
 *    unreserved    =3D ALPHA / DIGIT / "-" / "." / "_" / "~"=0A=
 *    pct-encoded   =3D "%" HEXDIG HEXDIG=0A=
 *    sub-delims    =3D "!" / "$" / "&amp;" / "'" / "(" / ")"=0A=
 *                     / "*" / "+" / "," / ";" / "=3D"=0A=
 */=0A=
function encodeUriQuery(val, pctEncodeSpaces) {=0A=
  return encodeURIComponent(val).=0A=
             replace(/%40/gi, '@').=0A=
             replace(/%3A/gi, ':').=0A=
             replace(/%24/g, '$').=0A=
             replace(/%2C/gi, ',').=0A=
             replace(/%3B/gi, ';').=0A=
             replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));=0A=
}=0A=
=0A=
var ngAttrPrefixes =3D ['ng-', 'data-ng-', 'ng:', 'x-ng-'];=0A=
=0A=
function getNgAttribute(element, ngAttr) {=0A=
  var attr, i, ii =3D ngAttrPrefixes.length;=0A=
  for (i =3D 0; i &lt; ii; ++i) {=0A=
    attr =3D ngAttrPrefixes[i] + ngAttr;=0A=
    if (isString(attr =3D element.getAttribute(attr))) {=0A=
      return attr;=0A=
    }=0A=
  }=0A=
  return null;=0A=
}=0A=
=0A=
function allowAutoBootstrap(document) {=0A=
  var script =3D document.currentScript;=0A=
=0A=
  if (!script) {=0A=
    // Support: IE 9-11 only=0A=
    // IE does not have `document.currentScript`=0A=
    return true;=0A=
  }=0A=
=0A=
  // If the `currentScript` property has been clobbered just return =
false, since this indicates a probable attack=0A=
  if (!(script instanceof window.HTMLScriptElement || script instanceof =
window.SVGScriptElement)) {=0A=
    return false;=0A=
  }=0A=
=0A=
  var attributes =3D script.attributes;=0A=
  var srcs =3D [attributes.getNamedItem('src'), =
attributes.getNamedItem('href'), attributes.getNamedItem('xlink:href')];=0A=
=0A=
  return srcs.every(function(src) {=0A=
    if (!src) {=0A=
      return true;=0A=
    }=0A=
    if (!src.value) {=0A=
      return false;=0A=
    }=0A=
=0A=
    var link =3D document.createElement('a');=0A=
    link.href =3D src.value;=0A=
=0A=
    if (document.location.origin =3D=3D=3D link.origin) {=0A=
      // Same-origin resources are always allowed, even for =
non-whitelisted schemes.=0A=
      return true;=0A=
    }=0A=
    // Disabled bootstrapping unless angular.js was loaded from a known =
scheme used on the web.=0A=
    // This is to prevent angular.js bundled with browser extensions =
from being used to bypass the=0A=
    // content security policy in web pages and other browser extensions.=0A=
    switch (link.protocol) {=0A=
      case 'http:':=0A=
      case 'https:':=0A=
      case 'ftp:':=0A=
      case 'blob:':=0A=
      case 'file:':=0A=
      case 'data:':=0A=
        return true;=0A=
      default:=0A=
        return false;=0A=
    }=0A=
  });=0A=
}=0A=
=0A=
// Cached as it has to run during loading so that document.currentScript =
is available.=0A=
var isAutoBootstrapAllowed =3D allowAutoBootstrap(window.document);=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngApp=0A=
 * @module ng=0A=
 *=0A=
 * @element ANY=0A=
 * @param {angular.Module} ngApp an optional application=0A=
 *   {@link angular.module module} name to load.=0A=
 * @param {boolean=3D} ngStrictDi if this attribute is present on the =
app element, the injector will be=0A=
 *   created in "strict-di" mode. This means that the application will =
fail to invoke functions which=0A=
 *   do not use explicit function annotation (and are thus unsuitable =
for minification), as described=0A=
 *   in {@link guide/di the Dependency Injection guide}, and useful =
debugging info will assist in=0A=
 *   tracking down the root of these bugs.=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * Use this directive to **auto-bootstrap** an AngularJS application. =
The `ngApp` directive=0A=
 * designates the **root element** of the application and is typically =
placed near the root element=0A=
 * of the page - e.g. on the `&lt;body&gt;` or `&lt;html&gt;` tags.=0A=
 *=0A=
 * There are a few things to keep in mind when using `ngApp`:=0A=
 * - only one AngularJS application can be auto-bootstrapped per HTML =
document. The first `ngApp`=0A=
 *   found in the document will be used to define the root element to =
auto-bootstrap as an=0A=
 *   application. To run multiple applications in an HTML document you =
must manually bootstrap them using=0A=
 *   {@link angular.bootstrap} instead.=0A=
 * - AngularJS applications cannot be nested within each other.=0A=
 * - Do not use a directive that uses {@link ng.$compile#transclusion =
transclusion} on the same element as `ngApp`.=0A=
 *   This includes directives such as {@link ng.ngIf `ngIf`}, {@link =
ng.ngInclude `ngInclude`} and=0A=
 *   {@link ngRoute.ngView `ngView`}.=0A=
 *   Doing this misplaces the app {@link ng.$rootElement `$rootElement`} =
and the app's {@link auto.$injector injector},=0A=
 *   causing animations to stop working and making the injector =
inaccessible from outside the app.=0A=
 *=0A=
 * You can specify an **AngularJS module** to be used as the root module =
for the application.  This=0A=
 * module will be loaded into the {@link auto.$injector} when the =
application is bootstrapped. It=0A=
 * should contain the application code needed or have dependencies on =
other modules that will=0A=
 * contain the code. See {@link angular.module} for more information.=0A=
 *=0A=
 * In the example below if the `ngApp` directive were not placed on the =
`html` element then the=0A=
 * document would not be compiled, the `AppController` would not be =
instantiated and the `{{ a+b }}`=0A=
 * would not be resolved to `3`.=0A=
 *=0A=
 * `ngApp` is the easiest, and most common way to bootstrap an =
application.=0A=
 *=0A=
 &lt;example module=3D"ngAppDemo" name=3D"ng-app"&gt;=0A=
   &lt;file name=3D"index.html"&gt;=0A=
   &lt;div ng-controller=3D"ngAppDemoController"&gt;=0A=
     I can add: {{a}} + {{b}} =3D  {{ a+b }}=0A=
   &lt;/div&gt;=0A=
   &lt;/file&gt;=0A=
   &lt;file name=3D"script.js"&gt;=0A=
   angular.module('ngAppDemo', []).controller('ngAppDemoController', =
function($scope) {=0A=
     $scope.a =3D 1;=0A=
     $scope.b =3D 2;=0A=
   });=0A=
   &lt;/file&gt;=0A=
 &lt;/example&gt;=0A=
 *=0A=
 * Using `ngStrictDi`, you would see something like this:=0A=
 *=0A=
 &lt;example ng-app-included=3D"true" name=3D"strict-di"&gt;=0A=
   &lt;file name=3D"index.html"&gt;=0A=
   &lt;div ng-app=3D"ngAppStrictDemo" ng-strict-di&gt;=0A=
       &lt;div ng-controller=3D"GoodController1"&gt;=0A=
           I can add: {{a}} + {{b}} =3D  {{ a+b }}=0A=
=0A=
           &lt;p&gt;This renders because the controller does not fail to=0A=
              instantiate, by using explicit annotation style (see=0A=
              script.js for details)=0A=
           &lt;/p&gt;=0A=
       &lt;/div&gt;=0A=
=0A=
       &lt;div ng-controller=3D"GoodController2"&gt;=0A=
           Name: &lt;input ng-model=3D"name"&gt;&lt;br /&gt;=0A=
           Hello, {{name}}!=0A=
=0A=
           &lt;p&gt;This renders because the controller does not fail to=0A=
              instantiate, by using explicit annotation style=0A=
              (see script.js for details)=0A=
           &lt;/p&gt;=0A=
       &lt;/div&gt;=0A=
=0A=
       &lt;div ng-controller=3D"BadController"&gt;=0A=
           I can add: {{a}} + {{b}} =3D  {{ a+b }}=0A=
=0A=
           &lt;p&gt;The controller could not be instantiated, due to =
relying=0A=
              on automatic function annotations (which are disabled in=0A=
              strict mode). As such, the content of this section is not=0A=
              interpolated, and there should be an error in your web =
console.=0A=
           &lt;/p&gt;=0A=
       &lt;/div&gt;=0A=
   &lt;/div&gt;=0A=
   &lt;/file&gt;=0A=
   &lt;file name=3D"script.js"&gt;=0A=
   angular.module('ngAppStrictDemo', [])=0A=
     // BadController will fail to instantiate, due to relying on =
automatic function annotation,=0A=
     // rather than an explicit annotation=0A=
     .controller('BadController', function($scope) {=0A=
       $scope.a =3D 1;=0A=
       $scope.b =3D 2;=0A=
     })=0A=
     // Unlike BadController, GoodController1 and GoodController2 will =
not fail to be instantiated,=0A=
     // due to using explicit annotations using the array style and =
$inject property, respectively.=0A=
     .controller('GoodController1', ['$scope', function($scope) {=0A=
       $scope.a =3D 1;=0A=
       $scope.b =3D 2;=0A=
     }])=0A=
     .controller('GoodController2', GoodController2);=0A=
     function GoodController2($scope) {=0A=
       $scope.name =3D 'World';=0A=
     }=0A=
     GoodController2.$inject =3D ['$scope'];=0A=
   &lt;/file&gt;=0A=
   &lt;file name=3D"style.css"&gt;=0A=
   div[ng-controller] {=0A=
       margin-bottom: 1em;=0A=
       -webkit-border-radius: 4px;=0A=
       border-radius: 4px;=0A=
       border: 1px solid;=0A=
       padding: .5em;=0A=
   }=0A=
   div[ng-controller^=3DGood] {=0A=
       border-color: #d6e9c6;=0A=
       background-color: #dff0d8;=0A=
       color: #3c763d;=0A=
   }=0A=
   div[ng-controller^=3DBad] {=0A=
       border-color: #ebccd1;=0A=
       background-color: #f2dede;=0A=
       color: #a94442;=0A=
       margin-bottom: 0;=0A=
   }=0A=
   &lt;/file&gt;=0A=
 &lt;/example&gt;=0A=
 */=0A=
function angularInit(element, bootstrap) {=0A=
  var appElement,=0A=
      module,=0A=
      config =3D {};=0A=
=0A=
  // The element `element` has priority over any other element.=0A=
  forEach(ngAttrPrefixes, function(prefix) {=0A=
    var name =3D prefix + 'app';=0A=
=0A=
    if (!appElement &amp;&amp; element.hasAttribute &amp;&amp; =
element.hasAttribute(name)) {=0A=
      appElement =3D element;=0A=
      module =3D element.getAttribute(name);=0A=
    }=0A=
  });=0A=
  forEach(ngAttrPrefixes, function(prefix) {=0A=
    var name =3D prefix + 'app';=0A=
    var candidate;=0A=
=0A=
    if (!appElement &amp;&amp; (candidate =3D element.querySelector('[' =
+ name.replace(':', '\\:') + ']'))) {=0A=
      appElement =3D candidate;=0A=
      module =3D candidate.getAttribute(name);=0A=
    }=0A=
  });=0A=
  if (appElement) {=0A=
    if (!isAutoBootstrapAllowed) {=0A=
      window.console.error('Angular: disabling automatic bootstrap. =
&lt;script&gt; protocol indicates ' +=0A=
          'an extension, document.location.href does not match.');=0A=
      return;=0A=
    }=0A=
    config.strictDi =3D getNgAttribute(appElement, 'strict-di') !=3D=3D =
null;=0A=
    bootstrap(appElement, module ? [module] : [], config);=0A=
  }=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.bootstrap=0A=
 * @module ng=0A=
 * @description=0A=
 * Use this function to manually start up angular application.=0A=
 *=0A=
 * For more information, see the {@link guide/bootstrap Bootstrap guide}.=0A=
 *=0A=
 * Angular will detect if it has been loaded into the browser more than =
once and only allow the=0A=
 * first loaded script to be bootstrapped and will report a warning to =
the browser console for=0A=
 * each of the subsequent scripts. This prevents strange results in =
applications, where otherwise=0A=
 * multiple instances of Angular try to work on the DOM.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * **Note:** Protractor based end-to-end tests cannot use this function =
to bootstrap manually.=0A=
 * They must use {@link ng.directive:ngApp ngApp}.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * **Note:** Do not bootstrap the app on an element with a directive =
that uses {@link ng.$compile#transclusion transclusion},=0A=
 * such as {@link ng.ngIf `ngIf`}, {@link ng.ngInclude `ngInclude`} and =
{@link ngRoute.ngView `ngView`}.=0A=
 * Doing this misplaces the app {@link ng.$rootElement `$rootElement`} =
and the app's {@link auto.$injector injector},=0A=
 * causing animations to stop working and making the injector =
inaccessible from outside the app.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * ```html=0A=
 * &lt;!doctype html&gt;=0A=
 * &lt;html&gt;=0A=
 * &lt;body&gt;=0A=
 * &lt;div ng-controller=3D"WelcomeController"&gt;=0A=
 *   {{greeting}}=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * &lt;script src=3D"angular.js"&gt;&lt;/script&gt;=0A=
 * &lt;script&gt;=0A=
 *   var app =3D angular.module('demo', [])=0A=
 *   .controller('WelcomeController', function($scope) {=0A=
 *       $scope.greeting =3D 'Welcome!';=0A=
 *   });=0A=
 *   angular.bootstrap(document, ['demo']);=0A=
 * &lt;/script&gt;=0A=
 * &lt;/body&gt;=0A=
 * &lt;/html&gt;=0A=
 * ```=0A=
 *=0A=
 * @param {DOMElement} element DOM element which is the root of angular =
application.=0A=
 * @param {Array&lt;String|Function|Array&gt;=3D} modules an array of =
modules to load into the application.=0A=
 *     Each item in the array should be the name of a predefined module =
or a (DI annotated)=0A=
 *     function that will be invoked by the injector as a `config` block.=0A=
 *     See: {@link angular.module modules}=0A=
 * @param {Object=3D} config an object for defining configuration =
options for the application. The=0A=
 *     following keys are supported:=0A=
 *=0A=
 * * `strictDi` - disable automatic function annotation for the =
application. This is meant to=0A=
 *   assist in finding bugs which break minified code. Defaults to =
`false`.=0A=
 *=0A=
 * @returns {auto.$injector} Returns the newly created injector for this =
app.=0A=
 */=0A=
function bootstrap(element, modules, config) {=0A=
  if (!isObject(config)) config =3D {};=0A=
  var defaultConfig =3D {=0A=
    strictDi: false=0A=
  };=0A=
  config =3D extend(defaultConfig, config);=0A=
  var doBootstrap =3D function() {=0A=
    element =3D jqLite(element);=0A=
=0A=
    if (element.injector()) {=0A=
      var tag =3D (element[0] =3D=3D=3D window.document) ? 'document' : =
startingTag(element);=0A=
      // Encode angle brackets to prevent input from being sanitized to =
empty string #8683.=0A=
      throw ngMinErr(=0A=
          'btstrpd',=0A=
          'App already bootstrapped with this element \'{0}\'',=0A=
          tag.replace(/&lt;/,'&amp;lt;').replace(/&gt;/,'&amp;gt;'));=0A=
    }=0A=
=0A=
    modules =3D modules || [];=0A=
    modules.unshift(['$provide', function($provide) {=0A=
      $provide.value('$rootElement', element);=0A=
    }]);=0A=
=0A=
    if (config.debugInfoEnabled) {=0A=
      // Pushing so that this overrides `debugInfoEnabled` setting =
defined in user's `modules`.=0A=
      modules.push(['$compileProvider', function($compileProvider) {=0A=
        $compileProvider.debugInfoEnabled(true);=0A=
      }]);=0A=
    }=0A=
=0A=
    modules.unshift('ng');=0A=
    var injector =3D createInjector(modules, config.strictDi);=0A=
    injector.invoke(['$rootScope', '$rootElement', '$compile', =
'$injector',=0A=
       function bootstrapApply(scope, element, compile, injector) {=0A=
        scope.$apply(function() {=0A=
          element.data('$injector', injector);=0A=
          compile(element)(scope);=0A=
        });=0A=
      }]=0A=
    );=0A=
    return injector;=0A=
  };=0A=
=0A=
  var NG_ENABLE_DEBUG_INFO =3D /^NG_ENABLE_DEBUG_INFO!/;=0A=
  var NG_DEFER_BOOTSTRAP =3D /^NG_DEFER_BOOTSTRAP!/;=0A=
=0A=
  if (window &amp;&amp; NG_ENABLE_DEBUG_INFO.test(window.name)) {=0A=
    config.debugInfoEnabled =3D true;=0A=
    window.name =3D window.name.replace(NG_ENABLE_DEBUG_INFO, '');=0A=
  }=0A=
=0A=
  if (window &amp;&amp; !NG_DEFER_BOOTSTRAP.test(window.name)) {=0A=
    return doBootstrap();=0A=
  }=0A=
=0A=
  window.name =3D window.name.replace(NG_DEFER_BOOTSTRAP, '');=0A=
  angular.resumeBootstrap =3D function(extraModules) {=0A=
    forEach(extraModules, function(module) {=0A=
      modules.push(module);=0A=
    });=0A=
    return doBootstrap();=0A=
  };=0A=
=0A=
  if (isFunction(angular.resumeDeferredBootstrap)) {=0A=
    angular.resumeDeferredBootstrap();=0A=
  }=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.reloadWithDebugInfo=0A=
 * @module ng=0A=
 * @description=0A=
 * Use this function to reload the current application with debug =
information turned on.=0A=
 * This takes precedence over a call to =
`$compileProvider.debugInfoEnabled(false)`.=0A=
 *=0A=
 * See {@link ng.$compileProvider#debugInfoEnabled} for more.=0A=
 */=0A=
function reloadWithDebugInfo() {=0A=
  window.name =3D 'NG_ENABLE_DEBUG_INFO!' + window.name;=0A=
  window.location.reload();=0A=
}=0A=
=0A=
/**=0A=
 * @name angular.getTestability=0A=
 * @module ng=0A=
 * @description=0A=
 * Get the testability service for the instance of Angular on the given=0A=
 * element.=0A=
 * @param {DOMElement} element DOM element which is the root of angular =
application.=0A=
 */=0A=
function getTestability(rootElement) {=0A=
  var injector =3D angular.element(rootElement).injector();=0A=
  if (!injector) {=0A=
    throw ngMinErr('test',=0A=
      'no injector found for element argument to getTestability');=0A=
  }=0A=
  return injector.get('$$testability');=0A=
}=0A=
=0A=
var SNAKE_CASE_REGEXP =3D /[A-Z]/g;=0A=
function snake_case(name, separator) {=0A=
  separator =3D separator || '_';=0A=
  return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {=0A=
    return (pos ? separator : '') + letter.toLowerCase();=0A=
  });=0A=
}=0A=
=0A=
var bindJQueryFired =3D false;=0A=
function bindJQuery() {=0A=
  var originalCleanData;=0A=
=0A=
  if (bindJQueryFired) {=0A=
    return;=0A=
  }=0A=
=0A=
  // bind to jQuery if present;=0A=
  var jqName =3D jq();=0A=
  jQuery =3D isUndefined(jqName) ? window.jQuery :   // use jQuery (if =
present)=0A=
           !jqName             ? undefined     :   // use jqLite=0A=
                                 window[jqName];   // use jQuery =
specified by `ngJq`=0A=
=0A=
  // Use jQuery if it exists with proper functionality, otherwise =
default to us.=0A=
  // Angular 1.2+ requires jQuery 1.7+ for on()/off() support.=0A=
  // Angular 1.3+ technically requires at least jQuery 2.1+ but it may =
work with older=0A=
  // versions. It will not work for sure with jQuery &lt;1.7, though.=0A=
  if (jQuery &amp;&amp; jQuery.fn.on) {=0A=
    jqLite =3D jQuery;=0A=
    extend(jQuery.fn, {=0A=
      scope: JQLitePrototype.scope,=0A=
      isolateScope: JQLitePrototype.isolateScope,=0A=
      controller: /** @type {?} */ (JQLitePrototype).controller,=0A=
      injector: JQLitePrototype.injector,=0A=
      inheritedData: JQLitePrototype.inheritedData=0A=
    });=0A=
=0A=
    // All nodes removed from the DOM via various jQuery APIs like =
.remove()=0A=
    // are passed through jQuery.cleanData. Monkey-patch this method to =
fire=0A=
    // the $destroy event on all removed nodes.=0A=
    originalCleanData =3D jQuery.cleanData;=0A=
    jQuery.cleanData =3D function(elems) {=0A=
      var events;=0A=
      for (var i =3D 0, elem; (elem =3D elems[i]) !=3D null; i++) {=0A=
        events =3D jQuery._data(elem, 'events');=0A=
        if (events &amp;&amp; events.$destroy) {=0A=
          jQuery(elem).triggerHandler('$destroy');=0A=
        }=0A=
      }=0A=
      originalCleanData(elems);=0A=
    };=0A=
  } else {=0A=
    jqLite =3D JQLite;=0A=
  }=0A=
=0A=
  angular.element =3D jqLite;=0A=
=0A=
  // Prevent double-proxying.=0A=
  bindJQueryFired =3D true;=0A=
}=0A=
=0A=
/**=0A=
 * throw error if the argument is falsy.=0A=
 */=0A=
function assertArg(arg, name, reason) {=0A=
  if (!arg) {=0A=
    throw ngMinErr('areq', 'Argument \'{0}\' is {1}', (name || '?'), =
(reason || 'required'));=0A=
  }=0A=
  return arg;=0A=
}=0A=
=0A=
function assertArgFn(arg, name, acceptArrayAnnotation) {=0A=
  if (acceptArrayAnnotation &amp;&amp; isArray(arg)) {=0A=
      arg =3D arg[arg.length - 1];=0A=
  }=0A=
=0A=
  assertArg(isFunction(arg), name, 'not a function, got ' +=0A=
      (arg &amp;&amp; typeof arg =3D=3D=3D 'object' ? =
arg.constructor.name || 'Object' : typeof arg));=0A=
  return arg;=0A=
}=0A=
=0A=
/**=0A=
 * throw error if the name given is hasOwnProperty=0A=
 * @param  {String} name    the name to test=0A=
 * @param  {String} context the context in which the name is used, such =
as module or directive=0A=
 */=0A=
function assertNotHasOwnProperty(name, context) {=0A=
  if (name =3D=3D=3D 'hasOwnProperty') {=0A=
    throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', =
context);=0A=
  }=0A=
}=0A=
=0A=
/**=0A=
 * Return the value accessible from the object by path. Any undefined =
traversals are ignored=0A=
 * @param {Object} obj starting object=0A=
 * @param {String} path path to traverse=0A=
 * @param {boolean} [bindFnToScope=3Dtrue]=0A=
 * @returns {Object} value as accessible by path=0A=
 */=0A=
//TODO(misko): this function needs to be removed=0A=
function getter(obj, path, bindFnToScope) {=0A=
  if (!path) return obj;=0A=
  var keys =3D path.split('.');=0A=
  var key;=0A=
  var lastInstance =3D obj;=0A=
  var len =3D keys.length;=0A=
=0A=
  for (var i =3D 0; i &lt; len; i++) {=0A=
    key =3D keys[i];=0A=
    if (obj) {=0A=
      obj =3D (lastInstance =3D obj)[key];=0A=
    }=0A=
  }=0A=
  if (!bindFnToScope &amp;&amp; isFunction(obj)) {=0A=
    return bind(lastInstance, obj);=0A=
  }=0A=
  return obj;=0A=
}=0A=
=0A=
/**=0A=
 * Return the DOM siblings between the first and last node in the given =
array.=0A=
 * @param {Array} array like object=0A=
 * @returns {Array} the inputted object or a jqLite collection =
containing the nodes=0A=
 */=0A=
function getBlockNodes(nodes) {=0A=
  // TODO(perf): update `nodes` instead of creating a new object?=0A=
  var node =3D nodes[0];=0A=
  var endNode =3D nodes[nodes.length - 1];=0A=
  var blockNodes;=0A=
=0A=
  for (var i =3D 1; node !=3D=3D endNode &amp;&amp; (node =3D =
node.nextSibling); i++) {=0A=
    if (blockNodes || nodes[i] !=3D=3D node) {=0A=
      if (!blockNodes) {=0A=
        blockNodes =3D jqLite(slice.call(nodes, 0, i));=0A=
      }=0A=
      blockNodes.push(node);=0A=
    }=0A=
  }=0A=
=0A=
  return blockNodes || nodes;=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * Creates a new object without a prototype. This object is useful for =
lookup without having to=0A=
 * guard against prototypically inherited properties via hasOwnProperty.=0A=
 *=0A=
 * Related micro-benchmarks:=0A=
 * - http://jsperf.com/object-create2=0A=
 * - http://jsperf.com/proto-map-lookup/2=0A=
 * - http://jsperf.com/for-in-vs-object-keys2=0A=
 *=0A=
 * @returns {Object}=0A=
 */=0A=
function createMap() {=0A=
  return Object.create(null);=0A=
}=0A=
=0A=
function stringify(value) {=0A=
  if (value =3D=3D null) { // null || undefined=0A=
    return '';=0A=
  }=0A=
  switch (typeof value) {=0A=
    case 'string':=0A=
      break;=0A=
    case 'number':=0A=
      value =3D '' + value;=0A=
      break;=0A=
    default:=0A=
      if (hasCustomToString(value) &amp;&amp; !isArray(value) &amp;&amp; =
!isDate(value)) {=0A=
        value =3D value.toString();=0A=
      } else {=0A=
        value =3D toJson(value);=0A=
      }=0A=
  }=0A=
=0A=
  return value;=0A=
}=0A=
=0A=
var NODE_TYPE_ELEMENT =3D 1;=0A=
var NODE_TYPE_ATTRIBUTE =3D 2;=0A=
var NODE_TYPE_TEXT =3D 3;=0A=
var NODE_TYPE_COMMENT =3D 8;=0A=
var NODE_TYPE_DOCUMENT =3D 9;=0A=
var NODE_TYPE_DOCUMENT_FRAGMENT =3D 11;=0A=
=0A=
/**=0A=
 * @ngdoc type=0A=
 * @name angular.Module=0A=
 * @module ng=0A=
 * @description=0A=
 *=0A=
 * Interface for configuring angular {@link angular.module modules}.=0A=
 */=0A=
=0A=
function setupModuleLoader(window) {=0A=
=0A=
  var $injectorMinErr =3D minErr('$injector');=0A=
  var ngMinErr =3D minErr('ng');=0A=
=0A=
  function ensure(obj, name, factory) {=0A=
    return obj[name] || (obj[name] =3D factory());=0A=
  }=0A=
=0A=
  var angular =3D ensure(window, 'angular', Object);=0A=
=0A=
  // We need to expose `angular.$$minErr` to modules such as =
`ngResource` that reference it during bootstrap=0A=
  angular.$$minErr =3D angular.$$minErr || minErr;=0A=
=0A=
  return ensure(angular, 'module', function() {=0A=
    /** @type {Object.&lt;string, angular.Module&gt;} */=0A=
    var modules =3D {};=0A=
=0A=
    /**=0A=
     * @ngdoc function=0A=
     * @name angular.module=0A=
     * @module ng=0A=
     * @description=0A=
     *=0A=
     * The `angular.module` is a global place for creating, registering =
and retrieving Angular=0A=
     * modules.=0A=
     * All modules (angular core or 3rd party) that should be available =
to an application must be=0A=
     * registered using this mechanism.=0A=
     *=0A=
     * Passing one argument retrieves an existing {@link angular.Module},=0A=
     * whereas passing more than one argument creates a new {@link =
angular.Module}=0A=
     *=0A=
     *=0A=
     * # Module=0A=
     *=0A=
     * A module is a collection of services, directives, controllers, =
filters, and configuration information.=0A=
     * `angular.module` is used to configure the {@link auto.$injector =
$injector}.=0A=
     *=0A=
     * ```js=0A=
     * // Create a new module=0A=
     * var myModule =3D angular.module('myModule', []);=0A=
     *=0A=
     * // register a new service=0A=
     * myModule.value('appName', 'MyCoolApp');=0A=
     *=0A=
     * // configure existing services inside initialization blocks.=0A=
     * myModule.config(['$locationProvider', function($locationProvider) =
{=0A=
     *   // Configure existing providers=0A=
     *   $locationProvider.hashPrefix('!');=0A=
     * }]);=0A=
     * ```=0A=
     *=0A=
     * Then you can create an injector and load your modules like this:=0A=
     *=0A=
     * ```js=0A=
     * var injector =3D angular.injector(['ng', 'myModule'])=0A=
     * ```=0A=
     *=0A=
     * However it's more likely that you'll just use=0A=
     * {@link ng.directive:ngApp ngApp} or=0A=
     * {@link angular.bootstrap} to simplify this process for you.=0A=
     *=0A=
     * @param {!string} name The name of the module to create or =
retrieve.=0A=
     * @param {!Array.&lt;string&gt;=3D} requires If specified then new =
module is being created. If=0A=
     *        unspecified then the module is being retrieved for further =
configuration.=0A=
     * @param {Function=3D} configFn Optional configuration function for =
the module. Same as=0A=
     *        {@link angular.Module#config Module#config()}.=0A=
     * @returns {angular.Module} new module with the {@link =
angular.Module} api.=0A=
     */=0A=
    return function module(name, requires, configFn) {=0A=
=0A=
      var info =3D {};=0A=
=0A=
      var assertNotHasOwnProperty =3D function(name, context) {=0A=
        if (name =3D=3D=3D 'hasOwnProperty') {=0A=
          throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} =
name', context);=0A=
        }=0A=
      };=0A=
=0A=
      assertNotHasOwnProperty(name, 'module');=0A=
      if (requires &amp;&amp; modules.hasOwnProperty(name)) {=0A=
        modules[name] =3D null;=0A=
      }=0A=
      return ensure(modules, name, function() {=0A=
        if (!requires) {=0A=
          throw $injectorMinErr('nomod', 'Module \'{0}\' is not =
available! You either misspelled ' +=0A=
             'the module name or forgot to load it. If registering a =
module ensure that you ' +=0A=
             'specify the dependencies as the second argument.', name);=0A=
        }=0A=
=0A=
        /** @type {!Array.&lt;Array.&lt;*&gt;&gt;} */=0A=
        var invokeQueue =3D [];=0A=
=0A=
        /** @type {!Array.&lt;Function&gt;} */=0A=
        var configBlocks =3D [];=0A=
=0A=
        /** @type {!Array.&lt;Function&gt;} */=0A=
        var runBlocks =3D [];=0A=
=0A=
        var config =3D invokeLater('$injector', 'invoke', 'push', =
configBlocks);=0A=
=0A=
        /** @type {angular.Module} */=0A=
        var moduleInstance =3D {=0A=
          // Private state=0A=
          _invokeQueue: invokeQueue,=0A=
          _configBlocks: configBlocks,=0A=
          _runBlocks: runBlocks,=0A=
=0A=
          /**=0A=
           * @ngdoc method=0A=
           * @name angular.Module#info=0A=
           * @module ng=0A=
           *=0A=
           * @param {Object=3D} info Information about the module=0A=
           * @returns {Object|Module} The current info object for this =
module if called as a getter,=0A=
           *                          or `this` if called as a setter.=0A=
           *=0A=
           * @description=0A=
           * Read and write custom information about this module.=0A=
           * For example you could put the version of the module in here.=0A=
           *=0A=
           * ```js=0A=
           * angular.module('myModule', []).info({ version: '1.0.0' });=0A=
           * ```=0A=
           *=0A=
           * The version could then be read back out by accessing the =
module elsewhere:=0A=
           *=0A=
           * ```=0A=
           * var version =3D angular.module('myModule').info().version;=0A=
           * ```=0A=
           *=0A=
           * You can also retrieve this information during runtime via =
the=0A=
           * {@link $injector#modules `$injector.modules`} property:=0A=
           *=0A=
           * ```js=0A=
           * var version =3D =
$injector.modules['myModule'].info().version;=0A=
           * ```=0A=
           */=0A=
          info: function(value) {=0A=
            if (isDefined(value)) {=0A=
              if (!isObject(value)) throw ngMinErr('aobj', 'Argument =
\'{0}\' must be an object', 'value');=0A=
              info =3D value;=0A=
              return this;=0A=
            }=0A=
            return info;=0A=
          },=0A=
=0A=
          /**=0A=
           * @ngdoc property=0A=
           * @name angular.Module#requires=0A=
           * @module ng=0A=
           *=0A=
           * @description=0A=
           * Holds the list of modules which the injector will load =
before the current module is=0A=
           * loaded.=0A=
           */=0A=
          requires: requires,=0A=
=0A=
          /**=0A=
           * @ngdoc property=0A=
           * @name angular.Module#name=0A=
           * @module ng=0A=
           *=0A=
           * @description=0A=
           * Name of the module.=0A=
           */=0A=
          name: name,=0A=
=0A=
=0A=
          /**=0A=
           * @ngdoc method=0A=
           * @name angular.Module#provider=0A=
           * @module ng=0A=
           * @param {string} name service name=0A=
           * @param {Function} providerType Construction function for =
creating new instance of the=0A=
           *                                service.=0A=
           * @description=0A=
           * See {@link auto.$provide#provider $provide.provider()}.=0A=
           */=0A=
          provider: invokeLaterAndSetModuleName('$provide', 'provider'),=0A=
=0A=
          /**=0A=
           * @ngdoc method=0A=
           * @name angular.Module#factory=0A=
           * @module ng=0A=
           * @param {string} name service name=0A=
           * @param {Function} providerFunction Function for creating =
new instance of the service.=0A=
           * @description=0A=
           * See {@link auto.$provide#factory $provide.factory()}.=0A=
           */=0A=
          factory: invokeLaterAndSetModuleName('$provide', 'factory'),=0A=
=0A=
          /**=0A=
           * @ngdoc method=0A=
           * @name angular.Module#service=0A=
           * @module ng=0A=
           * @param {string} name service name=0A=
           * @param {Function} constructor A constructor function that =
will be instantiated.=0A=
           * @description=0A=
           * See {@link auto.$provide#service $provide.service()}.=0A=
           */=0A=
          service: invokeLaterAndSetModuleName('$provide', 'service'),=0A=
=0A=
          /**=0A=
           * @ngdoc method=0A=
           * @name angular.Module#value=0A=
           * @module ng=0A=
           * @param {string} name service name=0A=
           * @param {*} object Service instance object.=0A=
           * @description=0A=
           * See {@link auto.$provide#value $provide.value()}.=0A=
           */=0A=
          value: invokeLater('$provide', 'value'),=0A=
=0A=
          /**=0A=
           * @ngdoc method=0A=
           * @name angular.Module#constant=0A=
           * @module ng=0A=
           * @param {string} name constant name=0A=
           * @param {*} object Constant value.=0A=
           * @description=0A=
           * Because the constants are fixed, they get applied before =
other provide methods.=0A=
           * See {@link auto.$provide#constant $provide.constant()}.=0A=
           */=0A=
          constant: invokeLater('$provide', 'constant', 'unshift'),=0A=
=0A=
           /**=0A=
           * @ngdoc method=0A=
           * @name angular.Module#decorator=0A=
           * @module ng=0A=
           * @param {string} name The name of the service to decorate.=0A=
           * @param {Function} decorFn This function will be invoked =
when the service needs to be=0A=
           *                           instantiated and should return =
the decorated service instance.=0A=
           * @description=0A=
           * See {@link auto.$provide#decorator $provide.decorator()}.=0A=
           */=0A=
          decorator: invokeLaterAndSetModuleName('$provide', =
'decorator', configBlocks),=0A=
=0A=
          /**=0A=
           * @ngdoc method=0A=
           * @name angular.Module#animation=0A=
           * @module ng=0A=
           * @param {string} name animation name=0A=
           * @param {Function} animationFactory Factory function for =
creating new instance of an=0A=
           *                                    animation.=0A=
           * @description=0A=
           *=0A=
           * **NOTE**: animations take effect only if the **ngAnimate** =
module is loaded.=0A=
           *=0A=
           *=0A=
           * Defines an animation hook that can be later used with=0A=
           * {@link $animate $animate} service and directives that use =
this service.=0A=
           *=0A=
           * ```js=0A=
           * module.animation('.animation-name', function($inject1, =
$inject2) {=0A=
           *   return {=0A=
           *     eventName : function(element, done) {=0A=
           *       //code to run the animation=0A=
           *       //once complete, then run done()=0A=
           *       return function cancellationFunction(element) {=0A=
           *         //code to cancel the animation=0A=
           *       }=0A=
           *     }=0A=
           *   }=0A=
           * })=0A=
           * ```=0A=
           *=0A=
           * See {@link ng.$animateProvider#register =
$animateProvider.register()} and=0A=
           * {@link ngAnimate ngAnimate module} for more information.=0A=
           */=0A=
          animation: invokeLaterAndSetModuleName('$animateProvider', =
'register'),=0A=
=0A=
          /**=0A=
           * @ngdoc method=0A=
           * @name angular.Module#filter=0A=
           * @module ng=0A=
           * @param {string} name Filter name - this must be a valid =
angular expression identifier=0A=
           * @param {Function} filterFactory Factory function for =
creating new instance of filter.=0A=
           * @description=0A=
           * See {@link ng.$filterProvider#register =
$filterProvider.register()}.=0A=
           *=0A=
           * &lt;div class=3D"alert alert-warning"&gt;=0A=
           * **Note:** Filter names must be valid angular {@link =
expression} identifiers, such as `uppercase` or `orderBy`.=0A=
           * Names with special characters, such as hyphens and dots, =
are not allowed. If you wish to namespace=0A=
           * your filters, then you can use capitalization =
(`myappSubsectionFilterx`) or underscores=0A=
           * (`myapp_subsection_filterx`).=0A=
           * &lt;/div&gt;=0A=
           */=0A=
          filter: invokeLaterAndSetModuleName('$filterProvider', =
'register'),=0A=
=0A=
          /**=0A=
           * @ngdoc method=0A=
           * @name angular.Module#controller=0A=
           * @module ng=0A=
           * @param {string|Object} name Controller name, or an object =
map of controllers where the=0A=
           *    keys are the names and the values are the constructors.=0A=
           * @param {Function} constructor Controller constructor =
function.=0A=
           * @description=0A=
           * See {@link ng.$controllerProvider#register =
$controllerProvider.register()}.=0A=
           */=0A=
          controller: invokeLaterAndSetModuleName('$controllerProvider', =
'register'),=0A=
=0A=
          /**=0A=
           * @ngdoc method=0A=
           * @name angular.Module#directive=0A=
           * @module ng=0A=
           * @param {string|Object} name Directive name, or an object =
map of directives where the=0A=
           *    keys are the names and the values are the factories.=0A=
           * @param {Function} directiveFactory Factory function for =
creating new instance of=0A=
           * directives.=0A=
           * @description=0A=
           * See {@link ng.$compileProvider#directive =
$compileProvider.directive()}.=0A=
           */=0A=
          directive: invokeLaterAndSetModuleName('$compileProvider', =
'directive'),=0A=
=0A=
          /**=0A=
           * @ngdoc method=0A=
           * @name angular.Module#component=0A=
           * @module ng=0A=
           * @param {string} name Name of the component in camel-case =
(i.e. myComp which will match as my-comp)=0A=
           * @param {Object} options Component definition object (a =
simplified=0A=
           *    {@link ng.$compile#directive-definition-object directive =
definition object})=0A=
           *=0A=
           * @description=0A=
           * See {@link ng.$compileProvider#component =
$compileProvider.component()}.=0A=
           */=0A=
          component: invokeLaterAndSetModuleName('$compileProvider', =
'component'),=0A=
=0A=
          /**=0A=
           * @ngdoc method=0A=
           * @name angular.Module#config=0A=
           * @module ng=0A=
           * @param {Function} configFn Execute this function on module =
load. Useful for service=0A=
           *    configuration.=0A=
           * @description=0A=
           * Use this method to register work which needs to be =
performed on module loading.=0A=
           * For more about how to configure services, see=0A=
           * {@link providers#provider-recipe Provider Recipe}.=0A=
           */=0A=
          config: config,=0A=
=0A=
          /**=0A=
           * @ngdoc method=0A=
           * @name angular.Module#run=0A=
           * @module ng=0A=
           * @param {Function} initializationFn Execute this function =
after injector creation.=0A=
           *    Useful for application initialization.=0A=
           * @description=0A=
           * Use this method to register work which should be performed =
when the injector is done=0A=
           * loading all modules.=0A=
           */=0A=
          run: function(block) {=0A=
            runBlocks.push(block);=0A=
            return this;=0A=
          }=0A=
        };=0A=
=0A=
        if (configFn) {=0A=
          config(configFn);=0A=
        }=0A=
=0A=
        return moduleInstance;=0A=
=0A=
        /**=0A=
         * @param {string} provider=0A=
         * @param {string} method=0A=
         * @param {String=3D} insertMethod=0A=
         * @returns {angular.Module}=0A=
         */=0A=
        function invokeLater(provider, method, insertMethod, queue) {=0A=
          if (!queue) queue =3D invokeQueue;=0A=
          return function() {=0A=
            queue[insertMethod || 'push']([provider, method, arguments]);=0A=
            return moduleInstance;=0A=
          };=0A=
        }=0A=
=0A=
        /**=0A=
         * @param {string} provider=0A=
         * @param {string} method=0A=
         * @returns {angular.Module}=0A=
         */=0A=
        function invokeLaterAndSetModuleName(provider, method, queue) {=0A=
          if (!queue) queue =3D invokeQueue;=0A=
          return function(recipeName, factoryFunction) {=0A=
            if (factoryFunction &amp;&amp; isFunction(factoryFunction)) =
factoryFunction.$$moduleName =3D name;=0A=
            queue.push([provider, method, arguments]);=0A=
            return moduleInstance;=0A=
          };=0A=
        }=0A=
      });=0A=
    };=0A=
  });=0A=
=0A=
}=0A=
=0A=
/* global shallowCopy: true */=0A=
=0A=
/**=0A=
 * Creates a shallow copy of an object, an array or a primitive.=0A=
 *=0A=
 * Assumes that there are no proto properties for objects.=0A=
 */=0A=
function shallowCopy(src, dst) {=0A=
  if (isArray(src)) {=0A=
    dst =3D dst || [];=0A=
=0A=
    for (var i =3D 0, ii =3D src.length; i &lt; ii; i++) {=0A=
      dst[i] =3D src[i];=0A=
    }=0A=
  } else if (isObject(src)) {=0A=
    dst =3D dst || {};=0A=
=0A=
    for (var key in src) {=0A=
      if (!(key.charAt(0) =3D=3D=3D '$' &amp;&amp; key.charAt(1) =
=3D=3D=3D '$')) {=0A=
        dst[key] =3D src[key];=0A=
      }=0A=
    }=0A=
  }=0A=
=0A=
  return dst || src;=0A=
}=0A=
=0A=
/* exported toDebugString */=0A=
=0A=
function serializeObject(obj, maxDepth) {=0A=
  var seen =3D [];=0A=
=0A=
  // There is no direct way to stringify object until reaching a =
specific depth=0A=
  // and a very deep object can cause a performance issue, so we copy =
the object=0A=
  // based on this specific depth and then stringify it.=0A=
  if (isValidObjectMaxDepth(maxDepth)) {=0A=
    // This file is also included in `angular-loader`, so `copy()` might =
not always be available in=0A=
    // the closure. Therefore, it is lazily retrieved as =
`angular.copy()` when needed.=0A=
    obj =3D angular.copy(obj, null, maxDepth);=0A=
  }=0A=
  return JSON.stringify(obj, function(key, val) {=0A=
    val =3D toJsonReplacer(key, val);=0A=
    if (isObject(val)) {=0A=
=0A=
      if (seen.indexOf(val) &gt;=3D 0) return '...';=0A=
=0A=
      seen.push(val);=0A=
    }=0A=
    return val;=0A=
  });=0A=
}=0A=
=0A=
function toDebugString(obj, maxDepth) {=0A=
  if (typeof obj =3D=3D=3D 'function') {=0A=
    return obj.toString().replace(/ \{[\s\S]*$/, '');=0A=
  } else if (isUndefined(obj)) {=0A=
    return 'undefined';=0A=
  } else if (typeof obj !=3D=3D 'string') {=0A=
    return serializeObject(obj, maxDepth);=0A=
  }=0A=
  return obj;=0A=
}=0A=
=0A=
/* global angularModule: true,=0A=
  version: true,=0A=
=0A=
  $CompileProvider,=0A=
=0A=
  htmlAnchorDirective,=0A=
  inputDirective,=0A=
  inputDirective,=0A=
  formDirective,=0A=
  scriptDirective,=0A=
  selectDirective,=0A=
  optionDirective,=0A=
  ngBindDirective,=0A=
  ngBindHtmlDirective,=0A=
  ngBindTemplateDirective,=0A=
  ngClassDirective,=0A=
  ngClassEvenDirective,=0A=
  ngClassOddDirective,=0A=
  ngCloakDirective,=0A=
  ngControllerDirective,=0A=
  ngFormDirective,=0A=
  ngHideDirective,=0A=
  ngIfDirective,=0A=
  ngIncludeDirective,=0A=
  ngIncludeFillContentDirective,=0A=
  ngInitDirective,=0A=
  ngNonBindableDirective,=0A=
  ngPluralizeDirective,=0A=
  ngRepeatDirective,=0A=
  ngShowDirective,=0A=
  ngStyleDirective,=0A=
  ngSwitchDirective,=0A=
  ngSwitchWhenDirective,=0A=
  ngSwitchDefaultDirective,=0A=
  ngOptionsDirective,=0A=
  ngTranscludeDirective,=0A=
  ngModelDirective,=0A=
  ngListDirective,=0A=
  ngChangeDirective,=0A=
  patternDirective,=0A=
  patternDirective,=0A=
  requiredDirective,=0A=
  requiredDirective,=0A=
  minlengthDirective,=0A=
  minlengthDirective,=0A=
  maxlengthDirective,=0A=
  maxlengthDirective,=0A=
  ngValueDirective,=0A=
  ngModelOptionsDirective,=0A=
  ngAttributeAliasDirectives,=0A=
  ngEventDirectives,=0A=
=0A=
  $AnchorScrollProvider,=0A=
  $AnimateProvider,=0A=
  $CoreAnimateCssProvider,=0A=
  $$CoreAnimateJsProvider,=0A=
  $$CoreAnimateQueueProvider,=0A=
  $$AnimateRunnerFactoryProvider,=0A=
  $$AnimateAsyncRunFactoryProvider,=0A=
  $BrowserProvider,=0A=
  $CacheFactoryProvider,=0A=
  $ControllerProvider,=0A=
  $DateProvider,=0A=
  $DocumentProvider,=0A=
  $$IsDocumentHiddenProvider,=0A=
  $ExceptionHandlerProvider,=0A=
  $FilterProvider,=0A=
  $$ForceReflowProvider,=0A=
  $InterpolateProvider,=0A=
  $IntervalProvider,=0A=
  $HttpProvider,=0A=
  $HttpParamSerializerProvider,=0A=
  $HttpParamSerializerJQLikeProvider,=0A=
  $HttpBackendProvider,=0A=
  $xhrFactoryProvider,=0A=
  $jsonpCallbacksProvider,=0A=
  $LocationProvider,=0A=
  $LogProvider,=0A=
  $$MapProvider,=0A=
  $ParseProvider,=0A=
  $RootScopeProvider,=0A=
  $QProvider,=0A=
  $$QProvider,=0A=
  $$SanitizeUriProvider,=0A=
  $SceProvider,=0A=
  $SceDelegateProvider,=0A=
  $SnifferProvider,=0A=
  $TemplateCacheProvider,=0A=
  $TemplateRequestProvider,=0A=
  $$TestabilityProvider,=0A=
  $TimeoutProvider,=0A=
  $$RAFProvider,=0A=
  $WindowProvider,=0A=
  $$jqLiteProvider,=0A=
  $$CookieReaderProvider=0A=
*/=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc object=0A=
 * @name angular.version=0A=
 * @module ng=0A=
 * @description=0A=
 * An object that contains information about the current AngularJS =
version.=0A=
 *=0A=
 * This object has the following properties:=0A=
 *=0A=
 * - `full` =E2=80&#65533; `{string}` =E2=80&#65533; Full version =
string, such as "0.9.18".=0A=
 * - `major` =E2=80&#65533; `{number}` =E2=80&#65533; Major version =
number, such as "0".=0A=
 * - `minor` =E2=80&#65533; `{number}` =E2=80&#65533; Minor version =
number, such as "9".=0A=
 * - `dot` =E2=80&#65533; `{number}` =E2=80&#65533; Dot version number, =
such as "18".=0A=
 * - `codeName` =E2=80&#65533; `{string}` =E2=80&#65533; Code name of =
the release, such as "jiggling-armfat".=0A=
 */=0A=
var version =3D {=0A=
  // These placeholder strings will be replaced by grunt's `build` task.=0A=
  // They need to be double- or single-quoted.=0A=
  full: '1.6.5',=0A=
  major: 1,=0A=
  minor: 6,=0A=
  dot: 5,=0A=
  codeName: 'toffee-salinization'=0A=
};=0A=
=0A=
=0A=
function publishExternalAPI(angular) {=0A=
  extend(angular, {=0A=
    'errorHandlingConfig': errorHandlingConfig,=0A=
    'bootstrap': bootstrap,=0A=
    'copy': copy,=0A=
    'extend': extend,=0A=
    'merge': merge,=0A=
    'equals': equals,=0A=
    'element': jqLite,=0A=
    'forEach': forEach,=0A=
    'injector': createInjector,=0A=
    'noop': noop,=0A=
    'bind': bind,=0A=
    'toJson': toJson,=0A=
    'fromJson': fromJson,=0A=
    'identity': identity,=0A=
    'isUndefined': isUndefined,=0A=
    'isDefined': isDefined,=0A=
    'isString': isString,=0A=
    'isFunction': isFunction,=0A=
    'isObject': isObject,=0A=
    'isNumber': isNumber,=0A=
    'isElement': isElement,=0A=
    'isArray': isArray,=0A=
    'version': version,=0A=
    'isDate': isDate,=0A=
    'lowercase': lowercase,=0A=
    'uppercase': uppercase,=0A=
    'callbacks': {$$counter: 0},=0A=
    'getTestability': getTestability,=0A=
    'reloadWithDebugInfo': reloadWithDebugInfo,=0A=
    '$$minErr': minErr,=0A=
    '$$csp': csp,=0A=
    '$$encodeUriSegment': encodeUriSegment,=0A=
    '$$encodeUriQuery': encodeUriQuery,=0A=
    '$$stringify': stringify=0A=
  });=0A=
=0A=
  angularModule =3D setupModuleLoader(window);=0A=
=0A=
  angularModule('ng', ['ngLocale'], ['$provide',=0A=
    function ngModule($provide) {=0A=
      // $$sanitizeUriProvider needs to be before $compileProvider as it =
is used by it.=0A=
      $provide.provider({=0A=
        $$sanitizeUri: $$SanitizeUriProvider=0A=
      });=0A=
      $provide.provider('$compile', $CompileProvider).=0A=
        directive({=0A=
            a: htmlAnchorDirective,=0A=
            input: inputDirective,=0A=
            textarea: inputDirective,=0A=
            form: formDirective,=0A=
            script: scriptDirective,=0A=
            select: selectDirective,=0A=
            option: optionDirective,=0A=
            ngBind: ngBindDirective,=0A=
            ngBindHtml: ngBindHtmlDirective,=0A=
            ngBindTemplate: ngBindTemplateDirective,=0A=
            ngClass: ngClassDirective,=0A=
            ngClassEven: ngClassEvenDirective,=0A=
            ngClassOdd: ngClassOddDirective,=0A=
            ngCloak: ngCloakDirective,=0A=
            ngController: ngControllerDirective,=0A=
            ngForm: ngFormDirective,=0A=
            ngHide: ngHideDirective,=0A=
            ngIf: ngIfDirective,=0A=
            ngInclude: ngIncludeDirective,=0A=
            ngInit: ngInitDirective,=0A=
            ngNonBindable: ngNonBindableDirective,=0A=
            ngPluralize: ngPluralizeDirective,=0A=
            ngRepeat: ngRepeatDirective,=0A=
            ngShow: ngShowDirective,=0A=
            ngStyle: ngStyleDirective,=0A=
            ngSwitch: ngSwitchDirective,=0A=
            ngSwitchWhen: ngSwitchWhenDirective,=0A=
            ngSwitchDefault: ngSwitchDefaultDirective,=0A=
            ngOptions: ngOptionsDirective,=0A=
            ngTransclude: ngTranscludeDirective,=0A=
            ngModel: ngModelDirective,=0A=
            ngList: ngListDirective,=0A=
            ngChange: ngChangeDirective,=0A=
            pattern: patternDirective,=0A=
            ngPattern: patternDirective,=0A=
            required: requiredDirective,=0A=
            ngRequired: requiredDirective,=0A=
            minlength: minlengthDirective,=0A=
            ngMinlength: minlengthDirective,=0A=
            maxlength: maxlengthDirective,=0A=
            ngMaxlength: maxlengthDirective,=0A=
            ngValue: ngValueDirective,=0A=
            ngModelOptions: ngModelOptionsDirective=0A=
        }).=0A=
        directive({=0A=
          ngInclude: ngIncludeFillContentDirective=0A=
        }).=0A=
        directive(ngAttributeAliasDirectives).=0A=
        directive(ngEventDirectives);=0A=
      $provide.provider({=0A=
        $anchorScroll: $AnchorScrollProvider,=0A=
        $animate: $AnimateProvider,=0A=
        $animateCss: $CoreAnimateCssProvider,=0A=
        $$animateJs: $$CoreAnimateJsProvider,=0A=
        $$animateQueue: $$CoreAnimateQueueProvider,=0A=
        $$AnimateRunner: $$AnimateRunnerFactoryProvider,=0A=
        $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,=0A=
        $browser: $BrowserProvider,=0A=
        $cacheFactory: $CacheFactoryProvider,=0A=
        $controller: $ControllerProvider,=0A=
        $document: $DocumentProvider,=0A=
        $$isDocumentHidden: $$IsDocumentHiddenProvider,=0A=
        $exceptionHandler: $ExceptionHandlerProvider,=0A=
        $filter: $FilterProvider,=0A=
        $$forceReflow: $$ForceReflowProvider,=0A=
        $interpolate: $InterpolateProvider,=0A=
        $interval: $IntervalProvider,=0A=
        $http: $HttpProvider,=0A=
        $httpParamSerializer: $HttpParamSerializerProvider,=0A=
        $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,=0A=
        $httpBackend: $HttpBackendProvider,=0A=
        $xhrFactory: $xhrFactoryProvider,=0A=
        $jsonpCallbacks: $jsonpCallbacksProvider,=0A=
        $location: $LocationProvider,=0A=
        $log: $LogProvider,=0A=
        $parse: $ParseProvider,=0A=
        $rootScope: $RootScopeProvider,=0A=
        $q: $QProvider,=0A=
        $$q: $$QProvider,=0A=
        $sce: $SceProvider,=0A=
        $sceDelegate: $SceDelegateProvider,=0A=
        $sniffer: $SnifferProvider,=0A=
        $templateCache: $TemplateCacheProvider,=0A=
        $templateRequest: $TemplateRequestProvider,=0A=
        $$testability: $$TestabilityProvider,=0A=
        $timeout: $TimeoutProvider,=0A=
        $window: $WindowProvider,=0A=
        $$rAF: $$RAFProvider,=0A=
        $$jqLite: $$jqLiteProvider,=0A=
        $$Map: $$MapProvider,=0A=
        $$cookieReader: $$CookieReaderProvider=0A=
      });=0A=
    }=0A=
  ])=0A=
  .info({ angularVersion: '1.6.5' });=0A=
}=0A=
=0A=
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * =
* *=0A=
 *     Any commits to this file should be reviewed with security in =
mind.  *=0A=
 *   Changes to this file can potentially create security =
vulnerabilities. *=0A=
 *          An approval from 2 Core members with history of modifying    =
  *=0A=
 *                         this file is required.                        =
  *=0A=
 *                                                                       =
  *=0A=
 *  Does the change somehow allow for arbitrary javascript to be =
executed? *=0A=
 *    Or allows for someone to change the prototype of built-in objects? =
  *=0A=
 *     Or gives undesired access to variables likes document or window?  =
  *=0A=
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * =
* */=0A=
=0A=
/* global=0A=
  JQLitePrototype: true,=0A=
  BOOLEAN_ATTR: true,=0A=
  ALIASED_ATTR: true=0A=
*/=0A=
=0A=
//////////////////////////////////=0A=
//JQLite=0A=
//////////////////////////////////=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.element=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Wraps a raw DOM element or HTML string as a =
[jQuery](http://jquery.com) element.=0A=
 *=0A=
 * If jQuery is available, `angular.element` is an alias for the=0A=
 * [jQuery](http://api.jquery.com/jQuery/) function. If jQuery is not =
available, `angular.element`=0A=
 * delegates to Angular's built-in subset of jQuery, called "jQuery =
lite" or **jqLite**.=0A=
 *=0A=
 * jqLite is a tiny, API-compatible subset of jQuery that allows=0A=
 * Angular to manipulate the DOM in a cross-browser compatible way. =
jqLite implements only the most=0A=
 * commonly needed functionality with the goal of having a very small =
footprint.=0A=
 *=0A=
 * To use `jQuery`, simply ensure it is loaded before the `angular.js` =
file. You can also use the=0A=
 * {@link ngJq `ngJq`} directive to specify that jqlite should be used =
over jQuery, or to use a=0A=
 * specific version of jQuery if multiple versions exist on the page.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-info"&gt;**Note:** All element =
references in Angular are always wrapped with jQuery or=0A=
 * jqLite (such as the element argument in a directive's compile / link =
function). They are never raw DOM references.&lt;/div&gt;=0A=
 *=0A=
 * &lt;div class=3D"alert alert-warning"&gt;**Note:** Keep in mind that =
this function will not find elements=0A=
 * by tag name / CSS selector. For lookups by tag name, try instead =
`angular.element(document).find(...)`=0A=
 * or `$document.find()`, or use the standard DOM APIs, e.g. =
`document.querySelectorAll()`.&lt;/div&gt;=0A=
 *=0A=
 * ## Angular's jqLite=0A=
 * jqLite provides only the following jQuery methods:=0A=
 *=0A=
 * - [`addClass()`](http://api.jquery.com/addClass/) - Does not support =
a function as first argument=0A=
 * - [`after()`](http://api.jquery.com/after/)=0A=
 * - [`append()`](http://api.jquery.com/append/)=0A=
 * - [`attr()`](http://api.jquery.com/attr/) - Does not support =
functions as parameters=0A=
 * - [`bind()`](http://api.jquery.com/bind/) (_deprecated_, use =
[`on()`](http://api.jquery.com/on/)) - Does not support namespaces, =
selectors or eventData=0A=
 * - [`children()`](http://api.jquery.com/children/) - Does not support =
selectors=0A=
 * - [`clone()`](http://api.jquery.com/clone/)=0A=
 * - [`contents()`](http://api.jquery.com/contents/)=0A=
 * - [`css()`](http://api.jquery.com/css/) - Only retrieves =
inline-styles, does not call `getComputedStyle()`.=0A=
 *   As a setter, does not convert numbers to strings or append 'px', =
and also does not have automatic property prefixing.=0A=
 * - [`data()`](http://api.jquery.com/data/)=0A=
 * - [`detach()`](http://api.jquery.com/detach/)=0A=
 * - [`empty()`](http://api.jquery.com/empty/)=0A=
 * - [`eq()`](http://api.jquery.com/eq/)=0A=
 * - [`find()`](http://api.jquery.com/find/) - Limited to lookups by tag =
name=0A=
 * - [`hasClass()`](http://api.jquery.com/hasClass/)=0A=
 * - [`html()`](http://api.jquery.com/html/)=0A=
 * - [`next()`](http://api.jquery.com/next/) - Does not support selectors=0A=
 * - [`on()`](http://api.jquery.com/on/) - Does not support namespaces, =
selectors or eventData=0A=
 * - [`off()`](http://api.jquery.com/off/) - Does not support =
namespaces, selectors or event object as parameter=0A=
 * - [`one()`](http://api.jquery.com/one/) - Does not support namespaces =
or selectors=0A=
 * - [`parent()`](http://api.jquery.com/parent/) - Does not support =
selectors=0A=
 * - [`prepend()`](http://api.jquery.com/prepend/)=0A=
 * - [`prop()`](http://api.jquery.com/prop/)=0A=
 * - [`ready()`](http://api.jquery.com/ready/) (_deprecated_, use =
`angular.element(callback)` instead of =
`angular.element(document).ready(callback)`)=0A=
 * - [`remove()`](http://api.jquery.com/remove/)=0A=
 * - [`removeAttr()`](http://api.jquery.com/removeAttr/) - Does not =
support multiple attributes=0A=
 * - [`removeClass()`](http://api.jquery.com/removeClass/) - Does not =
support a function as first argument=0A=
 * - [`removeData()`](http://api.jquery.com/removeData/)=0A=
 * - [`replaceWith()`](http://api.jquery.com/replaceWith/)=0A=
 * - [`text()`](http://api.jquery.com/text/)=0A=
 * - [`toggleClass()`](http://api.jquery.com/toggleClass/) - Does not =
support a function as first argument=0A=
 * - [`triggerHandler()`](http://api.jquery.com/triggerHandler/) - =
Passes a dummy event object to handlers=0A=
 * - [`unbind()`](http://api.jquery.com/unbind/) (_deprecated_, use =
[`off()`](http://api.jquery.com/off/)) - Does not support namespaces or =
event object as parameter=0A=
 * - [`val()`](http://api.jquery.com/val/)=0A=
 * - [`wrap()`](http://api.jquery.com/wrap/)=0A=
 *=0A=
 * ## jQuery/jqLite Extras=0A=
 * Angular also provides the following additional methods and events to =
both jQuery and jqLite:=0A=
 *=0A=
 * ### Events=0A=
 * - `$destroy` - AngularJS intercepts all jqLite/jQuery's DOM =
destruction apis and fires this event=0A=
 *    on all DOM nodes being removed.  This can be used to clean up any =
3rd party bindings to the DOM=0A=
 *    element before it is removed.=0A=
 *=0A=
 * ### Methods=0A=
 * - `controller(name)` - retrieves the controller of the current =
element or its parent. By default=0A=
 *   retrieves controller associated with the `ngController` directive. =
If `name` is provided as=0A=
 *   camelCase directive name, then the controller for this directive =
will be retrieved (e.g.=0A=
 *   `'ngModel'`).=0A=
 * - `injector()` - retrieves the injector of the current element or its =
parent.=0A=
 * - `scope()` - retrieves the {@link ng.$rootScope.Scope scope} of the =
current=0A=
 *   element or its parent. Requires {@link =
guide/production#disabling-debug-data Debug Data} to=0A=
 *   be enabled.=0A=
 * - `isolateScope()` - retrieves an isolate {@link ng.$rootScope.Scope =
scope} if one is attached directly to the=0A=
 *   current element. This getter should be used only on elements that =
contain a directive which starts a new isolate=0A=
 *   scope. Calling `scope()` on this element always returns the =
original non-isolate scope.=0A=
 *   Requires {@link guide/production#disabling-debug-data Debug Data} =
to be enabled.=0A=
 * - `inheritedData()` - same as `data()`, but walks up the DOM until a =
value is found or the top=0A=
 *   parent element is reached.=0A=
 *=0A=
 * @knownIssue You cannot spy on `angular.element` if you are using =
Jasmine version 1.x. See=0A=
 * https://github.com/angular/angular.js/issues/14251 for more =
information.=0A=
 *=0A=
 * @param {string|DOMElement} element HTML string or DOMElement to be =
wrapped into jQuery.=0A=
 * @returns {Object} jQuery object.=0A=
 */=0A=
=0A=
JQLite.expando =3D 'ng339';=0A=
=0A=
var jqCache =3D JQLite.cache =3D {},=0A=
    jqId =3D 1;=0A=
=0A=
/*=0A=
 * !!! This is an undocumented "private" function !!!=0A=
 */=0A=
JQLite._data =3D function(node) {=0A=
  //jQuery always returns an object on cache miss=0A=
  return this.cache[node[this.expando]] || {};=0A=
};=0A=
=0A=
function jqNextId() { return ++jqId; }=0A=
=0A=
=0A=
var DASH_LOWERCASE_REGEXP =3D /-([a-z])/g;=0A=
var MS_HACK_REGEXP =3D /^-ms-/;=0A=
var MOUSE_EVENT_MAP =3D { mouseleave: 'mouseout', mouseenter: =
'mouseover' };=0A=
var jqLiteMinErr =3D minErr('jqLite');=0A=
=0A=
/**=0A=
 * Converts kebab-case to camelCase.=0A=
 * There is also a special case for the ms prefix starting with a =
lowercase letter.=0A=
 * @param name Name to normalize=0A=
 */=0A=
function cssKebabToCamel(name) {=0A=
    return kebabToCamel(name.replace(MS_HACK_REGEXP, 'ms-'));=0A=
}=0A=
=0A=
function fnCamelCaseReplace(all, letter) {=0A=
  return letter.toUpperCase();=0A=
}=0A=
=0A=
/**=0A=
 * Converts kebab-case to camelCase.=0A=
 * @param name Name to normalize=0A=
 */=0A=
function kebabToCamel(name) {=0A=
  return name=0A=
    .replace(DASH_LOWERCASE_REGEXP, fnCamelCaseReplace);=0A=
}=0A=
=0A=
var SINGLE_TAG_REGEXP =3D /^&lt;([\w-]+)\s*\/?&gt;(?:&lt;\/\1&gt;|)$/;=0A=
var HTML_REGEXP =3D /&lt;|&amp;#?\w+;/;=0A=
var TAG_NAME_REGEXP =3D /&lt;([\w:-]+)/;=0A=
var XHTML_TAG_REGEXP =3D =
/&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^&gt;]*=
)\/&gt;/gi;=0A=
=0A=
var wrapMap =3D {=0A=
  'option': [1, '&lt;select multiple=3D"multiple"&gt;', =
'&lt;/select&gt;'],=0A=
=0A=
  'thead': [1, '&lt;table&gt;', '&lt;/table&gt;'],=0A=
  'col': [2, '&lt;table&gt;&lt;colgroup&gt;', =
'&lt;/colgroup&gt;&lt;/table&gt;'],=0A=
  'tr': [2, '&lt;table&gt;&lt;tbody&gt;', =
'&lt;/tbody&gt;&lt;/table&gt;'],=0A=
  'td': [3, '&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;', =
'&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;'],=0A=
  '_default': [0, '', '']=0A=
};=0A=
=0A=
wrapMap.optgroup =3D wrapMap.option;=0A=
wrapMap.tbody =3D wrapMap.tfoot =3D wrapMap.colgroup =3D wrapMap.caption =
=3D wrapMap.thead;=0A=
wrapMap.th =3D wrapMap.td;=0A=
=0A=
=0A=
function jqLiteIsTextNode(html) {=0A=
  return !HTML_REGEXP.test(html);=0A=
}=0A=
=0A=
function jqLiteAcceptsData(node) {=0A=
  // The window object can accept data but has no nodeType=0A=
  // Otherwise we are only interested in elements (1) and documents (9)=0A=
  var nodeType =3D node.nodeType;=0A=
  return nodeType =3D=3D=3D NODE_TYPE_ELEMENT || !nodeType || nodeType =
=3D=3D=3D NODE_TYPE_DOCUMENT;=0A=
}=0A=
=0A=
function jqLiteHasData(node) {=0A=
  for (var key in jqCache[node.ng339]) {=0A=
    return true;=0A=
  }=0A=
  return false;=0A=
}=0A=
=0A=
function jqLiteBuildFragment(html, context) {=0A=
  var tmp, tag, wrap,=0A=
      fragment =3D context.createDocumentFragment(),=0A=
      nodes =3D [], i;=0A=
=0A=
  if (jqLiteIsTextNode(html)) {=0A=
    // Convert non-html into a text node=0A=
    nodes.push(context.createTextNode(html));=0A=
  } else {=0A=
    // Convert html into DOM nodes=0A=
    tmp =3D fragment.appendChild(context.createElement('div'));=0A=
    tag =3D (TAG_NAME_REGEXP.exec(html) || ['', ''])[1].toLowerCase();=0A=
    wrap =3D wrapMap[tag] || wrapMap._default;=0A=
    tmp.innerHTML =3D wrap[1] + html.replace(XHTML_TAG_REGEXP, =
'&lt;$1&gt;&lt;/$2&gt;') + wrap[2];=0A=
=0A=
    // Descend through wrappers to the right content=0A=
    i =3D wrap[0];=0A=
    while (i--) {=0A=
      tmp =3D tmp.lastChild;=0A=
    }=0A=
=0A=
    nodes =3D concat(nodes, tmp.childNodes);=0A=
=0A=
    tmp =3D fragment.firstChild;=0A=
    tmp.textContent =3D '';=0A=
  }=0A=
=0A=
  // Remove wrapper from fragment=0A=
  fragment.textContent =3D '';=0A=
  fragment.innerHTML =3D ''; // Clear inner HTML=0A=
  forEach(nodes, function(node) {=0A=
    fragment.appendChild(node);=0A=
  });=0A=
=0A=
  return fragment;=0A=
}=0A=
=0A=
function jqLiteParseHTML(html, context) {=0A=
  context =3D context || window.document;=0A=
  var parsed;=0A=
=0A=
  if ((parsed =3D SINGLE_TAG_REGEXP.exec(html))) {=0A=
    return [context.createElement(parsed[1])];=0A=
  }=0A=
=0A=
  if ((parsed =3D jqLiteBuildFragment(html, context))) {=0A=
    return parsed.childNodes;=0A=
  }=0A=
=0A=
  return [];=0A=
}=0A=
=0A=
function jqLiteWrapNode(node, wrapper) {=0A=
  var parent =3D node.parentNode;=0A=
=0A=
  if (parent) {=0A=
    parent.replaceChild(wrapper, node);=0A=
  }=0A=
=0A=
  wrapper.appendChild(node);=0A=
}=0A=
=0A=
=0A=
// IE9-11 has no method "contains" in SVG element and in Node.prototype. =
Bug #10259.=0A=
var jqLiteContains =3D window.Node.prototype.contains || /** @this */ =
function(arg) {=0A=
  // eslint-disable-next-line no-bitwise=0A=
  return !!(this.compareDocumentPosition(arg) &amp; 16);=0A=
};=0A=
=0A=
/////////////////////////////////////////////=0A=
function JQLite(element) {=0A=
  if (element instanceof JQLite) {=0A=
    return element;=0A=
  }=0A=
=0A=
  var argIsString;=0A=
=0A=
  if (isString(element)) {=0A=
    element =3D trim(element);=0A=
    argIsString =3D true;=0A=
  }=0A=
  if (!(this instanceof JQLite)) {=0A=
    if (argIsString &amp;&amp; element.charAt(0) !=3D=3D '&lt;') {=0A=
      throw jqLiteMinErr('nosel', 'Looking up elements via selectors is =
not supported by jqLite! See: =
http://docs.angularjs.org/api/angular.element');=0A=
    }=0A=
    return new JQLite(element);=0A=
  }=0A=
=0A=
  if (argIsString) {=0A=
    jqLiteAddNodes(this, jqLiteParseHTML(element));=0A=
  } else if (isFunction(element)) {=0A=
    jqLiteReady(element);=0A=
  } else {=0A=
    jqLiteAddNodes(this, element);=0A=
  }=0A=
}=0A=
=0A=
function jqLiteClone(element) {=0A=
  return element.cloneNode(true);=0A=
}=0A=
=0A=
function jqLiteDealoc(element, onlyDescendants) {=0A=
  if (!onlyDescendants &amp;&amp; jqLiteAcceptsData(element)) =
jqLite.cleanData([element]);=0A=
=0A=
  if (element.querySelectorAll) {=0A=
    jqLite.cleanData(element.querySelectorAll('*'));=0A=
  }=0A=
}=0A=
=0A=
function jqLiteOff(element, type, fn, unsupported) {=0A=
  if (isDefined(unsupported)) throw jqLiteMinErr('offargs', =
'jqLite#off() does not support the `selector` argument');=0A=
=0A=
  var expandoStore =3D jqLiteExpandoStore(element);=0A=
  var events =3D expandoStore &amp;&amp; expandoStore.events;=0A=
  var handle =3D expandoStore &amp;&amp; expandoStore.handle;=0A=
=0A=
  if (!handle) return; //no listeners registered=0A=
=0A=
  if (!type) {=0A=
    for (type in events) {=0A=
      if (type !=3D=3D '$destroy') {=0A=
        element.removeEventListener(type, handle);=0A=
      }=0A=
      delete events[type];=0A=
    }=0A=
  } else {=0A=
=0A=
    var removeHandler =3D function(type) {=0A=
      var listenerFns =3D events[type];=0A=
      if (isDefined(fn)) {=0A=
        arrayRemove(listenerFns || [], fn);=0A=
      }=0A=
      if (!(isDefined(fn) &amp;&amp; listenerFns &amp;&amp; =
listenerFns.length &gt; 0)) {=0A=
        element.removeEventListener(type, handle);=0A=
        delete events[type];=0A=
      }=0A=
    };=0A=
=0A=
    forEach(type.split(' '), function(type) {=0A=
      removeHandler(type);=0A=
      if (MOUSE_EVENT_MAP[type]) {=0A=
        removeHandler(MOUSE_EVENT_MAP[type]);=0A=
      }=0A=
    });=0A=
  }=0A=
}=0A=
=0A=
function jqLiteRemoveData(element, name) {=0A=
  var expandoId =3D element.ng339;=0A=
  var expandoStore =3D expandoId &amp;&amp; jqCache[expandoId];=0A=
=0A=
  if (expandoStore) {=0A=
    if (name) {=0A=
      delete expandoStore.data[name];=0A=
      return;=0A=
    }=0A=
=0A=
    if (expandoStore.handle) {=0A=
      if (expandoStore.events.$destroy) {=0A=
        expandoStore.handle({}, '$destroy');=0A=
      }=0A=
      jqLiteOff(element);=0A=
    }=0A=
    delete jqCache[expandoId];=0A=
    element.ng339 =3D undefined; // don't delete DOM expandos. IE and =
Chrome don't like it=0A=
  }=0A=
}=0A=
=0A=
=0A=
function jqLiteExpandoStore(element, createIfNecessary) {=0A=
  var expandoId =3D element.ng339,=0A=
      expandoStore =3D expandoId &amp;&amp; jqCache[expandoId];=0A=
=0A=
  if (createIfNecessary &amp;&amp; !expandoStore) {=0A=
    element.ng339 =3D expandoId =3D jqNextId();=0A=
    expandoStore =3D jqCache[expandoId] =3D {events: {}, data: {}, =
handle: undefined};=0A=
  }=0A=
=0A=
  return expandoStore;=0A=
}=0A=
=0A=
=0A=
function jqLiteData(element, key, value) {=0A=
  if (jqLiteAcceptsData(element)) {=0A=
    var prop;=0A=
=0A=
    var isSimpleSetter =3D isDefined(value);=0A=
    var isSimpleGetter =3D !isSimpleSetter &amp;&amp; key &amp;&amp; =
!isObject(key);=0A=
    var massGetter =3D !key;=0A=
    var expandoStore =3D jqLiteExpandoStore(element, !isSimpleGetter);=0A=
    var data =3D expandoStore &amp;&amp; expandoStore.data;=0A=
=0A=
    if (isSimpleSetter) { // data('key', value)=0A=
      data[kebabToCamel(key)] =3D value;=0A=
    } else {=0A=
      if (massGetter) {  // data()=0A=
        return data;=0A=
      } else {=0A=
        if (isSimpleGetter) { // data('key')=0A=
          // don't force creation of expandoStore if it doesn't exist yet=0A=
          return data &amp;&amp; data[kebabToCamel(key)];=0A=
        } else { // mass-setter: data({key1: val1, key2: val2})=0A=
          for (prop in key) {=0A=
            data[kebabToCamel(prop)] =3D key[prop];=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
  }=0A=
}=0A=
=0A=
function jqLiteHasClass(element, selector) {=0A=
  if (!element.getAttribute) return false;=0A=
  return ((' ' + (element.getAttribute('class') || '') + ' =
').replace(/[\n\t]/g, ' ').=0A=
      indexOf(' ' + selector + ' ') &gt; -1);=0A=
}=0A=
=0A=
function jqLiteRemoveClass(element, cssClasses) {=0A=
  if (cssClasses &amp;&amp; element.setAttribute) {=0A=
    forEach(cssClasses.split(' '), function(cssClass) {=0A=
      element.setAttribute('class', trim(=0A=
          (' ' + (element.getAttribute('class') || '') + ' ')=0A=
          .replace(/[\n\t]/g, ' ')=0A=
          .replace(' ' + trim(cssClass) + ' ', ' '))=0A=
      );=0A=
    });=0A=
  }=0A=
}=0A=
=0A=
function jqLiteAddClass(element, cssClasses) {=0A=
  if (cssClasses &amp;&amp; element.setAttribute) {=0A=
    var existingClasses =3D (' ' + (element.getAttribute('class') || '') =
+ ' ')=0A=
                            .replace(/[\n\t]/g, ' ');=0A=
=0A=
    forEach(cssClasses.split(' '), function(cssClass) {=0A=
      cssClass =3D trim(cssClass);=0A=
      if (existingClasses.indexOf(' ' + cssClass + ' ') =3D=3D=3D -1) {=0A=
        existingClasses +=3D cssClass + ' ';=0A=
      }=0A=
    });=0A=
=0A=
    element.setAttribute('class', trim(existingClasses));=0A=
  }=0A=
}=0A=
=0A=
=0A=
function jqLiteAddNodes(root, elements) {=0A=
  // THIS CODE IS VERY HOT. Don't make changes without benchmarking.=0A=
=0A=
  if (elements) {=0A=
=0A=
    // if a Node (the most common case)=0A=
    if (elements.nodeType) {=0A=
      root[root.length++] =3D elements;=0A=
    } else {=0A=
      var length =3D elements.length;=0A=
=0A=
      // if an Array or NodeList and not a Window=0A=
      if (typeof length =3D=3D=3D 'number' &amp;&amp; elements.window =
!=3D=3D elements) {=0A=
        if (length) {=0A=
          for (var i =3D 0; i &lt; length; i++) {=0A=
            root[root.length++] =3D elements[i];=0A=
          }=0A=
        }=0A=
      } else {=0A=
        root[root.length++] =3D elements;=0A=
      }=0A=
    }=0A=
  }=0A=
}=0A=
=0A=
=0A=
function jqLiteController(element, name) {=0A=
  return jqLiteInheritedData(element, '$' + (name || 'ngController') + =
'Controller');=0A=
}=0A=
=0A=
function jqLiteInheritedData(element, name, value) {=0A=
  // if element is the document object work with the html element instead=0A=
  // this makes $(document).scope() possible=0A=
  if (element.nodeType =3D=3D=3D NODE_TYPE_DOCUMENT) {=0A=
    element =3D element.documentElement;=0A=
  }=0A=
  var names =3D isArray(name) ? name : [name];=0A=
=0A=
  while (element) {=0A=
    for (var i =3D 0, ii =3D names.length; i &lt; ii; i++) {=0A=
      if (isDefined(value =3D jqLite.data(element, names[i]))) return =
value;=0A=
    }=0A=
=0A=
    // If dealing with a document fragment node with a host element, and =
no parent, use the host=0A=
    // element as the parent. This enables directives within a Shadow =
DOM or polyfilled Shadow DOM=0A=
    // to lookup parent controllers.=0A=
    element =3D element.parentNode || (element.nodeType =3D=3D=3D =
NODE_TYPE_DOCUMENT_FRAGMENT &amp;&amp; element.host);=0A=
  }=0A=
}=0A=
=0A=
function jqLiteEmpty(element) {=0A=
  jqLiteDealoc(element, true);=0A=
  while (element.firstChild) {=0A=
    element.removeChild(element.firstChild);=0A=
  }=0A=
}=0A=
=0A=
function jqLiteRemove(element, keepData) {=0A=
  if (!keepData) jqLiteDealoc(element);=0A=
  var parent =3D element.parentNode;=0A=
  if (parent) parent.removeChild(element);=0A=
}=0A=
=0A=
=0A=
function jqLiteDocumentLoaded(action, win) {=0A=
  win =3D win || window;=0A=
  if (win.document.readyState =3D=3D=3D 'complete') {=0A=
    // Force the action to be run async for consistent behavior=0A=
    // from the action's point of view=0A=
    // i.e. it will definitely not be in a $apply=0A=
    win.setTimeout(action);=0A=
  } else {=0A=
    // No need to unbind this handler as load is only ever called once=0A=
    jqLite(win).on('load', action);=0A=
  }=0A=
}=0A=
=0A=
function jqLiteReady(fn) {=0A=
  function trigger() {=0A=
    window.document.removeEventListener('DOMContentLoaded', trigger);=0A=
    window.removeEventListener('load', trigger);=0A=
    fn();=0A=
  }=0A=
=0A=
  // check if document is already loaded=0A=
  if (window.document.readyState =3D=3D=3D 'complete') {=0A=
    window.setTimeout(fn);=0A=
  } else {=0A=
    // We can not use jqLite since we are not done loading and jQuery =
could be loaded later.=0A=
=0A=
    // Works for modern browsers and IE9=0A=
    window.document.addEventListener('DOMContentLoaded', trigger);=0A=
=0A=
    // Fallback to window.onload for others=0A=
    window.addEventListener('load', trigger);=0A=
  }=0A=
}=0A=
=0A=
//////////////////////////////////////////=0A=
// Functions which are declared directly.=0A=
//////////////////////////////////////////=0A=
var JQLitePrototype =3D JQLite.prototype =3D {=0A=
  ready: jqLiteReady,=0A=
  toString: function() {=0A=
    var value =3D [];=0A=
    forEach(this, function(e) { value.push('' + e);});=0A=
    return '[' + value.join(', ') + ']';=0A=
  },=0A=
=0A=
  eq: function(index) {=0A=
      return (index &gt;=3D 0) ? jqLite(this[index]) : =
jqLite(this[this.length + index]);=0A=
  },=0A=
=0A=
  length: 0,=0A=
  push: push,=0A=
  sort: [].sort,=0A=
  splice: [].splice=0A=
};=0A=
=0A=
//////////////////////////////////////////=0A=
// Functions iterating getter/setters.=0A=
// these functions return self on setter and=0A=
// value on get.=0A=
//////////////////////////////////////////=0A=
var BOOLEAN_ATTR =3D {};=0A=
forEach('multiple,selected,checked,disabled,readOnly,required,open'.split=
(','), function(value) {=0A=
  BOOLEAN_ATTR[lowercase(value)] =3D value;=0A=
});=0A=
var BOOLEAN_ELEMENTS =3D {};=0A=
forEach('input,select,option,textarea,button,form,details'.split(','), =
function(value) {=0A=
  BOOLEAN_ELEMENTS[value] =3D true;=0A=
});=0A=
var ALIASED_ATTR =3D {=0A=
  'ngMinlength': 'minlength',=0A=
  'ngMaxlength': 'maxlength',=0A=
  'ngMin': 'min',=0A=
  'ngMax': 'max',=0A=
  'ngPattern': 'pattern',=0A=
  'ngStep': 'step'=0A=
};=0A=
=0A=
function getBooleanAttrName(element, name) {=0A=
  // check dom last since we will most likely fail on name=0A=
  var booleanAttr =3D BOOLEAN_ATTR[name.toLowerCase()];=0A=
=0A=
  // booleanAttr is here twice to minimize DOM access=0A=
  return booleanAttr &amp;&amp; BOOLEAN_ELEMENTS[nodeName_(element)] =
&amp;&amp; booleanAttr;=0A=
}=0A=
=0A=
function getAliasedAttrName(name) {=0A=
  return ALIASED_ATTR[name];=0A=
}=0A=
=0A=
forEach({=0A=
  data: jqLiteData,=0A=
  removeData: jqLiteRemoveData,=0A=
  hasData: jqLiteHasData,=0A=
  cleanData: function jqLiteCleanData(nodes) {=0A=
    for (var i =3D 0, ii =3D nodes.length; i &lt; ii; i++) {=0A=
      jqLiteRemoveData(nodes[i]);=0A=
    }=0A=
  }=0A=
}, function(fn, name) {=0A=
  JQLite[name] =3D fn;=0A=
});=0A=
=0A=
forEach({=0A=
  data: jqLiteData,=0A=
  inheritedData: jqLiteInheritedData,=0A=
=0A=
  scope: function(element) {=0A=
    // Can't use jqLiteData here directly so we stay compatible with =
jQuery!=0A=
    return jqLite.data(element, '$scope') || =
jqLiteInheritedData(element.parentNode || element, ['$isolateScope', =
'$scope']);=0A=
  },=0A=
=0A=
  isolateScope: function(element) {=0A=
    // Can't use jqLiteData here directly so we stay compatible with =
jQuery!=0A=
    return jqLite.data(element, '$isolateScope') || jqLite.data(element, =
'$isolateScopeNoTemplate');=0A=
  },=0A=
=0A=
  controller: jqLiteController,=0A=
=0A=
  injector: function(element) {=0A=
    return jqLiteInheritedData(element, '$injector');=0A=
  },=0A=
=0A=
  removeAttr: function(element, name) {=0A=
    element.removeAttribute(name);=0A=
  },=0A=
=0A=
  hasClass: jqLiteHasClass,=0A=
=0A=
  css: function(element, name, value) {=0A=
    name =3D cssKebabToCamel(name);=0A=
=0A=
    if (isDefined(value)) {=0A=
      element.style[name] =3D value;=0A=
    } else {=0A=
      return element.style[name];=0A=
    }=0A=
  },=0A=
=0A=
  attr: function(element, name, value) {=0A=
    var ret;=0A=
    var nodeType =3D element.nodeType;=0A=
    if (nodeType =3D=3D=3D NODE_TYPE_TEXT || nodeType =3D=3D=3D =
NODE_TYPE_ATTRIBUTE || nodeType =3D=3D=3D NODE_TYPE_COMMENT ||=0A=
      !element.getAttribute) {=0A=
      return;=0A=
    }=0A=
=0A=
    var lowercasedName =3D lowercase(name);=0A=
    var isBooleanAttr =3D BOOLEAN_ATTR[lowercasedName];=0A=
=0A=
    if (isDefined(value)) {=0A=
      // setter=0A=
=0A=
      if (value =3D=3D=3D null || (value =3D=3D=3D false &amp;&amp; =
isBooleanAttr)) {=0A=
        element.removeAttribute(name);=0A=
      } else {=0A=
        element.setAttribute(name, isBooleanAttr ? lowercasedName : =
value);=0A=
      }=0A=
    } else {=0A=
      // getter=0A=
=0A=
      ret =3D element.getAttribute(name);=0A=
=0A=
      if (isBooleanAttr &amp;&amp; ret !=3D=3D null) {=0A=
        ret =3D lowercasedName;=0A=
      }=0A=
      // Normalize non-existing attributes to undefined (as jQuery).=0A=
      return ret =3D=3D=3D null ? undefined : ret;=0A=
    }=0A=
  },=0A=
=0A=
  prop: function(element, name, value) {=0A=
    if (isDefined(value)) {=0A=
      element[name] =3D value;=0A=
    } else {=0A=
      return element[name];=0A=
    }=0A=
  },=0A=
=0A=
  text: (function() {=0A=
    getText.$dv =3D '';=0A=
    return getText;=0A=
=0A=
    function getText(element, value) {=0A=
      if (isUndefined(value)) {=0A=
        var nodeType =3D element.nodeType;=0A=
        return (nodeType =3D=3D=3D NODE_TYPE_ELEMENT || nodeType =
=3D=3D=3D NODE_TYPE_TEXT) ? element.textContent : '';=0A=
      }=0A=
      element.textContent =3D value;=0A=
    }=0A=
  })(),=0A=
=0A=
  val: function(element, value) {=0A=
    if (isUndefined(value)) {=0A=
      if (element.multiple &amp;&amp; nodeName_(element) =3D=3D=3D =
'select') {=0A=
        var result =3D [];=0A=
        forEach(element.options, function(option) {=0A=
          if (option.selected) {=0A=
            result.push(option.value || option.text);=0A=
          }=0A=
        });=0A=
        return result;=0A=
      }=0A=
      return element.value;=0A=
    }=0A=
    element.value =3D value;=0A=
  },=0A=
=0A=
  html: function(element, value) {=0A=
    if (isUndefined(value)) {=0A=
      return element.innerHTML;=0A=
    }=0A=
    jqLiteDealoc(element, true);=0A=
    element.innerHTML =3D value;=0A=
  },=0A=
=0A=
  empty: jqLiteEmpty=0A=
}, function(fn, name) {=0A=
  /**=0A=
   * Properties: writes return selection, reads return first value=0A=
   */=0A=
  JQLite.prototype[name] =3D function(arg1, arg2) {=0A=
    var i, key;=0A=
    var nodeCount =3D this.length;=0A=
=0A=
    // jqLiteHasClass has only two arguments, but is a getter-only fn, =
so we need to special-case it=0A=
    // in a way that survives minification.=0A=
    // jqLiteEmpty takes no arguments but is a setter.=0A=
    if (fn !=3D=3D jqLiteEmpty &amp;&amp;=0A=
        (isUndefined((fn.length =3D=3D=3D 2 &amp;&amp; (fn !=3D=3D =
jqLiteHasClass &amp;&amp; fn !=3D=3D jqLiteController)) ? arg1 : arg2))) =
{=0A=
      if (isObject(arg1)) {=0A=
=0A=
        // we are a write, but the object properties are the key/values=0A=
        for (i =3D 0; i &lt; nodeCount; i++) {=0A=
          if (fn =3D=3D=3D jqLiteData) {=0A=
            // data() takes the whole object in jQuery=0A=
            fn(this[i], arg1);=0A=
          } else {=0A=
            for (key in arg1) {=0A=
              fn(this[i], key, arg1[key]);=0A=
            }=0A=
          }=0A=
        }=0A=
        // return self for chaining=0A=
        return this;=0A=
      } else {=0A=
        // we are a read, so read the first child.=0A=
        // TODO: do we still need this?=0A=
        var value =3D fn.$dv;=0A=
        // Only if we have $dv do we iterate over all, otherwise it is =
just the first element.=0A=
        var jj =3D (isUndefined(value)) ? Math.min(nodeCount, 1) : =
nodeCount;=0A=
        for (var j =3D 0; j &lt; jj; j++) {=0A=
          var nodeValue =3D fn(this[j], arg1, arg2);=0A=
          value =3D value ? value + nodeValue : nodeValue;=0A=
        }=0A=
        return value;=0A=
      }=0A=
    } else {=0A=
      // we are a write, so apply to all children=0A=
      for (i =3D 0; i &lt; nodeCount; i++) {=0A=
        fn(this[i], arg1, arg2);=0A=
      }=0A=
      // return self for chaining=0A=
      return this;=0A=
    }=0A=
  };=0A=
});=0A=
=0A=
function createEventHandler(element, events) {=0A=
  var eventHandler =3D function(event, type) {=0A=
    // jQuery specific api=0A=
    event.isDefaultPrevented =3D function() {=0A=
      return event.defaultPrevented;=0A=
    };=0A=
=0A=
    var eventFns =3D events[type || event.type];=0A=
    var eventFnsLength =3D eventFns ? eventFns.length : 0;=0A=
=0A=
    if (!eventFnsLength) return;=0A=
=0A=
    if (isUndefined(event.immediatePropagationStopped)) {=0A=
      var originalStopImmediatePropagation =3D =
event.stopImmediatePropagation;=0A=
      event.stopImmediatePropagation =3D function() {=0A=
        event.immediatePropagationStopped =3D true;=0A=
=0A=
        if (event.stopPropagation) {=0A=
          event.stopPropagation();=0A=
        }=0A=
=0A=
        if (originalStopImmediatePropagation) {=0A=
          originalStopImmediatePropagation.call(event);=0A=
        }=0A=
      };=0A=
    }=0A=
=0A=
    event.isImmediatePropagationStopped =3D function() {=0A=
      return event.immediatePropagationStopped =3D=3D=3D true;=0A=
    };=0A=
=0A=
    // Some events have special handlers that wrap the real handler=0A=
    var handlerWrapper =3D eventFns.specialHandlerWrapper || =
defaultHandlerWrapper;=0A=
=0A=
    // Copy event handlers in case event handlers array is modified =
during execution.=0A=
    if ((eventFnsLength &gt; 1)) {=0A=
      eventFns =3D shallowCopy(eventFns);=0A=
    }=0A=
=0A=
    for (var i =3D 0; i &lt; eventFnsLength; i++) {=0A=
      if (!event.isImmediatePropagationStopped()) {=0A=
        handlerWrapper(element, event, eventFns[i]);=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  // TODO: this is a hack for angularMocks/clearDataCache that makes it =
possible to deregister all=0A=
  //       events on `element`=0A=
  eventHandler.elem =3D element;=0A=
  return eventHandler;=0A=
}=0A=
=0A=
function defaultHandlerWrapper(element, event, handler) {=0A=
  handler.call(element, event);=0A=
}=0A=
=0A=
function specialMouseHandlerWrapper(target, event, handler) {=0A=
  // Refer to jQuery's implementation of mouseenter &amp; mouseleave=0A=
  // Read about mouseenter and mouseleave:=0A=
  // http://www.quirksmode.org/js/events_mouse.html#link8=0A=
  var related =3D event.relatedTarget;=0A=
  // For mousenter/leave call the handler if related is outside the =
target.=0A=
  // NB: No relatedTarget if the mouse left/entered the browser window=0A=
  if (!related || (related !=3D=3D target &amp;&amp; =
!jqLiteContains.call(target, related))) {=0A=
    handler.call(target, event);=0A=
  }=0A=
}=0A=
=0A=
//////////////////////////////////////////=0A=
// Functions iterating traversal.=0A=
// These functions chain results into a single=0A=
// selector.=0A=
//////////////////////////////////////////=0A=
forEach({=0A=
  removeData: jqLiteRemoveData,=0A=
=0A=
  on: function jqLiteOn(element, type, fn, unsupported) {=0A=
    if (isDefined(unsupported)) throw jqLiteMinErr('onargs', =
'jqLite#on() does not support the `selector` or `eventData` parameters');=0A=
=0A=
    // Do not add event handlers to non-elements because they will not =
be cleaned up.=0A=
    if (!jqLiteAcceptsData(element)) {=0A=
      return;=0A=
    }=0A=
=0A=
    var expandoStore =3D jqLiteExpandoStore(element, true);=0A=
    var events =3D expandoStore.events;=0A=
    var handle =3D expandoStore.handle;=0A=
=0A=
    if (!handle) {=0A=
      handle =3D expandoStore.handle =3D createEventHandler(element, =
events);=0A=
    }=0A=
=0A=
    // http://jsperf.com/string-indexof-vs-split=0A=
    var types =3D type.indexOf(' ') &gt;=3D 0 ? type.split(' ') : [type];=0A=
    var i =3D types.length;=0A=
=0A=
    var addHandler =3D function(type, specialHandlerWrapper, =
noEventListener) {=0A=
      var eventFns =3D events[type];=0A=
=0A=
      if (!eventFns) {=0A=
        eventFns =3D events[type] =3D [];=0A=
        eventFns.specialHandlerWrapper =3D specialHandlerWrapper;=0A=
        if (type !=3D=3D '$destroy' &amp;&amp; !noEventListener) {=0A=
          element.addEventListener(type, handle);=0A=
        }=0A=
      }=0A=
=0A=
      eventFns.push(fn);=0A=
    };=0A=
=0A=
    while (i--) {=0A=
      type =3D types[i];=0A=
      if (MOUSE_EVENT_MAP[type]) {=0A=
        addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper);=0A=
        addHandler(type, undefined, true);=0A=
      } else {=0A=
        addHandler(type);=0A=
      }=0A=
    }=0A=
  },=0A=
=0A=
  off: jqLiteOff,=0A=
=0A=
  one: function(element, type, fn) {=0A=
    element =3D jqLite(element);=0A=
=0A=
    //add the listener twice so that when it is called=0A=
    //you can remove the original function and still be=0A=
    //able to call element.off(ev, fn) normally=0A=
    element.on(type, function onFn() {=0A=
      element.off(type, fn);=0A=
      element.off(type, onFn);=0A=
    });=0A=
    element.on(type, fn);=0A=
  },=0A=
=0A=
  replaceWith: function(element, replaceNode) {=0A=
    var index, parent =3D element.parentNode;=0A=
    jqLiteDealoc(element);=0A=
    forEach(new JQLite(replaceNode), function(node) {=0A=
      if (index) {=0A=
        parent.insertBefore(node, index.nextSibling);=0A=
      } else {=0A=
        parent.replaceChild(node, element);=0A=
      }=0A=
      index =3D node;=0A=
    });=0A=
  },=0A=
=0A=
  children: function(element) {=0A=
    var children =3D [];=0A=
    forEach(element.childNodes, function(element) {=0A=
      if (element.nodeType =3D=3D=3D NODE_TYPE_ELEMENT) {=0A=
        children.push(element);=0A=
      }=0A=
    });=0A=
    return children;=0A=
  },=0A=
=0A=
  contents: function(element) {=0A=
    return element.contentDocument || element.childNodes || [];=0A=
  },=0A=
=0A=
  append: function(element, node) {=0A=
    var nodeType =3D element.nodeType;=0A=
    if (nodeType !=3D=3D NODE_TYPE_ELEMENT &amp;&amp; nodeType !=3D=3D =
NODE_TYPE_DOCUMENT_FRAGMENT) return;=0A=
=0A=
    node =3D new JQLite(node);=0A=
=0A=
    for (var i =3D 0, ii =3D node.length; i &lt; ii; i++) {=0A=
      var child =3D node[i];=0A=
      element.appendChild(child);=0A=
    }=0A=
  },=0A=
=0A=
  prepend: function(element, node) {=0A=
    if (element.nodeType =3D=3D=3D NODE_TYPE_ELEMENT) {=0A=
      var index =3D element.firstChild;=0A=
      forEach(new JQLite(node), function(child) {=0A=
        element.insertBefore(child, index);=0A=
      });=0A=
    }=0A=
  },=0A=
=0A=
  wrap: function(element, wrapNode) {=0A=
    jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0]);=0A=
  },=0A=
=0A=
  remove: jqLiteRemove,=0A=
=0A=
  detach: function(element) {=0A=
    jqLiteRemove(element, true);=0A=
  },=0A=
=0A=
  after: function(element, newElement) {=0A=
    var index =3D element, parent =3D element.parentNode;=0A=
=0A=
    if (parent) {=0A=
      newElement =3D new JQLite(newElement);=0A=
=0A=
      for (var i =3D 0, ii =3D newElement.length; i &lt; ii; i++) {=0A=
        var node =3D newElement[i];=0A=
        parent.insertBefore(node, index.nextSibling);=0A=
        index =3D node;=0A=
      }=0A=
    }=0A=
  },=0A=
=0A=
  addClass: jqLiteAddClass,=0A=
  removeClass: jqLiteRemoveClass,=0A=
=0A=
  toggleClass: function(element, selector, condition) {=0A=
    if (selector) {=0A=
      forEach(selector.split(' '), function(className) {=0A=
        var classCondition =3D condition;=0A=
        if (isUndefined(classCondition)) {=0A=
          classCondition =3D !jqLiteHasClass(element, className);=0A=
        }=0A=
        (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, =
className);=0A=
      });=0A=
    }=0A=
  },=0A=
=0A=
  parent: function(element) {=0A=
    var parent =3D element.parentNode;=0A=
    return parent &amp;&amp; parent.nodeType !=3D=3D =
NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;=0A=
  },=0A=
=0A=
  next: function(element) {=0A=
    return element.nextElementSibling;=0A=
  },=0A=
=0A=
  find: function(element, selector) {=0A=
    if (element.getElementsByTagName) {=0A=
      return element.getElementsByTagName(selector);=0A=
    } else {=0A=
      return [];=0A=
    }=0A=
  },=0A=
=0A=
  clone: jqLiteClone,=0A=
=0A=
  triggerHandler: function(element, event, extraParameters) {=0A=
=0A=
    var dummyEvent, eventFnsCopy, handlerArgs;=0A=
    var eventName =3D event.type || event;=0A=
    var expandoStore =3D jqLiteExpandoStore(element);=0A=
    var events =3D expandoStore &amp;&amp; expandoStore.events;=0A=
    var eventFns =3D events &amp;&amp; events[eventName];=0A=
=0A=
    if (eventFns) {=0A=
      // Create a dummy event to pass to the handlers=0A=
      dummyEvent =3D {=0A=
        preventDefault: function() { this.defaultPrevented =3D true; },=0A=
        isDefaultPrevented: function() { return this.defaultPrevented =
=3D=3D=3D true; },=0A=
        stopImmediatePropagation: function() { =
this.immediatePropagationStopped =3D true; },=0A=
        isImmediatePropagationStopped: function() { return =
this.immediatePropagationStopped =3D=3D=3D true; },=0A=
        stopPropagation: noop,=0A=
        type: eventName,=0A=
        target: element=0A=
      };=0A=
=0A=
      // If a custom event was provided then extend our dummy event with =
it=0A=
      if (event.type) {=0A=
        dummyEvent =3D extend(dummyEvent, event);=0A=
      }=0A=
=0A=
      // Copy event handlers in case event handlers array is modified =
during execution.=0A=
      eventFnsCopy =3D shallowCopy(eventFns);=0A=
      handlerArgs =3D extraParameters ? =
[dummyEvent].concat(extraParameters) : [dummyEvent];=0A=
=0A=
      forEach(eventFnsCopy, function(fn) {=0A=
        if (!dummyEvent.isImmediatePropagationStopped()) {=0A=
          fn.apply(element, handlerArgs);=0A=
        }=0A=
      });=0A=
    }=0A=
  }=0A=
}, function(fn, name) {=0A=
  /**=0A=
   * chaining functions=0A=
   */=0A=
  JQLite.prototype[name] =3D function(arg1, arg2, arg3) {=0A=
    var value;=0A=
=0A=
    for (var i =3D 0, ii =3D this.length; i &lt; ii; i++) {=0A=
      if (isUndefined(value)) {=0A=
        value =3D fn(this[i], arg1, arg2, arg3);=0A=
        if (isDefined(value)) {=0A=
          // any function which returns a value needs to be wrapped=0A=
          value =3D jqLite(value);=0A=
        }=0A=
      } else {=0A=
        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));=0A=
      }=0A=
    }=0A=
    return isDefined(value) ? value : this;=0A=
  };=0A=
});=0A=
=0A=
// bind legacy bind/unbind to on/off=0A=
JQLite.prototype.bind =3D JQLite.prototype.on;=0A=
JQLite.prototype.unbind =3D JQLite.prototype.off;=0A=
=0A=
=0A=
// Provider for private $$jqLite service=0A=
/** @this */=0A=
function $$jqLiteProvider() {=0A=
  this.$get =3D function $$jqLite() {=0A=
    return extend(JQLite, {=0A=
      hasClass: function(node, classes) {=0A=
        if (node.attr) node =3D node[0];=0A=
        return jqLiteHasClass(node, classes);=0A=
      },=0A=
      addClass: function(node, classes) {=0A=
        if (node.attr) node =3D node[0];=0A=
        return jqLiteAddClass(node, classes);=0A=
      },=0A=
      removeClass: function(node, classes) {=0A=
        if (node.attr) node =3D node[0];=0A=
        return jqLiteRemoveClass(node, classes);=0A=
      }=0A=
    });=0A=
  };=0A=
}=0A=
=0A=
/**=0A=
 * Computes a hash of an 'obj'.=0A=
 * Hash of a:=0A=
 *  string is string=0A=
 *  number is number as string=0A=
 *  object is either result of calling $$hashKey function on the object =
or uniquely generated id,=0A=
 *         that is also assigned to the $$hashKey property of the object.=0A=
 *=0A=
 * @param obj=0A=
 * @returns {string} hash string such that the same input will have the =
same hash string.=0A=
 *         The resulting string key is in 'type:hashKey' format.=0A=
 */=0A=
function hashKey(obj, nextUidFn) {=0A=
  var key =3D obj &amp;&amp; obj.$$hashKey;=0A=
=0A=
  if (key) {=0A=
    if (typeof key =3D=3D=3D 'function') {=0A=
      key =3D obj.$$hashKey();=0A=
    }=0A=
    return key;=0A=
  }=0A=
=0A=
  var objType =3D typeof obj;=0A=
  if (objType =3D=3D=3D 'function' || (objType =3D=3D=3D 'object' =
&amp;&amp; obj !=3D=3D null)) {=0A=
    key =3D obj.$$hashKey =3D objType + ':' + (nextUidFn || nextUid)();=0A=
  } else {=0A=
    key =3D objType + ':' + obj;=0A=
  }=0A=
=0A=
  return key;=0A=
}=0A=
=0A=
// A minimal ES2015 Map implementation.=0A=
// Should be bug/feature equivalent to the native implementations of =
supported browsers=0A=
// (for the features required in Angular).=0A=
// See https://kangax.github.io/compat-table/es6/#test-Map=0A=
var nanKey =3D Object.create(null);=0A=
function NgMapShim() {=0A=
  this._keys =3D [];=0A=
  this._values =3D [];=0A=
  this._lastKey =3D NaN;=0A=
  this._lastIndex =3D -1;=0A=
}=0A=
NgMapShim.prototype =3D {=0A=
  _idx: function(key) {=0A=
    if (key =3D=3D=3D this._lastKey) {=0A=
      return this._lastIndex;=0A=
    }=0A=
    this._lastKey =3D key;=0A=
    this._lastIndex =3D this._keys.indexOf(key);=0A=
    return this._lastIndex;=0A=
  },=0A=
  _transformKey: function(key) {=0A=
    return isNumberNaN(key) ? nanKey : key;=0A=
  },=0A=
  get: function(key) {=0A=
    key =3D this._transformKey(key);=0A=
    var idx =3D this._idx(key);=0A=
    if (idx !=3D=3D -1) {=0A=
      return this._values[idx];=0A=
    }=0A=
  },=0A=
  set: function(key, value) {=0A=
    key =3D this._transformKey(key);=0A=
    var idx =3D this._idx(key);=0A=
    if (idx =3D=3D=3D -1) {=0A=
      idx =3D this._lastIndex =3D this._keys.length;=0A=
    }=0A=
    this._keys[idx] =3D key;=0A=
    this._values[idx] =3D value;=0A=
=0A=
    // Support: IE11=0A=
    // Do not `return this` to simulate the partial IE11 implementation=0A=
  },=0A=
  delete: function(key) {=0A=
    key =3D this._transformKey(key);=0A=
    var idx =3D this._idx(key);=0A=
    if (idx =3D=3D=3D -1) {=0A=
      return false;=0A=
    }=0A=
    this._keys.splice(idx, 1);=0A=
    this._values.splice(idx, 1);=0A=
    this._lastKey =3D NaN;=0A=
    this._lastIndex =3D -1;=0A=
    return true;=0A=
  }=0A=
};=0A=
=0A=
// For now, always use `NgMapShim`, even if `window.Map` is available. =
Some native implementations=0A=
// are still buggy (often in subtle ways) and can cause hard-to-debug =
failures. When native `Map`=0A=
// implementations get more stable, we can reconsider switching to =
`window.Map` (when available).=0A=
var NgMap =3D NgMapShim;=0A=
=0A=
var $$MapProvider =3D [/** @this */function() {=0A=
  this.$get =3D [function() {=0A=
    return NgMap;=0A=
  }];=0A=
}];=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @module ng=0A=
 * @name angular.injector=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Creates an injector object that can be used for retrieving services =
as well as for=0A=
 * dependency injection (see {@link guide/di dependency injection}).=0A=
 *=0A=
 * @param {Array.&lt;string|Function&gt;} modules A list of module =
functions or their aliases. See=0A=
 *     {@link angular.module}. The `ng` module must be explicitly added.=0A=
 * @param {boolean=3D} [strictDi=3Dfalse] Whether the injector should be =
in strict mode, which=0A=
 *     disallows argument name annotation inference.=0A=
 * @returns {injector} Injector object. See {@link auto.$injector =
$injector}.=0A=
 *=0A=
 * @example=0A=
 * Typical usage=0A=
 * ```js=0A=
 *   // create an injector=0A=
 *   var $injector =3D angular.injector(['ng']);=0A=
 *=0A=
 *   // use the injector to kick off your application=0A=
 *   // use the type inference to auto inject arguments, or use implicit =
injection=0A=
 *   $injector.invoke(function($rootScope, $compile, $document) {=0A=
 *     $compile($document)($rootScope);=0A=
 *     $rootScope.$digest();=0A=
 *   });=0A=
 * ```=0A=
 *=0A=
 * Sometimes you want to get access to the injector of a currently =
running Angular app=0A=
 * from outside Angular. Perhaps, you want to inject and compile some =
markup after the=0A=
 * application has been bootstrapped. You can do this using the extra =
`injector()` added=0A=
 * to JQuery/jqLite elements. See {@link angular.element}.=0A=
 *=0A=
 * *This is fairly rare but could be the case if a third party library =
is injecting the=0A=
 * markup.*=0A=
 *=0A=
 * In the following example a new block of HTML containing a =
`ng-controller`=0A=
 * directive is added to the end of the document body by JQuery. We then =
compile and link=0A=
 * it into the current AngularJS scope.=0A=
 *=0A=
 * ```js=0A=
 * var $div =3D $('&lt;div =
ng-controller=3D"MyCtrl"&gt;{{content.label}}&lt;/div&gt;');=0A=
 * $(document.body).append($div);=0A=
 *=0A=
 * angular.element(document).injector().invoke(function($compile) {=0A=
 *   var scope =3D angular.element($div).scope();=0A=
 *   $compile($div)(scope);=0A=
 * });=0A=
 * ```=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc module=0A=
 * @name auto=0A=
 * @installation=0A=
 * @description=0A=
 *=0A=
 * Implicit module which gets automatically added to each {@link =
auto.$injector $injector}.=0A=
 */=0A=
=0A=
var ARROW_ARG =3D /^([^(]+?)=3D&gt;/;=0A=
var FN_ARGS =3D /^[^(]*\(\s*([^)]*)\)/m;=0A=
var FN_ARG_SPLIT =3D /,/;=0A=
var FN_ARG =3D /^\s*(_?)(\S+?)\1\s*$/;=0A=
var STRIP_COMMENTS =3D /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;=0A=
var $injectorMinErr =3D minErr('$injector');=0A=
=0A=
function stringifyFn(fn) {=0A=
  return Function.prototype.toString.call(fn);=0A=
}=0A=
=0A=
function extractArgs(fn) {=0A=
  var fnText =3D stringifyFn(fn).replace(STRIP_COMMENTS, ''),=0A=
      args =3D fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);=0A=
  return args;=0A=
}=0A=
=0A=
function anonFn(fn) {=0A=
  // For anonymous functions, showing at the very least the function =
signature can help in=0A=
  // debugging.=0A=
  var args =3D extractArgs(fn);=0A=
  if (args) {=0A=
    return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';=0A=
  }=0A=
  return 'fn';=0A=
}=0A=
=0A=
function annotate(fn, strictDi, name) {=0A=
  var $inject,=0A=
      argDecl,=0A=
      last;=0A=
=0A=
  if (typeof fn =3D=3D=3D 'function') {=0A=
    if (!($inject =3D fn.$inject)) {=0A=
      $inject =3D [];=0A=
      if (fn.length) {=0A=
        if (strictDi) {=0A=
          if (!isString(name) || !name) {=0A=
            name =3D fn.name || anonFn(fn);=0A=
          }=0A=
          throw $injectorMinErr('strictdi',=0A=
            '{0} is not using explicit annotation and cannot be invoked =
in strict mode', name);=0A=
        }=0A=
        argDecl =3D extractArgs(fn);=0A=
        forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {=0A=
          arg.replace(FN_ARG, function(all, underscore, name) {=0A=
            $inject.push(name);=0A=
          });=0A=
        });=0A=
      }=0A=
      fn.$inject =3D $inject;=0A=
    }=0A=
  } else if (isArray(fn)) {=0A=
    last =3D fn.length - 1;=0A=
    assertArgFn(fn[last], 'fn');=0A=
    $inject =3D fn.slice(0, last);=0A=
  } else {=0A=
    assertArgFn(fn, 'fn', true);=0A=
  }=0A=
  return $inject;=0A=
}=0A=
=0A=
///////////////////////////////////////=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $injector=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * `$injector` is used to retrieve object instances as defined by=0A=
 * {@link auto.$provide provider}, instantiate types, invoke methods,=0A=
 * and load modules.=0A=
 *=0A=
 * The following always holds true:=0A=
 *=0A=
 * ```js=0A=
 *   var $injector =3D angular.injector();=0A=
 *   expect($injector.get('$injector')).toBe($injector);=0A=
 *   expect($injector.invoke(function($injector) {=0A=
 *     return $injector;=0A=
 *   })).toBe($injector);=0A=
 * ```=0A=
 *=0A=
 * # Injection Function Annotation=0A=
 *=0A=
 * JavaScript does not have annotations, and annotations are needed for =
dependency injection. The=0A=
 * following are all valid ways of annotating function with injection =
arguments and are equivalent.=0A=
 *=0A=
 * ```js=0A=
 *   // inferred (only works if code not minified/obfuscated)=0A=
 *   $injector.invoke(function(serviceA){});=0A=
 *=0A=
 *   // annotated=0A=
 *   function explicit(serviceA) {};=0A=
 *   explicit.$inject =3D ['serviceA'];=0A=
 *   $injector.invoke(explicit);=0A=
 *=0A=
 *   // inline=0A=
 *   $injector.invoke(['serviceA', function(serviceA){}]);=0A=
 * ```=0A=
 *=0A=
 * ## Inference=0A=
 *=0A=
 * In JavaScript calling `toString()` on a function returns the function =
definition. The definition=0A=
 * can then be parsed and the function arguments can be extracted. This =
method of discovering=0A=
 * annotations is disallowed when the injector is in strict mode.=0A=
 * *NOTE:* This does not work with minification, and obfuscation tools =
since these tools change the=0A=
 * argument names.=0A=
 *=0A=
 * ## `$inject` Annotation=0A=
 * By adding an `$inject` property onto a function the injection =
parameters can be specified.=0A=
 *=0A=
 * ## Inline=0A=
 * As an array of injection names, where the last item in the array is =
the function to call.=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc property=0A=
 * @name $injector#modules=0A=
 * @type {Object}=0A=
 * @description=0A=
 * A hash containing all the modules that have been loaded into the=0A=
 * $injector.=0A=
 *=0A=
 * You can use this property to find out information about a module via =
the=0A=
 * {@link angular.Module#info `myModule.info(...)`} method.=0A=
 *=0A=
 * For example:=0A=
 *=0A=
 * ```=0A=
 * var info =3D $injector.modules['ngAnimate'].info();=0A=
 * ```=0A=
 *=0A=
 * **Do not use this property to attempt to modify the modules after the =
application=0A=
 * has been bootstrapped.**=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $injector#get=0A=
 *=0A=
 * @description=0A=
 * Return an instance of the service.=0A=
 *=0A=
 * @param {string} name The name of the instance to retrieve.=0A=
 * @param {string=3D} caller An optional string to provide the origin of =
the function call for error messages.=0A=
 * @return {*} The instance.=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $injector#invoke=0A=
 *=0A=
 * @description=0A=
 * Invoke the method and supply the method arguments from the =
`$injector`.=0A=
 *=0A=
 * @param {Function|Array.&lt;string|Function&gt;} fn The injectable =
function to invoke. Function parameters are=0A=
 *   injected according to the {@link guide/di $inject Annotation} rules.=0A=
 * @param {Object=3D} self The `this` for the invoked method.=0A=
 * @param {Object=3D} locals Optional object. If preset then any =
argument names are read from this=0A=
 *                         object first, before the `$injector` is =
consulted.=0A=
 * @returns {*} the value returned by the invoked `fn` function.=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $injector#has=0A=
 *=0A=
 * @description=0A=
 * Allows the user to query if the particular service exists.=0A=
 *=0A=
 * @param {string} name Name of the service to query.=0A=
 * @returns {boolean} `true` if injector has given service.=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $injector#instantiate=0A=
 * @description=0A=
 * Create a new instance of JS type. The method takes a constructor =
function, invokes the new=0A=
 * operator, and supplies all of the arguments to the constructor =
function as specified by the=0A=
 * constructor annotation.=0A=
 *=0A=
 * @param {Function} Type Annotated constructor function.=0A=
 * @param {Object=3D} locals Optional object. If preset then any =
argument names are read from this=0A=
 * object first, before the `$injector` is consulted.=0A=
 * @returns {Object} new instance of `Type`.=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $injector#annotate=0A=
 *=0A=
 * @description=0A=
 * Returns an array of service names which the function is requesting =
for injection. This API is=0A=
 * used by the injector to determine which services need to be injected =
into the function when the=0A=
 * function is invoked. There are three ways in which the function can =
be annotated with the needed=0A=
 * dependencies.=0A=
 *=0A=
 * # Argument names=0A=
 *=0A=
 * The simplest form is to extract the dependencies from the arguments =
of the function. This is done=0A=
 * by converting the function into a string using `toString()` method =
and extracting the argument=0A=
 * names.=0A=
 * ```js=0A=
 *   // Given=0A=
 *   function MyController($scope, $route) {=0A=
 *     // ...=0A=
 *   }=0A=
 *=0A=
 *   // Then=0A=
 *   expect(injector.annotate(MyController)).toEqual(['$scope', =
'$route']);=0A=
 * ```=0A=
 *=0A=
 * You can disallow this method by using strict injection mode.=0A=
 *=0A=
 * This method does not work with code minification / obfuscation. For =
this reason the following=0A=
 * annotation strategies are supported.=0A=
 *=0A=
 * # The `$inject` property=0A=
 *=0A=
 * If a function has an `$inject` property and its value is an array of =
strings, then the strings=0A=
 * represent names of services to be injected into the function.=0A=
 * ```js=0A=
 *   // Given=0A=
 *   var MyController =3D function(obfuscatedScope, obfuscatedRoute) {=0A=
 *     // ...=0A=
 *   }=0A=
 *   // Define function dependencies=0A=
 *   MyController['$inject'] =3D ['$scope', '$route'];=0A=
 *=0A=
 *   // Then=0A=
 *   expect(injector.annotate(MyController)).toEqual(['$scope', =
'$route']);=0A=
 * ```=0A=
 *=0A=
 * # The array notation=0A=
 *=0A=
 * It is often desirable to inline Injected functions and that's when =
setting the `$inject` property=0A=
 * is very inconvenient. In these situations using the array notation to =
specify the dependencies in=0A=
 * a way that survives minification is a better choice:=0A=
 *=0A=
 * ```js=0A=
 *   // We wish to write this (not minification / obfuscation safe)=0A=
 *   injector.invoke(function($compile, $rootScope) {=0A=
 *     // ...=0A=
 *   });=0A=
 *=0A=
 *   // We are forced to write break inlining=0A=
 *   var tmpFn =3D function(obfuscatedCompile, obfuscatedRootScope) {=0A=
 *     // ...=0A=
 *   };=0A=
 *   tmpFn.$inject =3D ['$compile', '$rootScope'];=0A=
 *   injector.invoke(tmpFn);=0A=
 *=0A=
 *   // To better support inline function the inline annotation is =
supported=0A=
 *   injector.invoke(['$compile', '$rootScope', function(obfCompile, =
obfRootScope) {=0A=
 *     // ...=0A=
 *   }]);=0A=
 *=0A=
 *   // Therefore=0A=
 *   expect(injector.annotate(=0A=
 *      ['$compile', '$rootScope', function(obfus_$compile, =
obfus_$rootScope) {}])=0A=
 *    ).toEqual(['$compile', '$rootScope']);=0A=
 * ```=0A=
 *=0A=
 * @param {Function|Array.&lt;string|Function&gt;} fn Function for which =
dependent service names need to=0A=
 * be retrieved as described above.=0A=
 *=0A=
 * @param {boolean=3D} [strictDi=3Dfalse] Disallow argument name =
annotation inference.=0A=
 *=0A=
 * @returns {Array.&lt;string&gt;} The names of the services which the =
function requires.=0A=
 */=0A=
=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $provide=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * The {@link auto.$provide $provide} service has a number of methods =
for registering components=0A=
 * with the {@link auto.$injector $injector}. Many of these functions =
are also exposed on=0A=
 * {@link angular.Module}.=0A=
 *=0A=
 * An Angular **service** is a singleton object created by a **service =
factory**.  These **service=0A=
 * factories** are functions which, in turn, are created by a **service =
provider**.=0A=
 * The **service providers** are constructor functions. When =
instantiated they must contain a=0A=
 * property called `$get`, which holds the **service factory** function.=0A=
 *=0A=
 * When you request a service, the {@link auto.$injector $injector} is =
responsible for finding the=0A=
 * correct **service provider**, instantiating it and then calling its =
`$get` **service factory**=0A=
 * function to get the instance of the **service**.=0A=
 *=0A=
 * Often services have no configuration options and there is no need to =
add methods to the service=0A=
 * provider.  The provider will be no more than a constructor function =
with a `$get` property. For=0A=
 * these cases the {@link auto.$provide $provide} service has additional =
helper methods to register=0A=
 * services without specifying a provider.=0A=
 *=0A=
 * * {@link auto.$provide#provider provider(name, provider)} - registers =
a **service provider** with the=0A=
 *     {@link auto.$injector $injector}=0A=
 * * {@link auto.$provide#constant constant(name, obj)} - registers a =
value/object that can be accessed by=0A=
 *     providers and services.=0A=
 * * {@link auto.$provide#value value(name, obj)} - registers a =
value/object that can only be accessed by=0A=
 *     services, not providers.=0A=
 * * {@link auto.$provide#factory factory(name, fn)} - registers a =
service **factory function**=0A=
 *     that will be wrapped in a **service provider** object, whose =
`$get` property will contain the=0A=
 *     given factory function.=0A=
 * * {@link auto.$provide#service service(name, Fn)} - registers a =
**constructor function**=0A=
 *     that will be wrapped in a **service provider** object, whose =
`$get` property will instantiate=0A=
 *      a new object using the given constructor function.=0A=
 * * {@link auto.$provide#decorator decorator(name, decorFn)} - =
registers a **decorator function** that=0A=
 *      will be able to modify or replace the implementation of another =
service.=0A=
 *=0A=
 * See the individual methods for more information and examples.=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $provide#provider=0A=
 * @description=0A=
 *=0A=
 * Register a **provider function** with the {@link auto.$injector =
$injector}. Provider functions=0A=
 * are constructor functions, whose instances are responsible for =
"providing" a factory for a=0A=
 * service.=0A=
 *=0A=
 * Service provider names start with the name of the service they =
provide followed by `Provider`.=0A=
 * For example, the {@link ng.$log $log} service has a provider called=0A=
 * {@link ng.$logProvider $logProvider}.=0A=
 *=0A=
 * Service provider objects can have additional methods which allow =
configuration of the provider=0A=
 * and its service. Importantly, you can configure what kind of service =
is created by the `$get`=0A=
 * method, or how that service will act. For example, the {@link =
ng.$logProvider $logProvider} has a=0A=
 * method {@link ng.$logProvider#debugEnabled debugEnabled}=0A=
 * which lets you specify whether the {@link ng.$log $log} service will =
log debug messages to the=0A=
 * console or not.=0A=
 *=0A=
 * @param {string} name The name of the instance. NOTE: the provider =
will be available under `name +=0A=
                        'Provider'` key.=0A=
 * @param {(Object|function())} provider If the provider is:=0A=
 *=0A=
 *   - `Object`: then it should have a `$get` method. The `$get` method =
will be invoked using=0A=
 *     {@link auto.$injector#invoke $injector.invoke()} when an instance =
needs to be created.=0A=
 *   - `Constructor`: a new instance of the provider will be created =
using=0A=
 *     {@link auto.$injector#instantiate $injector.instantiate()}, then =
treated as `object`.=0A=
 *=0A=
 * @returns {Object} registered provider instance=0A=
=0A=
 * @example=0A=
 *=0A=
 * The following example shows how to create a simple event tracking =
service and register it using=0A=
 * {@link auto.$provide#provider $provide.provider()}.=0A=
 *=0A=
 * ```js=0A=
 *  // Define the eventTracker provider=0A=
 *  function EventTrackerProvider() {=0A=
 *    var trackingUrl =3D '/track';=0A=
 *=0A=
 *    // A provider method for configuring where the tracked events =
should been saved=0A=
 *    this.setTrackingUrl =3D function(url) {=0A=
 *      trackingUrl =3D url;=0A=
 *    };=0A=
 *=0A=
 *    // The service factory function=0A=
 *    this.$get =3D ['$http', function($http) {=0A=
 *      var trackedEvents =3D {};=0A=
 *      return {=0A=
 *        // Call this to track an event=0A=
 *        event: function(event) {=0A=
 *          var count =3D trackedEvents[event] || 0;=0A=
 *          count +=3D 1;=0A=
 *          trackedEvents[event] =3D count;=0A=
 *          return count;=0A=
 *        },=0A=
 *        // Call this to save the tracked events to the trackingUrl=0A=
 *        save: function() {=0A=
 *          $http.post(trackingUrl, trackedEvents);=0A=
 *        }=0A=
 *      };=0A=
 *    }];=0A=
 *  }=0A=
 *=0A=
 *  describe('eventTracker', function() {=0A=
 *    var postSpy;=0A=
 *=0A=
 *    beforeEach(module(function($provide) {=0A=
 *      // Register the eventTracker provider=0A=
 *      $provide.provider('eventTracker', EventTrackerProvider);=0A=
 *    }));=0A=
 *=0A=
 *    beforeEach(module(function(eventTrackerProvider) {=0A=
 *      // Configure eventTracker provider=0A=
 *      eventTrackerProvider.setTrackingUrl('/custom-track');=0A=
 *    }));=0A=
 *=0A=
 *    it('tracks events', inject(function(eventTracker) {=0A=
 *      expect(eventTracker.event('login')).toEqual(1);=0A=
 *      expect(eventTracker.event('login')).toEqual(2);=0A=
 *    }));=0A=
 *=0A=
 *    it('saves to the tracking url', inject(function(eventTracker, =
$http) {=0A=
 *      postSpy =3D spyOn($http, 'post');=0A=
 *      eventTracker.event('login');=0A=
 *      eventTracker.save();=0A=
 *      expect(postSpy).toHaveBeenCalled();=0A=
 *      expect(postSpy.mostRecentCall.args[0]).not.toEqual('/track');=0A=
 *      expect(postSpy.mostRecentCall.args[0]).toEqual('/custom-track');=0A=
 *      expect(postSpy.mostRecentCall.args[1]).toEqual({ 'login': 1 });=0A=
 *    }));=0A=
 *  });=0A=
 * ```=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $provide#factory=0A=
 * @description=0A=
 *=0A=
 * Register a **service factory**, which will be called to return the =
service instance.=0A=
 * This is short for registering a service where its provider consists =
of only a `$get` property,=0A=
 * which is the given service factory function.=0A=
 * You should use {@link auto.$provide#factory $provide.factory(getFn)} =
if you do not need to=0A=
 * configure your service in a provider.=0A=
 *=0A=
 * @param {string} name The name of the instance.=0A=
 * @param {Function|Array.&lt;string|Function&gt;} $getFn The injectable =
$getFn for the instance creation.=0A=
 *                      Internally this is a short hand for =
`$provide.provider(name, {$get: $getFn})`.=0A=
 * @returns {Object} registered provider instance=0A=
 *=0A=
 * @example=0A=
 * Here is an example of registering a service=0A=
 * ```js=0A=
 *   $provide.factory('ping', ['$http', function($http) {=0A=
 *     return function ping() {=0A=
 *       return $http.send('/ping');=0A=
 *     };=0A=
 *   }]);=0A=
 * ```=0A=
 * You would then inject and use this service like this:=0A=
 * ```js=0A=
 *   someModule.controller('Ctrl', ['ping', function(ping) {=0A=
 *     ping();=0A=
 *   }]);=0A=
 * ```=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $provide#service=0A=
 * @description=0A=
 *=0A=
 * Register a **service constructor**, which will be invoked with `new` =
to create the service=0A=
 * instance.=0A=
 * This is short for registering a service where its provider's `$get` =
property is a factory=0A=
 * function that returns an instance instantiated by the injector from =
the service constructor=0A=
 * function.=0A=
 *=0A=
 * Internally it looks a bit like this:=0A=
 *=0A=
 * ```=0A=
 * {=0A=
 *   $get: function() {=0A=
 *     return $injector.instantiate(constructor);=0A=
 *   }=0A=
 * }=0A=
 * ```=0A=
 *=0A=
 *=0A=
 * You should use {@link auto.$provide#service $provide.service(class)} =
if you define your service=0A=
 * as a type/class.=0A=
 *=0A=
 * @param {string} name The name of the instance.=0A=
 * @param {Function|Array.&lt;string|Function&gt;} constructor An =
injectable class (constructor function)=0A=
 *     that will be instantiated.=0A=
 * @returns {Object} registered provider instance=0A=
 *=0A=
 * @example=0A=
 * Here is an example of registering a service using=0A=
 * {@link auto.$provide#service $provide.service(class)}.=0A=
 * ```js=0A=
 *   var Ping =3D function($http) {=0A=
 *     this.$http =3D $http;=0A=
 *   };=0A=
 *=0A=
 *   Ping.$inject =3D ['$http'];=0A=
 *=0A=
 *   Ping.prototype.send =3D function() {=0A=
 *     return this.$http.get('/ping');=0A=
 *   };=0A=
 *   $provide.service('ping', Ping);=0A=
 * ```=0A=
 * You would then inject and use this service like this:=0A=
 * ```js=0A=
 *   someModule.controller('Ctrl', ['ping', function(ping) {=0A=
 *     ping.send();=0A=
 *   }]);=0A=
 * ```=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $provide#value=0A=
 * @description=0A=
 *=0A=
 * Register a **value service** with the {@link auto.$injector =
$injector}, such as a string, a=0A=
 * number, an array, an object or a function. This is short for =
registering a service where its=0A=
 * provider's `$get` property is a factory function that takes no =
arguments and returns the **value=0A=
 * service**. That also means it is not possible to inject other =
services into a value service.=0A=
 *=0A=
 * Value services are similar to constant services, except that they =
cannot be injected into a=0A=
 * module configuration function (see {@link angular.Module#config}) but =
they can be overridden by=0A=
 * an Angular {@link auto.$provide#decorator decorator}.=0A=
 *=0A=
 * @param {string} name The name of the instance.=0A=
 * @param {*} value The value.=0A=
 * @returns {Object} registered provider instance=0A=
 *=0A=
 * @example=0A=
 * Here are some examples of creating value services.=0A=
 * ```js=0A=
 *   $provide.value('ADMIN_USER', 'admin');=0A=
 *=0A=
 *   $provide.value('RoleLookup', { admin: 0, writer: 1, reader: 2 });=0A=
 *=0A=
 *   $provide.value('halfOf', function(value) {=0A=
 *     return value / 2;=0A=
 *   });=0A=
 * ```=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $provide#constant=0A=
 * @description=0A=
 *=0A=
 * Register a **constant service** with the {@link auto.$injector =
$injector}, such as a string,=0A=
 * a number, an array, an object or a function. Like the {@link =
auto.$provide#value value}, it is not=0A=
 * possible to inject other services into a constant.=0A=
 *=0A=
 * But unlike {@link auto.$provide#value value}, a constant can be=0A=
 * injected into a module configuration function (see {@link =
angular.Module#config}) and it cannot=0A=
 * be overridden by an Angular {@link auto.$provide#decorator decorator}.=0A=
 *=0A=
 * @param {string} name The name of the constant.=0A=
 * @param {*} value The constant value.=0A=
 * @returns {Object} registered instance=0A=
 *=0A=
 * @example=0A=
 * Here a some examples of creating constants:=0A=
 * ```js=0A=
 *   $provide.constant('SHARD_HEIGHT', 306);=0A=
 *=0A=
 *   $provide.constant('MY_COLOURS', ['red', 'blue', 'grey']);=0A=
 *=0A=
 *   $provide.constant('double', function(value) {=0A=
 *     return value * 2;=0A=
 *   });=0A=
 * ```=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $provide#decorator=0A=
 * @description=0A=
 *=0A=
 * Register a **decorator function** with the {@link auto.$injector =
$injector}. A decorator function=0A=
 * intercepts the creation of a service, allowing it to override or =
modify the behavior of the=0A=
 * service. The return value of the decorator function may be the =
original service, or a new service=0A=
 * that replaces (or wraps and delegates to) the original service.=0A=
 *=0A=
 * You can find out more about using decorators in the {@link =
guide/decorators} guide.=0A=
 *=0A=
 * @param {string} name The name of the service to decorate.=0A=
 * @param {Function|Array.&lt;string|Function&gt;} decorator This =
function will be invoked when the service needs to be=0A=
 *    provided and should return the decorated service instance. The =
function is called using=0A=
 *    the {@link auto.$injector#invoke injector.invoke} method and is =
therefore fully injectable.=0A=
 *    Local injection arguments:=0A=
 *=0A=
 *    * `$delegate` - The original service instance, which can be =
replaced, monkey patched, configured,=0A=
 *      decorated or delegated to.=0A=
 *=0A=
 * @example=0A=
 * Here we decorate the {@link ng.$log $log} service to convert warnings =
to errors by intercepting=0A=
 * calls to {@link ng.$log#error $log.warn()}.=0A=
 * ```js=0A=
 *   $provide.decorator('$log', ['$delegate', function($delegate) {=0A=
 *     $delegate.warn =3D $delegate.error;=0A=
 *     return $delegate;=0A=
 *   }]);=0A=
 * ```=0A=
 */=0A=
=0A=
=0A=
function createInjector(modulesToLoad, strictDi) {=0A=
  strictDi =3D (strictDi =3D=3D=3D true);=0A=
  var INSTANTIATING =3D {},=0A=
      providerSuffix =3D 'Provider',=0A=
      path =3D [],=0A=
      loadedModules =3D new NgMap(),=0A=
      providerCache =3D {=0A=
        $provide: {=0A=
            provider: supportObject(provider),=0A=
            factory: supportObject(factory),=0A=
            service: supportObject(service),=0A=
            value: supportObject(value),=0A=
            constant: supportObject(constant),=0A=
            decorator: decorator=0A=
          }=0A=
      },=0A=
      providerInjector =3D (providerCache.$injector =3D=0A=
          createInternalInjector(providerCache, function(serviceName, =
caller) {=0A=
            if (angular.isString(caller)) {=0A=
              path.push(caller);=0A=
            }=0A=
            throw $injectorMinErr('unpr', 'Unknown provider: {0}', =
path.join(' &lt;- '));=0A=
          })),=0A=
      instanceCache =3D {},=0A=
      protoInstanceInjector =3D=0A=
          createInternalInjector(instanceCache, function(serviceName, =
caller) {=0A=
            var provider =3D providerInjector.get(serviceName + =
providerSuffix, caller);=0A=
            return instanceInjector.invoke(=0A=
                provider.$get, provider, undefined, serviceName);=0A=
          }),=0A=
      instanceInjector =3D protoInstanceInjector;=0A=
=0A=
  providerCache['$injector' + providerSuffix] =3D { $get: =
valueFn(protoInstanceInjector) };=0A=
  instanceInjector.modules =3D providerInjector.modules =3D createMap();=0A=
  var runBlocks =3D loadModules(modulesToLoad);=0A=
  instanceInjector =3D protoInstanceInjector.get('$injector');=0A=
  instanceInjector.strictDi =3D strictDi;=0A=
  forEach(runBlocks, function(fn) { if (fn) instanceInjector.invoke(fn); =
});=0A=
=0A=
  return instanceInjector;=0A=
=0A=
  ////////////////////////////////////=0A=
  // $provider=0A=
  ////////////////////////////////////=0A=
=0A=
  function supportObject(delegate) {=0A=
    return function(key, value) {=0A=
      if (isObject(key)) {=0A=
        forEach(key, reverseParams(delegate));=0A=
      } else {=0A=
        return delegate(key, value);=0A=
      }=0A=
    };=0A=
  }=0A=
=0A=
  function provider(name, provider_) {=0A=
    assertNotHasOwnProperty(name, 'service');=0A=
    if (isFunction(provider_) || isArray(provider_)) {=0A=
      provider_ =3D providerInjector.instantiate(provider_);=0A=
    }=0A=
    if (!provider_.$get) {=0A=
      throw $injectorMinErr('pget', 'Provider \'{0}\' must define $get =
factory method.', name);=0A=
    }=0A=
    return (providerCache[name + providerSuffix] =3D provider_);=0A=
  }=0A=
=0A=
  function enforceReturnValue(name, factory) {=0A=
    return /** @this */ function enforcedReturnValue() {=0A=
      var result =3D instanceInjector.invoke(factory, this);=0A=
      if (isUndefined(result)) {=0A=
        throw $injectorMinErr('undef', 'Provider \'{0}\' must return a =
value from $get factory method.', name);=0A=
      }=0A=
      return result;=0A=
    };=0A=
  }=0A=
=0A=
  function factory(name, factoryFn, enforce) {=0A=
    return provider(name, {=0A=
      $get: enforce !=3D=3D false ? enforceReturnValue(name, factoryFn) =
: factoryFn=0A=
    });=0A=
  }=0A=
=0A=
  function service(name, constructor) {=0A=
    return factory(name, ['$injector', function($injector) {=0A=
      return $injector.instantiate(constructor);=0A=
    }]);=0A=
  }=0A=
=0A=
  function value(name, val) { return factory(name, valueFn(val), false); =
}=0A=
=0A=
  function constant(name, value) {=0A=
    assertNotHasOwnProperty(name, 'constant');=0A=
    providerCache[name] =3D value;=0A=
    instanceCache[name] =3D value;=0A=
  }=0A=
=0A=
  function decorator(serviceName, decorFn) {=0A=
    var origProvider =3D providerInjector.get(serviceName + =
providerSuffix),=0A=
        orig$get =3D origProvider.$get;=0A=
=0A=
    origProvider.$get =3D function() {=0A=
      var origInstance =3D instanceInjector.invoke(orig$get, =
origProvider);=0A=
      return instanceInjector.invoke(decorFn, null, {$delegate: =
origInstance});=0A=
    };=0A=
  }=0A=
=0A=
  ////////////////////////////////////=0A=
  // Module Loading=0A=
  ////////////////////////////////////=0A=
  function loadModules(modulesToLoad) {=0A=
    assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), =
'modulesToLoad', 'not an array');=0A=
    var runBlocks =3D [], moduleFn;=0A=
    forEach(modulesToLoad, function(module) {=0A=
      if (loadedModules.get(module)) return;=0A=
      loadedModules.set(module, true);=0A=
=0A=
      function runInvokeQueue(queue) {=0A=
        var i, ii;=0A=
        for (i =3D 0, ii =3D queue.length; i &lt; ii; i++) {=0A=
          var invokeArgs =3D queue[i],=0A=
              provider =3D providerInjector.get(invokeArgs[0]);=0A=
=0A=
          provider[invokeArgs[1]].apply(provider, invokeArgs[2]);=0A=
        }=0A=
      }=0A=
=0A=
      try {=0A=
        if (isString(module)) {=0A=
          moduleFn =3D angularModule(module);=0A=
          instanceInjector.modules[module] =3D moduleFn;=0A=
          runBlocks =3D =
runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBloc=
ks);=0A=
          runInvokeQueue(moduleFn._invokeQueue);=0A=
          runInvokeQueue(moduleFn._configBlocks);=0A=
        } else if (isFunction(module)) {=0A=
            runBlocks.push(providerInjector.invoke(module));=0A=
        } else if (isArray(module)) {=0A=
            runBlocks.push(providerInjector.invoke(module));=0A=
        } else {=0A=
          assertArgFn(module, 'module');=0A=
        }=0A=
      } catch (e) {=0A=
        if (isArray(module)) {=0A=
          module =3D module[module.length - 1];=0A=
        }=0A=
        if (e.message &amp;&amp; e.stack &amp;&amp; =
e.stack.indexOf(e.message) =3D=3D=3D -1) {=0A=
          // Safari &amp; FF's stack traces don't contain error.message =
content=0A=
          // unlike those of Chrome and IE=0A=
          // So if stack doesn't contain message, we create a new string =
that contains both.=0A=
          // Since error.stack is read-only in Safari, I'm overriding e =
and not e.stack here.=0A=
          // eslint-disable-next-line no-ex-assign=0A=
          e =3D e.message + '\n' + e.stack;=0A=
        }=0A=
        throw $injectorMinErr('modulerr', 'Failed to instantiate module =
{0} due to:\n{1}',=0A=
                  module, e.stack || e.message || e);=0A=
      }=0A=
    });=0A=
    return runBlocks;=0A=
  }=0A=
=0A=
  ////////////////////////////////////=0A=
  // internal Injector=0A=
  ////////////////////////////////////=0A=
=0A=
  function createInternalInjector(cache, factory) {=0A=
=0A=
    function getService(serviceName, caller) {=0A=
      if (cache.hasOwnProperty(serviceName)) {=0A=
        if (cache[serviceName] =3D=3D=3D INSTANTIATING) {=0A=
          throw $injectorMinErr('cdep', 'Circular dependency found: {0}',=0A=
                    serviceName + ' &lt;- ' + path.join(' &lt;- '));=0A=
        }=0A=
        return cache[serviceName];=0A=
      } else {=0A=
        try {=0A=
          path.unshift(serviceName);=0A=
          cache[serviceName] =3D INSTANTIATING;=0A=
          cache[serviceName] =3D factory(serviceName, caller);=0A=
          return cache[serviceName];=0A=
        } catch (err) {=0A=
          if (cache[serviceName] =3D=3D=3D INSTANTIATING) {=0A=
            delete cache[serviceName];=0A=
          }=0A=
          throw err;=0A=
        } finally {=0A=
          path.shift();=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
=0A=
    function injectionArgs(fn, locals, serviceName) {=0A=
      var args =3D [],=0A=
          $inject =3D createInjector.$$annotate(fn, strictDi, =
serviceName);=0A=
=0A=
      for (var i =3D 0, length =3D $inject.length; i &lt; length; i++) {=0A=
        var key =3D $inject[i];=0A=
        if (typeof key !=3D=3D 'string') {=0A=
          throw $injectorMinErr('itkn',=0A=
                  'Incorrect injection token! Expected service name as =
string, got {0}', key);=0A=
        }=0A=
        args.push(locals &amp;&amp; locals.hasOwnProperty(key) ? =
locals[key] :=0A=
                                                         getService(key, =
serviceName));=0A=
      }=0A=
      return args;=0A=
    }=0A=
=0A=
    function isClass(func) {=0A=
      // Support: IE 9-11 only=0A=
      // IE 9-11 do not support classes and IE9 leaks with the code =
below.=0A=
      if (msie || typeof func !=3D=3D 'function') {=0A=
        return false;=0A=
      }=0A=
      var result =3D func.$$ngIsClass;=0A=
      if (!isBoolean(result)) {=0A=
        // Support: Edge 12-13 only=0A=
        // See: =
https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/6156=
135/=0A=
        result =3D func.$$ngIsClass =3D =
/^(?:class\b|constructor\()/.test(stringifyFn(func));=0A=
      }=0A=
      return result;=0A=
    }=0A=
=0A=
    function invoke(fn, self, locals, serviceName) {=0A=
      if (typeof locals =3D=3D=3D 'string') {=0A=
        serviceName =3D locals;=0A=
        locals =3D null;=0A=
      }=0A=
=0A=
      var args =3D injectionArgs(fn, locals, serviceName);=0A=
      if (isArray(fn)) {=0A=
        fn =3D fn[fn.length - 1];=0A=
      }=0A=
=0A=
      if (!isClass(fn)) {=0A=
        // http://jsperf.com/angularjs-invoke-apply-vs-switch=0A=
        // #5388=0A=
        return fn.apply(self, args);=0A=
      } else {=0A=
        args.unshift(null);=0A=
        return new (Function.prototype.bind.apply(fn, args))();=0A=
      }=0A=
    }=0A=
=0A=
=0A=
    function instantiate(Type, locals, serviceName) {=0A=
      // Check if Type is annotated and use just the given function at =
n-1 as parameter=0A=
      // e.g. someModule.factory('greeter', ['$window', =
function(renamed$window) {}]);=0A=
      var ctor =3D (isArray(Type) ? Type[Type.length - 1] : Type);=0A=
      var args =3D injectionArgs(Type, locals, serviceName);=0A=
      // Empty object at position 0 is ignored for invocation with =
`new`, but required.=0A=
      args.unshift(null);=0A=
      return new (Function.prototype.bind.apply(ctor, args))();=0A=
    }=0A=
=0A=
=0A=
    return {=0A=
      invoke: invoke,=0A=
      instantiate: instantiate,=0A=
      get: getService,=0A=
      annotate: createInjector.$$annotate,=0A=
      has: function(name) {=0A=
        return providerCache.hasOwnProperty(name + providerSuffix) || =
cache.hasOwnProperty(name);=0A=
      }=0A=
    };=0A=
  }=0A=
}=0A=
=0A=
createInjector.$$annotate =3D annotate;=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $anchorScrollProvider=0A=
 * @this=0A=
 *=0A=
 * @description=0A=
 * Use `$anchorScrollProvider` to disable automatic scrolling whenever=0A=
 * {@link ng.$location#hash $location.hash()} changes.=0A=
 */=0A=
function $AnchorScrollProvider() {=0A=
=0A=
  var autoScrollingEnabled =3D true;=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $anchorScrollProvider#disableAutoScrolling=0A=
   *=0A=
   * @description=0A=
   * By default, {@link ng.$anchorScroll $anchorScroll()} will =
automatically detect changes to=0A=
   * {@link ng.$location#hash $location.hash()} and scroll to the =
element matching the new hash.&lt;br /&gt;=0A=
   * Use this method to disable automatic scrolling.=0A=
   *=0A=
   * If automatic scrolling is disabled, one must explicitly call=0A=
   * {@link ng.$anchorScroll $anchorScroll()} in order to scroll to the =
element related to the=0A=
   * current hash.=0A=
   */=0A=
  this.disableAutoScrolling =3D function() {=0A=
    autoScrollingEnabled =3D false;=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc service=0A=
   * @name $anchorScroll=0A=
   * @kind function=0A=
   * @requires $window=0A=
   * @requires $location=0A=
   * @requires $rootScope=0A=
   *=0A=
   * @description=0A=
   * When called, it scrolls to the element related to the specified =
`hash` or (if omitted) to the=0A=
   * current value of {@link ng.$location#hash $location.hash()}, =
according to the rules specified=0A=
   * in the=0A=
   * [HTML5 =
spec](http://www.w3.org/html/wg/drafts/html/master/browsers.html#an-indic=
ated-part-of-the-document).=0A=
   *=0A=
   * It also watches the {@link ng.$location#hash $location.hash()} and =
automatically scrolls to=0A=
   * match any anchor whenever it changes. This can be disabled by =
calling=0A=
   * {@link ng.$anchorScrollProvider#disableAutoScrolling =
$anchorScrollProvider.disableAutoScrolling()}.=0A=
   *=0A=
   * Additionally, you can use its {@link ng.$anchorScroll#yOffset =
yOffset} property to specify a=0A=
   * vertical scroll-offset (either fixed or dynamic).=0A=
   *=0A=
   * @param {string=3D} hash The hash specifying the element to scroll =
to. If omitted, the value of=0A=
   *                       {@link ng.$location#hash $location.hash()} =
will be used.=0A=
   *=0A=
   * @property {(number|function|jqLite)} yOffset=0A=
   * If set, specifies a vertical scroll-offset. This is often useful =
when there are fixed=0A=
   * positioned elements at the top of the page, such as navbars, =
headers etc.=0A=
   *=0A=
   * `yOffset` can be specified in various ways:=0A=
   * - **number**: A fixed number of pixels to be used as offset.&lt;br =
/&gt;&lt;br /&gt;=0A=
   * - **function**: A getter function called everytime =
`$anchorScroll()` is executed. Must return=0A=
   *   a number representing the offset (in pixels).&lt;br /&gt;&lt;br =
/&gt;=0A=
   * - **jqLite**: A jqLite/jQuery element to be used for specifying the =
offset. The distance from=0A=
   *   the top of the page to the element's bottom will be used as =
offset.&lt;br /&gt;=0A=
   *   **Note**: The element will be taken into account only as long as =
its `position` is set to=0A=
   *   `fixed`. This option is useful, when dealing with responsive =
navbars/headers that adjust=0A=
   *   their height and/or positioning according to the viewport's size.=0A=
   *=0A=
   * &lt;br /&gt;=0A=
   * &lt;div class=3D"alert alert-warning"&gt;=0A=
   * In order for `yOffset` to work properly, scrolling should take =
place on the document's root and=0A=
   * not some child element.=0A=
   * &lt;/div&gt;=0A=
   *=0A=
   * @example=0A=
     &lt;example module=3D"anchorScrollExample" =
name=3D"anchor-scroll"&gt;=0A=
       &lt;file name=3D"index.html"&gt;=0A=
         &lt;div id=3D"scrollArea" ng-controller=3D"ScrollController"&gt;=0A=
           &lt;a ng-click=3D"gotoBottom()"&gt;Go to bottom&lt;/a&gt;=0A=
           &lt;a id=3D"bottom"&gt;&lt;/a&gt; You're at the bottom!=0A=
         &lt;/div&gt;=0A=
       &lt;/file&gt;=0A=
       &lt;file name=3D"script.js"&gt;=0A=
         angular.module('anchorScrollExample', [])=0A=
           .controller('ScrollController', ['$scope', '$location', =
'$anchorScroll',=0A=
             function($scope, $location, $anchorScroll) {=0A=
               $scope.gotoBottom =3D function() {=0A=
                 // set the location.hash to the id of=0A=
                 // the element you wish to scroll to.=0A=
                 $location.hash('bottom');=0A=
=0A=
                 // call $anchorScroll()=0A=
                 $anchorScroll();=0A=
               };=0A=
             }]);=0A=
       &lt;/file&gt;=0A=
       &lt;file name=3D"style.css"&gt;=0A=
         #scrollArea {=0A=
           height: 280px;=0A=
           overflow: auto;=0A=
         }=0A=
=0A=
         #bottom {=0A=
           display: block;=0A=
           margin-top: 2000px;=0A=
         }=0A=
       &lt;/file&gt;=0A=
     &lt;/example&gt;=0A=
   *=0A=
   * &lt;hr /&gt;=0A=
   * The example below illustrates the use of a vertical scroll-offset =
(specified as a fixed value).=0A=
   * See {@link ng.$anchorScroll#yOffset $anchorScroll.yOffset} for more =
details.=0A=
   *=0A=
   * @example=0A=
     &lt;example module=3D"anchorScrollOffsetExample" =
name=3D"anchor-scroll-offset"&gt;=0A=
       &lt;file name=3D"index.html"&gt;=0A=
         &lt;div class=3D"fixed-header" ng-controller=3D"headerCtrl"&gt;=0A=
           &lt;a href=3D"" ng-click=3D"gotoAnchor(x)" ng-repeat=3D"x in =
[1,2,3,4,5]"&gt;=0A=
             Go to anchor {{x}}=0A=
           &lt;/a&gt;=0A=
         &lt;/div&gt;=0A=
         &lt;div id=3D"anchor{{x}}" class=3D"anchor" ng-repeat=3D"x in =
[1,2,3,4,5]"&gt;=0A=
           Anchor {{x}} of 5=0A=
         &lt;/div&gt;=0A=
       &lt;/file&gt;=0A=
       &lt;file name=3D"script.js"&gt;=0A=
         angular.module('anchorScrollOffsetExample', [])=0A=
           .run(['$anchorScroll', function($anchorScroll) {=0A=
             $anchorScroll.yOffset =3D 50;   // always scroll by 50 =
extra pixels=0A=
           }])=0A=
           .controller('headerCtrl', ['$anchorScroll', '$location', =
'$scope',=0A=
             function($anchorScroll, $location, $scope) {=0A=
               $scope.gotoAnchor =3D function(x) {=0A=
                 var newHash =3D 'anchor' + x;=0A=
                 if ($location.hash() !=3D=3D newHash) {=0A=
                   // set the $location.hash to `newHash` and=0A=
                   // $anchorScroll will automatically scroll to it=0A=
                   $location.hash('anchor' + x);=0A=
                 } else {=0A=
                   // call $anchorScroll() explicitly,=0A=
                   // since $location.hash hasn't changed=0A=
                   $anchorScroll();=0A=
                 }=0A=
               };=0A=
             }=0A=
           ]);=0A=
       &lt;/file&gt;=0A=
       &lt;file name=3D"style.css"&gt;=0A=
         body {=0A=
           padding-top: 50px;=0A=
         }=0A=
=0A=
         .anchor {=0A=
           border: 2px dashed DarkOrchid;=0A=
           padding: 10px 10px 200px 10px;=0A=
         }=0A=
=0A=
         .fixed-header {=0A=
           background-color: rgba(0, 0, 0, 0.2);=0A=
           height: 50px;=0A=
           position: fixed;=0A=
           top: 0; left: 0; right: 0;=0A=
         }=0A=
=0A=
         .fixed-header &gt; a {=0A=
           display: inline-block;=0A=
           margin: 5px 15px;=0A=
         }=0A=
       &lt;/file&gt;=0A=
     &lt;/example&gt;=0A=
   */=0A=
  this.$get =3D ['$window', '$location', '$rootScope', function($window, =
$location, $rootScope) {=0A=
    var document =3D $window.document;=0A=
=0A=
    // Helper function to get first anchor from a NodeList=0A=
    // (using `Array#some()` instead of `angular#forEach()` since it's =
more performant=0A=
    //  and working in all supported browsers.)=0A=
    function getFirstAnchor(list) {=0A=
      var result =3D null;=0A=
      Array.prototype.some.call(list, function(element) {=0A=
        if (nodeName_(element) =3D=3D=3D 'a') {=0A=
          result =3D element;=0A=
          return true;=0A=
        }=0A=
      });=0A=
      return result;=0A=
    }=0A=
=0A=
    function getYOffset() {=0A=
=0A=
      var offset =3D scroll.yOffset;=0A=
=0A=
      if (isFunction(offset)) {=0A=
        offset =3D offset();=0A=
      } else if (isElement(offset)) {=0A=
        var elem =3D offset[0];=0A=
        var style =3D $window.getComputedStyle(elem);=0A=
        if (style.position !=3D=3D 'fixed') {=0A=
          offset =3D 0;=0A=
        } else {=0A=
          offset =3D elem.getBoundingClientRect().bottom;=0A=
        }=0A=
      } else if (!isNumber(offset)) {=0A=
        offset =3D 0;=0A=
      }=0A=
=0A=
      return offset;=0A=
    }=0A=
=0A=
    function scrollTo(elem) {=0A=
      if (elem) {=0A=
        elem.scrollIntoView();=0A=
=0A=
        var offset =3D getYOffset();=0A=
=0A=
        if (offset) {=0A=
          // `offset` is the number of pixels we should scroll UP in =
order to align `elem` properly.=0A=
          // This is true ONLY if the call to `elem.scrollIntoView()` =
initially aligns `elem` at the=0A=
          // top of the viewport.=0A=
          //=0A=
          // IF the number of pixels from the top of `elem` to the end =
of the page's content is less=0A=
          // than the height of the viewport, then =
`elem.scrollIntoView()` will align the `elem` some=0A=
          // way down the page.=0A=
          //=0A=
          // This is often the case for elements near the bottom of the =
page.=0A=
          //=0A=
          // In such cases we do not need to scroll the whole `offset` =
up, just the difference between=0A=
          // the top of the element and the offset, which is enough to =
align the top of `elem` at the=0A=
          // desired position.=0A=
          var elemTop =3D elem.getBoundingClientRect().top;=0A=
          $window.scrollBy(0, elemTop - offset);=0A=
        }=0A=
      } else {=0A=
        $window.scrollTo(0, 0);=0A=
      }=0A=
    }=0A=
=0A=
    function scroll(hash) {=0A=
      // Allow numeric hashes=0A=
      hash =3D isString(hash) ? hash : isNumber(hash) ? hash.toString() =
: $location.hash();=0A=
      var elm;=0A=
=0A=
      // empty hash, scroll to the top of the page=0A=
      if (!hash) scrollTo(null);=0A=
=0A=
      // element with given id=0A=
      else if ((elm =3D document.getElementById(hash))) scrollTo(elm);=0A=
=0A=
      // first anchor with given name :-D=0A=
      else if ((elm =3D =
getFirstAnchor(document.getElementsByName(hash)))) scrollTo(elm);=0A=
=0A=
      // no element and hash =3D=3D=3D 'top', scroll to the top of the =
page=0A=
      else if (hash =3D=3D=3D 'top') scrollTo(null);=0A=
    }=0A=
=0A=
    // does not scroll when user clicks on anchor link that is currently =
on=0A=
    // (no url change, no $location.hash() change), browser native does =
scroll=0A=
    if (autoScrollingEnabled) {=0A=
      $rootScope.$watch(function autoScrollWatch() {return =
$location.hash();},=0A=
        function autoScrollWatchAction(newVal, oldVal) {=0A=
          // skip the initial scroll if $location.hash is empty=0A=
          if (newVal =3D=3D=3D oldVal &amp;&amp; newVal =3D=3D=3D '') =
return;=0A=
=0A=
          jqLiteDocumentLoaded(function() {=0A=
            $rootScope.$evalAsync(scroll);=0A=
          });=0A=
        });=0A=
    }=0A=
=0A=
    return scroll;=0A=
  }];=0A=
}=0A=
=0A=
var $animateMinErr =3D minErr('$animate');=0A=
var ELEMENT_NODE =3D 1;=0A=
var NG_ANIMATE_CLASSNAME =3D 'ng-animate';=0A=
=0A=
function mergeClasses(a,b) {=0A=
  if (!a &amp;&amp; !b) return '';=0A=
  if (!a) return b;=0A=
  if (!b) return a;=0A=
  if (isArray(a)) a =3D a.join(' ');=0A=
  if (isArray(b)) b =3D b.join(' ');=0A=
  return a + ' ' + b;=0A=
}=0A=
=0A=
function extractElementNode(element) {=0A=
  for (var i =3D 0; i &lt; element.length; i++) {=0A=
    var elm =3D element[i];=0A=
    if (elm.nodeType =3D=3D=3D ELEMENT_NODE) {=0A=
      return elm;=0A=
    }=0A=
  }=0A=
}=0A=
=0A=
function splitClasses(classes) {=0A=
  if (isString(classes)) {=0A=
    classes =3D classes.split(' ');=0A=
  }=0A=
=0A=
  // Use createMap() to prevent class assumptions involving property =
names in=0A=
  // Object.prototype=0A=
  var obj =3D createMap();=0A=
  forEach(classes, function(klass) {=0A=
    // sometimes the split leaves empty string values=0A=
    // incase extra spaces were applied to the options=0A=
    if (klass.length) {=0A=
      obj[klass] =3D true;=0A=
    }=0A=
  });=0A=
  return obj;=0A=
}=0A=
=0A=
// if any other type of options value besides an Object value is=0A=
// passed into the $animate.method() animation then this helper code=0A=
// will be run which will ignore it. While this patch is not the=0A=
// greatest solution to this, a lot of existing plugins depend on=0A=
// $animate to either call the callback (&lt; 1.2) or return a promise=0A=
// that can be changed. This helper function ensures that the options=0A=
// are wiped clean incase a callback function is provided.=0A=
function prepareAnimateOptions(options) {=0A=
  return isObject(options)=0A=
      ? options=0A=
      : {};=0A=
}=0A=
=0A=
var $$CoreAnimateJsProvider =3D /** @this */ function() {=0A=
  this.$get =3D noop;=0A=
};=0A=
=0A=
// this is prefixed with Core since it conflicts with=0A=
// the animateQueueProvider defined in ngAnimate/animateQueue.js=0A=
var $$CoreAnimateQueueProvider =3D /** @this */ function() {=0A=
  var postDigestQueue =3D new NgMap();=0A=
  var postDigestElements =3D [];=0A=
=0A=
  this.$get =3D ['$$AnimateRunner', '$rootScope',=0A=
       function($$AnimateRunner,   $rootScope) {=0A=
    return {=0A=
      enabled: noop,=0A=
      on: noop,=0A=
      off: noop,=0A=
      pin: noop,=0A=
=0A=
      push: function(element, event, options, domOperation) {=0A=
        if (domOperation) {=0A=
          domOperation();=0A=
        }=0A=
=0A=
        options =3D options || {};=0A=
        if (options.from) {=0A=
          element.css(options.from);=0A=
        }=0A=
        if (options.to) {=0A=
          element.css(options.to);=0A=
        }=0A=
=0A=
        if (options.addClass || options.removeClass) {=0A=
          addRemoveClassesPostDigest(element, options.addClass, =
options.removeClass);=0A=
        }=0A=
=0A=
        var runner =3D new $$AnimateRunner();=0A=
=0A=
        // since there are no animations to run the runner needs to be=0A=
        // notified that the animation call is complete.=0A=
        runner.complete();=0A=
        return runner;=0A=
      }=0A=
    };=0A=
=0A=
=0A=
    function updateData(data, classes, value) {=0A=
      var changed =3D false;=0A=
      if (classes) {=0A=
        classes =3D isString(classes) ? classes.split(' ') :=0A=
                  isArray(classes) ? classes : [];=0A=
        forEach(classes, function(className) {=0A=
          if (className) {=0A=
            changed =3D true;=0A=
            data[className] =3D value;=0A=
          }=0A=
        });=0A=
      }=0A=
      return changed;=0A=
    }=0A=
=0A=
    function handleCSSClassChanges() {=0A=
      forEach(postDigestElements, function(element) {=0A=
        var data =3D postDigestQueue.get(element);=0A=
        if (data) {=0A=
          var existing =3D splitClasses(element.attr('class'));=0A=
          var toAdd =3D '';=0A=
          var toRemove =3D '';=0A=
          forEach(data, function(status, className) {=0A=
            var hasClass =3D !!existing[className];=0A=
            if (status !=3D=3D hasClass) {=0A=
              if (status) {=0A=
                toAdd +=3D (toAdd.length ? ' ' : '') + className;=0A=
              } else {=0A=
                toRemove +=3D (toRemove.length ? ' ' : '') + className;=0A=
              }=0A=
            }=0A=
          });=0A=
=0A=
          forEach(element, function(elm) {=0A=
            if (toAdd) {=0A=
              jqLiteAddClass(elm, toAdd);=0A=
            }=0A=
            if (toRemove) {=0A=
              jqLiteRemoveClass(elm, toRemove);=0A=
            }=0A=
          });=0A=
          postDigestQueue.delete(element);=0A=
        }=0A=
      });=0A=
      postDigestElements.length =3D 0;=0A=
    }=0A=
=0A=
=0A=
    function addRemoveClassesPostDigest(element, add, remove) {=0A=
      var data =3D postDigestQueue.get(element) || {};=0A=
=0A=
      var classesAdded =3D updateData(data, add, true);=0A=
      var classesRemoved =3D updateData(data, remove, false);=0A=
=0A=
      if (classesAdded || classesRemoved) {=0A=
=0A=
        postDigestQueue.set(element, data);=0A=
        postDigestElements.push(element);=0A=
=0A=
        if (postDigestElements.length =3D=3D=3D 1) {=0A=
          $rootScope.$$postDigest(handleCSSClassChanges);=0A=
        }=0A=
      }=0A=
    }=0A=
  }];=0A=
};=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $animateProvider=0A=
 *=0A=
 * @description=0A=
 * Default implementation of $animate that doesn't perform any =
animations, instead just=0A=
 * synchronously performs DOM updates and resolves the returned runner =
promise.=0A=
 *=0A=
 * In order to enable animations the `ngAnimate` module has to be loaded.=0A=
 *=0A=
 * To see the functional implementation check out =
`src/ngAnimate/animate.js`.=0A=
 */=0A=
var $AnimateProvider =3D ['$provide', /** @this */ function($provide) {=0A=
  var provider =3D this;=0A=
  var classNameFilter =3D null;=0A=
  var customFilter =3D null;=0A=
=0A=
  this.$$registeredAnimations =3D Object.create(null);=0A=
=0A=
   /**=0A=
   * @ngdoc method=0A=
   * @name $animateProvider#register=0A=
   *=0A=
   * @description=0A=
   * Registers a new injectable animation factory function. The factory =
function produces the=0A=
   * animation object which contains callback functions for each event =
that is expected to be=0A=
   * animated.=0A=
   *=0A=
   *   * `eventFn`: `function(element, ... , doneFunction, options)`=0A=
   *   The element to animate, the `doneFunction` and the options fed =
into the animation. Depending=0A=
   *   on the type of animation additional arguments will be injected =
into the animation function. The=0A=
   *   list below explains the function signatures for the different =
animation methods:=0A=
   *=0A=
   *   - setClass: function(element, addedClasses, removedClasses, =
doneFunction, options)=0A=
   *   - addClass: function(element, addedClasses, doneFunction, options)=0A=
   *   - removeClass: function(element, removedClasses, doneFunction, =
options)=0A=
   *   - enter, leave, move: function(element, doneFunction, options)=0A=
   *   - animate: function(element, fromStyles, toStyles, doneFunction, =
options)=0A=
   *=0A=
   *   Make sure to trigger the `doneFunction` once the animation is =
fully complete.=0A=
   *=0A=
   * ```js=0A=
   *   return {=0A=
   *     //enter, leave, move signature=0A=
   *     eventFn : function(element, done, options) {=0A=
   *       //code to run the animation=0A=
   *       //once complete, then run done()=0A=
   *       return function endFunction(wasCancelled) {=0A=
   *         //code to cancel the animation=0A=
   *       }=0A=
   *     }=0A=
   *   }=0A=
   * ```=0A=
   *=0A=
   * @param {string} name The name of the animation (this is what the =
class-based CSS value will be compared to).=0A=
   * @param {Function} factory The factory function that will be =
executed to return the animation=0A=
   *                           object.=0A=
   */=0A=
  this.register =3D function(name, factory) {=0A=
    if (name &amp;&amp; name.charAt(0) !=3D=3D '.') {=0A=
      throw $animateMinErr('notcsel', 'Expecting class selector starting =
with \'.\' got \'{0}\'.', name);=0A=
    }=0A=
=0A=
    var key =3D name + '-animation';=0A=
    provider.$$registeredAnimations[name.substr(1)] =3D key;=0A=
    $provide.factory(key, factory);=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $animateProvider#customFilter=0A=
   *=0A=
   * @description=0A=
   * Sets and/or returns the custom filter function that is used to =
"filter" animations, i.e.=0A=
   * determine if an animation is allowed or not. When no filter is =
specified (the default), no=0A=
   * animation will be blocked. Setting the `customFilter` value will =
only allow animations for=0A=
   * which the filter function's return value is truthy.=0A=
   *=0A=
   * This allows to easily create arbitrarily complex rules for =
filtering animations, such as=0A=
   * allowing specific events only, or enabling animations on specific =
subtrees of the DOM, etc.=0A=
   * Filtering animations can also boost performance for low-powered =
devices, as well as=0A=
   * applications containing a lot of structural operations.=0A=
   *=0A=
   * &lt;div class=3D"alert alert-success"&gt;=0A=
   *   **Best Practice:**=0A=
   *   Keep the filtering function as lean as possible, because it will =
be called for each DOM=0A=
   *   action (e.g. insertion, removal, class change) performed by =
"animation-aware" directives.=0A=
   *   See {@link guide/animations#which-directives-support-animations- =
here} for a list of built-in=0A=
   *   directives that support animations.=0A=
   *   Performing computationally expensive or time-consuming operations =
on each call of the=0A=
   *   filtering function can make your animations sluggish.=0A=
   * &lt;/div&gt;=0A=
   *=0A=
   * **Note:** If present, `customFilter` will be checked before=0A=
   * {@link $animateProvider#classNameFilter classNameFilter}.=0A=
   *=0A=
   * @param {Function=3D} filterFn - The filter function which will be =
used to filter all animations.=0A=
   *   If a falsy value is returned, no animation will be performed. The =
function will be called=0A=
   *   with the following arguments:=0A=
   *   - **node** `{DOMElement}` - The DOM element to be animated.=0A=
   *   - **event** `{String}` - The name of the animation event (e.g. =
`enter`, `leave`, `addClass`=0A=
   *     etc).=0A=
   *   - **options** `{Object}` - A collection of options/styles used =
for the animation.=0A=
   * @return {Function} The current filter function or `null` if there =
is none set.=0A=
   */=0A=
  this.customFilter =3D function(filterFn) {=0A=
    if (arguments.length =3D=3D=3D 1) {=0A=
      customFilter =3D isFunction(filterFn) ? filterFn : null;=0A=
    }=0A=
=0A=
    return customFilter;=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $animateProvider#classNameFilter=0A=
   *=0A=
   * @description=0A=
   * Sets and/or returns the CSS class regular expression that is =
checked when performing=0A=
   * an animation. Upon bootstrap the classNameFilter value is not set =
at all and will=0A=
   * therefore enable $animate to attempt to perform an animation on any =
element that is triggered.=0A=
   * When setting the `classNameFilter` value, animations will only be =
performed on elements=0A=
   * that successfully match the filter expression. This in turn can =
boost performance=0A=
   * for low-powered devices as well as applications containing a lot of =
structural operations.=0A=
   *=0A=
   * **Note:** If present, `classNameFilter` will be checked after=0A=
   * {@link $animateProvider#customFilter customFilter}. If =
`customFilter` is present and returns=0A=
   * false, `classNameFilter` will not be checked.=0A=
   *=0A=
   * @param {RegExp=3D} expression The className expression which will =
be checked against all animations=0A=
   * @return {RegExp} The current CSS className expression value. If =
null then there is no expression value=0A=
   */=0A=
  this.classNameFilter =3D function(expression) {=0A=
    if (arguments.length =3D=3D=3D 1) {=0A=
      classNameFilter =3D (expression instanceof RegExp) ? expression : =
null;=0A=
      if (classNameFilter) {=0A=
        var reservedRegex =3D new RegExp('[(\\s|\\/)]' + =
NG_ANIMATE_CLASSNAME + '[(\\s|\\/)]');=0A=
        if (reservedRegex.test(classNameFilter.toString())) {=0A=
          classNameFilter =3D null;=0A=
          throw $animateMinErr('nongcls', =
'$animateProvider.classNameFilter(regex) prohibits accepting a regex =
value which matches/contains the "{0}" CSS class.', =
NG_ANIMATE_CLASSNAME);=0A=
        }=0A=
      }=0A=
    }=0A=
    return classNameFilter;=0A=
  };=0A=
=0A=
  this.$get =3D ['$$animateQueue', function($$animateQueue) {=0A=
    function domInsert(element, parentElement, afterElement) {=0A=
      // if for some reason the previous element was removed=0A=
      // from the dom sometime before this code runs then let's=0A=
      // just stick to using the parent element as the anchor=0A=
      if (afterElement) {=0A=
        var afterNode =3D extractElementNode(afterElement);=0A=
        if (afterNode &amp;&amp; !afterNode.parentNode &amp;&amp; =
!afterNode.previousElementSibling) {=0A=
          afterElement =3D null;=0A=
        }=0A=
      }=0A=
      if (afterElement) {=0A=
        afterElement.after(element);=0A=
      } else {=0A=
        parentElement.prepend(element);=0A=
      }=0A=
    }=0A=
=0A=
    /**=0A=
     * @ngdoc service=0A=
     * @name $animate=0A=
     * @description The $animate service exposes a series of DOM utility =
methods that provide support=0A=
     * for animation hooks. The default behavior is the application of =
DOM operations, however,=0A=
     * when an animation is detected (and animations are enabled), =
$animate will do the heavy lifting=0A=
     * to ensure that animation runs with the triggered DOM operation.=0A=
     *=0A=
     * By default $animate doesn't trigger any animations. This is =
because the `ngAnimate` module isn't=0A=
     * included and only when it is active then the animation hooks that =
`$animate` triggers will be=0A=
     * functional. Once active then all structural `ng-` directives will =
trigger animations as they perform=0A=
     * their DOM-related operations (enter, leave and move). Other =
directives such as `ngClass`,=0A=
     * `ngShow`, `ngHide` and `ngMessages` also provide support for =
animations.=0A=
     *=0A=
     * It is recommended that the`$animate` service is always used when =
executing DOM-related procedures within directives.=0A=
     *=0A=
     * To learn more about enabling animation support, click here to =
visit the=0A=
     * {@link ngAnimate ngAnimate module page}.=0A=
     */=0A=
    return {=0A=
      // we don't call it directly since non-existant arguments may=0A=
      // be interpreted as null within the sub enabled function=0A=
=0A=
      /**=0A=
       *=0A=
       * @ngdoc method=0A=
       * @name $animate#on=0A=
       * @kind function=0A=
       * @description Sets up an event listener to fire whenever the =
animation event (enter, leave, move, etc...)=0A=
       *    has fired on the given element or among any of its children. =
Once the listener is fired, the provided callback=0A=
       *    is fired with the following params:=0A=
       *=0A=
       * ```js=0A=
       * $animate.on('enter', container,=0A=
       *    function callback(element, phase) {=0A=
       *      // cool we detected an enter animation within the container=0A=
       *    }=0A=
       * );=0A=
       * ```=0A=
       *=0A=
       * @param {string} event the animation event that will be captured =
(e.g. enter, leave, move, addClass, removeClass, etc...)=0A=
       * @param {DOMElement} container the container element that will =
capture each of the animation events that are fired on itself=0A=
       *     as well as among its children=0A=
       * @param {Function} callback the callback function that will be =
fired when the listener is triggered=0A=
       *=0A=
       * The arguments present in the callback function are:=0A=
       * * `element` - The captured DOM element that the animation was =
fired on.=0A=
       * * `phase` - The phase of the animation. The two possible phases =
are **start** (when the animation starts) and **close** (when it ends).=0A=
       */=0A=
      on: $$animateQueue.on,=0A=
=0A=
      /**=0A=
       *=0A=
       * @ngdoc method=0A=
       * @name $animate#off=0A=
       * @kind function=0A=
       * @description Deregisters an event listener based on the event =
which has been associated with the provided element. This method=0A=
       * can be used in three different ways depending on the arguments:=0A=
       *=0A=
       * ```js=0A=
       * // remove all the animation event listeners listening for =
`enter`=0A=
       * $animate.off('enter');=0A=
       *=0A=
       * // remove listeners for all animation events from the container =
element=0A=
       * $animate.off(container);=0A=
       *=0A=
       * // remove all the animation event listeners listening for =
`enter` on the given element and its children=0A=
       * $animate.off('enter', container);=0A=
       *=0A=
       * // remove the event listener function provided by `callback` =
that is set=0A=
       * // to listen for `enter` on the given `container` as well as =
its children=0A=
       * $animate.off('enter', container, callback);=0A=
       * ```=0A=
       *=0A=
       * @param {string|DOMElement} event|container the animation event =
(e.g. enter, leave, move,=0A=
       * addClass, removeClass, etc...), or the container element. If it =
is the element, all other=0A=
       * arguments are ignored.=0A=
       * @param {DOMElement=3D} container the container element the =
event listener was placed on=0A=
       * @param {Function=3D} callback the callback function that was =
registered as the listener=0A=
       */=0A=
      off: $$animateQueue.off,=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $animate#pin=0A=
       * @kind function=0A=
       * @description Associates the provided element with a host parent =
element to allow the element to be animated even if it exists=0A=
       *    outside of the DOM structure of the Angular application. By =
doing so, any animation triggered via `$animate` can be issued on the=0A=
       *    element despite being outside the realm of the application =
or within another application. Say for example if the application=0A=
       *    was bootstrapped on an element that is somewhere inside of =
the `&lt;body&gt;` tag, but we wanted to allow for an element to be =
situated=0A=
       *    as a direct child of `document.body`, then this can be =
achieved by pinning the element via `$animate.pin(element)`. Keep in mind=0A=
       *    that calling `$animate.pin(element, parentElement)` will not =
actually insert into the DOM anywhere; it will just create the =
association.=0A=
       *=0A=
       *    Note that this feature is only active when the `ngAnimate` =
module is used.=0A=
       *=0A=
       * @param {DOMElement} element the external element that will be =
pinned=0A=
       * @param {DOMElement} parentElement the host parent element that =
will be associated with the external element=0A=
       */=0A=
      pin: $$animateQueue.pin,=0A=
=0A=
      /**=0A=
       *=0A=
       * @ngdoc method=0A=
       * @name $animate#enabled=0A=
       * @kind function=0A=
       * @description Used to get and set whether animations are enabled =
or not on the entire application or on an element and its children. This=0A=
       * function can be called in four ways:=0A=
       *=0A=
       * ```js=0A=
       * // returns true or false=0A=
       * $animate.enabled();=0A=
       *=0A=
       * // changes the enabled state for all animations=0A=
       * $animate.enabled(false);=0A=
       * $animate.enabled(true);=0A=
       *=0A=
       * // returns true or false if animations are enabled for an =
element=0A=
       * $animate.enabled(element);=0A=
       *=0A=
       * // changes the enabled state for an element and its children=0A=
       * $animate.enabled(element, true);=0A=
       * $animate.enabled(element, false);=0A=
       * ```=0A=
       *=0A=
       * @param {DOMElement=3D} element the element that will be =
considered for checking/setting the enabled state=0A=
       * @param {boolean=3D} enabled whether or not the animations will =
be enabled for the element=0A=
       *=0A=
       * @return {boolean} whether or not animations are enabled=0A=
       */=0A=
      enabled: $$animateQueue.enabled,=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $animate#cancel=0A=
       * @kind function=0A=
       * @description Cancels the provided animation.=0A=
       *=0A=
       * @param {Promise} animationPromise The animation promise that is =
returned when an animation is started.=0A=
       */=0A=
      cancel: function(runner) {=0A=
        if (runner.end) {=0A=
          runner.end();=0A=
        }=0A=
      },=0A=
=0A=
      /**=0A=
       *=0A=
       * @ngdoc method=0A=
       * @name $animate#enter=0A=
       * @kind function=0A=
       * @description Inserts the element into the DOM either after the =
`after` element (if provided) or=0A=
       *   as the first child within the `parent` element and then =
triggers an animation.=0A=
       *   A promise is returned that will be resolved during the next =
digest once the animation=0A=
       *   has completed.=0A=
       *=0A=
       * @param {DOMElement} element the element which will be inserted =
into the DOM=0A=
       * @param {DOMElement} parent the parent element which will append =
the element as=0A=
       *   a child (so long as the after element is not present)=0A=
       * @param {DOMElement=3D} after the sibling element after which =
the element will be appended=0A=
       * @param {object=3D} options an optional collection of =
options/styles that will be applied to the element.=0A=
       *   The object can have the following properties:=0A=
       *=0A=
       *   - **addClass** - `{string}` - space-separated CSS classes to =
add to element=0A=
       *   - **from** - `{Object}` - CSS properties &amp; values at the =
beginning of animation. Must have matching `to`=0A=
       *   - **removeClass** - `{string}` - space-separated CSS classes =
to remove from element=0A=
       *   - **to** - `{Object}` - CSS properties &amp; values at end of =
animation. Must have matching `from`=0A=
       *=0A=
       * @return {Promise} the animation callback promise=0A=
       */=0A=
      enter: function(element, parent, after, options) {=0A=
        parent =3D parent &amp;&amp; jqLite(parent);=0A=
        after =3D after &amp;&amp; jqLite(after);=0A=
        parent =3D parent || after.parent();=0A=
        domInsert(element, parent, after);=0A=
        return $$animateQueue.push(element, 'enter', =
prepareAnimateOptions(options));=0A=
      },=0A=
=0A=
      /**=0A=
       *=0A=
       * @ngdoc method=0A=
       * @name $animate#move=0A=
       * @kind function=0A=
       * @description Inserts (moves) the element into its new position =
in the DOM either after=0A=
       *   the `after` element (if provided) or as the first child =
within the `parent` element=0A=
       *   and then triggers an animation. A promise is returned that =
will be resolved=0A=
       *   during the next digest once the animation has completed.=0A=
       *=0A=
       * @param {DOMElement} element the element which will be moved =
into the new DOM position=0A=
       * @param {DOMElement} parent the parent element which will append =
the element as=0A=
       *   a child (so long as the after element is not present)=0A=
       * @param {DOMElement=3D} after the sibling element after which =
the element will be appended=0A=
       * @param {object=3D} options an optional collection of =
options/styles that will be applied to the element.=0A=
       *   The object can have the following properties:=0A=
       *=0A=
       *   - **addClass** - `{string}` - space-separated CSS classes to =
add to element=0A=
       *   - **from** - `{Object}` - CSS properties &amp; values at the =
beginning of animation. Must have matching `to`=0A=
       *   - **removeClass** - `{string}` - space-separated CSS classes =
to remove from element=0A=
       *   - **to** - `{Object}` - CSS properties &amp; values at end of =
animation. Must have matching `from`=0A=
       *=0A=
       * @return {Promise} the animation callback promise=0A=
       */=0A=
      move: function(element, parent, after, options) {=0A=
        parent =3D parent &amp;&amp; jqLite(parent);=0A=
        after =3D after &amp;&amp; jqLite(after);=0A=
        parent =3D parent || after.parent();=0A=
        domInsert(element, parent, after);=0A=
        return $$animateQueue.push(element, 'move', =
prepareAnimateOptions(options));=0A=
      },=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $animate#leave=0A=
       * @kind function=0A=
       * @description Triggers an animation and then removes the element =
from the DOM.=0A=
       * When the function is called a promise is returned that will be =
resolved during the next=0A=
       * digest once the animation has completed.=0A=
       *=0A=
       * @param {DOMElement} element the element which will be removed =
from the DOM=0A=
       * @param {object=3D} options an optional collection of =
options/styles that will be applied to the element.=0A=
       *   The object can have the following properties:=0A=
       *=0A=
       *   - **addClass** - `{string}` - space-separated CSS classes to =
add to element=0A=
       *   - **from** - `{Object}` - CSS properties &amp; values at the =
beginning of animation. Must have matching `to`=0A=
       *   - **removeClass** - `{string}` - space-separated CSS classes =
to remove from element=0A=
       *   - **to** - `{Object}` - CSS properties &amp; values at end of =
animation. Must have matching `from`=0A=
       *=0A=
       * @return {Promise} the animation callback promise=0A=
       */=0A=
      leave: function(element, options) {=0A=
        return $$animateQueue.push(element, 'leave', =
prepareAnimateOptions(options), function() {=0A=
          element.remove();=0A=
        });=0A=
      },=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $animate#addClass=0A=
       * @kind function=0A=
       *=0A=
       * @description Triggers an addClass animation surrounding the =
addition of the provided CSS class(es). Upon=0A=
       *   execution, the addClass operation will only be handled after =
the next digest and it will not trigger an=0A=
       *   animation if element already contains the CSS class or if the =
class is removed at a later step.=0A=
       *   Note that class-based animations are treated differently =
compared to structural animations=0A=
       *   (like enter, move and leave) since the CSS classes may be =
added/removed at different points=0A=
       *   depending if CSS or JavaScript animations are used.=0A=
       *=0A=
       * @param {DOMElement} element the element which the CSS classes =
will be applied to=0A=
       * @param {string} className the CSS class(es) that will be added =
(multiple classes are separated via spaces)=0A=
       * @param {object=3D} options an optional collection of =
options/styles that will be applied to the element.=0A=
       *   The object can have the following properties:=0A=
       *=0A=
       *   - **addClass** - `{string}` - space-separated CSS classes to =
add to element=0A=
       *   - **from** - `{Object}` - CSS properties &amp; values at the =
beginning of animation. Must have matching `to`=0A=
       *   - **removeClass** - `{string}` - space-separated CSS classes =
to remove from element=0A=
       *   - **to** - `{Object}` - CSS properties &amp; values at end of =
animation. Must have matching `from`=0A=
       *=0A=
       * @return {Promise} the animation callback promise=0A=
       */=0A=
      addClass: function(element, className, options) {=0A=
        options =3D prepareAnimateOptions(options);=0A=
        options.addClass =3D mergeClasses(options.addclass, className);=0A=
        return $$animateQueue.push(element, 'addClass', options);=0A=
      },=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $animate#removeClass=0A=
       * @kind function=0A=
       *=0A=
       * @description Triggers a removeClass animation surrounding the =
removal of the provided CSS class(es). Upon=0A=
       *   execution, the removeClass operation will only be handled =
after the next digest and it will not trigger an=0A=
       *   animation if element does not contain the CSS class or if the =
class is added at a later step.=0A=
       *   Note that class-based animations are treated differently =
compared to structural animations=0A=
       *   (like enter, move and leave) since the CSS classes may be =
added/removed at different points=0A=
       *   depending if CSS or JavaScript animations are used.=0A=
       *=0A=
       * @param {DOMElement} element the element which the CSS classes =
will be applied to=0A=
       * @param {string} className the CSS class(es) that will be =
removed (multiple classes are separated via spaces)=0A=
       * @param {object=3D} options an optional collection of =
options/styles that will be applied to the element.=0A=
       *   The object can have the following properties:=0A=
       *=0A=
       *   - **addClass** - `{string}` - space-separated CSS classes to =
add to element=0A=
       *   - **from** - `{Object}` - CSS properties &amp; values at the =
beginning of animation. Must have matching `to`=0A=
       *   - **removeClass** - `{string}` - space-separated CSS classes =
to remove from element=0A=
       *   - **to** - `{Object}` - CSS properties &amp; values at end of =
animation. Must have matching `from`=0A=
       *=0A=
       * @return {Promise} the animation callback promise=0A=
       */=0A=
      removeClass: function(element, className, options) {=0A=
        options =3D prepareAnimateOptions(options);=0A=
        options.removeClass =3D mergeClasses(options.removeClass, =
className);=0A=
        return $$animateQueue.push(element, 'removeClass', options);=0A=
      },=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $animate#setClass=0A=
       * @kind function=0A=
       *=0A=
       * @description Performs both the addition and removal of a CSS =
classes on an element and (during the process)=0A=
       *    triggers an animation surrounding the class =
addition/removal. Much like `$animate.addClass` and=0A=
       *    `$animate.removeClass`, `setClass` will only evaluate the =
classes being added/removed once a digest has=0A=
       *    passed. Note that class-based animations are treated =
differently compared to structural animations=0A=
       *    (like enter, move and leave) since the CSS classes may be =
added/removed at different points=0A=
       *    depending if CSS or JavaScript animations are used.=0A=
       *=0A=
       * @param {DOMElement} element the element which the CSS classes =
will be applied to=0A=
       * @param {string} add the CSS class(es) that will be added =
(multiple classes are separated via spaces)=0A=
       * @param {string} remove the CSS class(es) that will be removed =
(multiple classes are separated via spaces)=0A=
       * @param {object=3D} options an optional collection of =
options/styles that will be applied to the element.=0A=
       *   The object can have the following properties:=0A=
       *=0A=
       *   - **addClass** - `{string}` - space-separated CSS classes to =
add to element=0A=
       *   - **from** - `{Object}` - CSS properties &amp; values at the =
beginning of animation. Must have matching `to`=0A=
       *   - **removeClass** - `{string}` - space-separated CSS classes =
to remove from element=0A=
       *   - **to** - `{Object}` - CSS properties &amp; values at end of =
animation. Must have matching `from`=0A=
       *=0A=
       * @return {Promise} the animation callback promise=0A=
       */=0A=
      setClass: function(element, add, remove, options) {=0A=
        options =3D prepareAnimateOptions(options);=0A=
        options.addClass =3D mergeClasses(options.addClass, add);=0A=
        options.removeClass =3D mergeClasses(options.removeClass, =
remove);=0A=
        return $$animateQueue.push(element, 'setClass', options);=0A=
      },=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $animate#animate=0A=
       * @kind function=0A=
       *=0A=
       * @description Performs an inline animation on the element which =
applies the provided to and from CSS styles to the element.=0A=
       * If any detected CSS transition, keyframe or JavaScript matches =
the provided className value, then the animation will take=0A=
       * on the provided styles. For example, if a transition animation =
is set for the given className, then the provided `from` and=0A=
       * `to` styles will be applied alongside the given transition. If =
the CSS style provided in `from` does not have a corresponding=0A=
       * style in `to`, the style in `from` is applied immediately, and =
no animation is run.=0A=
       * If a JavaScript animation is detected then the provided styles =
will be given in as function parameters into the `animate`=0A=
       * method (or as part of the `options` parameter):=0A=
       *=0A=
       * ```js=0A=
       * ngModule.animation('.my-inline-animation', function() {=0A=
       *   return {=0A=
       *     animate : function(element, from, to, done, options) {=0A=
       *       //animation=0A=
       *       done();=0A=
       *     }=0A=
       *   }=0A=
       * });=0A=
       * ```=0A=
       *=0A=
       * @param {DOMElement} element the element which the CSS styles =
will be applied to=0A=
       * @param {object} from the from (starting) CSS styles that will =
be applied to the element and across the animation.=0A=
       * @param {object} to the to (destination) CSS styles that will be =
applied to the element and across the animation.=0A=
       * @param {string=3D} className an optional CSS class that will be =
applied to the element for the duration of the animation. If=0A=
       *    this value is left as empty then a CSS class of =
`ng-inline-animate` will be applied to the element.=0A=
       *    (Note that if no animation is detected then this value will =
not be applied to the element.)=0A=
       * @param {object=3D} options an optional collection of =
options/styles that will be applied to the element.=0A=
       *   The object can have the following properties:=0A=
       *=0A=
       *   - **addClass** - `{string}` - space-separated CSS classes to =
add to element=0A=
       *   - **from** - `{Object}` - CSS properties &amp; values at the =
beginning of animation. Must have matching `to`=0A=
       *   - **removeClass** - `{string}` - space-separated CSS classes =
to remove from element=0A=
       *   - **to** - `{Object}` - CSS properties &amp; values at end of =
animation. Must have matching `from`=0A=
       *=0A=
       * @return {Promise} the animation callback promise=0A=
       */=0A=
      animate: function(element, from, to, className, options) {=0A=
        options =3D prepareAnimateOptions(options);=0A=
        options.from =3D options.from ? extend(options.from, from) : =
from;=0A=
        options.to   =3D options.to   ? extend(options.to, to)     : to;=0A=
=0A=
        className =3D className || 'ng-inline-animate';=0A=
        options.tempClasses =3D mergeClasses(options.tempClasses, =
className);=0A=
        return $$animateQueue.push(element, 'animate', options);=0A=
      }=0A=
    };=0A=
  }];=0A=
}];=0A=
=0A=
var $$AnimateAsyncRunFactoryProvider =3D /** @this */ function() {=0A=
  this.$get =3D ['$$rAF', function($$rAF) {=0A=
    var waitQueue =3D [];=0A=
=0A=
    function waitForTick(fn) {=0A=
      waitQueue.push(fn);=0A=
      if (waitQueue.length &gt; 1) return;=0A=
      $$rAF(function() {=0A=
        for (var i =3D 0; i &lt; waitQueue.length; i++) {=0A=
          waitQueue[i]();=0A=
        }=0A=
        waitQueue =3D [];=0A=
      });=0A=
    }=0A=
=0A=
    return function() {=0A=
      var passed =3D false;=0A=
      waitForTick(function() {=0A=
        passed =3D true;=0A=
      });=0A=
      return function(callback) {=0A=
        if (passed) {=0A=
          callback();=0A=
        } else {=0A=
          waitForTick(callback);=0A=
        }=0A=
      };=0A=
    };=0A=
  }];=0A=
};=0A=
=0A=
var $$AnimateRunnerFactoryProvider =3D /** @this */ function() {=0A=
  this.$get =3D ['$q', '$sniffer', '$$animateAsyncRun', =
'$$isDocumentHidden', '$timeout',=0A=
       function($q,   $sniffer,   $$animateAsyncRun,   =
$$isDocumentHidden,   $timeout) {=0A=
=0A=
    var INITIAL_STATE =3D 0;=0A=
    var DONE_PENDING_STATE =3D 1;=0A=
    var DONE_COMPLETE_STATE =3D 2;=0A=
=0A=
    AnimateRunner.chain =3D function(chain, callback) {=0A=
      var index =3D 0;=0A=
=0A=
      next();=0A=
      function next() {=0A=
        if (index =3D=3D=3D chain.length) {=0A=
          callback(true);=0A=
          return;=0A=
        }=0A=
=0A=
        chain[index](function(response) {=0A=
          if (response =3D=3D=3D false) {=0A=
            callback(false);=0A=
            return;=0A=
          }=0A=
          index++;=0A=
          next();=0A=
        });=0A=
      }=0A=
    };=0A=
=0A=
    AnimateRunner.all =3D function(runners, callback) {=0A=
      var count =3D 0;=0A=
      var status =3D true;=0A=
      forEach(runners, function(runner) {=0A=
        runner.done(onProgress);=0A=
      });=0A=
=0A=
      function onProgress(response) {=0A=
        status =3D status &amp;&amp; response;=0A=
        if (++count =3D=3D=3D runners.length) {=0A=
          callback(status);=0A=
        }=0A=
      }=0A=
    };=0A=
=0A=
    function AnimateRunner(host) {=0A=
      this.setHost(host);=0A=
=0A=
      var rafTick =3D $$animateAsyncRun();=0A=
      var timeoutTick =3D function(fn) {=0A=
        $timeout(fn, 0, false);=0A=
      };=0A=
=0A=
      this._doneCallbacks =3D [];=0A=
      this._tick =3D function(fn) {=0A=
        if ($$isDocumentHidden()) {=0A=
          timeoutTick(fn);=0A=
        } else {=0A=
          rafTick(fn);=0A=
        }=0A=
      };=0A=
      this._state =3D 0;=0A=
    }=0A=
=0A=
    AnimateRunner.prototype =3D {=0A=
      setHost: function(host) {=0A=
        this.host =3D host || {};=0A=
      },=0A=
=0A=
      done: function(fn) {=0A=
        if (this._state =3D=3D=3D DONE_COMPLETE_STATE) {=0A=
          fn();=0A=
        } else {=0A=
          this._doneCallbacks.push(fn);=0A=
        }=0A=
      },=0A=
=0A=
      progress: noop,=0A=
=0A=
      getPromise: function() {=0A=
        if (!this.promise) {=0A=
          var self =3D this;=0A=
          this.promise =3D $q(function(resolve, reject) {=0A=
            self.done(function(status) {=0A=
              if (status =3D=3D=3D false) {=0A=
                reject();=0A=
              } else {=0A=
                resolve();=0A=
              }=0A=
            });=0A=
          });=0A=
        }=0A=
        return this.promise;=0A=
      },=0A=
=0A=
      then: function(resolveHandler, rejectHandler) {=0A=
        return this.getPromise().then(resolveHandler, rejectHandler);=0A=
      },=0A=
=0A=
      'catch': function(handler) {=0A=
        return this.getPromise()['catch'](handler);=0A=
      },=0A=
=0A=
      'finally': function(handler) {=0A=
        return this.getPromise()['finally'](handler);=0A=
      },=0A=
=0A=
      pause: function() {=0A=
        if (this.host.pause) {=0A=
          this.host.pause();=0A=
        }=0A=
      },=0A=
=0A=
      resume: function() {=0A=
        if (this.host.resume) {=0A=
          this.host.resume();=0A=
        }=0A=
      },=0A=
=0A=
      end: function() {=0A=
        if (this.host.end) {=0A=
          this.host.end();=0A=
        }=0A=
        this._resolve(true);=0A=
      },=0A=
=0A=
      cancel: function() {=0A=
        if (this.host.cancel) {=0A=
          this.host.cancel();=0A=
        }=0A=
        this._resolve(false);=0A=
      },=0A=
=0A=
      complete: function(response) {=0A=
        var self =3D this;=0A=
        if (self._state =3D=3D=3D INITIAL_STATE) {=0A=
          self._state =3D DONE_PENDING_STATE;=0A=
          self._tick(function() {=0A=
            self._resolve(response);=0A=
          });=0A=
        }=0A=
      },=0A=
=0A=
      _resolve: function(response) {=0A=
        if (this._state !=3D=3D DONE_COMPLETE_STATE) {=0A=
          forEach(this._doneCallbacks, function(fn) {=0A=
            fn(response);=0A=
          });=0A=
          this._doneCallbacks.length =3D 0;=0A=
          this._state =3D DONE_COMPLETE_STATE;=0A=
        }=0A=
      }=0A=
    };=0A=
=0A=
    return AnimateRunner;=0A=
  }];=0A=
};=0A=
=0A=
/* exported $CoreAnimateCssProvider */=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $animateCss=0A=
 * @kind object=0A=
 * @this=0A=
 *=0A=
 * @description=0A=
 * This is the core version of `$animateCss`. By default, only when the =
`ngAnimate` is included,=0A=
 * then the `$animateCss` service will actually perform animations.=0A=
 *=0A=
 * Click here {@link ngAnimate.$animateCss to read the documentation for =
$animateCss}.=0A=
 */=0A=
var $CoreAnimateCssProvider =3D function() {=0A=
  this.$get =3D ['$$rAF', '$q', '$$AnimateRunner', function($$rAF, $q, =
$$AnimateRunner) {=0A=
=0A=
    return function(element, initialOptions) {=0A=
      // all of the animation functions should create=0A=
      // a copy of the options data, however, if a=0A=
      // parent service has already created a copy then=0A=
      // we should stick to using that=0A=
      var options =3D initialOptions || {};=0A=
      if (!options.$$prepared) {=0A=
        options =3D copy(options);=0A=
      }=0A=
=0A=
      // there is no point in applying the styles since=0A=
      // there is no animation that goes on at all in=0A=
      // this version of $animateCss.=0A=
      if (options.cleanupStyles) {=0A=
        options.from =3D options.to =3D null;=0A=
      }=0A=
=0A=
      if (options.from) {=0A=
        element.css(options.from);=0A=
        options.from =3D null;=0A=
      }=0A=
=0A=
      var closed, runner =3D new $$AnimateRunner();=0A=
      return {=0A=
        start: run,=0A=
        end: run=0A=
      };=0A=
=0A=
      function run() {=0A=
        $$rAF(function() {=0A=
          applyAnimationContents();=0A=
          if (!closed) {=0A=
            runner.complete();=0A=
          }=0A=
          closed =3D true;=0A=
        });=0A=
        return runner;=0A=
      }=0A=
=0A=
      function applyAnimationContents() {=0A=
        if (options.addClass) {=0A=
          element.addClass(options.addClass);=0A=
          options.addClass =3D null;=0A=
        }=0A=
        if (options.removeClass) {=0A=
          element.removeClass(options.removeClass);=0A=
          options.removeClass =3D null;=0A=
        }=0A=
        if (options.to) {=0A=
          element.css(options.to);=0A=
          options.to =3D null;=0A=
        }=0A=
      }=0A=
    };=0A=
  }];=0A=
};=0A=
=0A=
/* global stripHash: true */=0A=
=0A=
/**=0A=
 * ! This is a private undocumented service !=0A=
 *=0A=
 * @name $browser=0A=
 * @requires $log=0A=
 * @description=0A=
 * This object has two goals:=0A=
 *=0A=
 * - hide all the global state in the browser caused by the window object=0A=
 * - abstract away all the browser specific features and inconsistencies=0A=
 *=0A=
 * For tests we provide {@link ngMock.$browser mock implementation} of =
the `$browser`=0A=
 * service, which can be used for convenient testing of the application =
without the interaction with=0A=
 * the real browser apis.=0A=
 */=0A=
/**=0A=
 * @param {object} window The global window object.=0A=
 * @param {object} document jQuery wrapped document.=0A=
 * @param {object} $log window.console or an object with the same =
interface.=0A=
 * @param {object} $sniffer $sniffer service=0A=
 */=0A=
function Browser(window, document, $log, $sniffer) {=0A=
  var self =3D this,=0A=
      location =3D window.location,=0A=
      history =3D window.history,=0A=
      setTimeout =3D window.setTimeout,=0A=
      clearTimeout =3D window.clearTimeout,=0A=
      pendingDeferIds =3D {};=0A=
=0A=
  self.isMock =3D false;=0A=
=0A=
  var outstandingRequestCount =3D 0;=0A=
  var outstandingRequestCallbacks =3D [];=0A=
=0A=
  // TODO(vojta): remove this temporary api=0A=
  self.$$completeOutstandingRequest =3D completeOutstandingRequest;=0A=
  self.$$incOutstandingRequestCount =3D function() { =
outstandingRequestCount++; };=0A=
=0A=
  /**=0A=
   * Executes the `fn` function(supports currying) and decrements the =
`outstandingRequestCallbacks`=0A=
   * counter. If the counter reaches 0, all the =
`outstandingRequestCallbacks` are executed.=0A=
   */=0A=
  function completeOutstandingRequest(fn) {=0A=
    try {=0A=
      fn.apply(null, sliceArgs(arguments, 1));=0A=
    } finally {=0A=
      outstandingRequestCount--;=0A=
      if (outstandingRequestCount =3D=3D=3D 0) {=0A=
        while (outstandingRequestCallbacks.length) {=0A=
          try {=0A=
            outstandingRequestCallbacks.pop()();=0A=
          } catch (e) {=0A=
            $log.error(e);=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
  }=0A=
=0A=
  function getHash(url) {=0A=
    var index =3D url.indexOf('#');=0A=
    return index =3D=3D=3D -1 ? '' : url.substr(index);=0A=
  }=0A=
=0A=
  /**=0A=
   * @private=0A=
   * Note: this method is used only by scenario runner=0A=
   * TODO(vojta): prefix this method with $$ ?=0A=
   * @param {function()} callback Function that will be called when no =
outstanding request=0A=
   */=0A=
  self.notifyWhenNoOutstandingRequests =3D function(callback) {=0A=
    if (outstandingRequestCount =3D=3D=3D 0) {=0A=
      callback();=0A=
    } else {=0A=
      outstandingRequestCallbacks.push(callback);=0A=
    }=0A=
  };=0A=
=0A=
  //////////////////////////////////////////////////////////////=0A=
  // URL API=0A=
  //////////////////////////////////////////////////////////////=0A=
=0A=
  var cachedState, lastHistoryState,=0A=
      lastBrowserUrl =3D location.href,=0A=
      baseElement =3D document.find('base'),=0A=
      pendingLocation =3D null,=0A=
      getCurrentState =3D !$sniffer.history ? noop : function =
getCurrentState() {=0A=
        try {=0A=
          return history.state;=0A=
        } catch (e) {=0A=
          // MSIE can reportedly throw when there is no state =
(UNCONFIRMED).=0A=
        }=0A=
      };=0A=
=0A=
  cacheState();=0A=
=0A=
  /**=0A=
   * @name $browser#url=0A=
   *=0A=
   * @description=0A=
   * GETTER:=0A=
   * Without any argument, this method just returns current value of =
location.href.=0A=
   *=0A=
   * SETTER:=0A=
   * With at least one argument, this method sets url to new value.=0A=
   * If html5 history api supported, pushState/replaceState is used, =
otherwise=0A=
   * location.href/location.replace is used.=0A=
   * Returns its own instance to allow chaining=0A=
   *=0A=
   * NOTE: this api is intended for use only by the $location service. =
Please use the=0A=
   * {@link ng.$location $location service} to change url.=0A=
   *=0A=
   * @param {string} url New url (when used as setter)=0A=
   * @param {boolean=3D} replace Should new url replace current history =
record?=0A=
   * @param {object=3D} state object to use with pushState/replaceState=0A=
   */=0A=
  self.url =3D function(url, replace, state) {=0A=
    // In modern browsers `history.state` is `null` by default; treating =
it separately=0A=
    // from `undefined` would cause `$browser.url('/foo')` to change =
`history.state`=0A=
    // to undefined via `pushState`. Instead, let's change `undefined` =
to `null` here.=0A=
    if (isUndefined(state)) {=0A=
      state =3D null;=0A=
    }=0A=
=0A=
    // Android Browser BFCache causes location, history reference to =
become stale.=0A=
    if (location !=3D=3D window.location) location =3D window.location;=0A=
    if (history !=3D=3D window.history) history =3D window.history;=0A=
=0A=
    // setter=0A=
    if (url) {=0A=
      var sameState =3D lastHistoryState =3D=3D=3D state;=0A=
=0A=
      // Don't change anything if previous and current URLs and states =
match. This also prevents=0A=
      // IE&lt;10 from getting into redirect loop when in =
LocationHashbangInHtml5Url mode.=0A=
      // See https://github.com/angular/angular.js/commit/ffb2701=0A=
      if (lastBrowserUrl =3D=3D=3D url &amp;&amp; (!$sniffer.history || =
sameState)) {=0A=
        return self;=0A=
      }=0A=
      var sameBase =3D lastBrowserUrl &amp;&amp; =
stripHash(lastBrowserUrl) =3D=3D=3D stripHash(url);=0A=
      lastBrowserUrl =3D url;=0A=
      lastHistoryState =3D state;=0A=
      // Don't use history API if only the hash changed=0A=
      // due to a bug in IE10/IE11 which leads=0A=
      // to not firing a `hashchange` nor `popstate` event=0A=
      // in some cases (see #9143).=0A=
      if ($sniffer.history &amp;&amp; (!sameBase || !sameState)) {=0A=
        history[replace ? 'replaceState' : 'pushState'](state, '', url);=0A=
        cacheState();=0A=
      } else {=0A=
        if (!sameBase) {=0A=
          pendingLocation =3D url;=0A=
        }=0A=
        if (replace) {=0A=
          location.replace(url);=0A=
        } else if (!sameBase) {=0A=
          location.href =3D url;=0A=
        } else {=0A=
          location.hash =3D getHash(url);=0A=
        }=0A=
        if (location.href !=3D=3D url) {=0A=
          pendingLocation =3D url;=0A=
        }=0A=
      }=0A=
      if (pendingLocation) {=0A=
        pendingLocation =3D url;=0A=
      }=0A=
      return self;=0A=
    // getter=0A=
    } else {=0A=
      // - pendingLocation is needed as browsers don't allow to read out=0A=
      //   the new location.href if a reload happened or if there is a =
bug like in iOS 9 (see=0A=
      //   https://openradar.appspot.com/22186109).=0A=
      // - the replacement is a workaround for =
https://bugzilla.mozilla.org/show_bug.cgi?id=3D407172=0A=
      return pendingLocation || location.href.replace(/%27/g,'\'');=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * @name $browser#state=0A=
   *=0A=
   * @description=0A=
   * This method is a getter.=0A=
   *=0A=
   * Return history.state or null if history.state is undefined.=0A=
   *=0A=
   * @returns {object} state=0A=
   */=0A=
  self.state =3D function() {=0A=
    return cachedState;=0A=
  };=0A=
=0A=
  var urlChangeListeners =3D [],=0A=
      urlChangeInit =3D false;=0A=
=0A=
  function cacheStateAndFireUrlChange() {=0A=
    pendingLocation =3D null;=0A=
    fireStateOrUrlChange();=0A=
  }=0A=
=0A=
  // This variable should be used *only* inside the cacheState function.=0A=
  var lastCachedState =3D null;=0A=
  function cacheState() {=0A=
    // This should be the only place in $browser where `history.state` =
is read.=0A=
    cachedState =3D getCurrentState();=0A=
    cachedState =3D isUndefined(cachedState) ? null : cachedState;=0A=
=0A=
    // Prevent callbacks fo fire twice if both hashchange &amp; popstate =
were fired.=0A=
    if (equals(cachedState, lastCachedState)) {=0A=
      cachedState =3D lastCachedState;=0A=
    }=0A=
=0A=
    lastCachedState =3D cachedState;=0A=
    lastHistoryState =3D cachedState;=0A=
  }=0A=
=0A=
  function fireStateOrUrlChange() {=0A=
    var prevLastHistoryState =3D lastHistoryState;=0A=
    cacheState();=0A=
=0A=
    if (lastBrowserUrl =3D=3D=3D self.url() &amp;&amp; =
prevLastHistoryState =3D=3D=3D cachedState) {=0A=
      return;=0A=
    }=0A=
=0A=
    lastBrowserUrl =3D self.url();=0A=
    lastHistoryState =3D cachedState;=0A=
    forEach(urlChangeListeners, function(listener) {=0A=
      listener(self.url(), cachedState);=0A=
    });=0A=
  }=0A=
=0A=
  /**=0A=
   * @name $browser#onUrlChange=0A=
   *=0A=
   * @description=0A=
   * Register callback function that will be called, when url changes.=0A=
   *=0A=
   * It's only called when the url is changed from outside of angular:=0A=
   * - user types different url into address bar=0A=
   * - user clicks on history (forward/back) button=0A=
   * - user clicks on a link=0A=
   *=0A=
   * It's not called when url is changed by $browser.url() method=0A=
   *=0A=
   * The listener gets called with new url as parameter.=0A=
   *=0A=
   * NOTE: this api is intended for use only by the $location service. =
Please use the=0A=
   * {@link ng.$location $location service} to monitor url changes in =
angular apps.=0A=
   *=0A=
   * @param {function(string)} listener Listener function to be called =
when url changes.=0A=
   * @return {function(string)} Returns the registered listener fn - =
handy if the fn is anonymous.=0A=
   */=0A=
  self.onUrlChange =3D function(callback) {=0A=
    // TODO(vojta): refactor to use node's syntax for events=0A=
    if (!urlChangeInit) {=0A=
      // We listen on both (hashchange/popstate) when available, as some =
browsers don't=0A=
      // fire popstate when user changes the address bar and don't fire =
hashchange when url=0A=
      // changed by push/replaceState=0A=
=0A=
      // html5 history api - popstate event=0A=
      if ($sniffer.history) jqLite(window).on('popstate', =
cacheStateAndFireUrlChange);=0A=
      // hashchange event=0A=
      jqLite(window).on('hashchange', cacheStateAndFireUrlChange);=0A=
=0A=
      urlChangeInit =3D true;=0A=
    }=0A=
=0A=
    urlChangeListeners.push(callback);=0A=
    return callback;=0A=
  };=0A=
=0A=
  /**=0A=
   * @private=0A=
   * Remove popstate and hashchange handler from window.=0A=
   *=0A=
   * NOTE: this api is intended for use only by $rootScope.=0A=
   */=0A=
  self.$$applicationDestroyed =3D function() {=0A=
    jqLite(window).off('hashchange popstate', =
cacheStateAndFireUrlChange);=0A=
  };=0A=
=0A=
  /**=0A=
   * Checks whether the url has changed outside of Angular.=0A=
   * Needs to be exported to be able to check for changes that have been =
done in sync,=0A=
   * as hashchange/popstate events fire in async.=0A=
   */=0A=
  self.$$checkUrlChange =3D fireStateOrUrlChange;=0A=
=0A=
  //////////////////////////////////////////////////////////////=0A=
  // Misc API=0A=
  //////////////////////////////////////////////////////////////=0A=
=0A=
  /**=0A=
   * @name $browser#baseHref=0A=
   *=0A=
   * @description=0A=
   * Returns current &lt;base href&gt;=0A=
   * (always relative - without domain)=0A=
   *=0A=
   * @returns {string} The current base href=0A=
   */=0A=
  self.baseHref =3D function() {=0A=
    var href =3D baseElement.attr('href');=0A=
    return href ? href.replace(/^(https?:)?\/\/[^/]*/, '') : '';=0A=
  };=0A=
=0A=
  /**=0A=
   * @name $browser#defer=0A=
   * @param {function()} fn A function, who's execution should be =
deferred.=0A=
   * @param {number=3D} [delay=3D0] of milliseconds to defer the =
function execution.=0A=
   * @returns {*} DeferId that can be used to cancel the task via =
`$browser.defer.cancel()`.=0A=
   *=0A=
   * @description=0A=
   * Executes a fn asynchronously via `setTimeout(fn, delay)`.=0A=
   *=0A=
   * Unlike when calling `setTimeout` directly, in test this function is =
mocked and instead of using=0A=
   * `setTimeout` in tests, the fns are queued in an array, which can be =
programmatically flushed=0A=
   * via `$browser.defer.flush()`.=0A=
   *=0A=
   */=0A=
  self.defer =3D function(fn, delay) {=0A=
    var timeoutId;=0A=
    outstandingRequestCount++;=0A=
    timeoutId =3D setTimeout(function() {=0A=
      delete pendingDeferIds[timeoutId];=0A=
      completeOutstandingRequest(fn);=0A=
    }, delay || 0);=0A=
    pendingDeferIds[timeoutId] =3D true;=0A=
    return timeoutId;=0A=
  };=0A=
=0A=
=0A=
  /**=0A=
   * @name $browser#defer.cancel=0A=
   *=0A=
   * @description=0A=
   * Cancels a deferred task identified with `deferId`.=0A=
   *=0A=
   * @param {*} deferId Token returned by the `$browser.defer` function.=0A=
   * @returns {boolean} Returns `true` if the task hasn't executed yet =
and was successfully=0A=
   *                    canceled.=0A=
   */=0A=
  self.defer.cancel =3D function(deferId) {=0A=
    if (pendingDeferIds[deferId]) {=0A=
      delete pendingDeferIds[deferId];=0A=
      clearTimeout(deferId);=0A=
      completeOutstandingRequest(noop);=0A=
      return true;=0A=
    }=0A=
    return false;=0A=
  };=0A=
=0A=
}=0A=
=0A=
/** @this */=0A=
function $BrowserProvider() {=0A=
  this.$get =3D ['$window', '$log', '$sniffer', '$document',=0A=
      function($window, $log, $sniffer, $document) {=0A=
        return new Browser($window, $document, $log, $sniffer);=0A=
      }];=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $cacheFactory=0A=
 * @this=0A=
 *=0A=
 * @description=0A=
 * Factory that constructs {@link $cacheFactory.Cache Cache} objects and =
gives access to=0A=
 * them.=0A=
 *=0A=
 * ```js=0A=
 *=0A=
 *  var cache =3D $cacheFactory('cacheId');=0A=
 *  expect($cacheFactory.get('cacheId')).toBe(cache);=0A=
 *  expect($cacheFactory.get('noSuchCacheId')).not.toBeDefined();=0A=
 *=0A=
 *  cache.put("key", "value");=0A=
 *  cache.put("another key", "another value");=0A=
 *=0A=
 *  // We've specified no options on creation=0A=
 *  expect(cache.info()).toEqual({id: 'cacheId', size: 2});=0A=
 *=0A=
 * ```=0A=
 *=0A=
 *=0A=
 * @param {string} cacheId Name or id of the newly created cache.=0A=
 * @param {object=3D} options Options object that specifies the cache =
behavior. Properties:=0A=
 *=0A=
 *   - `{number=3D}` `capacity` =E2=80&#65533; turns the cache into LRU =
cache.=0A=
 *=0A=
 * @returns {object} Newly created cache object with the following set =
of methods:=0A=
 *=0A=
 * - `{object}` `info()` =E2=80&#65533; Returns id, size, and options of =
cache.=0A=
 * - `{{*}}` `put({string} key, {*} value)` =E2=80&#65533; Puts a new =
key-value pair into the cache and returns=0A=
 *   it.=0A=
 * - `{{*}}` `get({string} key)` =E2=80&#65533; Returns cached value for =
`key` or undefined for cache miss.=0A=
 * - `{void}` `remove({string} key)` =E2=80&#65533; Removes a key-value =
pair from the cache.=0A=
 * - `{void}` `removeAll()` =E2=80&#65533; Removes all cached values.=0A=
 * - `{void}` `destroy()` =E2=80&#65533; Removes references to this =
cache from $cacheFactory.=0A=
 *=0A=
 * @example=0A=
   &lt;example module=3D"cacheExampleApp" name=3D"cache-factory"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
       &lt;div ng-controller=3D"CacheController"&gt;=0A=
         &lt;input ng-model=3D"newCacheKey" placeholder=3D"Key"&gt;=0A=
         &lt;input ng-model=3D"newCacheValue" placeholder=3D"Value"&gt;=0A=
         &lt;button ng-click=3D"put(newCacheKey, =
newCacheValue)"&gt;Cache&lt;/button&gt;=0A=
=0A=
         &lt;p ng-if=3D"keys.length"&gt;Cached Values&lt;/p&gt;=0A=
         &lt;div ng-repeat=3D"key in keys"&gt;=0A=
           &lt;span ng-bind=3D"key"&gt;&lt;/span&gt;=0A=
           &lt;span&gt;: &lt;/span&gt;=0A=
           &lt;b ng-bind=3D"cache.get(key)"&gt;&lt;/b&gt;=0A=
         &lt;/div&gt;=0A=
=0A=
         &lt;p&gt;Cache Info&lt;/p&gt;=0A=
         &lt;div ng-repeat=3D"(key, value) in cache.info()"&gt;=0A=
           &lt;span ng-bind=3D"key"&gt;&lt;/span&gt;=0A=
           &lt;span&gt;: &lt;/span&gt;=0A=
           &lt;b ng-bind=3D"value"&gt;&lt;/b&gt;=0A=
         &lt;/div&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"script.js"&gt;=0A=
       angular.module('cacheExampleApp', []).=0A=
         controller('CacheController', ['$scope', '$cacheFactory', =
function($scope, $cacheFactory) {=0A=
           $scope.keys =3D [];=0A=
           $scope.cache =3D $cacheFactory('cacheId');=0A=
           $scope.put =3D function(key, value) {=0A=
             if (angular.isUndefined($scope.cache.get(key))) {=0A=
               $scope.keys.push(key);=0A=
             }=0A=
             $scope.cache.put(key, angular.isUndefined(value) ? null : =
value);=0A=
           };=0A=
         }]);=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"style.css"&gt;=0A=
       p {=0A=
         margin: 10px 0 3px;=0A=
       }=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
function $CacheFactoryProvider() {=0A=
=0A=
  this.$get =3D function() {=0A=
    var caches =3D {};=0A=
=0A=
    function cacheFactory(cacheId, options) {=0A=
      if (cacheId in caches) {=0A=
        throw minErr('$cacheFactory')('iid', 'CacheId \'{0}\' is already =
taken!', cacheId);=0A=
      }=0A=
=0A=
      var size =3D 0,=0A=
          stats =3D extend({}, options, {id: cacheId}),=0A=
          data =3D createMap(),=0A=
          capacity =3D (options &amp;&amp; options.capacity) || =
Number.MAX_VALUE,=0A=
          lruHash =3D createMap(),=0A=
          freshEnd =3D null,=0A=
          staleEnd =3D null;=0A=
=0A=
      /**=0A=
       * @ngdoc type=0A=
       * @name $cacheFactory.Cache=0A=
       *=0A=
       * @description=0A=
       * A cache object used to store and retrieve data, primarily used =
by=0A=
       * {@link $http $http} and the {@link ng.directive:script script} =
directive to cache=0A=
       * templates and other data.=0A=
       *=0A=
       * ```js=0A=
       *  angular.module('superCache')=0A=
       *    .factory('superCache', ['$cacheFactory', =
function($cacheFactory) {=0A=
       *      return $cacheFactory('super-cache');=0A=
       *    }]);=0A=
       * ```=0A=
       *=0A=
       * Example test:=0A=
       *=0A=
       * ```js=0A=
       *  it('should behave like a cache', inject(function(superCache) {=0A=
       *    superCache.put('key', 'value');=0A=
       *    superCache.put('another key', 'another value');=0A=
       *=0A=
       *    expect(superCache.info()).toEqual({=0A=
       *      id: 'super-cache',=0A=
       *      size: 2=0A=
       *    });=0A=
       *=0A=
       *    superCache.remove('another key');=0A=
       *    expect(superCache.get('another key')).toBeUndefined();=0A=
       *=0A=
       *    superCache.removeAll();=0A=
       *    expect(superCache.info()).toEqual({=0A=
       *      id: 'super-cache',=0A=
       *      size: 0=0A=
       *    });=0A=
       *  }));=0A=
       * ```=0A=
       */=0A=
      return (caches[cacheId] =3D {=0A=
=0A=
        /**=0A=
         * @ngdoc method=0A=
         * @name $cacheFactory.Cache#put=0A=
         * @kind function=0A=
         *=0A=
         * @description=0A=
         * Inserts a named entry into the {@link $cacheFactory.Cache =
Cache} object to be=0A=
         * retrieved later, and incrementing the size of the cache if =
the key was not already=0A=
         * present in the cache. If behaving like an LRU cache, it will =
also remove stale=0A=
         * entries from the set.=0A=
         *=0A=
         * It will not insert undefined values into the cache.=0A=
         *=0A=
         * @param {string} key the key under which the cached data is =
stored.=0A=
         * @param {*} value the value to store alongside the key. If it =
is undefined, the key=0A=
         *    will not be stored.=0A=
         * @returns {*} the value stored.=0A=
         */=0A=
        put: function(key, value) {=0A=
          if (isUndefined(value)) return;=0A=
          if (capacity &lt; Number.MAX_VALUE) {=0A=
            var lruEntry =3D lruHash[key] || (lruHash[key] =3D {key: =
key});=0A=
=0A=
            refresh(lruEntry);=0A=
          }=0A=
=0A=
          if (!(key in data)) size++;=0A=
          data[key] =3D value;=0A=
=0A=
          if (size &gt; capacity) {=0A=
            this.remove(staleEnd.key);=0A=
          }=0A=
=0A=
          return value;=0A=
        },=0A=
=0A=
        /**=0A=
         * @ngdoc method=0A=
         * @name $cacheFactory.Cache#get=0A=
         * @kind function=0A=
         *=0A=
         * @description=0A=
         * Retrieves named data stored in the {@link $cacheFactory.Cache =
Cache} object.=0A=
         *=0A=
         * @param {string} key the key of the data to be retrieved=0A=
         * @returns {*} the value stored.=0A=
         */=0A=
        get: function(key) {=0A=
          if (capacity &lt; Number.MAX_VALUE) {=0A=
            var lruEntry =3D lruHash[key];=0A=
=0A=
            if (!lruEntry) return;=0A=
=0A=
            refresh(lruEntry);=0A=
          }=0A=
=0A=
          return data[key];=0A=
        },=0A=
=0A=
=0A=
        /**=0A=
         * @ngdoc method=0A=
         * @name $cacheFactory.Cache#remove=0A=
         * @kind function=0A=
         *=0A=
         * @description=0A=
         * Removes an entry from the {@link $cacheFactory.Cache Cache} =
object.=0A=
         *=0A=
         * @param {string} key the key of the entry to be removed=0A=
         */=0A=
        remove: function(key) {=0A=
          if (capacity &lt; Number.MAX_VALUE) {=0A=
            var lruEntry =3D lruHash[key];=0A=
=0A=
            if (!lruEntry) return;=0A=
=0A=
            if (lruEntry =3D=3D=3D freshEnd) freshEnd =3D lruEntry.p;=0A=
            if (lruEntry =3D=3D=3D staleEnd) staleEnd =3D lruEntry.n;=0A=
            link(lruEntry.n,lruEntry.p);=0A=
=0A=
            delete lruHash[key];=0A=
          }=0A=
=0A=
          if (!(key in data)) return;=0A=
=0A=
          delete data[key];=0A=
          size--;=0A=
        },=0A=
=0A=
=0A=
        /**=0A=
         * @ngdoc method=0A=
         * @name $cacheFactory.Cache#removeAll=0A=
         * @kind function=0A=
         *=0A=
         * @description=0A=
         * Clears the cache object of any entries.=0A=
         */=0A=
        removeAll: function() {=0A=
          data =3D createMap();=0A=
          size =3D 0;=0A=
          lruHash =3D createMap();=0A=
          freshEnd =3D staleEnd =3D null;=0A=
        },=0A=
=0A=
=0A=
        /**=0A=
         * @ngdoc method=0A=
         * @name $cacheFactory.Cache#destroy=0A=
         * @kind function=0A=
         *=0A=
         * @description=0A=
         * Destroys the {@link $cacheFactory.Cache Cache} object =
entirely,=0A=
         * removing it from the {@link $cacheFactory $cacheFactory} set.=0A=
         */=0A=
        destroy: function() {=0A=
          data =3D null;=0A=
          stats =3D null;=0A=
          lruHash =3D null;=0A=
          delete caches[cacheId];=0A=
        },=0A=
=0A=
=0A=
        /**=0A=
         * @ngdoc method=0A=
         * @name $cacheFactory.Cache#info=0A=
         * @kind function=0A=
         *=0A=
         * @description=0A=
         * Retrieve information regarding a particular {@link =
$cacheFactory.Cache Cache}.=0A=
         *=0A=
         * @returns {object} an object with the following properties:=0A=
         *   &lt;ul&gt;=0A=
         *     &lt;li&gt;**id**: the id of the cache instance&lt;/li&gt;=0A=
         *     &lt;li&gt;**size**: the number of entries kept in the =
cache instance&lt;/li&gt;=0A=
         *     &lt;li&gt;**...**: any additional properties from the =
options object when creating the=0A=
         *       cache.&lt;/li&gt;=0A=
         *   &lt;/ul&gt;=0A=
         */=0A=
        info: function() {=0A=
          return extend({}, stats, {size: size});=0A=
        }=0A=
      });=0A=
=0A=
=0A=
      /**=0A=
       * makes the `entry` the freshEnd of the LRU linked list=0A=
       */=0A=
      function refresh(entry) {=0A=
        if (entry !=3D=3D freshEnd) {=0A=
          if (!staleEnd) {=0A=
            staleEnd =3D entry;=0A=
          } else if (staleEnd =3D=3D=3D entry) {=0A=
            staleEnd =3D entry.n;=0A=
          }=0A=
=0A=
          link(entry.n, entry.p);=0A=
          link(entry, freshEnd);=0A=
          freshEnd =3D entry;=0A=
          freshEnd.n =3D null;=0A=
        }=0A=
      }=0A=
=0A=
=0A=
      /**=0A=
       * bidirectionally links two entries of the LRU linked list=0A=
       */=0A=
      function link(nextEntry, prevEntry) {=0A=
        if (nextEntry !=3D=3D prevEntry) {=0A=
          if (nextEntry) nextEntry.p =3D prevEntry; //p stands for =
previous, 'prev' didn't minify=0A=
          if (prevEntry) prevEntry.n =3D nextEntry; //n stands for next, =
'next' didn't minify=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $cacheFactory#info=0A=
   *=0A=
   * @description=0A=
   * Get information about all the caches that have been created=0A=
   *=0A=
   * @returns {Object} - key-value map of `cacheId` to the result of =
calling `cache#info`=0A=
   */=0A=
    cacheFactory.info =3D function() {=0A=
      var info =3D {};=0A=
      forEach(caches, function(cache, cacheId) {=0A=
        info[cacheId] =3D cache.info();=0A=
      });=0A=
      return info;=0A=
    };=0A=
=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $cacheFactory#get=0A=
   *=0A=
   * @description=0A=
   * Get access to a cache object by the `cacheId` used when it was =
created.=0A=
   *=0A=
   * @param {string} cacheId Name or id of a cache to access.=0A=
   * @returns {object} Cache object identified by the cacheId or =
undefined if no such cache.=0A=
   */=0A=
    cacheFactory.get =3D function(cacheId) {=0A=
      return caches[cacheId];=0A=
    };=0A=
=0A=
=0A=
    return cacheFactory;=0A=
  };=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $templateCache=0A=
 * @this=0A=
 *=0A=
 * @description=0A=
 * The first time a template is used, it is loaded in the template cache =
for quick retrieval. You=0A=
 * can load templates directly into the cache in a `script` tag, or by =
consuming the=0A=
 * `$templateCache` service directly.=0A=
 *=0A=
 * Adding via the `script` tag:=0A=
 *=0A=
 * ```html=0A=
 *   &lt;script type=3D"text/ng-template" id=3D"templateId.html"&gt;=0A=
 *     &lt;p&gt;This is the content of the template&lt;/p&gt;=0A=
 *   &lt;/script&gt;=0A=
 * ```=0A=
 *=0A=
 * **Note:** the `script` tag containing the template does not need to =
be included in the `head` of=0A=
 * the document, but it must be a descendent of the {@link =
ng.$rootElement $rootElement} (IE,=0A=
 * element with ng-app attribute), otherwise the template will be =
ignored.=0A=
 *=0A=
 * Adding via the `$templateCache` service:=0A=
 *=0A=
 * ```js=0A=
 * var myApp =3D angular.module('myApp', []);=0A=
 * myApp.run(function($templateCache) {=0A=
 *   $templateCache.put('templateId.html', 'This is the content of the =
template');=0A=
 * });=0A=
 * ```=0A=
 *=0A=
 * To retrieve the template later, simply use it in your component:=0A=
 * ```js=0A=
 * myApp.component('myComponent', {=0A=
 *    templateUrl: 'templateId.html'=0A=
 * });=0A=
 * ```=0A=
 *=0A=
 * or get it via the `$templateCache` service:=0A=
 * ```js=0A=
 * $templateCache.get('templateId.html')=0A=
 * ```=0A=
 *=0A=
 * See {@link ng.$cacheFactory $cacheFactory}.=0A=
 *=0A=
 */=0A=
function $TemplateCacheProvider() {=0A=
  this.$get =3D ['$cacheFactory', function($cacheFactory) {=0A=
    return $cacheFactory('templates');=0A=
  }];=0A=
}=0A=
=0A=
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * =
* *=0A=
 *     Any commits to this file should be reviewed with security in =
mind.  *=0A=
 *   Changes to this file can potentially create security =
vulnerabilities. *=0A=
 *          An approval from 2 Core members with history of modifying    =
  *=0A=
 *                         this file is required.                        =
  *=0A=
 *                                                                       =
  *=0A=
 *  Does the change somehow allow for arbitrary javascript to be =
executed? *=0A=
 *    Or allows for someone to change the prototype of built-in objects? =
  *=0A=
 *     Or gives undesired access to variables like document or window?   =
 *=0A=
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * =
* */=0A=
=0A=
/* ! VARIABLE/FUNCTION NAMING CONVENTIONS THAT APPLY TO THIS FILE!=0A=
 *=0A=
 * DOM-related variables:=0A=
 *=0A=
 * - "node" - DOM Node=0A=
 * - "element" - DOM Element or Node=0A=
 * - "$node" or "$element" - jqLite-wrapped node or element=0A=
 *=0A=
 *=0A=
 * Compiler related stuff:=0A=
 *=0A=
 * - "linkFn" - linking fn of a single directive=0A=
 * - "nodeLinkFn" - function that aggregates all linking fns for a =
particular node=0A=
 * - "childLinkFn" -  function that aggregates all linking fns for child =
nodes of a particular node=0A=
 * - "compositeLinkFn" - function that aggregates all linking fns for a =
compilation root (nodeList)=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $compile=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Compiles an HTML string or DOM into a template and produces a =
template function, which=0A=
 * can then be used to link {@link ng.$rootScope.Scope `scope`} and the =
template together.=0A=
 *=0A=
 * The compilation is a process of walking the DOM tree and matching DOM =
elements to=0A=
 * {@link ng.$compileProvider#directive directives}.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * **Note:** This document is an in-depth reference of all directive =
options.=0A=
 * For a gentle introduction to directives with examples of common use =
cases,=0A=
 * see the {@link guide/directive directive guide}.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * ## Comprehensive Directive API=0A=
 *=0A=
 * There are many different options for a directive.=0A=
 *=0A=
 * The difference resides in the return value of the factory function.=0A=
 * You can either return a {@link $compile#directive-definition-object =
Directive Definition Object (see below)}=0A=
 * that defines the directive properties, or just the `postLink` =
function (all other properties will have=0A=
 * the default values).=0A=
 *=0A=
 * &lt;div class=3D"alert alert-success"&gt;=0A=
 * **Best Practice:** It's recommended to use the "directive definition =
object" form.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * Here's an example directive declared with a Directive Definition =
Object:=0A=
 *=0A=
 * ```js=0A=
 *   var myModule =3D angular.module(...);=0A=
 *=0A=
 *   myModule.directive('directiveName', function factory(injectables) {=0A=
 *     var directiveDefinitionObject =3D {=0A=
 *       {@link $compile#-priority- priority}: 0,=0A=
 *       {@link $compile#-template- template}: =
'&lt;div&gt;&lt;/div&gt;', // or // function(tElement, tAttrs) { ... },=0A=
 *       // or=0A=
 *       // {@link $compile#-templateurl- templateUrl}: =
'directive.html', // or // function(tElement, tAttrs) { ... },=0A=
 *       {@link $compile#-transclude- transclude}: false,=0A=
 *       {@link $compile#-restrict- restrict}: 'A',=0A=
 *       {@link $compile#-templatenamespace- templateNamespace}: 'html',=0A=
 *       {@link $compile#-scope- scope}: false,=0A=
 *       {@link $compile#-controller- controller}: function($scope, =
$element, $attrs, $transclude, otherInjectables) { ... },=0A=
 *       {@link $compile#-controlleras- controllerAs}: =
'stringIdentifier',=0A=
 *       {@link $compile#-bindtocontroller- bindToController}: false,=0A=
 *       {@link $compile#-require- require}: 'siblingDirectiveName', // =
or // ['^parentDirectiveName', '?optionalDirectiveName', =
'?^optionalParent'],=0A=
 *       {@link $compile#-multielement- multiElement}: false,=0A=
 *       {@link $compile#-compile- compile}: function compile(tElement, =
tAttrs, transclude) {=0A=
 *         return {=0A=
 *            {@link $compile#pre-linking-function pre}: function =
preLink(scope, iElement, iAttrs, controller) { ... },=0A=
 *            {@link $compile#post-linking-function post}: function =
postLink(scope, iElement, iAttrs, controller) { ... }=0A=
 *         }=0A=
 *         // or=0A=
 *         // return function postLink( ... ) { ... }=0A=
 *       },=0A=
 *       // or=0A=
 *       // {@link $compile#-link- link}: {=0A=
 *       //  {@link $compile#pre-linking-function pre}: function =
preLink(scope, iElement, iAttrs, controller) { ... },=0A=
 *       //  {@link $compile#post-linking-function post}: function =
postLink(scope, iElement, iAttrs, controller) { ... }=0A=
 *       // }=0A=
 *       // or=0A=
 *       // {@link $compile#-link- link}: function postLink( ... ) { ... =
}=0A=
 *     };=0A=
 *     return directiveDefinitionObject;=0A=
 *   });=0A=
 * ```=0A=
 *=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * **Note:** Any unspecified options will use the default value. You can =
see the default values below.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * Therefore the above can be simplified as:=0A=
 *=0A=
 * ```js=0A=
 *   var myModule =3D angular.module(...);=0A=
 *=0A=
 *   myModule.directive('directiveName', function factory(injectables) {=0A=
 *     var directiveDefinitionObject =3D {=0A=
 *       link: function postLink(scope, iElement, iAttrs) { ... }=0A=
 *     };=0A=
 *     return directiveDefinitionObject;=0A=
 *     // or=0A=
 *     // return function postLink(scope, iElement, iAttrs) { ... }=0A=
 *   });=0A=
 * ```=0A=
 *=0A=
 * ### Life-cycle hooks=0A=
 * Directive controllers can provide the following methods that are =
called by Angular at points in the life-cycle of the=0A=
 * directive:=0A=
 * * `$onInit()` - Called on each controller after all the controllers =
on an element have been constructed and=0A=
 *   had their bindings initialized (and before the pre &amp;amp; post =
linking functions for the directives on=0A=
 *   this element). This is a good place to put initialization code for =
your controller.=0A=
 * * `$onChanges(changesObj)` - Called whenever one-way (`&lt;`) or =
interpolation (`@`) bindings are updated. The=0A=
 *   `changesObj` is a hash whose keys are the names of the bound =
properties that have changed, and the values are an=0A=
 *   object of the form `{ currentValue, previousValue, isFirstChange() =
}`. Use this hook to trigger updates within a=0A=
 *   component such as cloning the bound value to prevent accidental =
mutation of the outer value. Note that this will=0A=
 *   also be called when your bindings are initialized.=0A=
 * * `$doCheck()` - Called on each turn of the digest cycle. Provides an =
opportunity to detect and act on=0A=
 *   changes. Any actions that you wish to take in response to the =
changes that you detect must be=0A=
 *   invoked from this hook; implementing this has no effect on when =
`$onChanges` is called. For example, this hook=0A=
 *   could be useful if you wish to perform a deep equality check, or to =
check a Date object, changes to which would not=0A=
 *   be detected by Angular's change detector and thus not trigger =
`$onChanges`. This hook is invoked with no arguments;=0A=
 *   if detecting changes, you must store the previous value(s) for =
comparison to the current values.=0A=
 * * `$onDestroy()` - Called on a controller when its containing scope =
is destroyed. Use this hook for releasing=0A=
 *   external resources, watches and event handlers. Note that =
components have their `$onDestroy()` hooks called in=0A=
 *   the same order as the `$scope.$broadcast` events are triggered, =
which is top down. This means that parent=0A=
 *   components will have their `$onDestroy()` hook called before child =
components.=0A=
 * * `$postLink()` - Called after this controller's element and its =
children have been linked. Similar to the post-link=0A=
 *   function this hook can be used to set up DOM event handlers and do =
direct DOM manipulation.=0A=
 *   Note that child elements that contain `templateUrl` directives will =
not have been compiled and linked since=0A=
 *   they are waiting for their template to load asynchronously and =
their own compilation and linking has been=0A=
 *   suspended until that occurs.=0A=
 *=0A=
 * #### Comparison with Angular 2 life-cycle hooks=0A=
 * Angular 2 also uses life-cycle hooks for its components. While the =
Angular 1 life-cycle hooks are similar there are=0A=
 * some differences that you should be aware of, especially when it =
comes to moving your code from Angular 1 to Angular 2:=0A=
 *=0A=
 * * Angular 1 hooks are prefixed with `$`, such as `$onInit`. Angular 2 =
hooks are prefixed with `ng`, such as `ngOnInit`.=0A=
 * * Angular 1 hooks can be defined on the controller prototype or added =
to the controller inside its constructor.=0A=
 *   In Angular 2 you can only define hooks on the prototype of the =
Component class.=0A=
 * * Due to the differences in change-detection, you may get many more =
calls to `$doCheck` in Angular 1 than you would to=0A=
 *   `ngDoCheck` in Angular 2=0A=
 * * Changes to the model inside `$doCheck` will trigger new turns of =
the digest loop, which will cause the changes to be=0A=
 *   propagated throughout the application.=0A=
 *   Angular 2 does not allow the `ngDoCheck` hook to trigger a change =
outside of the component. It will either throw an=0A=
 *   error or do nothing depending upon the state of `enableProdMode()`.=0A=
 *=0A=
 * #### Life-cycle hook examples=0A=
 *=0A=
 * This example shows how you can check for mutations to a Date object =
even though the identity of the object=0A=
 * has not changed.=0A=
 *=0A=
 * &lt;example name=3D"doCheckDateExample" module=3D"do-check-module"&gt;=0A=
 *   &lt;file name=3D"app.js"&gt;=0A=
 *     angular.module('do-check-module', [])=0A=
 *       .component('app', {=0A=
 *         template:=0A=
 *           'Month: &lt;input ng-model=3D"$ctrl.month" =
ng-change=3D"$ctrl.updateDate()"&gt;' +=0A=
 *           'Date: {{ $ctrl.date }}' +=0A=
 *           '&lt;test date=3D"$ctrl.date"&gt;&lt;/test&gt;',=0A=
 *         controller: function() {=0A=
 *           this.date =3D new Date();=0A=
 *           this.month =3D this.date.getMonth();=0A=
 *           this.updateDate =3D function() {=0A=
 *             this.date.setMonth(this.month);=0A=
 *           };=0A=
 *         }=0A=
 *       })=0A=
 *       .component('test', {=0A=
 *         bindings: { date: '&lt;' },=0A=
 *         template:=0A=
 *           '&lt;pre&gt;{{ $ctrl.log | json }}&lt;/pre&gt;',=0A=
 *         controller: function() {=0A=
 *           var previousValue;=0A=
 *           this.log =3D [];=0A=
 *           this.$doCheck =3D function() {=0A=
 *             var currentValue =3D this.date &amp;&amp; =
this.date.valueOf();=0A=
 *             if (previousValue !=3D=3D currentValue) {=0A=
 *               this.log.push('doCheck: date mutated: ' + this.date);=0A=
 *               previousValue =3D currentValue;=0A=
 *             }=0A=
 *           };=0A=
 *         }=0A=
 *       });=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"index.html"&gt;=0A=
 *     &lt;app&gt;&lt;/app&gt;=0A=
 *   &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 *=0A=
 * This example show how you might use `$doCheck` to trigger changes in =
your component's inputs even if the=0A=
 * actual identity of the component doesn't change. (Be aware that =
cloning and deep equality checks on large=0A=
 * arrays or objects can have a negative impact on your application =
performance)=0A=
 *=0A=
 * &lt;example name=3D"doCheckArrayExample" =
module=3D"do-check-module"&gt;=0A=
 *   &lt;file name=3D"index.html"&gt;=0A=
 *     &lt;div ng-init=3D"items =3D []"&gt;=0A=
 *       &lt;button ng-click=3D"items.push(items.length)"&gt;Add =
Item&lt;/button&gt;=0A=
 *       &lt;button ng-click=3D"items =3D []"&gt;Reset =
Items&lt;/button&gt;=0A=
 *       &lt;pre&gt;{{ items }}&lt;/pre&gt;=0A=
 *       &lt;test items=3D"items"&gt;&lt;/test&gt;=0A=
 *     &lt;/div&gt;=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"app.js"&gt;=0A=
 *      angular.module('do-check-module', [])=0A=
 *        .component('test', {=0A=
 *          bindings: { items: '&lt;' },=0A=
 *          template:=0A=
 *            '&lt;pre&gt;{{ $ctrl.log | json }}&lt;/pre&gt;',=0A=
 *          controller: function() {=0A=
 *            this.log =3D [];=0A=
 *=0A=
 *            this.$doCheck =3D function() {=0A=
 *              if (this.items_ref !=3D=3D this.items) {=0A=
 *                this.log.push('doCheck: items changed');=0A=
 *                this.items_ref =3D this.items;=0A=
 *              }=0A=
 *              if (!angular.equals(this.items_clone, this.items)) {=0A=
 *                this.log.push('doCheck: items mutated');=0A=
 *                this.items_clone =3D angular.copy(this.items);=0A=
 *              }=0A=
 *            };=0A=
 *          }=0A=
 *        });=0A=
 *   &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 *=0A=
 *=0A=
 * ### Directive Definition Object=0A=
 *=0A=
 * The directive definition object provides instructions to the {@link =
ng.$compile=0A=
 * compiler}. The attributes are:=0A=
 *=0A=
 * #### `multiElement`=0A=
 * When this property is set to true (default is `false`), the HTML =
compiler will collect DOM nodes between=0A=
 * nodes with the attributes `directive-name-start` and =
`directive-name-end`, and group them=0A=
 * together as the directive elements. It is recommended that this =
feature be used on directives=0A=
 * which are not strictly behavioral (such as {@link ngClick}), and which=0A=
 * do not manipulate or replace child nodes (such as {@link ngInclude}).=0A=
 *=0A=
 * #### `priority`=0A=
 * When there are multiple directives defined on a single DOM element, =
sometimes it=0A=
 * is necessary to specify the order in which the directives are =
applied. The `priority` is used=0A=
 * to sort the directives before their `compile` functions get called. =
Priority is defined as a=0A=
 * number. Directives with greater numerical `priority` are compiled =
first. Pre-link functions=0A=
 * are also run in priority order, but post-link functions are run in =
reverse order. The order=0A=
 * of directives with the same priority is undefined. The default =
priority is `0`.=0A=
 *=0A=
 * #### `terminal`=0A=
 * If set to true then the current `priority` will be the last set of =
directives=0A=
 * which will execute (any directives at the current priority will still =
execute=0A=
 * as the order of execution on same `priority` is undefined). Note that =
expressions=0A=
 * and other directives used in the directive's template will also be =
excluded from execution.=0A=
 *=0A=
 * #### `scope`=0A=
 * The scope property can be `false`, `true`, or an object:=0A=
 *=0A=
 * * **`false` (default):** No scope will be created for the directive. =
The directive will use its=0A=
 * parent's scope.=0A=
 *=0A=
 * * **`true`:** A new child scope that prototypically inherits from its =
parent will be created for=0A=
 * the directive's element. If multiple directives on the same element =
request a new scope,=0A=
 * only one new scope is created.=0A=
 *=0A=
 * * **`{...}` (an object hash):** A new "isolate" scope is created for =
the directive's template.=0A=
 * The 'isolate' scope differs from normal scope in that it does not =
prototypically=0A=
 * inherit from its parent scope. This is useful when creating reusable =
components, which should not=0A=
 * accidentally read or modify data in the parent scope. Note that an =
isolate scope=0A=
 * directive without a `template` or `templateUrl` will not apply the =
isolate scope=0A=
 * to its children elements.=0A=
 *=0A=
 * The 'isolate' scope object hash defines a set of local scope =
properties derived from attributes on the=0A=
 * directive's element. These local properties are useful for aliasing =
values for templates. The keys in=0A=
 * the object hash map to the name of the property on the isolate scope; =
the values define how the property=0A=
 * is bound to the parent scope, via matching attributes on the =
directive's element:=0A=
 *=0A=
 * * `@` or `@attr` - bind a local scope property to the value of DOM =
attribute. The result is=0A=
 *   always a string since DOM attributes are strings. If no `attr` name =
is specified then the=0A=
 *   attribute name is assumed to be the same as the local name. Given =
`&lt;my-component=0A=
 *   my-attr=3D"hello {{name}}"&gt;` and the isolate scope definition =
`scope: { localName:'@myAttr' }`,=0A=
 *   the directive's scope property `localName` will reflect the =
interpolated value of `hello=0A=
 *   {{name}}`. As the `name` attribute changes so will the `localName` =
property on the directive's=0A=
 *   scope. The `name` is read from the parent scope (not the =
directive's scope).=0A=
 *=0A=
 * * `=3D` or `=3Dattr` - set up a bidirectional binding between a local =
scope property and an expression=0A=
 *   passed via the attribute `attr`. The expression is evaluated in the =
context of the parent scope.=0A=
 *   If no `attr` name is specified then the attribute name is assumed =
to be the same as the local=0A=
 *   name. Given `&lt;my-component my-attr=3D"parentModel"&gt;` and the =
isolate scope definition `scope: {=0A=
 *   localModel: '=3DmyAttr' }`, the property `localModel` on the =
directive's scope will reflect the=0A=
 *   value of `parentModel` on the parent scope. Changes to =
`parentModel` will be reflected in=0A=
 *   `localModel` and vice versa. Optional attributes should be marked =
as such with a question mark:=0A=
 *   `=3D?` or `=3D?attr`. If the binding expression is non-assignable, =
or if the attribute isn't=0A=
 *   optional and doesn't exist, an exception ({@link =
error/$compile/nonassign `$compile:nonassign`})=0A=
 *   will be thrown upon discovering changes to the local value, since =
it will be impossible to sync=0A=
 *   them back to the parent scope. By default, the {@link =
ng.$rootScope.Scope#$watch `$watch`}=0A=
 *   method is used for tracking changes, and the equality check is =
based on object identity.=0A=
 *   However, if an object literal or an array literal is passed as the =
binding expression, the=0A=
 *   equality check is done by value (using the {@link angular.equals} =
function). It's also possible=0A=
 *   to watch the evaluated value shallowly with {@link =
ng.$rootScope.Scope#$watchCollection=0A=
 *   `$watchCollection`}: use `=3D*` or `=3D*attr` (`=3D*?` or =
`=3D*?attr` if the attribute is optional).=0A=
 *=0A=
  * * `&lt;` or `&lt;attr` - set up a one-way (one-directional) binding =
between a local scope property and an=0A=
 *   expression passed via the attribute `attr`. The expression is =
evaluated in the context of the=0A=
 *   parent scope. If no `attr` name is specified then the attribute =
name is assumed to be the same as the=0A=
 *   local name. You can also make the binding optional by adding `?`: =
`&lt;?` or `&lt;?attr`.=0A=
 *=0A=
 *   For example, given `&lt;my-component my-attr=3D"parentModel"&gt;` =
and directive definition of=0A=
 *   `scope: { localModel:'&lt;myAttr' }`, then the isolated scope =
property `localModel` will reflect the=0A=
 *   value of `parentModel` on the parent scope. Any changes to =
`parentModel` will be reflected=0A=
 *   in `localModel`, but changes in `localModel` will not reflect in =
`parentModel`. There are however=0A=
 *   two caveats:=0A=
 *     1. one-way binding does not copy the value from the parent to the =
isolate scope, it simply=0A=
 *     sets the same value. That means if your bound value is an object, =
changes to its properties=0A=
 *     in the isolated scope will be reflected in the parent scope =
(because both reference the same object).=0A=
 *     2. one-way binding watches changes to the **identity** of the =
parent value. That means the=0A=
 *     {@link ng.$rootScope.Scope#$watch `$watch`} on the parent value =
only fires if the reference=0A=
 *     to the value has changed. In most cases, this should not be of =
concern, but can be important=0A=
 *     to know if you one-way bind to an object, and then replace that =
object in the isolated scope.=0A=
 *     If you now change a property of the object in your parent scope, =
the change will not be=0A=
 *     propagated to the isolated scope, because the identity of the =
object on the parent scope=0A=
 *     has not changed. Instead you must assign a new object.=0A=
 *=0A=
 *   One-way binding is useful if you do not plan to propagate changes =
to your isolated scope bindings=0A=
 *   back to the parent. However, it does not make this completely =
impossible.=0A=
 *=0A=
 * * `&amp;` or `&amp;attr` - provides a way to execute an expression in =
the context of the parent scope. If=0A=
 *   no `attr` name is specified then the attribute name is assumed to =
be the same as the local name.=0A=
 *   Given `&lt;my-component my-attr=3D"count =3D count + value"&gt;` =
and the isolate scope definition `scope: {=0A=
 *   localFn:'&amp;myAttr' }`, the isolate scope property `localFn` will =
point to a function wrapper for=0A=
 *   the `count =3D count + value` expression. Often it's desirable to =
pass data from the isolated scope=0A=
 *   via an expression to the parent scope. This can be done by passing =
a map of local variable names=0A=
 *   and values into the expression wrapper fn. For example, if the =
expression is `increment(amount)`=0A=
 *   then we can specify the amount value by calling the `localFn` as =
`localFn({amount: 22})`.=0A=
 *=0A=
 * In general it's possible to apply more than one directive to one =
element, but there might be limitations=0A=
 * depending on the type of scope required by the directives. The =
following points will help explain these limitations.=0A=
 * For simplicity only two directives are taken into account, but it is =
also applicable for several directives:=0A=
 *=0A=
 * * **no scope** + **no scope** =3D&gt; Two directives which don't =
require their own scope will use their parent's scope=0A=
 * * **child scope** + **no scope** =3D&gt;  Both directives will share =
one single child scope=0A=
 * * **child scope** + **child scope** =3D&gt;  Both directives will =
share one single child scope=0A=
 * * **isolated scope** + **no scope** =3D&gt;  The isolated directive =
will use it's own created isolated scope. The other directive will use=0A=
 * its parent's scope=0A=
 * * **isolated scope** + **child scope** =3D&gt;  **Won't work!** Only =
one scope can be related to one element. Therefore these directives =
cannot=0A=
 * be applied to the same element.=0A=
 * * **isolated scope** + **isolated scope**  =3D&gt;  **Won't work!** =
Only one scope can be related to one element. Therefore these directives=0A=
 * cannot be applied to the same element.=0A=
 *=0A=
 *=0A=
 * #### `bindToController`=0A=
 * This property is used to bind scope properties directly to the =
controller. It can be either=0A=
 * `true` or an object hash with the same format as the `scope` property.=0A=
 *=0A=
 * When an isolate scope is used for a directive (see above), =
`bindToController: true` will=0A=
 * allow a component to have its properties bound to the controller, =
rather than to scope.=0A=
 *=0A=
 * After the controller is instantiated, the initial values of the =
isolate scope bindings will be bound to the controller=0A=
 * properties. You can access these bindings once they have been =
initialized by providing a controller method called=0A=
 * `$onInit`, which is called after all the controllers on an element =
have been constructed and had their bindings=0A=
 * initialized.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * **Deprecation warning:** if =
`$compileProcvider.preAssignBindingsEnabled(true)` was called, bindings =
for non-ES6 class=0A=
 * controllers are bound to `this` before the controller constructor is =
called but this use is now deprecated. Please=0A=
 * place initialization code that relies upon bindings inside a =
`$onInit` method on the controller, instead.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * It is also possible to set `bindToController` to an object hash with =
the same format as the `scope` property.=0A=
 * This will set up the scope bindings to the controller directly. Note =
that `scope` can still be used=0A=
 * to define which kind of scope is created. By default, no scope is =
created. Use `scope: {}` to create an isolate=0A=
 * scope (useful for component directives).=0A=
 *=0A=
 * If both `bindToController` and `scope` are defined and have object =
hashes, `bindToController` overrides `scope`.=0A=
 *=0A=
 *=0A=
 * #### `controller`=0A=
 * Controller constructor function. The controller is instantiated =
before the=0A=
 * pre-linking phase and can be accessed by other directives (see=0A=
 * `require` attribute). This allows the directives to communicate with =
each other and augment=0A=
 * each other's behavior. The controller is injectable (and supports =
bracket notation) with the following locals:=0A=
 *=0A=
 * * `$scope` - Current scope associated with the element=0A=
 * * `$element` - Current element=0A=
 * * `$attrs` - Current attributes object for the element=0A=
 * * `$transclude` - A transclude linking function pre-bound to the =
correct transclusion scope:=0A=
 *   `function([scope], cloneLinkingFn, futureParentElement, slotName)`:=0A=
 *    * `scope`: (optional) override the scope.=0A=
 *    * `cloneLinkingFn`: (optional) argument to create clones of the =
original transcluded content.=0A=
 *    * `futureParentElement` (optional):=0A=
 *        * defines the parent to which the `cloneLinkingFn` will add =
the cloned elements.=0A=
 *        * default: `$element.parent()` resp. `$element` for =
`transclude:'element'` resp. `transclude:true`.=0A=
 *        * only needed for transcludes that are allowed to contain non =
html elements (e.g. SVG elements)=0A=
 *          and when the `cloneLinkingFn` is passed,=0A=
 *          as those elements need to created and cloned in a special =
way when they are defined outside their=0A=
 *          usual containers (e.g. like `&lt;svg&gt;`).=0A=
 *        * See also the `directive.templateNamespace` property.=0A=
 *    * `slotName`: (optional) the name of the slot to transclude. If =
falsy (e.g. `null`, `undefined` or `''`)=0A=
 *      then the default transclusion is provided.=0A=
 *    The `$transclude` function also has a method on it, =
`$transclude.isSlotFilled(slotName)`, which returns=0A=
 *    `true` if the specified slot contains content (i.e. one or more =
DOM nodes).=0A=
 *=0A=
 * #### `require`=0A=
 * Require another directive and inject its controller as the fourth =
argument to the linking function. The=0A=
 * `require` property can be a string, an array or an object:=0A=
 * * a **string** containing the name of the directive to pass to the =
linking function=0A=
 * * an **array** containing the names of directives to pass to the =
linking function. The argument passed to the=0A=
 * linking function will be an array of controllers in the same order as =
the names in the `require` property=0A=
 * * an **object** whose property values are the names of the directives =
to pass to the linking function. The argument=0A=
 * passed to the linking function will also be an object with matching =
keys, whose values will hold the corresponding=0A=
 * controllers.=0A=
 *=0A=
 * If the `require` property is an object and `bindToController` is =
truthy, then the required controllers are=0A=
 * bound to the controller using the keys of the `require` property. =
This binding occurs after all the controllers=0A=
 * have been constructed but before `$onInit` is called.=0A=
 * If the name of the required controller is the same as the local name =
(the key), the name can be=0A=
 * omitted. For example, `{parentDir: '^^'}` is equivalent to =
`{parentDir: '^^parentDir'}`.=0A=
 * See the {@link $compileProvider#component} helper for an example of =
how this can be used.=0A=
 * If no such required directive(s) can be found, or if the directive =
does not have a controller, then an error is=0A=
 * raised (unless no link function is specified and the required =
controllers are not being bound to the directive=0A=
 * controller, in which case error checking is skipped). The name can be =
prefixed with:=0A=
 *=0A=
 * * (no prefix) - Locate the required controller on the current =
element. Throw an error if not found.=0A=
 * * `?` - Attempt to locate the required controller or pass `null` to =
the `link` fn if not found.=0A=
 * * `^` - Locate the required controller by searching the element and =
its parents. Throw an error if not found.=0A=
 * * `^^` - Locate the required controller by searching the element's =
parents. Throw an error if not found.=0A=
 * * `?^` - Attempt to locate the required controller by searching the =
element and its parents or pass=0A=
 *   `null` to the `link` fn if not found.=0A=
 * * `?^^` - Attempt to locate the required controller by searching the =
element's parents, or pass=0A=
 *   `null` to the `link` fn if not found.=0A=
 *=0A=
 *=0A=
 * #### `controllerAs`=0A=
 * Identifier name for a reference to the controller in the directive's =
scope.=0A=
 * This allows the controller to be referenced from the directive =
template. This is especially=0A=
 * useful when a directive is used as component, i.e. with an `isolate` =
scope. It's also possible=0A=
 * to use it in a directive without an `isolate` / `new` scope, but you =
need to be aware that the=0A=
 * `controllerAs` reference might overwrite a property that already =
exists on the parent scope.=0A=
 *=0A=
 *=0A=
 * #### `restrict`=0A=
 * String of subset of `EACM` which restricts the directive to a =
specific directive=0A=
 * declaration style. If omitted, the defaults (elements and attributes) =
are used.=0A=
 *=0A=
 * * `E` - Element name (default): =
`&lt;my-directive&gt;&lt;/my-directive&gt;`=0A=
 * * `A` - Attribute (default): `&lt;div =
my-directive=3D"exp"&gt;&lt;/div&gt;`=0A=
 * * `C` - Class: `&lt;div class=3D"my-directive: exp;"&gt;&lt;/div&gt;`=0A=
 * * `M` - Comment: `&lt;!-- directive: my-directive exp --&gt;`=0A=
 *=0A=
 *=0A=
 * #### `templateNamespace`=0A=
 * String representing the document type used by the markup in the =
template.=0A=
 * AngularJS needs this information as those elements need to be created =
and cloned=0A=
 * in a special way when they are defined outside their usual containers =
like `&lt;svg&gt;` and `&lt;math&gt;`.=0A=
 *=0A=
 * * `html` - All root nodes in the template are HTML. Root nodes may =
also be=0A=
 *   top-level elements such as `&lt;svg&gt;` or `&lt;math&gt;`.=0A=
 * * `svg` - The root nodes in the template are SVG elements (excluding =
`&lt;math&gt;`).=0A=
 * * `math` - The root nodes in the template are MathML elements =
(excluding `&lt;svg&gt;`).=0A=
 *=0A=
 * If no `templateNamespace` is specified, then the namespace is =
considered to be `html`.=0A=
 *=0A=
 * #### `template`=0A=
 * HTML markup that may:=0A=
 * * Replace the contents of the directive's element (default).=0A=
 * * Replace the directive's element itself (if `replace` is true - =
DEPRECATED).=0A=
 * * Wrap the contents of the directive's element (if `transclude` is =
true).=0A=
 *=0A=
 * Value may be:=0A=
 *=0A=
 * * A string. For example `&lt;div =
red-on-hover&gt;{{delete_str}}&lt;/div&gt;`.=0A=
 * * A function which takes two arguments `tElement` and `tAttrs` =
(described in the `compile`=0A=
 *   function api below) and returns a string value.=0A=
 *=0A=
 *=0A=
 * #### `templateUrl`=0A=
 * This is similar to `template` but the template is loaded from the =
specified URL, asynchronously.=0A=
 *=0A=
 * Because template loading is asynchronous the compiler will suspend =
compilation of directives on that element=0A=
 * for later when the template has been resolved.  In the meantime it =
will continue to compile and link=0A=
 * sibling and parent elements as though this element had not contained =
any directives.=0A=
 *=0A=
 * The compiler does not suspend the entire compilation to wait for =
templates to be loaded because this=0A=
 * would result in the whole app "stalling" until all templates are =
loaded asynchronously - even in the=0A=
 * case when only one deeply nested directive has `templateUrl`.=0A=
 *=0A=
 * Template loading is asynchronous even if the template has been =
preloaded into the {@link $templateCache}=0A=
 *=0A=
 * You can specify `templateUrl` as a string representing the URL or as =
a function which takes two=0A=
 * arguments `tElement` and `tAttrs` (described in the `compile` =
function api below) and returns=0A=
 * a string value representing the url.  In either case, the template =
URL is passed through {@link=0A=
 * $sce#getTrustedResourceUrl $sce.getTrustedResourceUrl}.=0A=
 *=0A=
 *=0A=
 * #### `replace` ([*DEPRECATED*!], will be removed in next major =
release - i.e. v2.0)=0A=
 * specify what the template should replace. Defaults to `false`.=0A=
 *=0A=
 * * `true` - the template will replace the directive's element.=0A=
 * * `false` - the template will replace the contents of the directive's =
element.=0A=
 *=0A=
 * The replacement process migrates all of the attributes / classes from =
the old element to the new=0A=
 * one. See the {@link guide/directive#template-expanding-directive=0A=
 * Directives Guide} for an example.=0A=
 *=0A=
 * There are very few scenarios where element replacement is required =
for the application function,=0A=
 * the main one being reusable custom components that are used within =
SVG contexts=0A=
 * (because SVG doesn't work with custom elements in the DOM tree).=0A=
 *=0A=
 * #### `transclude`=0A=
 * Extract the contents of the element where the directive appears and =
make it available to the directive.=0A=
 * The contents are compiled and provided to the directive as a =
**transclusion function**. See the=0A=
 * {@link $compile#transclusion Transclusion} section below.=0A=
 *=0A=
 *=0A=
 * #### `compile`=0A=
 *=0A=
 * ```js=0A=
 *   function compile(tElement, tAttrs, transclude) { ... }=0A=
 * ```=0A=
 *=0A=
 * The compile function deals with transforming the template DOM. Since =
most directives do not do=0A=
 * template transformation, it is not used often. The compile function =
takes the following arguments:=0A=
 *=0A=
 *   * `tElement` - template element - The element where the directive =
has been declared. It is=0A=
 *     safe to do template transformation on the element and child =
elements only.=0A=
 *=0A=
 *   * `tAttrs` - template attributes - Normalized list of attributes =
declared on this element shared=0A=
 *     between all directive compile functions.=0A=
 *=0A=
 *   * `transclude` -  [*DEPRECATED*!] A transclude linking function: =
`function(scope, cloneLinkingFn)`=0A=
 *=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * **Note:** The template instance and the link instance may be =
different objects if the template has=0A=
 * been cloned. For this reason it is **not** safe to do anything other =
than DOM transformations that=0A=
 * apply to all cloned DOM nodes within the compile function. =
Specifically, DOM listener registration=0A=
 * should be done in a linking function rather than in a compile =
function.=0A=
 * &lt;/div&gt;=0A=
=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * **Note:** The compile function cannot handle directives that =
recursively use themselves in their=0A=
 * own templates or compile functions. Compiling these directives =
results in an infinite loop and=0A=
 * stack overflow errors.=0A=
 *=0A=
 * This can be avoided by manually using $compile in the postLink =
function to imperatively compile=0A=
 * a directive's template instead of relying on automatic template =
compilation via `template` or=0A=
 * `templateUrl` declaration or manual compilation inside the compile =
function.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * &lt;div class=3D"alert alert-danger"&gt;=0A=
 * **Note:** The `transclude` function that is passed to the compile =
function is deprecated, as it=0A=
 *   e.g. does not know about the right outer scope. Please use the =
transclude function that is passed=0A=
 *   to the link function instead.=0A=
 * &lt;/div&gt;=0A=
=0A=
 * A compile function can have a return value which can be either a =
function or an object.=0A=
 *=0A=
 * * returning a (post-link) function - is equivalent to registering the =
linking function via the=0A=
 *   `link` property of the config object when the compile function is =
empty.=0A=
 *=0A=
 * * returning an object with function(s) registered via `pre` and =
`post` properties - allows you to=0A=
 *   control when a linking function should be called during the linking =
phase. See info about=0A=
 *   pre-linking and post-linking functions below.=0A=
 *=0A=
 *=0A=
 * #### `link`=0A=
 * This property is used only if the `compile` property is not defined.=0A=
 *=0A=
 * ```js=0A=
 *   function link(scope, iElement, iAttrs, controller, transcludeFn) { =
... }=0A=
 * ```=0A=
 *=0A=
 * The link function is responsible for registering DOM listeners as =
well as updating the DOM. It is=0A=
 * executed after the template has been cloned. This is where most of =
the directive logic will be=0A=
 * put.=0A=
 *=0A=
 *   * `scope` - {@link ng.$rootScope.Scope Scope} - The scope to be =
used by the=0A=
 *     directive for registering {@link ng.$rootScope.Scope#$watch =
watches}.=0A=
 *=0A=
 *   * `iElement` - instance element - The element where the directive =
is to be used. It is safe to=0A=
 *     manipulate the children of the element only in `postLink` =
function since the children have=0A=
 *     already been linked.=0A=
 *=0A=
 *   * `iAttrs` - instance attributes - Normalized list of attributes =
declared on this element shared=0A=
 *     between all directive linking functions.=0A=
 *=0A=
 *   * `controller` - the directive's required controller instance(s) - =
Instances are shared=0A=
 *     among all directives, which allows the directives to use the =
controllers as a communication=0A=
 *     channel. The exact value depends on the directive's `require` =
property:=0A=
 *       * no controller(s) required: the directive's own controller, or =
`undefined` if it doesn't have one=0A=
 *       * `string`: the controller instance=0A=
 *       * `array`: array of controller instances=0A=
 *=0A=
 *     If a required controller cannot be found, and it is optional, the =
instance is `null`,=0A=
 *     otherwise the {@link error:$compile:ctreq Missing Required =
Controller} error is thrown.=0A=
 *=0A=
 *     Note that you can also require the directive's own controller - =
it will be made available like=0A=
 *     any other controller.=0A=
 *=0A=
 *   * `transcludeFn` - A transclude linking function pre-bound to the =
correct transclusion scope.=0A=
 *     This is the same as the `$transclude` parameter of directive =
controllers,=0A=
 *     see {@link ng.$compile#-controller- the controller section for =
details}.=0A=
 *     `function([scope], cloneLinkingFn, futureParentElement)`.=0A=
 *=0A=
 * #### Pre-linking function=0A=
 *=0A=
 * Executed before the child elements are linked. Not safe to do DOM =
transformation since the=0A=
 * compiler linking function will fail to locate the correct elements =
for linking.=0A=
 *=0A=
 * #### Post-linking function=0A=
 *=0A=
 * Executed after the child elements are linked.=0A=
 *=0A=
 * Note that child elements that contain `templateUrl` directives will =
not have been compiled=0A=
 * and linked since they are waiting for their template to load =
asynchronously and their own=0A=
 * compilation and linking has been suspended until that occurs.=0A=
 *=0A=
 * It is safe to do DOM transformation in the post-linking function on =
elements that are not waiting=0A=
 * for their async templates to be resolved.=0A=
 *=0A=
 *=0A=
 * ### Transclusion=0A=
 *=0A=
 * Transclusion is the process of extracting a collection of DOM =
elements from one part of the DOM and=0A=
 * copying them to another part of the DOM, while maintaining their =
connection to the original AngularJS=0A=
 * scope from where they were taken.=0A=
 *=0A=
 * Transclusion is used (often with {@link ngTransclude}) to insert the=0A=
 * original contents of a directive's element into a specified place in =
the template of the directive.=0A=
 * The benefit of transclusion, over simply moving the DOM elements =
manually, is that the transcluded=0A=
 * content has access to the properties on the scope from which it was =
taken, even if the directive=0A=
 * has isolated scope.=0A=
 * See the {@link =
guide/directive#creating-a-directive-that-wraps-other-elements =
Directives Guide}.=0A=
 *=0A=
 * This makes it possible for the widget to have private state for its =
template, while the transcluded=0A=
 * content has access to its originating scope.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * **Note:** When testing an element transclude directive you must not =
place the directive at the root of the=0A=
 * DOM fragment that is being compiled. See {@link =
guide/unit-testing#testing-transclusion-directives=0A=
 * Testing Transclusion Directives}.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * There are three kinds of transclusion depending upon whether you want =
to transclude just the contents of the=0A=
 * directive's element, the entire element or multiple parts of the =
element contents:=0A=
 *=0A=
 * * `true` - transclude the content (i.e. the child nodes) of the =
directive's element.=0A=
 * * `'element'` - transclude the whole of the directive's element =
including any directives on this=0A=
 *   element that defined at a lower priority than this directive. When =
used, the `template`=0A=
 *   property is ignored.=0A=
 * * **`{...}` (an object hash):** - map elements of the content onto =
transclusion "slots" in the template.=0A=
 *=0A=
 * **Mult-slot transclusion** is declared by providing an object for the =
`transclude` property.=0A=
 *=0A=
 * This object is a map where the keys are the name of the slot to fill =
and the value is an element selector=0A=
 * used to match the HTML to the slot. The element selector should be in =
normalized form (e.g. `myElement`)=0A=
 * and will match the standard element variants (e.g. `my-element`, =
`my:element`, `data-my-element`, etc).=0A=
 *=0A=
 * For further information check out the guide on {@link =
guide/directive#matching-directives Matching Directives}=0A=
 *=0A=
 * If the element selector is prefixed with a `?` then that slot is =
optional.=0A=
 *=0A=
 * For example, the transclude object `{ slotA: '?myCustomElement' }` =
maps `&lt;my-custom-element&gt;` elements to=0A=
 * the `slotA` slot, which can be accessed via the `$transclude` =
function or via the {@link ngTransclude} directive.=0A=
 *=0A=
 * Slots that are not marked as optional (`?`) will trigger a compile =
time error if there are no matching elements=0A=
 * in the transclude content. If you wish to know if an optional slot =
was filled with content, then you can call=0A=
 * `$transclude.isSlotFilled(slotName)` on the transclude function =
passed to the directive's link function and=0A=
 * injectable into the directive's controller.=0A=
 *=0A=
 *=0A=
 * #### Transclusion Functions=0A=
 *=0A=
 * When a directive requests transclusion, the compiler extracts its =
contents and provides a **transclusion=0A=
 * function** to the directive's `link` function and `controller`. This =
transclusion function is a special=0A=
 * **linking function** that will return the compiled contents linked to =
a new transclusion scope.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-info"&gt;=0A=
 * If you are just using {@link ngTransclude} then you don't need to =
worry about this function, since=0A=
 * ngTransclude will deal with it for us.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * If you want to manually control the insertion and removal of the =
transcluded content in your directive=0A=
 * then you must use this transclude function. When you call a =
transclude function it returns a a jqLite/JQuery=0A=
 * object that contains the compiled DOM, which is linked to the correct =
transclusion scope.=0A=
 *=0A=
 * When you call a transclusion function you can pass in a **clone =
attach function**. This function accepts=0A=
 * two parameters, `function(clone, scope) { ... }`, where the `clone` =
is a fresh compiled copy of your transcluded=0A=
 * content and the `scope` is the newly created transclusion scope, =
which the clone will be linked to.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-info"&gt;=0A=
 * **Best Practice**: Always provide a `cloneFn` (clone attach function) =
when you call a transclude function=0A=
 * since you then get a fresh clone of the original DOM and also have =
access to the new transclusion scope.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * It is normal practice to attach your transcluded content (`clone`) to =
the DOM inside your **clone=0A=
 * attach function**:=0A=
 *=0A=
 * ```js=0A=
 * var transcludedContent, transclusionScope;=0A=
 *=0A=
 * $transclude(function(clone, scope) {=0A=
 *   element.append(clone);=0A=
 *   transcludedContent =3D clone;=0A=
 *   transclusionScope =3D scope;=0A=
 * });=0A=
 * ```=0A=
 *=0A=
 * Later, if you want to remove the transcluded content from your DOM =
then you should also destroy the=0A=
 * associated transclusion scope:=0A=
 *=0A=
 * ```js=0A=
 * transcludedContent.remove();=0A=
 * transclusionScope.$destroy();=0A=
 * ```=0A=
 *=0A=
 * &lt;div class=3D"alert alert-info"&gt;=0A=
 * **Best Practice**: if you intend to add and remove transcluded =
content manually in your directive=0A=
 * (by calling the transclude function to get the DOM and calling =
`element.remove()` to remove it),=0A=
 * then you are also responsible for calling `$destroy` on the =
transclusion scope.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * The built-in DOM manipulation directives, such as {@link ngIf}, =
{@link ngSwitch} and {@link ngRepeat}=0A=
 * automatically destroy their transcluded clones as necessary so you do =
not need to worry about this if=0A=
 * you are simply using {@link ngTransclude} to inject the transclusion =
into your directive.=0A=
 *=0A=
 *=0A=
 * #### Transclusion Scopes=0A=
 *=0A=
 * When you call a transclude function it returns a DOM fragment that is =
pre-bound to a **transclusion=0A=
 * scope**. This scope is special, in that it is a child of the =
directive's scope (and so gets destroyed=0A=
 * when the directive's scope gets destroyed) but it inherits the =
properties of the scope from which it=0A=
 * was taken.=0A=
 *=0A=
 * For example consider a directive that uses transclusion and isolated =
scope. The DOM hierarchy might look=0A=
 * like this:=0A=
 *=0A=
 * ```html=0A=
 * &lt;div ng-app&gt;=0A=
 *   &lt;div isolate&gt;=0A=
 *     &lt;div transclusion&gt;=0A=
 *     &lt;/div&gt;=0A=
 *   &lt;/div&gt;=0A=
 * &lt;/div&gt;=0A=
 * ```=0A=
 *=0A=
 * The `$parent` scope hierarchy will look like this:=0A=
 *=0A=
   ```=0A=
   - $rootScope=0A=
     - isolate=0A=
       - transclusion=0A=
   ```=0A=
 *=0A=
 * but the scopes will inherit prototypically from different scopes to =
their `$parent`.=0A=
 *=0A=
   ```=0A=
   - $rootScope=0A=
     - transclusion=0A=
   - isolate=0A=
   ```=0A=
 *=0A=
 *=0A=
 * ### Attributes=0A=
 *=0A=
 * The {@link ng.$compile.directive.Attributes Attributes} object - =
passed as a parameter in the=0A=
 * `link()` or `compile()` functions. It has a variety of uses.=0A=
 *=0A=
 * * *Accessing normalized attribute names:* Directives like 'ngBind' =
can be expressed in many ways:=0A=
 *   'ng:bind', `data-ng-bind`, or 'x-ng-bind'. The attributes object =
allows for normalized access=0A=
 *   to the attributes.=0A=
 *=0A=
 * * *Directive inter-communication:* All directives share the same =
instance of the attributes=0A=
 *   object which allows the directives to use the attributes object as =
inter directive=0A=
 *   communication.=0A=
 *=0A=
 * * *Supports interpolation:* Interpolation attributes are assigned to =
the attribute object=0A=
 *   allowing other directives to read the interpolated value.=0A=
 *=0A=
 * * *Observing interpolated attributes:* Use `$observe` to observe the =
value changes of attributes=0A=
 *   that contain interpolation (e.g. `src=3D"{{bar}}"`). Not only is =
this very efficient but it's also=0A=
 *   the only way to easily get the actual value because during the =
linking phase the interpolation=0A=
 *   hasn't been evaluated yet and so the value is at this time set to =
`undefined`.=0A=
 *=0A=
 * ```js=0A=
 * function linkingFn(scope, elm, attrs, ctrl) {=0A=
 *   // get the attribute value=0A=
 *   console.log(attrs.ngModel);=0A=
 *=0A=
 *   // change the attribute=0A=
 *   attrs.$set('ngModel', 'new value');=0A=
 *=0A=
 *   // observe changes to interpolated attribute=0A=
 *   attrs.$observe('ngModel', function(value) {=0A=
 *     console.log('ngModel has changed value to ' + value);=0A=
 *   });=0A=
 * }=0A=
 * ```=0A=
 *=0A=
 * ## Example=0A=
 *=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * **Note**: Typically directives are registered with =
`module.directive`. The example below is=0A=
 * to illustrate how `$compile` works.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 &lt;example module=3D"compileExample" name=3D"compile"&gt;=0A=
   &lt;file name=3D"index.html"&gt;=0A=
    &lt;script&gt;=0A=
      angular.module('compileExample', [], function($compileProvider) {=0A=
        // configure new 'compile' directive by passing a directive=0A=
        // factory function. The factory function injects the '$compile'=0A=
        $compileProvider.directive('compile', function($compile) {=0A=
          // directive factory creates a link function=0A=
          return function(scope, element, attrs) {=0A=
            scope.$watch(=0A=
              function(scope) {=0A=
                 // watch the 'compile' expression for changes=0A=
                return scope.$eval(attrs.compile);=0A=
              },=0A=
              function(value) {=0A=
                // when the 'compile' expression changes=0A=
                // assign it into the current DOM=0A=
                element.html(value);=0A=
=0A=
                // compile the new DOM and link it to the current=0A=
                // scope.=0A=
                // NOTE: we only compile .childNodes so that=0A=
                // we don't get into infinite loop compiling ourselves=0A=
                $compile(element.contents())(scope);=0A=
              }=0A=
            );=0A=
          };=0A=
        });=0A=
      })=0A=
      .controller('GreeterController', ['$scope', function($scope) {=0A=
        $scope.name =3D 'Angular';=0A=
        $scope.html =3D 'Hello {{name}}';=0A=
      }]);=0A=
    &lt;/script&gt;=0A=
    &lt;div ng-controller=3D"GreeterController"&gt;=0A=
      &lt;input ng-model=3D"name"&gt; &lt;br/&gt;=0A=
      &lt;textarea ng-model=3D"html"&gt;&lt;/textarea&gt; &lt;br/&gt;=0A=
      &lt;div compile=3D"html"&gt;&lt;/div&gt;=0A=
    &lt;/div&gt;=0A=
   &lt;/file&gt;=0A=
   &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
     it('should auto compile', function() {=0A=
       var textarea =3D $('textarea');=0A=
       var output =3D $('div[compile]');=0A=
       // The initial state reads 'Hello Angular'.=0A=
       expect(output.getText()).toBe('Hello Angular');=0A=
       textarea.clear();=0A=
       textarea.sendKeys('{{name}}!');=0A=
       expect(output.getText()).toBe('Angular!');=0A=
     });=0A=
   &lt;/file&gt;=0A=
 &lt;/example&gt;=0A=
=0A=
 *=0A=
 *=0A=
 * @param {string|DOMElement} element Element or HTML string to compile =
into a template function.=0A=
 * @param {function(angular.Scope, cloneAttachFn=3D)} transclude =
function available to directives - DEPRECATED.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-danger"&gt;=0A=
 * **Note:** Passing a `transclude` function to the $compile function is =
deprecated, as it=0A=
 *   e.g. will not use the right outer scope. Please pass the transclude =
function as a=0A=
 *   `parentBoundTranscludeFn` to the link function instead.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * @param {number} maxPriority only apply directives lower than given =
priority (Only effects the=0A=
 *                 root element(s), not their children)=0A=
 * @returns {function(scope, cloneAttachFn=3D, options=3D)} a link =
function which is used to bind template=0A=
 * (a DOM element/tree) to a scope. Where:=0A=
 *=0A=
 *  * `scope` - A {@link ng.$rootScope.Scope Scope} to bind to.=0A=
 *  * `cloneAttachFn` - If `cloneAttachFn` is provided, then the link =
function will clone the=0A=
 *  `template` and call the `cloneAttachFn` function allowing the caller =
to attach the=0A=
 *  cloned elements to the DOM document at the appropriate place. The =
`cloneAttachFn` is=0A=
 *  called as: &lt;br/&gt; `cloneAttachFn(clonedElement, scope)` where:=0A=
 *=0A=
 *      * `clonedElement` - is a clone of the original `element` passed =
into the compiler.=0A=
 *      * `scope` - is the current scope with which the linking function =
is working with.=0A=
 *=0A=
 *  * `options` - An optional object hash with linking options. If =
`options` is provided, then the following=0A=
 *  keys may be used to control linking behavior:=0A=
 *=0A=
 *      * `parentBoundTranscludeFn` - the transclude function made =
available to=0A=
 *        directives; if given, it will be passed through to the link =
functions of=0A=
 *        directives found in `element` during compilation.=0A=
 *      * `transcludeControllers` - an object hash with keys that map =
controller names=0A=
 *        to a hash with the key `instance`, which maps to the =
controller instance;=0A=
 *        if given, it will make the controllers available to directives =
on the compileNode:=0A=
 *        ```=0A=
 *        {=0A=
 *          parent: {=0A=
 *            instance: parentControllerInstance=0A=
 *          }=0A=
 *        }=0A=
 *        ```=0A=
 *      * `futureParentElement` - defines the parent to which the =
`cloneAttachFn` will add=0A=
 *        the cloned elements; only needed for transcludes that are =
allowed to contain non html=0A=
 *        elements (e.g. SVG elements). See also the =
directive.controller property.=0A=
 *=0A=
 * Calling the linking function returns the element of the template. It =
is either the original=0A=
 * element passed in, or the clone of the element if the `cloneAttachFn` =
is provided.=0A=
 *=0A=
 * After linking the view is not updated until after a call to $digest =
which typically is done by=0A=
 * Angular automatically.=0A=
 *=0A=
 * If you need access to the bound view, there are two ways to do it:=0A=
 *=0A=
 * - If you are not asking the linking function to clone the template, =
create the DOM element(s)=0A=
 *   before you send them to the compiler and keep this reference around.=0A=
 *   ```js=0A=
 *     var element =3D $compile('&lt;p&gt;{{total}}&lt;/p&gt;')(scope);=0A=
 *   ```=0A=
 *=0A=
 * - if on the other hand, you need the element to be cloned, the view =
reference from the original=0A=
 *   example would not point to the clone, but rather to the original =
template that was cloned. In=0A=
 *   this case, you can access the clone via the cloneAttachFn:=0A=
 *   ```js=0A=
 *     var templateElement =3D =
angular.element('&lt;p&gt;{{total}}&lt;/p&gt;'),=0A=
 *         scope =3D ....;=0A=
 *=0A=
 *     var clonedElement =3D $compile(templateElement)(scope, =
function(clonedElement, scope) {=0A=
 *       //attach the clone to DOM document at the right place=0A=
 *     });=0A=
 *=0A=
 *     //now we have reference to the cloned DOM via `clonedElement`=0A=
 *   ```=0A=
 *=0A=
 *=0A=
 * For information on how the compiler works, see the=0A=
 * {@link guide/compiler Angular HTML Compiler} section of the Developer =
Guide.=0A=
 *=0A=
 * @knownIssue=0A=
 *=0A=
 * ### Double Compilation=0A=
 *=0A=
   Double compilation occurs when an already compiled part of the DOM =
gets=0A=
   compiled again. This is an undesired effect and can lead to =
misbehaving directives, performance issues,=0A=
   and memory leaks. Refer to the Compiler Guide {@link =
guide/compiler#double-compilation-and-how-to-avoid-it=0A=
   section on double compilation} for an in-depth explanation and ways =
to avoid it.=0A=
 *=0A=
 */=0A=
=0A=
var $compileMinErr =3D minErr('$compile');=0A=
=0A=
function UNINITIALIZED_VALUE() {}=0A=
var _UNINITIALIZED_VALUE =3D new UNINITIALIZED_VALUE();=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $compileProvider=0A=
 *=0A=
 * @description=0A=
 */=0A=
$CompileProvider.$inject =3D ['$provide', '$$sanitizeUriProvider'];=0A=
/** @this */=0A=
function $CompileProvider($provide, $$sanitizeUriProvider) {=0A=
  var hasDirectives =3D {},=0A=
      Suffix =3D 'Directive',=0A=
      COMMENT_DIRECTIVE_REGEXP =3D /^\s*directive:\s*([\w-]+)\s+(.*)$/,=0A=
      CLASS_DIRECTIVE_REGEXP =3D /(([\w-]+)(?::([^;]+))?;?)/,=0A=
      ALL_OR_NOTHING_ATTRS =3D makeMap('ngSrc,ngSrcset,src,srcset'),=0A=
      REQUIRE_PREFIX_REGEXP =3D /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;=0A=
=0A=
  // Ref: =
http://developers.whatwg.org/webappapis.html#event-handler-idl-attributes=0A=
  // The assumption is that future DOM event attribute names will begin =
with=0A=
  // 'on' and be composed of only English letters.=0A=
  var EVENT_HANDLER_ATTR_REGEXP =3D /^(on[a-z]+|formaction)$/;=0A=
  var bindingCache =3D createMap();=0A=
=0A=
  function parseIsolateBindings(scope, directiveName, isController) {=0A=
    var LOCAL_REGEXP =3D =
/^\s*([@&amp;&lt;]|=3D(\*?))(\??)\s*([\w$]*)\s*$/;=0A=
=0A=
    var bindings =3D createMap();=0A=
=0A=
    forEach(scope, function(definition, scopeName) {=0A=
      if (definition in bindingCache) {=0A=
        bindings[scopeName] =3D bindingCache[definition];=0A=
        return;=0A=
      }=0A=
      var match =3D definition.match(LOCAL_REGEXP);=0A=
=0A=
      if (!match) {=0A=
        throw $compileMinErr('iscp',=0A=
            'Invalid {3} for directive \'{0}\'.' +=0A=
            ' Definition: {... {1}: \'{2}\' ...}',=0A=
            directiveName, scopeName, definition,=0A=
            (isController ? 'controller bindings definition' :=0A=
            'isolate scope definition'));=0A=
      }=0A=
=0A=
      bindings[scopeName] =3D {=0A=
        mode: match[1][0],=0A=
        collection: match[2] =3D=3D=3D '*',=0A=
        optional: match[3] =3D=3D=3D '?',=0A=
        attrName: match[4] || scopeName=0A=
      };=0A=
      if (match[4]) {=0A=
        bindingCache[definition] =3D bindings[scopeName];=0A=
      }=0A=
    });=0A=
=0A=
    return bindings;=0A=
  }=0A=
=0A=
  function parseDirectiveBindings(directive, directiveName) {=0A=
    var bindings =3D {=0A=
      isolateScope: null,=0A=
      bindToController: null=0A=
    };=0A=
    if (isObject(directive.scope)) {=0A=
      if (directive.bindToController =3D=3D=3D true) {=0A=
        bindings.bindToController =3D =
parseIsolateBindings(directive.scope,=0A=
                                                         directiveName, =
true);=0A=
        bindings.isolateScope =3D {};=0A=
      } else {=0A=
        bindings.isolateScope =3D parseIsolateBindings(directive.scope,=0A=
                                                     directiveName, =
false);=0A=
      }=0A=
    }=0A=
    if (isObject(directive.bindToController)) {=0A=
      bindings.bindToController =3D=0A=
          parseIsolateBindings(directive.bindToController, =
directiveName, true);=0A=
    }=0A=
    if (bindings.bindToController &amp;&amp; !directive.controller) {=0A=
      // There is no controller=0A=
      throw $compileMinErr('noctrl',=0A=
            'Cannot bind to controller without directive \'{0}\'s =
controller.',=0A=
            directiveName);=0A=
    }=0A=
    return bindings;=0A=
  }=0A=
=0A=
  function assertValidDirectiveName(name) {=0A=
    var letter =3D name.charAt(0);=0A=
    if (!letter || letter !=3D=3D lowercase(letter)) {=0A=
      throw $compileMinErr('baddir', 'Directive/Component name \'{0}\' =
is invalid. The first character must be a lowercase letter', name);=0A=
    }=0A=
    if (name !=3D=3D name.trim()) {=0A=
      throw $compileMinErr('baddir',=0A=
            'Directive/Component name \'{0}\' is invalid. The name =
should not contain leading or trailing whitespaces',=0A=
            name);=0A=
    }=0A=
  }=0A=
=0A=
  function getDirectiveRequire(directive) {=0A=
    var require =3D directive.require || (directive.controller =
&amp;&amp; directive.name);=0A=
=0A=
    if (!isArray(require) &amp;&amp; isObject(require)) {=0A=
      forEach(require, function(value, key) {=0A=
        var match =3D value.match(REQUIRE_PREFIX_REGEXP);=0A=
        var name =3D value.substring(match[0].length);=0A=
        if (!name) require[key] =3D match[0] + key;=0A=
      });=0A=
    }=0A=
=0A=
    return require;=0A=
  }=0A=
=0A=
  function getDirectiveRestrict(restrict, name) {=0A=
    if (restrict &amp;&amp; !(isString(restrict) &amp;&amp; =
/[EACM]/.test(restrict))) {=0A=
      throw $compileMinErr('badrestrict',=0A=
          'Restrict property \'{0}\' of directive \'{1}\' is invalid',=0A=
          restrict,=0A=
          name);=0A=
    }=0A=
=0A=
    return restrict || 'EA';=0A=
  }=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $compileProvider#directive=0A=
   * @kind function=0A=
   *=0A=
   * @description=0A=
   * Register a new directive with the compiler.=0A=
   *=0A=
   * @param {string|Object} name Name of the directive in camel-case =
(i.e. &lt;code&gt;ngBind&lt;/code&gt; which=0A=
   *    will match as &lt;code&gt;ng-bind&lt;/code&gt;), or an object =
map of directives where the keys are the=0A=
   *    names and the values are the factories.=0A=
   * @param {Function|Array} directiveFactory An injectable directive =
factory function. See the=0A=
   *    {@link guide/directive directive guide} and the {@link $compile =
compile API} for more info.=0A=
   * @returns {ng.$compileProvider} Self for chaining.=0A=
   */=0A=
  this.directive =3D function registerDirective(name, directiveFactory) {=0A=
    assertArg(name, 'name');=0A=
    assertNotHasOwnProperty(name, 'directive');=0A=
    if (isString(name)) {=0A=
      assertValidDirectiveName(name);=0A=
      assertArg(directiveFactory, 'directiveFactory');=0A=
      if (!hasDirectives.hasOwnProperty(name)) {=0A=
        hasDirectives[name] =3D [];=0A=
        $provide.factory(name + Suffix, ['$injector', =
'$exceptionHandler',=0A=
          function($injector, $exceptionHandler) {=0A=
            var directives =3D [];=0A=
            forEach(hasDirectives[name], function(directiveFactory, =
index) {=0A=
              try {=0A=
                var directive =3D $injector.invoke(directiveFactory);=0A=
                if (isFunction(directive)) {=0A=
                  directive =3D { compile: valueFn(directive) };=0A=
                } else if (!directive.compile &amp;&amp; directive.link) =
{=0A=
                  directive.compile =3D valueFn(directive.link);=0A=
                }=0A=
                directive.priority =3D directive.priority || 0;=0A=
                directive.index =3D index;=0A=
                directive.name =3D directive.name || name;=0A=
                directive.require =3D getDirectiveRequire(directive);=0A=
                directive.restrict =3D =
getDirectiveRestrict(directive.restrict, name);=0A=
                directive.$$moduleName =3D directiveFactory.$$moduleName;=0A=
                directives.push(directive);=0A=
              } catch (e) {=0A=
                $exceptionHandler(e);=0A=
              }=0A=
            });=0A=
            return directives;=0A=
          }]);=0A=
      }=0A=
      hasDirectives[name].push(directiveFactory);=0A=
    } else {=0A=
      forEach(name, reverseParams(registerDirective));=0A=
    }=0A=
    return this;=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $compileProvider#component=0A=
   * @module ng=0A=
   * @param {string|Object} name Name of the component in camelCase =
(i.e. `myComp` which will match `&lt;my-comp&gt;`),=0A=
   *    or an object map of components where the keys are the names and =
the values are the component definition objects.=0A=
   * @param {Object} options Component definition object (a simplified=0A=
   *    {@link ng.$compile#directive-definition-object directive =
definition object}),=0A=
   *    with the following properties (all optional):=0A=
   *=0A=
   *    - `controller` =E2=80&#65533; `{(string|function()=3D}` =
=E2=80&#65533; controller constructor function that should be=0A=
   *      associated with newly created scope or the name of a {@link =
ng.$compile#-controller-=0A=
   *      registered controller} if passed as a string. An empty `noop` =
function by default.=0A=
   *    - `controllerAs` =E2=80&#65533; `{string=3D}` =E2=80&#65533; =
identifier name for to reference the controller in the component's scope.=0A=
   *      If present, the controller will be published to scope under =
the `controllerAs` name.=0A=
   *      If not present, this will default to be `$ctrl`.=0A=
   *    - `template` =E2=80&#65533; `{string=3D|function()=3D}` =
=E2=80&#65533; html template as a string or a function that=0A=
   *      returns an html template as a string which should be used as =
the contents of this component.=0A=
   *      Empty string by default.=0A=
   *=0A=
   *      If `template` is a function, then it is {@link =
auto.$injector#invoke injected} with=0A=
   *      the following locals:=0A=
   *=0A=
   *      - `$element` - Current element=0A=
   *      - `$attrs` - Current attributes object for the element=0A=
   *=0A=
   *    - `templateUrl` =E2=80&#65533; `{string=3D|function()=3D}` =
=E2=80&#65533; path or function that returns a path to an html=0A=
   *      template that should be used  as the contents of this =
component.=0A=
   *=0A=
   *      If `templateUrl` is a function, then it is {@link =
auto.$injector#invoke injected} with=0A=
   *      the following locals:=0A=
   *=0A=
   *      - `$element` - Current element=0A=
   *      - `$attrs` - Current attributes object for the element=0A=
   *=0A=
   *    - `bindings` =E2=80&#65533; `{object=3D}` =E2=80&#65533; defines =
bindings between DOM attributes and component properties.=0A=
   *      Component properties are always bound to the component =
controller and not to the scope.=0A=
   *      See {@link ng.$compile#-bindtocontroller- `bindToController`}.=0A=
   *    - `transclude` =E2=80&#65533; `{boolean=3D}` =E2=80&#65533; =
whether {@link $compile#transclusion content transclusion} is enabled.=0A=
   *      Disabled by default.=0A=
   *    - `require` - `{Object&lt;string, string&gt;=3D}` - requires the =
controllers of other directives and binds them to=0A=
   *      this component's controller. The object keys specify the =
property names under which the required=0A=
   *      controllers (object values) will be bound. See {@link =
ng.$compile#-require- `require`}.=0A=
   *    - `$...` =E2=80&#65533; additional properties to attach to the =
directive factory function and the controller=0A=
   *      constructor function. (This is used by the component router to =
annotate)=0A=
   *=0A=
   * @returns {ng.$compileProvider} the compile provider itself, for =
chaining of function calls.=0A=
   * @description=0A=
   * Register a **component definition** with the compiler. This is a =
shorthand for registering a special=0A=
   * type of directive, which represents a self-contained UI component =
in your application. Such components=0A=
   * are always isolated (i.e. `scope: {}`) and are always restricted to =
elements (i.e. `restrict: 'E'`).=0A=
   *=0A=
   * Component definitions are very simple and do not require as much =
configuration as defining general=0A=
   * directives. Component definitions usually consist only of a =
template and a controller backing it.=0A=
   *=0A=
   * In order to make the definition easier, components enforce best =
practices like use of `controllerAs`,=0A=
   * `bindToController`. They always have **isolate scope** and are =
restricted to elements.=0A=
   *=0A=
   * Here are a few examples of how you would usually define components:=0A=
   *=0A=
   * ```js=0A=
   *   var myMod =3D angular.module(...);=0A=
   *   myMod.component('myComp', {=0A=
   *     template: '&lt;div&gt;My name is {{$ctrl.name}}&lt;/div&gt;',=0A=
   *     controller: function() {=0A=
   *       this.name =3D 'shahar';=0A=
   *     }=0A=
   *   });=0A=
   *=0A=
   *   myMod.component('myComp', {=0A=
   *     template: '&lt;div&gt;My name is {{$ctrl.name}}&lt;/div&gt;',=0A=
   *     bindings: {name: '@'}=0A=
   *   });=0A=
   *=0A=
   *   myMod.component('myComp', {=0A=
   *     templateUrl: 'views/my-comp.html',=0A=
   *     controller: 'MyCtrl',=0A=
   *     controllerAs: 'ctrl',=0A=
   *     bindings: {name: '@'}=0A=
   *   });=0A=
   *=0A=
   * ```=0A=
   * For more examples, and an in-depth guide, see the {@link =
guide/component component guide}.=0A=
   *=0A=
   * &lt;br /&gt;=0A=
   * See also {@link ng.$compileProvider#directive =
$compileProvider.directive()}.=0A=
   */=0A=
  this.component =3D function registerComponent(name, options) {=0A=
    if (!isString(name)) {=0A=
      forEach(name, reverseParams(bind(this, registerComponent)));=0A=
      return this;=0A=
    }=0A=
=0A=
    var controller =3D options.controller || function() {};=0A=
=0A=
    function factory($injector) {=0A=
      function makeInjectable(fn) {=0A=
        if (isFunction(fn) || isArray(fn)) {=0A=
          return /** @this */ function(tElement, tAttrs) {=0A=
            return $injector.invoke(fn, this, {$element: tElement, =
$attrs: tAttrs});=0A=
          };=0A=
        } else {=0A=
          return fn;=0A=
        }=0A=
      }=0A=
=0A=
      var template =3D (!options.template &amp;&amp; =
!options.templateUrl ? '' : options.template);=0A=
      var ddo =3D {=0A=
        controller: controller,=0A=
        controllerAs: identifierForController(options.controller) || =
options.controllerAs || '$ctrl',=0A=
        template: makeInjectable(template),=0A=
        templateUrl: makeInjectable(options.templateUrl),=0A=
        transclude: options.transclude,=0A=
        scope: {},=0A=
        bindToController: options.bindings || {},=0A=
        restrict: 'E',=0A=
        require: options.require=0A=
      };=0A=
=0A=
      // Copy annotations (starting with $) over to the DDO=0A=
      forEach(options, function(val, key) {=0A=
        if (key.charAt(0) =3D=3D=3D '$') ddo[key] =3D val;=0A=
      });=0A=
=0A=
      return ddo;=0A=
    }=0A=
=0A=
    // TODO(pete) remove the following `forEach` before we release 1.6.0=0A=
    // The component-router@0.2.0 looks for the annotations on the =
controller constructor=0A=
    // Nothing in Angular looks for annotations on the factory function =
but we can't remove=0A=
    // it from 1.5.x yet.=0A=
=0A=
    // Copy any annotation properties (starting with $) over to the =
factory and controller constructor functions=0A=
    // These could be used by libraries such as the new component router=0A=
    forEach(options, function(val, key) {=0A=
      if (key.charAt(0) =3D=3D=3D '$') {=0A=
        factory[key] =3D val;=0A=
        // Don't try to copy over annotations to named controller=0A=
        if (isFunction(controller)) controller[key] =3D val;=0A=
      }=0A=
    });=0A=
=0A=
    factory.$inject =3D ['$injector'];=0A=
=0A=
    return this.directive(name, factory);=0A=
  };=0A=
=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $compileProvider#aHrefSanitizationWhitelist=0A=
   * @kind function=0A=
   *=0A=
   * @description=0A=
   * Retrieves or overrides the default regular expression that is used =
for whitelisting of safe=0A=
   * urls during a[href] sanitization.=0A=
   *=0A=
   * The sanitization is a security measure aimed at preventing XSS =
attacks via html links.=0A=
   *=0A=
   * Any url about to be assigned to a[href] via data-binding is first =
normalized and turned into=0A=
   * an absolute url. Afterwards, the url is matched against the =
`aHrefSanitizationWhitelist`=0A=
   * regular expression. If a match is found, the original url is =
written into the dom. Otherwise,=0A=
   * the absolute url is prefixed with `'unsafe:'` string and only then =
is it written into the DOM.=0A=
   *=0A=
   * @param {RegExp=3D} regexp New regexp to whitelist urls with.=0A=
   * @returns {RegExp|ng.$compileProvider} Current RegExp if called =
without value or self for=0A=
   *    chaining otherwise.=0A=
   */=0A=
  this.aHrefSanitizationWhitelist =3D function(regexp) {=0A=
    if (isDefined(regexp)) {=0A=
      $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);=0A=
      return this;=0A=
    } else {=0A=
      return $$sanitizeUriProvider.aHrefSanitizationWhitelist();=0A=
    }=0A=
  };=0A=
=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $compileProvider#imgSrcSanitizationWhitelist=0A=
   * @kind function=0A=
   *=0A=
   * @description=0A=
   * Retrieves or overrides the default regular expression that is used =
for whitelisting of safe=0A=
   * urls during img[src] sanitization.=0A=
   *=0A=
   * The sanitization is a security measure aimed at prevent XSS attacks =
via html links.=0A=
   *=0A=
   * Any url about to be assigned to img[src] via data-binding is first =
normalized and turned into=0A=
   * an absolute url. Afterwards, the url is matched against the =
`imgSrcSanitizationWhitelist`=0A=
   * regular expression. If a match is found, the original url is =
written into the dom. Otherwise,=0A=
   * the absolute url is prefixed with `'unsafe:'` string and only then =
is it written into the DOM.=0A=
   *=0A=
   * @param {RegExp=3D} regexp New regexp to whitelist urls with.=0A=
   * @returns {RegExp|ng.$compileProvider} Current RegExp if called =
without value or self for=0A=
   *    chaining otherwise.=0A=
   */=0A=
  this.imgSrcSanitizationWhitelist =3D function(regexp) {=0A=
    if (isDefined(regexp)) {=0A=
      $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);=0A=
      return this;=0A=
    } else {=0A=
      return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name  $compileProvider#debugInfoEnabled=0A=
   *=0A=
   * @param {boolean=3D} enabled update the debugInfoEnabled state if =
provided, otherwise just return the=0A=
   * current debugInfoEnabled state=0A=
   * @returns {*} current value if used as getter or itself (chaining) =
if used as setter=0A=
   *=0A=
   * @kind function=0A=
   *=0A=
   * @description=0A=
   * Call this method to enable/disable various debug runtime =
information in the compiler such as adding=0A=
   * binding information and a reference to the current scope on to DOM =
elements.=0A=
   * If enabled, the compiler will add the following to DOM elements =
that have been bound to the scope=0A=
   * * `ng-binding` CSS class=0A=
   * * `$binding` data property containing an array of the binding =
expressions=0A=
   *=0A=
   * You may want to disable this in production for a significant =
performance boost. See=0A=
   * {@link guide/production#disabling-debug-data Disabling Debug Data} =
for more.=0A=
   *=0A=
   * The default value is true.=0A=
   */=0A=
  var debugInfoEnabled =3D true;=0A=
  this.debugInfoEnabled =3D function(enabled) {=0A=
    if (isDefined(enabled)) {=0A=
      debugInfoEnabled =3D enabled;=0A=
      return this;=0A=
    }=0A=
    return debugInfoEnabled;=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name  $compileProvider#preAssignBindingsEnabled=0A=
   *=0A=
   * @param {boolean=3D} enabled update the preAssignBindingsEnabled =
state if provided, otherwise just return the=0A=
   * current preAssignBindingsEnabled state=0A=
   * @returns {*} current value if used as getter or itself (chaining) =
if used as setter=0A=
   *=0A=
   * @kind function=0A=
   *=0A=
   * @description=0A=
   * Call this method to enable/disable whether directive controllers =
are assigned bindings before=0A=
   * calling the controller's constructor.=0A=
   * If enabled (true), the compiler assigns the value of each of the =
bindings to the=0A=
   * properties of the controller object before the constructor of this =
object is called.=0A=
   *=0A=
   * If disabled (false), the compiler calls the constructor first =
before assigning bindings.=0A=
   *=0A=
   * The default value is false.=0A=
   *=0A=
   * @deprecated=0A=
   * sinceVersion=3D"1.6.0"=0A=
   * removeVersion=3D"1.7.0"=0A=
   *=0A=
   * This method and the option to assign the bindings before calling =
the controller's constructor=0A=
   * will be removed in v1.7.0.=0A=
   */=0A=
  var preAssignBindingsEnabled =3D false;=0A=
  this.preAssignBindingsEnabled =3D function(enabled) {=0A=
    if (isDefined(enabled)) {=0A=
      preAssignBindingsEnabled =3D enabled;=0A=
      return this;=0A=
    }=0A=
    return preAssignBindingsEnabled;=0A=
  };=0A=
=0A=
=0A=
  var TTL =3D 10;=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $compileProvider#onChangesTtl=0A=
   * @description=0A=
   *=0A=
   * Sets the number of times `$onChanges` hooks can trigger new changes =
before giving up and=0A=
   * assuming that the model is unstable.=0A=
   *=0A=
   * The current default is 10 iterations.=0A=
   *=0A=
   * In complex applications it's possible that dependencies between =
`$onChanges` hooks and bindings will result=0A=
   * in several iterations of calls to these hooks. However if an =
application needs more than the default 10=0A=
   * iterations to stabilize then you should investigate what is causing =
the model to continuously change during=0A=
   * the `$onChanges` hook execution.=0A=
   *=0A=
   * Increasing the TTL could have performance implications, so you =
should not change it without proper justification.=0A=
   *=0A=
   * @param {number} limit The number of `$onChanges` hook iterations.=0A=
   * @returns {number|object} the current limit (or `this` if called as =
a setter for chaining)=0A=
   */=0A=
  this.onChangesTtl =3D function(value) {=0A=
    if (arguments.length) {=0A=
      TTL =3D value;=0A=
      return this;=0A=
    }=0A=
    return TTL;=0A=
  };=0A=
=0A=
  var commentDirectivesEnabledConfig =3D true;=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $compileProvider#commentDirectivesEnabled=0A=
   * @description=0A=
   *=0A=
   * It indicates to the compiler=0A=
   * whether or not directives on comments should be compiled.=0A=
   * Defaults to `true`.=0A=
   *=0A=
   * Calling this function with false disables the compilation of =
directives=0A=
   * on comments for the whole application.=0A=
   * This results in a compilation performance gain,=0A=
   * as the compiler doesn't have to check comments when looking for =
directives.=0A=
   * This should however only be used if you are sure that no comment =
directives are used in=0A=
   * the application (including any 3rd party directives).=0A=
   *=0A=
   * @param {boolean} enabled `false` if the compiler may ignore =
directives on comments=0A=
   * @returns {boolean|object} the current value (or `this` if called as =
a setter for chaining)=0A=
   */=0A=
  this.commentDirectivesEnabled =3D function(value) {=0A=
    if (arguments.length) {=0A=
      commentDirectivesEnabledConfig =3D value;=0A=
      return this;=0A=
    }=0A=
    return commentDirectivesEnabledConfig;=0A=
  };=0A=
=0A=
=0A=
  var cssClassDirectivesEnabledConfig =3D true;=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $compileProvider#cssClassDirectivesEnabled=0A=
   * @description=0A=
   *=0A=
   * It indicates to the compiler=0A=
   * whether or not directives on element classes should be compiled.=0A=
   * Defaults to `true`.=0A=
   *=0A=
   * Calling this function with false disables the compilation of =
directives=0A=
   * on element classes for the whole application.=0A=
   * This results in a compilation performance gain,=0A=
   * as the compiler doesn't have to check element classes when looking =
for directives.=0A=
   * This should however only be used if you are sure that no class =
directives are used in=0A=
   * the application (including any 3rd party directives).=0A=
   *=0A=
   * @param {boolean} enabled `false` if the compiler may ignore =
directives on element classes=0A=
   * @returns {boolean|object} the current value (or `this` if called as =
a setter for chaining)=0A=
   */=0A=
  this.cssClassDirectivesEnabled =3D function(value) {=0A=
    if (arguments.length) {=0A=
      cssClassDirectivesEnabledConfig =3D value;=0A=
      return this;=0A=
    }=0A=
    return cssClassDirectivesEnabledConfig;=0A=
  };=0A=
=0A=
  this.$get =3D [=0A=
            '$injector', '$interpolate', '$exceptionHandler', =
'$templateRequest', '$parse',=0A=
            '$controller', '$rootScope', '$sce', '$animate', =
'$$sanitizeUri',=0A=
    function($injector,   $interpolate,   $exceptionHandler,   =
$templateRequest,   $parse,=0A=
             $controller,   $rootScope,   $sce,   $animate,   =
$$sanitizeUri) {=0A=
=0A=
    var SIMPLE_ATTR_NAME =3D /^\w/;=0A=
    var specialAttrHolder =3D window.document.createElement('div');=0A=
=0A=
=0A=
    var commentDirectivesEnabled =3D commentDirectivesEnabledConfig;=0A=
    var cssClassDirectivesEnabled =3D cssClassDirectivesEnabledConfig;=0A=
=0A=
=0A=
    var onChangesTtl =3D TTL;=0A=
    // The onChanges hooks should all be run together in a single digest=0A=
    // When changes occur, the call to trigger their hooks will be added =
to this queue=0A=
    var onChangesQueue;=0A=
=0A=
    // This function is called in a $$postDigest to trigger all the =
onChanges hooks in a single digest=0A=
    function flushOnChangesQueue() {=0A=
      try {=0A=
        if (!(--onChangesTtl)) {=0A=
          // We have hit the TTL limit so reset everything=0A=
          onChangesQueue =3D undefined;=0A=
          throw $compileMinErr('infchng', '{0} $onChanges() iterations =
reached. Aborting!\n', TTL);=0A=
        }=0A=
        // We must run this hook in an apply since the $$postDigest runs =
outside apply=0A=
        $rootScope.$apply(function() {=0A=
          var errors =3D [];=0A=
          for (var i =3D 0, ii =3D onChangesQueue.length; i &lt; ii; =
++i) {=0A=
            try {=0A=
              onChangesQueue[i]();=0A=
            } catch (e) {=0A=
              errors.push(e);=0A=
            }=0A=
          }=0A=
          // Reset the queue to trigger a new schedule next time there =
is a change=0A=
          onChangesQueue =3D undefined;=0A=
          if (errors.length) {=0A=
            throw errors;=0A=
          }=0A=
        });=0A=
      } finally {=0A=
        onChangesTtl++;=0A=
      }=0A=
    }=0A=
=0A=
=0A=
    function Attributes(element, attributesToCopy) {=0A=
      if (attributesToCopy) {=0A=
        var keys =3D Object.keys(attributesToCopy);=0A=
        var i, l, key;=0A=
=0A=
        for (i =3D 0, l =3D keys.length; i &lt; l; i++) {=0A=
          key =3D keys[i];=0A=
          this[key] =3D attributesToCopy[key];=0A=
        }=0A=
      } else {=0A=
        this.$attr =3D {};=0A=
      }=0A=
=0A=
      this.$$element =3D element;=0A=
    }=0A=
=0A=
    Attributes.prototype =3D {=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $compile.directive.Attributes#$normalize=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Converts an attribute name (e.g. =
dash/colon/underscore-delimited string, optionally prefixed with `x-` or=0A=
       * `data-`) to its normalized, camelCase form.=0A=
       *=0A=
       * Also there is special case for Moz prefix starting with upper =
case letter.=0A=
       *=0A=
       * For further information check out the guide on {@link =
guide/directive#matching-directives Matching Directives}=0A=
       *=0A=
       * @param {string} name Name to normalize=0A=
       */=0A=
      $normalize: directiveNormalize,=0A=
=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $compile.directive.Attributes#$addClass=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Adds the CSS class value specified by the classVal parameter to =
the element. If animations=0A=
       * are enabled then an animation will be triggered for the class =
addition.=0A=
       *=0A=
       * @param {string} classVal The className value that will be added =
to the element=0A=
       */=0A=
      $addClass: function(classVal) {=0A=
        if (classVal &amp;&amp; classVal.length &gt; 0) {=0A=
          $animate.addClass(this.$$element, classVal);=0A=
        }=0A=
      },=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $compile.directive.Attributes#$removeClass=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Removes the CSS class value specified by the classVal parameter =
from the element. If=0A=
       * animations are enabled then an animation will be triggered for =
the class removal.=0A=
       *=0A=
       * @param {string} classVal The className value that will be =
removed from the element=0A=
       */=0A=
      $removeClass: function(classVal) {=0A=
        if (classVal &amp;&amp; classVal.length &gt; 0) {=0A=
          $animate.removeClass(this.$$element, classVal);=0A=
        }=0A=
      },=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $compile.directive.Attributes#$updateClass=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Adds and removes the appropriate CSS class values to the =
element based on the difference=0A=
       * between the new and old CSS class values (specified as =
newClasses and oldClasses).=0A=
       *=0A=
       * @param {string} newClasses The current CSS className value=0A=
       * @param {string} oldClasses The former CSS className value=0A=
       */=0A=
      $updateClass: function(newClasses, oldClasses) {=0A=
        var toAdd =3D tokenDifference(newClasses, oldClasses);=0A=
        if (toAdd &amp;&amp; toAdd.length) {=0A=
          $animate.addClass(this.$$element, toAdd);=0A=
        }=0A=
=0A=
        var toRemove =3D tokenDifference(oldClasses, newClasses);=0A=
        if (toRemove &amp;&amp; toRemove.length) {=0A=
          $animate.removeClass(this.$$element, toRemove);=0A=
        }=0A=
      },=0A=
=0A=
      /**=0A=
       * Set a normalized attribute on the element in a way such that =
all directives=0A=
       * can share the attribute. This function properly handles boolean =
attributes.=0A=
       * @param {string} key Normalized key. (ie ngAttribute)=0A=
       * @param {string|boolean} value The value to set. If `null` =
attribute will be deleted.=0A=
       * @param {boolean=3D} writeAttr If false, does not write the =
value to DOM element attribute.=0A=
       *     Defaults to true.=0A=
       * @param {string=3D} attrName Optional none normalized name. =
Defaults to key.=0A=
       */=0A=
      $set: function(key, value, writeAttr, attrName) {=0A=
        // TODO: decide whether or not to throw an error if "class"=0A=
        //is set through this function since it may cause $updateClass to=0A=
        //become unstable.=0A=
=0A=
        var node =3D this.$$element[0],=0A=
            booleanKey =3D getBooleanAttrName(node, key),=0A=
            aliasedKey =3D getAliasedAttrName(key),=0A=
            observer =3D key,=0A=
            nodeName;=0A=
=0A=
        if (booleanKey) {=0A=
          this.$$element.prop(key, value);=0A=
          attrName =3D booleanKey;=0A=
        } else if (aliasedKey) {=0A=
          this[aliasedKey] =3D value;=0A=
          observer =3D aliasedKey;=0A=
        }=0A=
=0A=
        this[key] =3D value;=0A=
=0A=
        // translate normalized key to actual key=0A=
        if (attrName) {=0A=
          this.$attr[key] =3D attrName;=0A=
        } else {=0A=
          attrName =3D this.$attr[key];=0A=
          if (!attrName) {=0A=
            this.$attr[key] =3D attrName =3D snake_case(key, '-');=0A=
          }=0A=
        }=0A=
=0A=
        nodeName =3D nodeName_(this.$$element);=0A=
=0A=
        if ((nodeName =3D=3D=3D 'a' &amp;&amp; (key =3D=3D=3D 'href' || =
key =3D=3D=3D 'xlinkHref')) ||=0A=
            (nodeName =3D=3D=3D 'img' &amp;&amp; key =3D=3D=3D 'src')) {=0A=
          // sanitize a[href] and img[src] values=0A=
          this[key] =3D value =3D $$sanitizeUri(value, key =3D=3D=3D =
'src');=0A=
        } else if (nodeName =3D=3D=3D 'img' &amp;&amp; key =3D=3D=3D =
'srcset' &amp;&amp; isDefined(value)) {=0A=
          // sanitize img[srcset] values=0A=
          var result =3D '';=0A=
=0A=
          // first check if there are spaces because it's not the same =
pattern=0A=
          var trimmedSrcset =3D trim(value);=0A=
          //                (   999x   ,|   999w   ,|   ,|,   )=0A=
          var srcPattern =3D /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;=0A=
          var pattern =3D /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;=0A=
=0A=
          // split srcset into tuple of uri and descriptor except for =
the last item=0A=
          var rawUris =3D trimmedSrcset.split(pattern);=0A=
=0A=
          // for each tuples=0A=
          var nbrUrisWith2parts =3D Math.floor(rawUris.length / 2);=0A=
          for (var i =3D 0; i &lt; nbrUrisWith2parts; i++) {=0A=
            var innerIdx =3D i * 2;=0A=
            // sanitize the uri=0A=
            result +=3D $$sanitizeUri(trim(rawUris[innerIdx]), true);=0A=
            // add the descriptor=0A=
            result +=3D (' ' + trim(rawUris[innerIdx + 1]));=0A=
          }=0A=
=0A=
          // split the last item into uri and descriptor=0A=
          var lastTuple =3D trim(rawUris[i * 2]).split(/\s/);=0A=
=0A=
          // sanitize the last uri=0A=
          result +=3D $$sanitizeUri(trim(lastTuple[0]), true);=0A=
=0A=
          // and add the last descriptor if any=0A=
          if (lastTuple.length =3D=3D=3D 2) {=0A=
            result +=3D (' ' + trim(lastTuple[1]));=0A=
          }=0A=
          this[key] =3D value =3D result;=0A=
        }=0A=
=0A=
        if (writeAttr !=3D=3D false) {=0A=
          if (value =3D=3D=3D null || isUndefined(value)) {=0A=
            this.$$element.removeAttr(attrName);=0A=
          } else {=0A=
            if (SIMPLE_ATTR_NAME.test(attrName)) {=0A=
              this.$$element.attr(attrName, value);=0A=
            } else {=0A=
              setSpecialAttr(this.$$element[0], attrName, value);=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        // fire observers=0A=
        var $$observers =3D this.$$observers;=0A=
        if ($$observers) {=0A=
          forEach($$observers[observer], function(fn) {=0A=
            try {=0A=
              fn(value);=0A=
            } catch (e) {=0A=
              $exceptionHandler(e);=0A=
            }=0A=
          });=0A=
        }=0A=
      },=0A=
=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $compile.directive.Attributes#$observe=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Observes an interpolated attribute.=0A=
       *=0A=
       * The observer function will be invoked once during the next =
`$digest` following=0A=
       * compilation. The observer is then invoked whenever the =
interpolated value=0A=
       * changes.=0A=
       *=0A=
       * @param {string} key Normalized key. (ie ngAttribute) .=0A=
       * @param {function(interpolatedValue)} fn Function that will be =
called whenever=0A=
                the interpolated value of the attribute changes.=0A=
       *        See the {@link =
guide/interpolation#how-text-and-attribute-bindings-work Interpolation=0A=
       *        guide} for more info.=0A=
       * @returns {function()} Returns a deregistration function for =
this observer.=0A=
       */=0A=
      $observe: function(key, fn) {=0A=
        var attrs =3D this,=0A=
            $$observers =3D (attrs.$$observers || (attrs.$$observers =3D =
createMap())),=0A=
            listeners =3D ($$observers[key] || ($$observers[key] =3D =
[]));=0A=
=0A=
        listeners.push(fn);=0A=
        $rootScope.$evalAsync(function() {=0A=
          if (!listeners.$$inter &amp;&amp; attrs.hasOwnProperty(key) =
&amp;&amp; !isUndefined(attrs[key])) {=0A=
            // no one registered attribute interpolation function, so =
lets call it manually=0A=
            fn(attrs[key]);=0A=
          }=0A=
        });=0A=
=0A=
        return function() {=0A=
          arrayRemove(listeners, fn);=0A=
        };=0A=
      }=0A=
    };=0A=
=0A=
    function setSpecialAttr(element, attrName, value) {=0A=
      // Attributes names that do not start with letters (such as =
`(click)`) cannot be set using `setAttribute`=0A=
      // so we have to jump through some hoops to get such an attribute=0A=
      // https://github.com/angular/angular.js/pull/13318=0A=
      specialAttrHolder.innerHTML =3D '&lt;span ' + attrName + '&gt;';=0A=
      var attributes =3D specialAttrHolder.firstChild.attributes;=0A=
      var attribute =3D attributes[0];=0A=
      // We have to remove the attribute from its container element =
before we can add it to the destination element=0A=
      attributes.removeNamedItem(attribute.name);=0A=
      attribute.value =3D value;=0A=
      element.attributes.setNamedItem(attribute);=0A=
    }=0A=
=0A=
    function safeAddClass($element, className) {=0A=
      try {=0A=
        $element.addClass(className);=0A=
      } catch (e) {=0A=
        // ignore, since it means that we are trying to set class on=0A=
        // SVG element, where class name is read-only.=0A=
      }=0A=
    }=0A=
=0A=
=0A=
    var startSymbol =3D $interpolate.startSymbol(),=0A=
        endSymbol =3D $interpolate.endSymbol(),=0A=
        denormalizeTemplate =3D (startSymbol =3D=3D=3D '{{' &amp;&amp; =
endSymbol  =3D=3D=3D '}}')=0A=
            ? identity=0A=
            : function denormalizeTemplate(template) {=0A=
              return template.replace(/\{\{/g, =
startSymbol).replace(/}}/g, endSymbol);=0A=
        },=0A=
        NG_ATTR_BINDING =3D /^ngAttr[A-Z]/;=0A=
    var MULTI_ELEMENT_DIR_RE =3D /^(.+)Start$/;=0A=
=0A=
    compile.$$addBindingInfo =3D debugInfoEnabled ? function =
$$addBindingInfo($element, binding) {=0A=
      var bindings =3D $element.data('$binding') || [];=0A=
=0A=
      if (isArray(binding)) {=0A=
        bindings =3D bindings.concat(binding);=0A=
      } else {=0A=
        bindings.push(binding);=0A=
      }=0A=
=0A=
      $element.data('$binding', bindings);=0A=
    } : noop;=0A=
=0A=
    compile.$$addBindingClass =3D debugInfoEnabled ? function =
$$addBindingClass($element) {=0A=
      safeAddClass($element, 'ng-binding');=0A=
    } : noop;=0A=
=0A=
    compile.$$addScopeInfo =3D debugInfoEnabled ? function =
$$addScopeInfo($element, scope, isolated, noTemplate) {=0A=
      var dataName =3D isolated ? (noTemplate ? =
'$isolateScopeNoTemplate' : '$isolateScope') : '$scope';=0A=
      $element.data(dataName, scope);=0A=
    } : noop;=0A=
=0A=
    compile.$$addScopeClass =3D debugInfoEnabled ? function =
$$addScopeClass($element, isolated) {=0A=
      safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');=0A=
    } : noop;=0A=
=0A=
    compile.$$createComment =3D function(directiveName, comment) {=0A=
      var content =3D '';=0A=
      if (debugInfoEnabled) {=0A=
        content =3D ' ' + (directiveName || '') + ': ';=0A=
        if (comment) content +=3D comment + ' ';=0A=
      }=0A=
      return window.document.createComment(content);=0A=
    };=0A=
=0A=
    return compile;=0A=
=0A=
    =
//=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=0A=
=0A=
    function compile($compileNodes, transcludeFn, maxPriority, =
ignoreDirective,=0A=
                        previousCompileContext) {=0A=
      if (!($compileNodes instanceof jqLite)) {=0A=
        // jquery always rewraps, whereas we need to preserve the =
original selector so that we can=0A=
        // modify it.=0A=
        $compileNodes =3D jqLite($compileNodes);=0A=
      }=0A=
      var compositeLinkFn =3D=0A=
              compileNodes($compileNodes, transcludeFn, $compileNodes,=0A=
                           maxPriority, ignoreDirective, =
previousCompileContext);=0A=
      compile.$$addScopeClass($compileNodes);=0A=
      var namespace =3D null;=0A=
      return function publicLinkFn(scope, cloneConnectFn, options) {=0A=
        if (!$compileNodes) {=0A=
          throw $compileMinErr('multilink', 'This element has already =
been linked.');=0A=
        }=0A=
        assertArg(scope, 'scope');=0A=
=0A=
        if (previousCompileContext &amp;&amp; =
previousCompileContext.needsNewScope) {=0A=
          // A parent directive did a replace and a directive on this =
element asked=0A=
          // for transclusion, which caused us to lose a layer of =
element on which=0A=
          // we could hold the new transclusion scope, so we will create =
it manually=0A=
          // here.=0A=
          scope =3D scope.$parent.$new();=0A=
        }=0A=
=0A=
        options =3D options || {};=0A=
        var parentBoundTranscludeFn =3D options.parentBoundTranscludeFn,=0A=
          transcludeControllers =3D options.transcludeControllers,=0A=
          futureParentElement =3D options.futureParentElement;=0A=
=0A=
        // When `parentBoundTranscludeFn` is passed, it is a=0A=
        // `controllersBoundTransclude` function (it was previously =
passed=0A=
        // as `transclude` to directive.link) so we must unwrap it to get=0A=
        // its `boundTranscludeFn`=0A=
        if (parentBoundTranscludeFn &amp;&amp; =
parentBoundTranscludeFn.$$boundTransclude) {=0A=
          parentBoundTranscludeFn =3D =
parentBoundTranscludeFn.$$boundTransclude;=0A=
        }=0A=
=0A=
        if (!namespace) {=0A=
          namespace =3D =
detectNamespaceForChildElements(futureParentElement);=0A=
        }=0A=
        var $linkNode;=0A=
        if (namespace !=3D=3D 'html') {=0A=
          // When using a directive with replace:true and templateUrl =
the $compileNodes=0A=
          // (or a child element inside of them)=0A=
          // might change, so we need to recreate the namespace adapted =
compileNodes=0A=
          // for call to the link function.=0A=
          // Note: This will already clone the nodes...=0A=
          $linkNode =3D jqLite(=0A=
            wrapTemplate(namespace, =
jqLite('&lt;div&gt;').append($compileNodes).html())=0A=
          );=0A=
        } else if (cloneConnectFn) {=0A=
          // important!!: we must call our jqLite.clone() since the =
jQuery one is trying to be smart=0A=
          // and sometimes changes the structure of the DOM.=0A=
          $linkNode =3D JQLitePrototype.clone.call($compileNodes);=0A=
        } else {=0A=
          $linkNode =3D $compileNodes;=0A=
        }=0A=
=0A=
        if (transcludeControllers) {=0A=
          for (var controllerName in transcludeControllers) {=0A=
            $linkNode.data('$' + controllerName + 'Controller', =
transcludeControllers[controllerName].instance);=0A=
          }=0A=
        }=0A=
=0A=
        compile.$$addScopeInfo($linkNode, scope);=0A=
=0A=
        if (cloneConnectFn) cloneConnectFn($linkNode, scope);=0A=
        if (compositeLinkFn) compositeLinkFn(scope, $linkNode, =
$linkNode, parentBoundTranscludeFn);=0A=
=0A=
        if (!cloneConnectFn) {=0A=
          $compileNodes =3D compositeLinkFn =3D null;=0A=
        }=0A=
        return $linkNode;=0A=
      };=0A=
    }=0A=
=0A=
    function detectNamespaceForChildElements(parentElement) {=0A=
      // TODO: Make this detect MathML as well...=0A=
      var node =3D parentElement &amp;&amp; parentElement[0];=0A=
      if (!node) {=0A=
        return 'html';=0A=
      } else {=0A=
        return nodeName_(node) !=3D=3D 'foreignobject' &amp;&amp; =
toString.call(node).match(/SVG/) ? 'svg' : 'html';=0A=
      }=0A=
    }=0A=
=0A=
    /**=0A=
     * Compile function matches each node in nodeList against the =
directives. Once all directives=0A=
     * for a particular node are collected their compile functions are =
executed. The compile=0A=
     * functions return values - the linking functions - are combined =
into a composite linking=0A=
     * function, which is the a linking function for the node.=0A=
     *=0A=
     * @param {NodeList} nodeList an array of nodes or NodeList to =
compile=0A=
     * @param {function(angular.Scope, cloneAttachFn=3D)} transcludeFn A =
linking function, where the=0A=
     *        scope argument is auto-generated to the new child of the =
transcluded parent scope.=0A=
     * @param {DOMElement=3D} $rootElement If the nodeList is the root =
of the compilation tree then=0A=
     *        the rootElement must be set the jqLite collection of the =
compile root. This is=0A=
     *        needed so that the jqLite collection items can be replaced =
with widgets.=0A=
     * @param {number=3D} maxPriority Max directive priority.=0A=
     * @returns {Function} A composite linking function of all of the =
matched directives or null.=0A=
     */=0A=
    function compileNodes(nodeList, transcludeFn, $rootElement, =
maxPriority, ignoreDirective,=0A=
                            previousCompileContext) {=0A=
      var linkFns =3D [],=0A=
          // `nodeList` can be either an element's `.childNodes` (live =
NodeList)=0A=
          // or a jqLite/jQuery collection or an array=0A=
          notLiveList =3D isArray(nodeList) || (nodeList instanceof =
jqLite),=0A=
          attrs, directives, nodeLinkFn, childNodes, childLinkFn, =
linkFnFound, nodeLinkFnFound;=0A=
=0A=
=0A=
      for (var i =3D 0; i &lt; nodeList.length; i++) {=0A=
        attrs =3D new Attributes();=0A=
=0A=
        // Support: IE 11 only=0A=
        // Workaround for #11781 and #14924=0A=
        if (msie =3D=3D=3D 11) {=0A=
          mergeConsecutiveTextNodes(nodeList, i, notLiveList);=0A=
        }=0A=
=0A=
        // We must always refer to `nodeList[i]` hereafter,=0A=
        // since the nodes can be replaced underneath us.=0A=
        directives =3D collectDirectives(nodeList[i], [], attrs, i =
=3D=3D=3D 0 ? maxPriority : undefined,=0A=
                                        ignoreDirective);=0A=
=0A=
        nodeLinkFn =3D (directives.length)=0A=
            ? applyDirectivesToNode(directives, nodeList[i], attrs, =
transcludeFn, $rootElement,=0A=
                                      null, [], [], =
previousCompileContext)=0A=
            : null;=0A=
=0A=
        if (nodeLinkFn &amp;&amp; nodeLinkFn.scope) {=0A=
          compile.$$addScopeClass(attrs.$$element);=0A=
        }=0A=
=0A=
        childLinkFn =3D (nodeLinkFn &amp;&amp; nodeLinkFn.terminal ||=0A=
                      !(childNodes =3D nodeList[i].childNodes) ||=0A=
                      !childNodes.length)=0A=
            ? null=0A=
            : compileNodes(childNodes,=0A=
                 nodeLinkFn ? (=0A=
                  (nodeLinkFn.transcludeOnThisElement || =
!nodeLinkFn.templateOnThisElement)=0A=
                     &amp;&amp; nodeLinkFn.transclude) : transcludeFn);=0A=
=0A=
        if (nodeLinkFn || childLinkFn) {=0A=
          linkFns.push(i, nodeLinkFn, childLinkFn);=0A=
          linkFnFound =3D true;=0A=
          nodeLinkFnFound =3D nodeLinkFnFound || nodeLinkFn;=0A=
        }=0A=
=0A=
        //use the previous context only for the first element in the =
virtual group=0A=
        previousCompileContext =3D null;=0A=
      }=0A=
=0A=
      // return a linking function if we have found anything, null =
otherwise=0A=
      return linkFnFound ? compositeLinkFn : null;=0A=
=0A=
      function compositeLinkFn(scope, nodeList, $rootElement, =
parentBoundTranscludeFn) {=0A=
        var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, =
childBoundTranscludeFn;=0A=
        var stableNodeList;=0A=
=0A=
=0A=
        if (nodeLinkFnFound) {=0A=
          // copy nodeList so that if a nodeLinkFn removes or adds an =
element at this DOM level our=0A=
          // offsets don't get screwed up=0A=
          var nodeListLength =3D nodeList.length;=0A=
          stableNodeList =3D new Array(nodeListLength);=0A=
=0A=
          // create a sparse array by only copying the elements which =
have a linkFn=0A=
          for (i =3D 0; i &lt; linkFns.length; i +=3D 3) {=0A=
            idx =3D linkFns[i];=0A=
            stableNodeList[idx] =3D nodeList[idx];=0A=
          }=0A=
        } else {=0A=
          stableNodeList =3D nodeList;=0A=
        }=0A=
=0A=
        for (i =3D 0, ii =3D linkFns.length; i &lt; ii;) {=0A=
          node =3D stableNodeList[linkFns[i++]];=0A=
          nodeLinkFn =3D linkFns[i++];=0A=
          childLinkFn =3D linkFns[i++];=0A=
=0A=
          if (nodeLinkFn) {=0A=
            if (nodeLinkFn.scope) {=0A=
              childScope =3D scope.$new();=0A=
              compile.$$addScopeInfo(jqLite(node), childScope);=0A=
            } else {=0A=
              childScope =3D scope;=0A=
            }=0A=
=0A=
            if (nodeLinkFn.transcludeOnThisElement) {=0A=
              childBoundTranscludeFn =3D createBoundTranscludeFn(=0A=
                  scope, nodeLinkFn.transclude, parentBoundTranscludeFn);=0A=
=0A=
            } else if (!nodeLinkFn.templateOnThisElement &amp;&amp; =
parentBoundTranscludeFn) {=0A=
              childBoundTranscludeFn =3D parentBoundTranscludeFn;=0A=
=0A=
            } else if (!parentBoundTranscludeFn &amp;&amp; transcludeFn) =
{=0A=
              childBoundTranscludeFn =3D createBoundTranscludeFn(scope, =
transcludeFn);=0A=
=0A=
            } else {=0A=
              childBoundTranscludeFn =3D null;=0A=
            }=0A=
=0A=
            nodeLinkFn(childLinkFn, childScope, node, $rootElement, =
childBoundTranscludeFn);=0A=
=0A=
          } else if (childLinkFn) {=0A=
            childLinkFn(scope, node.childNodes, undefined, =
parentBoundTranscludeFn);=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    function mergeConsecutiveTextNodes(nodeList, idx, notLiveList) {=0A=
      var node =3D nodeList[idx];=0A=
      var parent =3D node.parentNode;=0A=
      var sibling;=0A=
=0A=
      if (node.nodeType !=3D=3D NODE_TYPE_TEXT) {=0A=
        return;=0A=
      }=0A=
=0A=
      while (true) {=0A=
        sibling =3D parent ? node.nextSibling : nodeList[idx + 1];=0A=
        if (!sibling || sibling.nodeType !=3D=3D NODE_TYPE_TEXT) {=0A=
          break;=0A=
        }=0A=
=0A=
        node.nodeValue =3D node.nodeValue + sibling.nodeValue;=0A=
=0A=
        if (sibling.parentNode) {=0A=
          sibling.parentNode.removeChild(sibling);=0A=
        }=0A=
        if (notLiveList &amp;&amp; sibling =3D=3D=3D nodeList[idx + 1]) {=0A=
          nodeList.splice(idx + 1, 1);=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    function createBoundTranscludeFn(scope, transcludeFn, =
previousBoundTranscludeFn) {=0A=
      function boundTranscludeFn(transcludedScope, cloneFn, controllers, =
futureParentElement, containingScope) {=0A=
=0A=
        if (!transcludedScope) {=0A=
          transcludedScope =3D scope.$new(false, containingScope);=0A=
          transcludedScope.$$transcluded =3D true;=0A=
        }=0A=
=0A=
        return transcludeFn(transcludedScope, cloneFn, {=0A=
          parentBoundTranscludeFn: previousBoundTranscludeFn,=0A=
          transcludeControllers: controllers,=0A=
          futureParentElement: futureParentElement=0A=
        });=0A=
      }=0A=
=0A=
      // We need  to attach the transclusion slots onto the =
`boundTranscludeFn`=0A=
      // so that they are available inside the =
`controllersBoundTransclude` function=0A=
      var boundSlots =3D boundTranscludeFn.$$slots =3D createMap();=0A=
      for (var slotName in transcludeFn.$$slots) {=0A=
        if (transcludeFn.$$slots[slotName]) {=0A=
          boundSlots[slotName] =3D createBoundTranscludeFn(scope, =
transcludeFn.$$slots[slotName], previousBoundTranscludeFn);=0A=
        } else {=0A=
          boundSlots[slotName] =3D null;=0A=
        }=0A=
      }=0A=
=0A=
      return boundTranscludeFn;=0A=
    }=0A=
=0A=
    /**=0A=
     * Looks for directives on the given node and adds them to the =
directive collection which is=0A=
     * sorted.=0A=
     *=0A=
     * @param node Node to search.=0A=
     * @param directives An array to which the directives are added to. =
This array is sorted before=0A=
     *        the function returns.=0A=
     * @param attrs The shared attrs object which is used to populate =
the normalized attributes.=0A=
     * @param {number=3D} maxPriority Max directive priority.=0A=
     */=0A=
    function collectDirectives(node, directives, attrs, maxPriority, =
ignoreDirective) {=0A=
      var nodeType =3D node.nodeType,=0A=
          attrsMap =3D attrs.$attr,=0A=
          match,=0A=
          nodeName,=0A=
          className;=0A=
=0A=
      switch (nodeType) {=0A=
        case NODE_TYPE_ELEMENT: /* Element */=0A=
=0A=
          nodeName =3D nodeName_(node);=0A=
=0A=
          // use the node name: &lt;directive&gt;=0A=
          addDirective(directives,=0A=
              directiveNormalize(nodeName), 'E', maxPriority, =
ignoreDirective);=0A=
=0A=
          // iterate over the attributes=0A=
          for (var attr, name, nName, ngAttrName, value, isNgAttr, =
nAttrs =3D node.attributes,=0A=
                   j =3D 0, jj =3D nAttrs &amp;&amp; nAttrs.length; j =
&lt; jj; j++) {=0A=
            var attrStartName =3D false;=0A=
            var attrEndName =3D false;=0A=
=0A=
            attr =3D nAttrs[j];=0A=
            name =3D attr.name;=0A=
            value =3D attr.value;=0A=
=0A=
            // support ngAttr attribute binding=0A=
            ngAttrName =3D directiveNormalize(name);=0A=
            isNgAttr =3D NG_ATTR_BINDING.test(ngAttrName);=0A=
            if (isNgAttr) {=0A=
              name =3D name.replace(PREFIX_REGEXP, '')=0A=
                .substr(8).replace(/_(.)/g, function(match, letter) {=0A=
                  return letter.toUpperCase();=0A=
                });=0A=
            }=0A=
=0A=
            var multiElementMatch =3D =
ngAttrName.match(MULTI_ELEMENT_DIR_RE);=0A=
            if (multiElementMatch &amp;&amp; =
directiveIsMultiElement(multiElementMatch[1])) {=0A=
              attrStartName =3D name;=0A=
              attrEndName =3D name.substr(0, name.length - 5) + 'end';=0A=
              name =3D name.substr(0, name.length - 6);=0A=
            }=0A=
=0A=
            nName =3D directiveNormalize(name.toLowerCase());=0A=
            attrsMap[nName] =3D name;=0A=
            if (isNgAttr || !attrs.hasOwnProperty(nName)) {=0A=
                attrs[nName] =3D value;=0A=
                if (getBooleanAttrName(node, nName)) {=0A=
                  attrs[nName] =3D true; // presence means true=0A=
                }=0A=
            }=0A=
            addAttrInterpolateDirective(node, directives, value, nName, =
isNgAttr);=0A=
            addDirective(directives, nName, 'A', maxPriority, =
ignoreDirective, attrStartName,=0A=
                          attrEndName);=0A=
          }=0A=
=0A=
          if (nodeName =3D=3D=3D 'input' &amp;&amp; =
node.getAttribute('type') =3D=3D=3D 'hidden') {=0A=
            // Hidden input elements can have strange behaviour when =
navigating back to the page=0A=
            // This tells the browser not to try to cache and reinstate =
previous values=0A=
            node.setAttribute('autocomplete', 'off');=0A=
          }=0A=
=0A=
          // use class as directive=0A=
          if (!cssClassDirectivesEnabled) break;=0A=
          className =3D node.className;=0A=
          if (isObject(className)) {=0A=
              // Maybe SVGAnimatedString=0A=
              className =3D className.animVal;=0A=
          }=0A=
          if (isString(className) &amp;&amp; className !=3D=3D '') {=0A=
            while ((match =3D CLASS_DIRECTIVE_REGEXP.exec(className))) {=0A=
              nName =3D directiveNormalize(match[2]);=0A=
              if (addDirective(directives, nName, 'C', maxPriority, =
ignoreDirective)) {=0A=
                attrs[nName] =3D trim(match[3]);=0A=
              }=0A=
              className =3D className.substr(match.index + =
match[0].length);=0A=
            }=0A=
          }=0A=
          break;=0A=
        case NODE_TYPE_TEXT: /* Text Node */=0A=
          addTextInterpolateDirective(directives, node.nodeValue);=0A=
          break;=0A=
        case NODE_TYPE_COMMENT: /* Comment */=0A=
          if (!commentDirectivesEnabled) break;=0A=
          collectCommentDirectives(node, directives, attrs, maxPriority, =
ignoreDirective);=0A=
          break;=0A=
      }=0A=
=0A=
      directives.sort(byPriority);=0A=
      return directives;=0A=
    }=0A=
=0A=
    function collectCommentDirectives(node, directives, attrs, =
maxPriority, ignoreDirective) {=0A=
      // function created because of performance, try/catch disables=0A=
      // the optimization of the whole function #14848=0A=
      try {=0A=
        var match =3D COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);=0A=
        if (match) {=0A=
          var nName =3D directiveNormalize(match[1]);=0A=
          if (addDirective(directives, nName, 'M', maxPriority, =
ignoreDirective)) {=0A=
            attrs[nName] =3D trim(match[2]);=0A=
          }=0A=
        }=0A=
      } catch (e) {=0A=
        // turns out that under some circumstances IE9 throws errors =
when one attempts to read=0A=
        // comment's node value.=0A=
        // Just ignore it and continue. (Can't seem to reproduce in test =
case.)=0A=
      }=0A=
    }=0A=
=0A=
    /**=0A=
     * Given a node with a directive-start it collects all of the =
siblings until it finds=0A=
     * directive-end.=0A=
     * @param node=0A=
     * @param attrStart=0A=
     * @param attrEnd=0A=
     * @returns {*}=0A=
     */=0A=
    function groupScan(node, attrStart, attrEnd) {=0A=
      var nodes =3D [];=0A=
      var depth =3D 0;=0A=
      if (attrStart &amp;&amp; node.hasAttribute &amp;&amp; =
node.hasAttribute(attrStart)) {=0A=
        do {=0A=
          if (!node) {=0A=
            throw $compileMinErr('uterdir',=0A=
                      'Unterminated attribute, found \'{0}\' but no =
matching \'{1}\' found.',=0A=
                      attrStart, attrEnd);=0A=
          }=0A=
          if (node.nodeType =3D=3D=3D NODE_TYPE_ELEMENT) {=0A=
            if (node.hasAttribute(attrStart)) depth++;=0A=
            if (node.hasAttribute(attrEnd)) depth--;=0A=
          }=0A=
          nodes.push(node);=0A=
          node =3D node.nextSibling;=0A=
        } while (depth &gt; 0);=0A=
      } else {=0A=
        nodes.push(node);=0A=
      }=0A=
=0A=
      return jqLite(nodes);=0A=
    }=0A=
=0A=
    /**=0A=
     * Wrapper for linking function which converts normal linking =
function into a grouped=0A=
     * linking function.=0A=
     * @param linkFn=0A=
     * @param attrStart=0A=
     * @param attrEnd=0A=
     * @returns {Function}=0A=
     */=0A=
    function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {=0A=
      return function groupedElementsLink(scope, element, attrs, =
controllers, transcludeFn) {=0A=
        element =3D groupScan(element[0], attrStart, attrEnd);=0A=
        return linkFn(scope, element, attrs, controllers, transcludeFn);=0A=
      };=0A=
    }=0A=
=0A=
    /**=0A=
     * A function generator that is used to support both eager and lazy =
compilation=0A=
     * linking function.=0A=
     * @param eager=0A=
     * @param $compileNodes=0A=
     * @param transcludeFn=0A=
     * @param maxPriority=0A=
     * @param ignoreDirective=0A=
     * @param previousCompileContext=0A=
     * @returns {Function}=0A=
     */=0A=
    function compilationGenerator(eager, $compileNodes, transcludeFn, =
maxPriority, ignoreDirective, previousCompileContext) {=0A=
      var compiled;=0A=
=0A=
      if (eager) {=0A=
        return compile($compileNodes, transcludeFn, maxPriority, =
ignoreDirective, previousCompileContext);=0A=
      }=0A=
      return /** @this */ function lazyCompilation() {=0A=
        if (!compiled) {=0A=
          compiled =3D compile($compileNodes, transcludeFn, maxPriority, =
ignoreDirective, previousCompileContext);=0A=
=0A=
          // Null out all of these references in order to make them =
eligible for garbage collection=0A=
          // since this is a potentially long lived closure=0A=
          $compileNodes =3D transcludeFn =3D previousCompileContext =3D =
null;=0A=
        }=0A=
        return compiled.apply(this, arguments);=0A=
      };=0A=
    }=0A=
=0A=
    /**=0A=
     * Once the directives have been collected, their compile functions =
are executed. This method=0A=
     * is responsible for inlining directive templates as well as =
terminating the application=0A=
     * of the directives if the terminal directive has been reached.=0A=
     *=0A=
     * @param {Array} directives Array of collected directives to =
execute their compile function.=0A=
     *        this needs to be pre-sorted by priority order.=0A=
     * @param {Node} compileNode The raw DOM node to apply the compile =
functions to=0A=
     * @param {Object} templateAttrs The shared attribute function=0A=
     * @param {function(angular.Scope, cloneAttachFn=3D)} transcludeFn A =
linking function, where the=0A=
     *                                                  scope argument =
is auto-generated to the new=0A=
     *                                                  child of the =
transcluded parent scope.=0A=
     * @param {JQLite} jqCollection If we are working on the root of the =
compile tree then this=0A=
     *                              argument has the root jqLite array =
so that we can replace nodes=0A=
     *                              on it.=0A=
     * @param {Object=3D} originalReplaceDirective An optional directive =
that will be ignored when=0A=
     *                                           compiling the =
transclusion.=0A=
     * @param {Array.&lt;Function&gt;} preLinkFns=0A=
     * @param {Array.&lt;Function&gt;} postLinkFns=0A=
     * @param {Object} previousCompileContext Context used for previous =
compilation of the current=0A=
     *                                        node=0A=
     * @returns {Function} linkFn=0A=
     */=0A=
    function applyDirectivesToNode(directives, compileNode, =
templateAttrs, transcludeFn,=0A=
                                   jqCollection, =
originalReplaceDirective, preLinkFns, postLinkFns,=0A=
                                   previousCompileContext) {=0A=
      previousCompileContext =3D previousCompileContext || {};=0A=
=0A=
      var terminalPriority =3D -Number.MAX_VALUE,=0A=
          newScopeDirective =3D previousCompileContext.newScopeDirective,=0A=
          controllerDirectives =3D =
previousCompileContext.controllerDirectives,=0A=
          newIsolateScopeDirective =3D =
previousCompileContext.newIsolateScopeDirective,=0A=
          templateDirective =3D previousCompileContext.templateDirective,=0A=
          nonTlbTranscludeDirective =3D =
previousCompileContext.nonTlbTranscludeDirective,=0A=
          hasTranscludeDirective =3D false,=0A=
          hasTemplate =3D false,=0A=
          hasElementTranscludeDirective =3D =
previousCompileContext.hasElementTranscludeDirective,=0A=
          $compileNode =3D templateAttrs.$$element =3D =
jqLite(compileNode),=0A=
          directive,=0A=
          directiveName,=0A=
          $template,=0A=
          replaceDirective =3D originalReplaceDirective,=0A=
          childTranscludeFn =3D transcludeFn,=0A=
          linkFn,=0A=
          didScanForMultipleTransclusion =3D false,=0A=
          mightHaveMultipleTransclusionError =3D false,=0A=
          directiveValue;=0A=
=0A=
      // executes all directives on the current element=0A=
      for (var i =3D 0, ii =3D directives.length; i &lt; ii; i++) {=0A=
        directive =3D directives[i];=0A=
        var attrStart =3D directive.$$start;=0A=
        var attrEnd =3D directive.$$end;=0A=
=0A=
        // collect multiblock sections=0A=
        if (attrStart) {=0A=
          $compileNode =3D groupScan(compileNode, attrStart, attrEnd);=0A=
        }=0A=
        $template =3D undefined;=0A=
=0A=
        if (terminalPriority &gt; directive.priority) {=0A=
          break; // prevent further processing of directives=0A=
        }=0A=
=0A=
        directiveValue =3D directive.scope;=0A=
=0A=
        if (directiveValue) {=0A=
=0A=
          // skip the check for directives with async templates, we'll =
check the derived sync=0A=
          // directive when the template arrives=0A=
          if (!directive.templateUrl) {=0A=
            if (isObject(directiveValue)) {=0A=
              // This directive is trying to add an isolated scope.=0A=
              // Check that there is no scope of any kind already=0A=
              assertNoDuplicate('new/isolated scope', =
newIsolateScopeDirective || newScopeDirective,=0A=
                                directive, $compileNode);=0A=
              newIsolateScopeDirective =3D directive;=0A=
            } else {=0A=
              // This directive is trying to add a child scope.=0A=
              // Check that there is no isolated scope already=0A=
              assertNoDuplicate('new/isolated scope', =
newIsolateScopeDirective, directive,=0A=
                                $compileNode);=0A=
            }=0A=
          }=0A=
=0A=
          newScopeDirective =3D newScopeDirective || directive;=0A=
        }=0A=
=0A=
        directiveName =3D directive.name;=0A=
=0A=
        // If we encounter a condition that can result in transclusion =
on the directive,=0A=
        // then scan ahead in the remaining directives for others that =
may cause a multiple=0A=
        // transclusion error to be thrown during the compilation =
process.  If a matching directive=0A=
        // is found, then we know that when we encounter a transcluded =
directive, we need to eagerly=0A=
        // compile the `transclude` function rather than doing it lazily =
in order to throw=0A=
        // exceptions at the correct time=0A=
        if (!didScanForMultipleTransclusion &amp;&amp; =
((directive.replace &amp;&amp; (directive.templateUrl || =
directive.template))=0A=
            || (directive.transclude &amp;&amp; !directive.$$tlb))) {=0A=
                var candidateDirective;=0A=
=0A=
                for (var scanningIndex =3D i + 1; (candidateDirective =
=3D directives[scanningIndex++]);) {=0A=
                    if ((candidateDirective.transclude &amp;&amp; =
!candidateDirective.$$tlb)=0A=
                        || (candidateDirective.replace &amp;&amp; =
(candidateDirective.templateUrl || candidateDirective.template))) {=0A=
                        mightHaveMultipleTransclusionError =3D true;=0A=
                        break;=0A=
                    }=0A=
                }=0A=
=0A=
                didScanForMultipleTransclusion =3D true;=0A=
        }=0A=
=0A=
        if (!directive.templateUrl &amp;&amp; directive.controller) {=0A=
          controllerDirectives =3D controllerDirectives || createMap();=0A=
          assertNoDuplicate('\'' + directiveName + '\' controller',=0A=
              controllerDirectives[directiveName], directive, =
$compileNode);=0A=
          controllerDirectives[directiveName] =3D directive;=0A=
        }=0A=
=0A=
        directiveValue =3D directive.transclude;=0A=
=0A=
        if (directiveValue) {=0A=
          hasTranscludeDirective =3D true;=0A=
=0A=
          // Special case ngIf and ngRepeat so that we don't complain =
about duplicate transclusion.=0A=
          // This option should only be used by directives that know how =
to safely handle element transclusion,=0A=
          // where the transcluded nodes are added or replaced after =
linking.=0A=
          if (!directive.$$tlb) {=0A=
            assertNoDuplicate('transclusion', nonTlbTranscludeDirective, =
directive, $compileNode);=0A=
            nonTlbTranscludeDirective =3D directive;=0A=
          }=0A=
=0A=
          if (directiveValue =3D=3D=3D 'element') {=0A=
            hasElementTranscludeDirective =3D true;=0A=
            terminalPriority =3D directive.priority;=0A=
            $template =3D $compileNode;=0A=
            $compileNode =3D templateAttrs.$$element =3D=0A=
                jqLite(compile.$$createComment(directiveName, =
templateAttrs[directiveName]));=0A=
            compileNode =3D $compileNode[0];=0A=
            replaceWith(jqCollection, sliceArgs($template), compileNode);=0A=
=0A=
            // Support: Chrome &lt; 50=0A=
            // https://github.com/angular/angular.js/issues/14041=0A=
=0A=
            // In the versions of V8 prior to Chrome 50, the document =
fragment that is created=0A=
            // in the `replaceWith` function is improperly garbage =
collected despite still=0A=
            // being referenced by the `parentNode` property of all of =
the child nodes.  By adding=0A=
            // a reference to the fragment via a different property, we =
can avoid that incorrect=0A=
            // behavior.=0A=
            // TODO: remove this line after Chrome 50 has been released=0A=
            $template[0].$$parentNode =3D $template[0].parentNode;=0A=
=0A=
            childTranscludeFn =3D =
compilationGenerator(mightHaveMultipleTransclusionError, $template, =
transcludeFn, terminalPriority,=0A=
                                        replaceDirective &amp;&amp; =
replaceDirective.name, {=0A=
                                          // Don't pass in:=0A=
                                          // - controllerDirectives - =
otherwise we'll create duplicates controllers=0A=
                                          // - newIsolateScopeDirective =
or templateDirective - combining templates with=0A=
                                          //   element transclusion =
doesn't make sense.=0A=
                                          //=0A=
                                          // We need only =
nonTlbTranscludeDirective so that we prevent putting transclusion=0A=
                                          // on the same element more =
than once.=0A=
                                          nonTlbTranscludeDirective: =
nonTlbTranscludeDirective=0A=
                                        });=0A=
          } else {=0A=
=0A=
            var slots =3D createMap();=0A=
=0A=
            if (!isObject(directiveValue)) {=0A=
              $template =3D jqLite(jqLiteClone(compileNode)).contents();=0A=
            } else {=0A=
=0A=
              // We have transclusion slots,=0A=
              // collect them up, compile them and store their =
transclusion functions=0A=
              $template =3D [];=0A=
=0A=
              var slotMap =3D createMap();=0A=
              var filledSlots =3D createMap();=0A=
=0A=
              // Parse the element selectors=0A=
              forEach(directiveValue, function(elementSelector, =
slotName) {=0A=
                // If an element selector starts with a ? then it is =
optional=0A=
                var optional =3D (elementSelector.charAt(0) =3D=3D=3D =
'?');=0A=
                elementSelector =3D optional ? =
elementSelector.substring(1) : elementSelector;=0A=
=0A=
                slotMap[elementSelector] =3D slotName;=0A=
=0A=
                // We explicitly assign `null` since this implies that a =
slot was defined but not filled.=0A=
                // Later when calling boundTransclusion functions with a =
slot name we only error if the=0A=
                // slot is `undefined`=0A=
                slots[slotName] =3D null;=0A=
=0A=
                // filledSlots contains `true` for all slots that are =
either optional or have been=0A=
                // filled. This is used to check that we have not missed =
any required slots=0A=
                filledSlots[slotName] =3D optional;=0A=
              });=0A=
=0A=
              // Add the matching elements into their slot=0A=
              forEach($compileNode.contents(), function(node) {=0A=
                var slotName =3D =
slotMap[directiveNormalize(nodeName_(node))];=0A=
                if (slotName) {=0A=
                  filledSlots[slotName] =3D true;=0A=
                  slots[slotName] =3D slots[slotName] || [];=0A=
                  slots[slotName].push(node);=0A=
                } else {=0A=
                  $template.push(node);=0A=
                }=0A=
              });=0A=
=0A=
              // Check for required slots that were not filled=0A=
              forEach(filledSlots, function(filled, slotName) {=0A=
                if (!filled) {=0A=
                  throw $compileMinErr('reqslot', 'Required transclusion =
slot `{0}` was not filled.', slotName);=0A=
                }=0A=
              });=0A=
=0A=
              for (var slotName in slots) {=0A=
                if (slots[slotName]) {=0A=
                  // Only define a transclusion function if the slot was =
filled=0A=
                  slots[slotName] =3D =
compilationGenerator(mightHaveMultipleTransclusionError, =
slots[slotName], transcludeFn);=0A=
                }=0A=
              }=0A=
            }=0A=
=0A=
            $compileNode.empty(); // clear contents=0A=
            childTranscludeFn =3D =
compilationGenerator(mightHaveMultipleTransclusionError, $template, =
transcludeFn, undefined,=0A=
                undefined, { needsNewScope: directive.$$isolateScope || =
directive.$$newScope});=0A=
            childTranscludeFn.$$slots =3D slots;=0A=
          }=0A=
        }=0A=
=0A=
        if (directive.template) {=0A=
          hasTemplate =3D true;=0A=
          assertNoDuplicate('template', templateDirective, directive, =
$compileNode);=0A=
          templateDirective =3D directive;=0A=
=0A=
          directiveValue =3D (isFunction(directive.template))=0A=
              ? directive.template($compileNode, templateAttrs)=0A=
              : directive.template;=0A=
=0A=
          directiveValue =3D denormalizeTemplate(directiveValue);=0A=
=0A=
          if (directive.replace) {=0A=
            replaceDirective =3D directive;=0A=
            if (jqLiteIsTextNode(directiveValue)) {=0A=
              $template =3D [];=0A=
            } else {=0A=
              $template =3D =
removeComments(wrapTemplate(directive.templateNamespace, =
trim(directiveValue)));=0A=
            }=0A=
            compileNode =3D $template[0];=0A=
=0A=
            if ($template.length !=3D=3D 1 || compileNode.nodeType =
!=3D=3D NODE_TYPE_ELEMENT) {=0A=
              throw $compileMinErr('tplrt',=0A=
                  'Template for directive \'{0}\' must have exactly one =
root element. {1}',=0A=
                  directiveName, '');=0A=
            }=0A=
=0A=
            replaceWith(jqCollection, $compileNode, compileNode);=0A=
=0A=
            var newTemplateAttrs =3D {$attr: {}};=0A=
=0A=
            // combine directives from the original node and from the =
template:=0A=
            // - take the array of directives for this element=0A=
            // - split it into two parts, those that already applied =
(processed) and those that weren't (unprocessed)=0A=
            // - collect directives from the template and sort them by =
priority=0A=
            // - combine directives as: processed + template + =
unprocessed=0A=
            var templateDirectives =3D collectDirectives(compileNode, =
[], newTemplateAttrs);=0A=
            var unprocessedDirectives =3D directives.splice(i + 1, =
directives.length - (i + 1));=0A=
=0A=
            if (newIsolateScopeDirective || newScopeDirective) {=0A=
              // The original directive caused the current element to be =
replaced but this element=0A=
              // also needs to have a new scope, so we need to tell the =
template directives=0A=
              // that they would need to get their scope from further =
up, if they require transclusion=0A=
              markDirectiveScope(templateDirectives, =
newIsolateScopeDirective, newScopeDirective);=0A=
            }=0A=
            directives =3D =
directives.concat(templateDirectives).concat(unprocessedDirectives);=0A=
            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);=0A=
=0A=
            ii =3D directives.length;=0A=
          } else {=0A=
            $compileNode.html(directiveValue);=0A=
          }=0A=
        }=0A=
=0A=
        if (directive.templateUrl) {=0A=
          hasTemplate =3D true;=0A=
          assertNoDuplicate('template', templateDirective, directive, =
$compileNode);=0A=
          templateDirective =3D directive;=0A=
=0A=
          if (directive.replace) {=0A=
            replaceDirective =3D directive;=0A=
          }=0A=
=0A=
          // eslint-disable-next-line no-func-assign=0A=
          nodeLinkFn =3D compileTemplateUrl(directives.splice(i, =
directives.length - i), $compileNode,=0A=
              templateAttrs, jqCollection, hasTranscludeDirective =
&amp;&amp; childTranscludeFn, preLinkFns, postLinkFns, {=0A=
                controllerDirectives: controllerDirectives,=0A=
                newScopeDirective: (newScopeDirective !=3D=3D directive) =
&amp;&amp; newScopeDirective,=0A=
                newIsolateScopeDirective: newIsolateScopeDirective,=0A=
                templateDirective: templateDirective,=0A=
                nonTlbTranscludeDirective: nonTlbTranscludeDirective=0A=
              });=0A=
          ii =3D directives.length;=0A=
        } else if (directive.compile) {=0A=
          try {=0A=
            linkFn =3D directive.compile($compileNode, templateAttrs, =
childTranscludeFn);=0A=
            var context =3D directive.$$originalDirective || directive;=0A=
            if (isFunction(linkFn)) {=0A=
              addLinkFns(null, bind(context, linkFn), attrStart, =
attrEnd);=0A=
            } else if (linkFn) {=0A=
              addLinkFns(bind(context, linkFn.pre), bind(context, =
linkFn.post), attrStart, attrEnd);=0A=
            }=0A=
          } catch (e) {=0A=
            $exceptionHandler(e, startingTag($compileNode));=0A=
          }=0A=
        }=0A=
=0A=
        if (directive.terminal) {=0A=
          nodeLinkFn.terminal =3D true;=0A=
          terminalPriority =3D Math.max(terminalPriority, =
directive.priority);=0A=
        }=0A=
=0A=
      }=0A=
=0A=
      nodeLinkFn.scope =3D newScopeDirective &amp;&amp; =
newScopeDirective.scope =3D=3D=3D true;=0A=
      nodeLinkFn.transcludeOnThisElement =3D hasTranscludeDirective;=0A=
      nodeLinkFn.templateOnThisElement =3D hasTemplate;=0A=
      nodeLinkFn.transclude =3D childTranscludeFn;=0A=
=0A=
      previousCompileContext.hasElementTranscludeDirective =3D =
hasElementTranscludeDirective;=0A=
=0A=
      // might be normal or delayed nodeLinkFn depending on if =
templateUrl is present=0A=
      return nodeLinkFn;=0A=
=0A=
      ////////////////////=0A=
=0A=
      function addLinkFns(pre, post, attrStart, attrEnd) {=0A=
        if (pre) {=0A=
          if (attrStart) pre =3D groupElementsLinkFnWrapper(pre, =
attrStart, attrEnd);=0A=
          pre.require =3D directive.require;=0A=
          pre.directiveName =3D directiveName;=0A=
          if (newIsolateScopeDirective =3D=3D=3D directive || =
directive.$$isolateScope) {=0A=
            pre =3D cloneAndAnnotateFn(pre, {isolateScope: true});=0A=
          }=0A=
          preLinkFns.push(pre);=0A=
        }=0A=
        if (post) {=0A=
          if (attrStart) post =3D groupElementsLinkFnWrapper(post, =
attrStart, attrEnd);=0A=
          post.require =3D directive.require;=0A=
          post.directiveName =3D directiveName;=0A=
          if (newIsolateScopeDirective =3D=3D=3D directive || =
directive.$$isolateScope) {=0A=
            post =3D cloneAndAnnotateFn(post, {isolateScope: true});=0A=
          }=0A=
          postLinkFns.push(post);=0A=
        }=0A=
      }=0A=
=0A=
      function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, =
boundTranscludeFn) {=0A=
        var i, ii, linkFn, isolateScope, controllerScope, =
elementControllers, transcludeFn, $element,=0A=
            attrs, scopeBindingInfo;=0A=
=0A=
        if (compileNode =3D=3D=3D linkNode) {=0A=
          attrs =3D templateAttrs;=0A=
          $element =3D templateAttrs.$$element;=0A=
        } else {=0A=
          $element =3D jqLite(linkNode);=0A=
          attrs =3D new Attributes($element, templateAttrs);=0A=
        }=0A=
=0A=
        controllerScope =3D scope;=0A=
        if (newIsolateScopeDirective) {=0A=
          isolateScope =3D scope.$new(true);=0A=
        } else if (newScopeDirective) {=0A=
          controllerScope =3D scope.$parent;=0A=
        }=0A=
=0A=
        if (boundTranscludeFn) {=0A=
          // track `boundTranscludeFn` so it can be unwrapped if =
`transcludeFn`=0A=
          // is later passed as `parentBoundTranscludeFn` to =
`publicLinkFn`=0A=
          transcludeFn =3D controllersBoundTransclude;=0A=
          transcludeFn.$$boundTransclude =3D boundTranscludeFn;=0A=
          // expose the slots on the `$transclude` function=0A=
          transcludeFn.isSlotFilled =3D function(slotName) {=0A=
            return !!boundTranscludeFn.$$slots[slotName];=0A=
          };=0A=
        }=0A=
=0A=
        if (controllerDirectives) {=0A=
          elementControllers =3D setupControllers($element, attrs, =
transcludeFn, controllerDirectives, isolateScope, scope, =
newIsolateScopeDirective);=0A=
        }=0A=
=0A=
        if (newIsolateScopeDirective) {=0A=
          // Initialize isolate scope bindings for new isolate scope =
directive.=0A=
          compile.$$addScopeInfo($element, isolateScope, true, =
!(templateDirective &amp;&amp; (templateDirective =3D=3D=3D =
newIsolateScopeDirective ||=0A=
              templateDirective =3D=3D=3D =
newIsolateScopeDirective.$$originalDirective)));=0A=
          compile.$$addScopeClass($element, true);=0A=
          isolateScope.$$isolateBindings =3D=0A=
              newIsolateScopeDirective.$$isolateBindings;=0A=
          scopeBindingInfo =3D initializeDirectiveBindings(scope, attrs, =
isolateScope,=0A=
                                        isolateScope.$$isolateBindings,=0A=
                                        newIsolateScopeDirective);=0A=
          if (scopeBindingInfo.removeWatches) {=0A=
            isolateScope.$on('$destroy', scopeBindingInfo.removeWatches);=0A=
          }=0A=
        }=0A=
=0A=
        // Initialize bindToController bindings=0A=
        for (var name in elementControllers) {=0A=
          var controllerDirective =3D controllerDirectives[name];=0A=
          var controller =3D elementControllers[name];=0A=
          var bindings =3D =
controllerDirective.$$bindings.bindToController;=0A=
=0A=
          if (preAssignBindingsEnabled) {=0A=
            if (bindings) {=0A=
              controller.bindingInfo =3D=0A=
                initializeDirectiveBindings(controllerScope, attrs, =
controller.instance, bindings, controllerDirective);=0A=
            } else {=0A=
              controller.bindingInfo =3D {};=0A=
            }=0A=
=0A=
            var controllerResult =3D controller();=0A=
            if (controllerResult !=3D=3D controller.instance) {=0A=
              // If the controller constructor has a return value, =
overwrite the instance=0A=
              // from setupControllers=0A=
              controller.instance =3D controllerResult;=0A=
              $element.data('$' + controllerDirective.name + =
'Controller', controllerResult);=0A=
              if (controller.bindingInfo.removeWatches) {=0A=
                controller.bindingInfo.removeWatches();=0A=
              }=0A=
              controller.bindingInfo =3D=0A=
                initializeDirectiveBindings(controllerScope, attrs, =
controller.instance, bindings, controllerDirective);=0A=
            }=0A=
          } else {=0A=
            controller.instance =3D controller();=0A=
            $element.data('$' + controllerDirective.name + 'Controller', =
controller.instance);=0A=
            controller.bindingInfo =3D=0A=
              initializeDirectiveBindings(controllerScope, attrs, =
controller.instance, bindings, controllerDirective);=0A=
          }=0A=
        }=0A=
=0A=
        // Bind the required controllers to the controller, if `require` =
is an object and `bindToController` is truthy=0A=
        forEach(controllerDirectives, function(controllerDirective, =
name) {=0A=
          var require =3D controllerDirective.require;=0A=
          if (controllerDirective.bindToController &amp;&amp; =
!isArray(require) &amp;&amp; isObject(require)) {=0A=
            extend(elementControllers[name].instance, =
getControllers(name, require, $element, elementControllers));=0A=
          }=0A=
        });=0A=
=0A=
        // Handle the init and destroy lifecycle hooks on all =
controllers that have them=0A=
        forEach(elementControllers, function(controller) {=0A=
          var controllerInstance =3D controller.instance;=0A=
          if (isFunction(controllerInstance.$onChanges)) {=0A=
            try {=0A=
              =
controllerInstance.$onChanges(controller.bindingInfo.initialChanges);=0A=
            } catch (e) {=0A=
              $exceptionHandler(e);=0A=
            }=0A=
          }=0A=
          if (isFunction(controllerInstance.$onInit)) {=0A=
            try {=0A=
              controllerInstance.$onInit();=0A=
            } catch (e) {=0A=
              $exceptionHandler(e);=0A=
            }=0A=
          }=0A=
          if (isFunction(controllerInstance.$doCheck)) {=0A=
            controllerScope.$watch(function() { =
controllerInstance.$doCheck(); });=0A=
            controllerInstance.$doCheck();=0A=
          }=0A=
          if (isFunction(controllerInstance.$onDestroy)) {=0A=
            controllerScope.$on('$destroy', function callOnDestroyHook() =
{=0A=
              controllerInstance.$onDestroy();=0A=
            });=0A=
          }=0A=
        });=0A=
=0A=
        // PRELINKING=0A=
        for (i =3D 0, ii =3D preLinkFns.length; i &lt; ii; i++) {=0A=
          linkFn =3D preLinkFns[i];=0A=
          invokeLinkFn(linkFn,=0A=
              linkFn.isolateScope ? isolateScope : scope,=0A=
              $element,=0A=
              attrs,=0A=
              linkFn.require &amp;&amp; =
getControllers(linkFn.directiveName, linkFn.require, $element, =
elementControllers),=0A=
              transcludeFn=0A=
          );=0A=
        }=0A=
=0A=
        // RECURSION=0A=
        // We only pass the isolate scope, if the isolate directive has =
a template,=0A=
        // otherwise the child elements do not belong to the isolate =
directive.=0A=
        var scopeToChild =3D scope;=0A=
        if (newIsolateScopeDirective &amp;&amp; =
(newIsolateScopeDirective.template || =
newIsolateScopeDirective.templateUrl =3D=3D=3D null)) {=0A=
          scopeToChild =3D isolateScope;=0A=
        }=0A=
        if (childLinkFn) {=0A=
          childLinkFn(scopeToChild, linkNode.childNodes, undefined, =
boundTranscludeFn);=0A=
        }=0A=
=0A=
        // POSTLINKING=0A=
        for (i =3D postLinkFns.length - 1; i &gt;=3D 0; i--) {=0A=
          linkFn =3D postLinkFns[i];=0A=
          invokeLinkFn(linkFn,=0A=
              linkFn.isolateScope ? isolateScope : scope,=0A=
              $element,=0A=
              attrs,=0A=
              linkFn.require &amp;&amp; =
getControllers(linkFn.directiveName, linkFn.require, $element, =
elementControllers),=0A=
              transcludeFn=0A=
          );=0A=
        }=0A=
=0A=
        // Trigger $postLink lifecycle hooks=0A=
        forEach(elementControllers, function(controller) {=0A=
          var controllerInstance =3D controller.instance;=0A=
          if (isFunction(controllerInstance.$postLink)) {=0A=
            controllerInstance.$postLink();=0A=
          }=0A=
        });=0A=
=0A=
        // This is the function that is injected as `$transclude`.=0A=
        // Note: all arguments are optional!=0A=
        function controllersBoundTransclude(scope, cloneAttachFn, =
futureParentElement, slotName) {=0A=
          var transcludeControllers;=0A=
          // No scope passed in:=0A=
          if (!isScope(scope)) {=0A=
            slotName =3D futureParentElement;=0A=
            futureParentElement =3D cloneAttachFn;=0A=
            cloneAttachFn =3D scope;=0A=
            scope =3D undefined;=0A=
          }=0A=
=0A=
          if (hasElementTranscludeDirective) {=0A=
            transcludeControllers =3D elementControllers;=0A=
          }=0A=
          if (!futureParentElement) {=0A=
            futureParentElement =3D hasElementTranscludeDirective ? =
$element.parent() : $element;=0A=
          }=0A=
          if (slotName) {=0A=
            // slotTranscludeFn can be one of three things:=0A=
            //  * a transclude function - a filled slot=0A=
            //  * `null` - an optional slot that was not filled=0A=
            //  * `undefined` - a slot that was not declared (i.e. =
invalid)=0A=
            var slotTranscludeFn =3D boundTranscludeFn.$$slots[slotName];=0A=
            if (slotTranscludeFn) {=0A=
              return slotTranscludeFn(scope, cloneAttachFn, =
transcludeControllers, futureParentElement, scopeToChild);=0A=
            } else if (isUndefined(slotTranscludeFn)) {=0A=
              throw $compileMinErr('noslot',=0A=
               'No parent directive that requires a transclusion with =
slot name "{0}". ' +=0A=
               'Element: {1}',=0A=
               slotName, startingTag($element));=0A=
            }=0A=
          } else {=0A=
            return boundTranscludeFn(scope, cloneAttachFn, =
transcludeControllers, futureParentElement, scopeToChild);=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    function getControllers(directiveName, require, $element, =
elementControllers) {=0A=
      var value;=0A=
=0A=
      if (isString(require)) {=0A=
        var match =3D require.match(REQUIRE_PREFIX_REGEXP);=0A=
        var name =3D require.substring(match[0].length);=0A=
        var inheritType =3D match[1] || match[3];=0A=
        var optional =3D match[2] =3D=3D=3D '?';=0A=
=0A=
        //If only parents then start at the parent element=0A=
        if (inheritType =3D=3D=3D '^^') {=0A=
          $element =3D $element.parent();=0A=
        //Otherwise attempt getting the controller from =
elementControllers in case=0A=
        //the element is transcluded (and has no data) and to avoid =
.data if possible=0A=
        } else {=0A=
          value =3D elementControllers &amp;&amp; =
elementControllers[name];=0A=
          value =3D value &amp;&amp; value.instance;=0A=
        }=0A=
=0A=
        if (!value) {=0A=
          var dataName =3D '$' + name + 'Controller';=0A=
          value =3D inheritType ? $element.inheritedData(dataName) : =
$element.data(dataName);=0A=
        }=0A=
=0A=
        if (!value &amp;&amp; !optional) {=0A=
          throw $compileMinErr('ctreq',=0A=
              'Controller \'{0}\', required by directive \'{1}\', can\'t =
be found!',=0A=
              name, directiveName);=0A=
        }=0A=
      } else if (isArray(require)) {=0A=
        value =3D [];=0A=
        for (var i =3D 0, ii =3D require.length; i &lt; ii; i++) {=0A=
          value[i] =3D getControllers(directiveName, require[i], =
$element, elementControllers);=0A=
        }=0A=
      } else if (isObject(require)) {=0A=
        value =3D {};=0A=
        forEach(require, function(controller, property) {=0A=
          value[property] =3D getControllers(directiveName, controller, =
$element, elementControllers);=0A=
        });=0A=
      }=0A=
=0A=
      return value || null;=0A=
    }=0A=
=0A=
    function setupControllers($element, attrs, transcludeFn, =
controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {=0A=
      var elementControllers =3D createMap();=0A=
      for (var controllerKey in controllerDirectives) {=0A=
        var directive =3D controllerDirectives[controllerKey];=0A=
        var locals =3D {=0A=
          $scope: directive =3D=3D=3D newIsolateScopeDirective || =
directive.$$isolateScope ? isolateScope : scope,=0A=
          $element: $element,=0A=
          $attrs: attrs,=0A=
          $transclude: transcludeFn=0A=
        };=0A=
=0A=
        var controller =3D directive.controller;=0A=
        if (controller =3D=3D=3D '@') {=0A=
          controller =3D attrs[directive.name];=0A=
        }=0A=
=0A=
        var controllerInstance =3D $controller(controller, locals, true, =
directive.controllerAs);=0A=
=0A=
        // For directives with element transclusion the element is a =
comment.=0A=
        // In this case .data will not attach any data.=0A=
        // Instead, we save the controllers for the element in a local =
hash and attach to .data=0A=
        // later, once we have the actual element.=0A=
        elementControllers[directive.name] =3D controllerInstance;=0A=
        $element.data('$' + directive.name + 'Controller', =
controllerInstance.instance);=0A=
      }=0A=
      return elementControllers;=0A=
    }=0A=
=0A=
    // Depending upon the context in which a directive finds itself it =
might need to have a new isolated=0A=
    // or child scope created. For instance:=0A=
    // * if the directive has been pulled into a template because =
another directive with a higher priority=0A=
    // asked for element transclusion=0A=
    // * if the directive itself asks for transclusion but it is at the =
root of a template and the original=0A=
    // element was replaced. See =
https://github.com/angular/angular.js/issues/12936=0A=
    function markDirectiveScope(directives, isolateScope, newScope) {=0A=
      for (var j =3D 0, jj =3D directives.length; j &lt; jj; j++) {=0A=
        directives[j] =3D inherit(directives[j], {$$isolateScope: =
isolateScope, $$newScope: newScope});=0A=
      }=0A=
    }=0A=
=0A=
    /**=0A=
     * looks up the directive and decorates it with exception handling =
and proper parameters. We=0A=
     * call this the boundDirective.=0A=
     *=0A=
     * @param {string} name name of the directive to look up.=0A=
     * @param {string} location The directive must be found in specific =
format.=0A=
     *   String containing any of theses characters:=0A=
     *=0A=
     *   * `E`: element name=0A=
     *   * `A': attribute=0A=
     *   * `C`: class=0A=
     *   * `M`: comment=0A=
     * @returns {boolean} true if directive was added.=0A=
     */=0A=
    function addDirective(tDirectives, name, location, maxPriority, =
ignoreDirective, startAttrName,=0A=
                          endAttrName) {=0A=
      if (name =3D=3D=3D ignoreDirective) return null;=0A=
      var match =3D null;=0A=
      if (hasDirectives.hasOwnProperty(name)) {=0A=
        for (var directive, directives =3D $injector.get(name + Suffix),=0A=
            i =3D 0, ii =3D directives.length; i &lt; ii; i++) {=0A=
          directive =3D directives[i];=0A=
          if ((isUndefined(maxPriority) || maxPriority &gt; =
directive.priority) &amp;&amp;=0A=
               directive.restrict.indexOf(location) !=3D=3D -1) {=0A=
            if (startAttrName) {=0A=
              directive =3D inherit(directive, {$$start: startAttrName, =
$$end: endAttrName});=0A=
            }=0A=
            if (!directive.$$bindings) {=0A=
              var bindings =3D directive.$$bindings =3D=0A=
                  parseDirectiveBindings(directive, directive.name);=0A=
              if (isObject(bindings.isolateScope)) {=0A=
                directive.$$isolateBindings =3D bindings.isolateScope;=0A=
              }=0A=
            }=0A=
            tDirectives.push(directive);=0A=
            match =3D directive;=0A=
          }=0A=
        }=0A=
      }=0A=
      return match;=0A=
    }=0A=
=0A=
=0A=
    /**=0A=
     * looks up the directive and returns true if it is a multi-element =
directive,=0A=
     * and therefore requires DOM nodes between -start and -end markers =
to be grouped=0A=
     * together.=0A=
     *=0A=
     * @param {string} name name of the directive to look up.=0A=
     * @returns true if directive was registered as multi-element.=0A=
     */=0A=
    function directiveIsMultiElement(name) {=0A=
      if (hasDirectives.hasOwnProperty(name)) {=0A=
        for (var directive, directives =3D $injector.get(name + Suffix),=0A=
            i =3D 0, ii =3D directives.length; i &lt; ii; i++) {=0A=
          directive =3D directives[i];=0A=
          if (directive.multiElement) {=0A=
            return true;=0A=
          }=0A=
        }=0A=
      }=0A=
      return false;=0A=
    }=0A=
=0A=
    /**=0A=
     * When the element is replaced with HTML template then the new =
attributes=0A=
     * on the template need to be merged with the existing attributes in =
the DOM.=0A=
     * The desired effect is to have both of the attributes present.=0A=
     *=0A=
     * @param {object} dst destination attributes (original DOM)=0A=
     * @param {object} src source attributes (from the directive =
template)=0A=
     */=0A=
    function mergeTemplateAttributes(dst, src) {=0A=
      var srcAttr =3D src.$attr,=0A=
          dstAttr =3D dst.$attr;=0A=
=0A=
      // reapply the old attributes to the new element=0A=
      forEach(dst, function(value, key) {=0A=
        if (key.charAt(0) !=3D=3D '$') {=0A=
          if (src[key] &amp;&amp; src[key] !=3D=3D value) {=0A=
            if (value.length) {=0A=
              value +=3D (key =3D=3D=3D 'style' ? ';' : ' ') + src[key];=0A=
            } else {=0A=
              value =3D src[key];=0A=
            }=0A=
          }=0A=
          dst.$set(key, value, true, srcAttr[key]);=0A=
        }=0A=
      });=0A=
=0A=
      // copy the new attributes on the old attrs object=0A=
      forEach(src, function(value, key) {=0A=
        // Check if we already set this attribute in the loop above.=0A=
        // `dst` will never contain hasOwnProperty as DOM parser won't =
let it.=0A=
        // You will get an "InvalidCharacterError: DOM Exception 5" =
error if you=0A=
        // have an attribute like "has-own-property" or =
"data-has-own-property", etc.=0A=
        if (!dst.hasOwnProperty(key) &amp;&amp; key.charAt(0) !=3D=3D =
'$') {=0A=
          dst[key] =3D value;=0A=
=0A=
          if (key !=3D=3D 'class' &amp;&amp; key !=3D=3D 'style') {=0A=
            dstAttr[key] =3D srcAttr[key];=0A=
          }=0A=
        }=0A=
      });=0A=
    }=0A=
=0A=
=0A=
    function compileTemplateUrl(directives, $compileNode, tAttrs,=0A=
        $rootElement, childTranscludeFn, preLinkFns, postLinkFns, =
previousCompileContext) {=0A=
      var linkQueue =3D [],=0A=
          afterTemplateNodeLinkFn,=0A=
          afterTemplateChildLinkFn,=0A=
          beforeTemplateCompileNode =3D $compileNode[0],=0A=
          origAsyncDirective =3D directives.shift(),=0A=
          derivedSyncDirective =3D inherit(origAsyncDirective, {=0A=
            templateUrl: null, transclude: null, replace: null, =
$$originalDirective: origAsyncDirective=0A=
          }),=0A=
          templateUrl =3D (isFunction(origAsyncDirective.templateUrl))=0A=
              ? origAsyncDirective.templateUrl($compileNode, tAttrs)=0A=
              : origAsyncDirective.templateUrl,=0A=
          templateNamespace =3D origAsyncDirective.templateNamespace;=0A=
=0A=
      $compileNode.empty();=0A=
=0A=
      $templateRequest(templateUrl)=0A=
        .then(function(content) {=0A=
          var compileNode, tempTemplateAttrs, $template, =
childBoundTranscludeFn;=0A=
=0A=
          content =3D denormalizeTemplate(content);=0A=
=0A=
          if (origAsyncDirective.replace) {=0A=
            if (jqLiteIsTextNode(content)) {=0A=
              $template =3D [];=0A=
            } else {=0A=
              $template =3D =
removeComments(wrapTemplate(templateNamespace, trim(content)));=0A=
            }=0A=
            compileNode =3D $template[0];=0A=
=0A=
            if ($template.length !=3D=3D 1 || compileNode.nodeType =
!=3D=3D NODE_TYPE_ELEMENT) {=0A=
              throw $compileMinErr('tplrt',=0A=
                  'Template for directive \'{0}\' must have exactly one =
root element. {1}',=0A=
                  origAsyncDirective.name, templateUrl);=0A=
            }=0A=
=0A=
            tempTemplateAttrs =3D {$attr: {}};=0A=
            replaceWith($rootElement, $compileNode, compileNode);=0A=
            var templateDirectives =3D collectDirectives(compileNode, =
[], tempTemplateAttrs);=0A=
=0A=
            if (isObject(origAsyncDirective.scope)) {=0A=
              // the original directive that caused the template to be =
loaded async required=0A=
              // an isolate scope=0A=
              markDirectiveScope(templateDirectives, true);=0A=
            }=0A=
            directives =3D templateDirectives.concat(directives);=0A=
            mergeTemplateAttributes(tAttrs, tempTemplateAttrs);=0A=
          } else {=0A=
            compileNode =3D beforeTemplateCompileNode;=0A=
            $compileNode.html(content);=0A=
          }=0A=
=0A=
          directives.unshift(derivedSyncDirective);=0A=
=0A=
          afterTemplateNodeLinkFn =3D applyDirectivesToNode(directives, =
compileNode, tAttrs,=0A=
              childTranscludeFn, $compileNode, origAsyncDirective, =
preLinkFns, postLinkFns,=0A=
              previousCompileContext);=0A=
          forEach($rootElement, function(node, i) {=0A=
            if (node =3D=3D=3D compileNode) {=0A=
              $rootElement[i] =3D $compileNode[0];=0A=
            }=0A=
          });=0A=
          afterTemplateChildLinkFn =3D =
compileNodes($compileNode[0].childNodes, childTranscludeFn);=0A=
=0A=
          while (linkQueue.length) {=0A=
            var scope =3D linkQueue.shift(),=0A=
                beforeTemplateLinkNode =3D linkQueue.shift(),=0A=
                linkRootElement =3D linkQueue.shift(),=0A=
                boundTranscludeFn =3D linkQueue.shift(),=0A=
                linkNode =3D $compileNode[0];=0A=
=0A=
            if (scope.$$destroyed) continue;=0A=
=0A=
            if (beforeTemplateLinkNode !=3D=3D =
beforeTemplateCompileNode) {=0A=
              var oldClasses =3D beforeTemplateLinkNode.className;=0A=
=0A=
              if (!(previousCompileContext.hasElementTranscludeDirective =
&amp;&amp;=0A=
                  origAsyncDirective.replace)) {=0A=
                // it was cloned therefore we have to clone as well.=0A=
                linkNode =3D jqLiteClone(compileNode);=0A=
              }=0A=
              replaceWith(linkRootElement, =
jqLite(beforeTemplateLinkNode), linkNode);=0A=
=0A=
              // Copy in CSS classes from original node=0A=
              safeAddClass(jqLite(linkNode), oldClasses);=0A=
            }=0A=
            if (afterTemplateNodeLinkFn.transcludeOnThisElement) {=0A=
              childBoundTranscludeFn =3D createBoundTranscludeFn(scope, =
afterTemplateNodeLinkFn.transclude, boundTranscludeFn);=0A=
            } else {=0A=
              childBoundTranscludeFn =3D boundTranscludeFn;=0A=
            }=0A=
            afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, =
linkNode, $rootElement,=0A=
              childBoundTranscludeFn);=0A=
          }=0A=
          linkQueue =3D null;=0A=
        }).catch(function(error) {=0A=
          if (isError(error)) {=0A=
            $exceptionHandler(error);=0A=
          }=0A=
        });=0A=
=0A=
      return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, =
rootElement, boundTranscludeFn) {=0A=
        var childBoundTranscludeFn =3D boundTranscludeFn;=0A=
        if (scope.$$destroyed) return;=0A=
        if (linkQueue) {=0A=
          linkQueue.push(scope,=0A=
                         node,=0A=
                         rootElement,=0A=
                         childBoundTranscludeFn);=0A=
        } else {=0A=
          if (afterTemplateNodeLinkFn.transcludeOnThisElement) {=0A=
            childBoundTranscludeFn =3D createBoundTranscludeFn(scope, =
afterTemplateNodeLinkFn.transclude, boundTranscludeFn);=0A=
          }=0A=
          afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, =
rootElement, childBoundTranscludeFn);=0A=
        }=0A=
      };=0A=
    }=0A=
=0A=
=0A=
    /**=0A=
     * Sorting function for bound directives.=0A=
     */=0A=
    function byPriority(a, b) {=0A=
      var diff =3D b.priority - a.priority;=0A=
      if (diff !=3D=3D 0) return diff;=0A=
      if (a.name !=3D=3D b.name) return (a.name &lt; b.name) ? -1 : 1;=0A=
      return a.index - b.index;=0A=
    }=0A=
=0A=
    function assertNoDuplicate(what, previousDirective, directive, =
element) {=0A=
=0A=
      function wrapModuleNameIfDefined(moduleName) {=0A=
        return moduleName ?=0A=
          (' (module: ' + moduleName + ')') :=0A=
          '';=0A=
      }=0A=
=0A=
      if (previousDirective) {=0A=
        throw $compileMinErr('multidir', 'Multiple directives [{0}{1}, =
{2}{3}] asking for {4} on: {5}',=0A=
            previousDirective.name, =
wrapModuleNameIfDefined(previousDirective.$$moduleName),=0A=
            directive.name, =
wrapModuleNameIfDefined(directive.$$moduleName), what, =
startingTag(element));=0A=
      }=0A=
    }=0A=
=0A=
=0A=
    function addTextInterpolateDirective(directives, text) {=0A=
      var interpolateFn =3D $interpolate(text, true);=0A=
      if (interpolateFn) {=0A=
        directives.push({=0A=
          priority: 0,=0A=
          compile: function textInterpolateCompileFn(templateNode) {=0A=
            var templateNodeParent =3D templateNode.parent(),=0A=
                hasCompileParent =3D !!templateNodeParent.length;=0A=
=0A=
            // When transcluding a template that has bindings in the root=0A=
            // we don't have a parent and thus need to add the class =
during linking fn.=0A=
            if (hasCompileParent) =
compile.$$addBindingClass(templateNodeParent);=0A=
=0A=
            return function textInterpolateLinkFn(scope, node) {=0A=
              var parent =3D node.parent();=0A=
              if (!hasCompileParent) compile.$$addBindingClass(parent);=0A=
              compile.$$addBindingInfo(parent, =
interpolateFn.expressions);=0A=
              scope.$watch(interpolateFn, function =
interpolateFnWatchAction(value) {=0A=
                node[0].nodeValue =3D value;=0A=
              });=0A=
            };=0A=
          }=0A=
        });=0A=
      }=0A=
    }=0A=
=0A=
=0A=
    function wrapTemplate(type, template) {=0A=
      type =3D lowercase(type || 'html');=0A=
      switch (type) {=0A=
      case 'svg':=0A=
      case 'math':=0A=
        var wrapper =3D window.document.createElement('div');=0A=
        wrapper.innerHTML =3D '&lt;' + type + '&gt;' + template + =
'&lt;/' + type + '&gt;';=0A=
        return wrapper.childNodes[0].childNodes;=0A=
      default:=0A=
        return template;=0A=
      }=0A=
    }=0A=
=0A=
=0A=
    function getTrustedContext(node, attrNormalizedName) {=0A=
      if (attrNormalizedName =3D=3D=3D 'srcdoc') {=0A=
        return $sce.HTML;=0A=
      }=0A=
      var tag =3D nodeName_(node);=0A=
      // All tags with src attributes require a RESOURCE_URL value, =
except for=0A=
      // img and various html5 media tags.=0A=
      if (attrNormalizedName =3D=3D=3D 'src' || attrNormalizedName =
=3D=3D=3D 'ngSrc') {=0A=
        if (['img', 'video', 'audio', 'source', 'track'].indexOf(tag) =
=3D=3D=3D -1) {=0A=
          return $sce.RESOURCE_URL;=0A=
        }=0A=
      // maction[xlink:href] can source SVG.  It's not limited to =
&lt;maction&gt;.=0A=
      } else if (attrNormalizedName =3D=3D=3D 'xlinkHref' ||=0A=
          (tag =3D=3D=3D 'form' &amp;&amp; attrNormalizedName =3D=3D=3D =
'action') ||=0A=
          // links can be stylesheets or imports, which can run script =
in the current origin=0A=
          (tag =3D=3D=3D 'link' &amp;&amp; attrNormalizedName =3D=3D=3D =
'href')=0A=
      ) {=0A=
        return $sce.RESOURCE_URL;=0A=
      }=0A=
    }=0A=
=0A=
=0A=
    function addAttrInterpolateDirective(node, directives, value, name, =
isNgAttr) {=0A=
      var trustedContext =3D getTrustedContext(node, name);=0A=
      var mustHaveExpression =3D !isNgAttr;=0A=
      var allOrNothing =3D ALL_OR_NOTHING_ATTRS[name] || isNgAttr;=0A=
=0A=
      var interpolateFn =3D $interpolate(value, mustHaveExpression, =
trustedContext, allOrNothing);=0A=
=0A=
      // no interpolation found -&gt; ignore=0A=
      if (!interpolateFn) return;=0A=
=0A=
      if (name =3D=3D=3D 'multiple' &amp;&amp; nodeName_(node) =3D=3D=3D =
'select') {=0A=
        throw $compileMinErr('selmulti',=0A=
            'Binding to the \'multiple\' attribute is not supported. =
Element: {0}',=0A=
            startingTag(node));=0A=
      }=0A=
=0A=
      if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {=0A=
        throw $compileMinErr('nodomevents',=0A=
            'Interpolations for HTML DOM event attributes are =
disallowed.  Please use the ' +=0A=
                'ng- versions (such as ng-click instead of onclick) =
instead.');=0A=
      }=0A=
=0A=
      directives.push({=0A=
        priority: 100,=0A=
        compile: function() {=0A=
            return {=0A=
              pre: function attrInterpolatePreLinkFn(scope, element, =
attr) {=0A=
                var $$observers =3D (attr.$$observers || =
(attr.$$observers =3D createMap()));=0A=
=0A=
                // If the attribute has changed since last =
$interpolate()ed=0A=
                var newValue =3D attr[name];=0A=
                if (newValue !=3D=3D value) {=0A=
                  // we need to interpolate again since the attribute =
value has been updated=0A=
                  // (e.g. by another directive's compile function)=0A=
                  // ensure unset/empty values make interpolateFn falsy=0A=
                  interpolateFn =3D newValue &amp;&amp; =
$interpolate(newValue, true, trustedContext, allOrNothing);=0A=
                  value =3D newValue;=0A=
                }=0A=
=0A=
                // if attribute was updated so that there is no =
interpolation going on we don't want to=0A=
                // register any observers=0A=
                if (!interpolateFn) return;=0A=
=0A=
                // initialize attr object so that it's ready in case we =
need the value for isolate=0A=
                // scope initialization, otherwise the value would not =
be available from isolate=0A=
                // directive's linking fn during linking phase=0A=
                attr[name] =3D interpolateFn(scope);=0A=
=0A=
                ($$observers[name] || ($$observers[name] =3D =
[])).$$inter =3D true;=0A=
                (attr.$$observers &amp;&amp; =
attr.$$observers[name].$$scope || scope).=0A=
                  $watch(interpolateFn, function =
interpolateFnWatchAction(newValue, oldValue) {=0A=
                    //special case for class attribute addition + removal=0A=
                    //so that class changes can tap into the animation=0A=
                    //hooks provided by the $animate service. Be sure to=0A=
                    //skip animations when the first digest occurs (when=0A=
                    //both the new and the old values are the same) since=0A=
                    //the CSS classes are the non-interpolated values=0A=
                    if (name =3D=3D=3D 'class' &amp;&amp; newValue =
!=3D=3D oldValue) {=0A=
                      attr.$updateClass(newValue, oldValue);=0A=
                    } else {=0A=
                      attr.$set(name, newValue);=0A=
                    }=0A=
                  });=0A=
              }=0A=
            };=0A=
          }=0A=
      });=0A=
    }=0A=
=0A=
=0A=
    /**=0A=
     * This is a special jqLite.replaceWith, which can replace items =
which=0A=
     * have no parents, provided that the containing jqLite collection =
is provided.=0A=
     *=0A=
     * @param {JqLite=3D} $rootElement The root of the compile tree. =
Used so that we can replace nodes=0A=
     *                               in the root of the tree.=0A=
     * @param {JqLite} elementsToRemove The jqLite element which we are =
going to replace. We keep=0A=
     *                                  the shell, but replace its DOM =
node reference.=0A=
     * @param {Node} newNode The new DOM node.=0A=
     */=0A=
    function replaceWith($rootElement, elementsToRemove, newNode) {=0A=
      var firstElementToRemove =3D elementsToRemove[0],=0A=
          removeCount =3D elementsToRemove.length,=0A=
          parent =3D firstElementToRemove.parentNode,=0A=
          i, ii;=0A=
=0A=
      if ($rootElement) {=0A=
        for (i =3D 0, ii =3D $rootElement.length; i &lt; ii; i++) {=0A=
          if ($rootElement[i] =3D=3D=3D firstElementToRemove) {=0A=
            $rootElement[i++] =3D newNode;=0A=
            for (var j =3D i, j2 =3D j + removeCount - 1,=0A=
                     jj =3D $rootElement.length;=0A=
                 j &lt; jj; j++, j2++) {=0A=
              if (j2 &lt; jj) {=0A=
                $rootElement[j] =3D $rootElement[j2];=0A=
              } else {=0A=
                delete $rootElement[j];=0A=
              }=0A=
            }=0A=
            $rootElement.length -=3D removeCount - 1;=0A=
=0A=
            // If the replaced element is also the jQuery .context then =
replace it=0A=
            // .context is a deprecated jQuery api, so we should set it =
only when jQuery set it=0A=
            // http://api.jquery.com/context/=0A=
            if ($rootElement.context =3D=3D=3D firstElementToRemove) {=0A=
              $rootElement.context =3D newNode;=0A=
            }=0A=
            break;=0A=
          }=0A=
        }=0A=
      }=0A=
=0A=
      if (parent) {=0A=
        parent.replaceChild(newNode, firstElementToRemove);=0A=
      }=0A=
=0A=
      // Append all the `elementsToRemove` to a fragment. This will...=0A=
      // - remove them from the DOM=0A=
      // - allow them to still be traversed with .nextSibling=0A=
      // - allow a single fragment.qSA to fetch all elements being =
removed=0A=
      var fragment =3D window.document.createDocumentFragment();=0A=
      for (i =3D 0; i &lt; removeCount; i++) {=0A=
        fragment.appendChild(elementsToRemove[i]);=0A=
      }=0A=
=0A=
      if (jqLite.hasData(firstElementToRemove)) {=0A=
        // Copy over user data (that includes Angular's $scope etc.). =
Don't copy private=0A=
        // data here because there's no public interface in jQuery to do =
that and copying over=0A=
        // event listeners (which is the main use of private data) =
wouldn't work anyway.=0A=
        jqLite.data(newNode, jqLite.data(firstElementToRemove));=0A=
=0A=
        // Remove $destroy event listeners from `firstElementToRemove`=0A=
        jqLite(firstElementToRemove).off('$destroy');=0A=
      }=0A=
=0A=
      // Cleanup any data/listeners on the elements and children.=0A=
      // This includes invoking the $destroy event on any elements with =
listeners.=0A=
      jqLite.cleanData(fragment.querySelectorAll('*'));=0A=
=0A=
      // Update the jqLite collection to only contain the `newNode`=0A=
      for (i =3D 1; i &lt; removeCount; i++) {=0A=
        delete elementsToRemove[i];=0A=
      }=0A=
      elementsToRemove[0] =3D newNode;=0A=
      elementsToRemove.length =3D 1;=0A=
    }=0A=
=0A=
=0A=
    function cloneAndAnnotateFn(fn, annotation) {=0A=
      return extend(function() { return fn.apply(null, arguments); }, =
fn, annotation);=0A=
    }=0A=
=0A=
=0A=
    function invokeLinkFn(linkFn, scope, $element, attrs, controllers, =
transcludeFn) {=0A=
      try {=0A=
        linkFn(scope, $element, attrs, controllers, transcludeFn);=0A=
      } catch (e) {=0A=
        $exceptionHandler(e, startingTag($element));=0A=
      }=0A=
    }=0A=
=0A=
=0A=
    // Set up $watches for isolate scope and controller bindings.=0A=
    function initializeDirectiveBindings(scope, attrs, destination, =
bindings, directive) {=0A=
      var removeWatchCollection =3D [];=0A=
      var initialChanges =3D {};=0A=
      var changes;=0A=
      forEach(bindings, function initializeBinding(definition, =
scopeName) {=0A=
        var attrName =3D definition.attrName,=0A=
        optional =3D definition.optional,=0A=
        mode =3D definition.mode, // @, =3D, &lt;, or &amp;=0A=
        lastValue,=0A=
        parentGet, parentSet, compare, removeWatch;=0A=
=0A=
        switch (mode) {=0A=
=0A=
          case '@':=0A=
            if (!optional &amp;&amp; !hasOwnProperty.call(attrs, =
attrName)) {=0A=
              destination[scopeName] =3D attrs[attrName] =3D undefined;=0A=
            }=0A=
            removeWatch =3D attrs.$observe(attrName, function(value) {=0A=
              if (isString(value) || isBoolean(value)) {=0A=
                var oldValue =3D destination[scopeName];=0A=
                recordChanges(scopeName, value, oldValue);=0A=
                destination[scopeName] =3D value;=0A=
              }=0A=
            });=0A=
            attrs.$$observers[attrName].$$scope =3D scope;=0A=
            lastValue =3D attrs[attrName];=0A=
            if (isString(lastValue)) {=0A=
              // If the attribute has been provided then we trigger an =
interpolation to ensure=0A=
              // the value is there for use in the link fn=0A=
              destination[scopeName] =3D $interpolate(lastValue)(scope);=0A=
            } else if (isBoolean(lastValue)) {=0A=
              // If the attributes is one of the BOOLEAN_ATTR then =
Angular will have converted=0A=
              // the value to boolean rather than a string, so we =
special case this situation=0A=
              destination[scopeName] =3D lastValue;=0A=
            }=0A=
            initialChanges[scopeName] =3D new =
SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);=0A=
            removeWatchCollection.push(removeWatch);=0A=
            break;=0A=
=0A=
          case '=3D':=0A=
            if (!hasOwnProperty.call(attrs, attrName)) {=0A=
              if (optional) break;=0A=
              attrs[attrName] =3D undefined;=0A=
            }=0A=
            if (optional &amp;&amp; !attrs[attrName]) break;=0A=
=0A=
            parentGet =3D $parse(attrs[attrName]);=0A=
            if (parentGet.literal) {=0A=
              compare =3D equals;=0A=
            } else {=0A=
              compare =3D simpleCompare;=0A=
            }=0A=
            parentSet =3D parentGet.assign || function() {=0A=
              // reset the change, or we will throw this exception on =
every $digest=0A=
              lastValue =3D destination[scopeName] =3D parentGet(scope);=0A=
              throw $compileMinErr('nonassign',=0A=
                  'Expression \'{0}\' in attribute \'{1}\' used with =
directive \'{2}\' is non-assignable!',=0A=
                  attrs[attrName], attrName, directive.name);=0A=
            };=0A=
            lastValue =3D destination[scopeName] =3D parentGet(scope);=0A=
            var parentValueWatch =3D function =
parentValueWatch(parentValue) {=0A=
              if (!compare(parentValue, destination[scopeName])) {=0A=
                // we are out of sync and need to copy=0A=
                if (!compare(parentValue, lastValue)) {=0A=
                  // parent changed and it has precedence=0A=
                  destination[scopeName] =3D parentValue;=0A=
                } else {=0A=
                  // if the parent can be assigned then do so=0A=
                  parentSet(scope, parentValue =3D =
destination[scopeName]);=0A=
                }=0A=
              }=0A=
              lastValue =3D parentValue;=0A=
              return lastValue;=0A=
            };=0A=
            parentValueWatch.$stateful =3D true;=0A=
            if (definition.collection) {=0A=
              removeWatch =3D scope.$watchCollection(attrs[attrName], =
parentValueWatch);=0A=
            } else {=0A=
              removeWatch =3D scope.$watch($parse(attrs[attrName], =
parentValueWatch), null, parentGet.literal);=0A=
            }=0A=
            removeWatchCollection.push(removeWatch);=0A=
            break;=0A=
=0A=
          case '&lt;':=0A=
            if (!hasOwnProperty.call(attrs, attrName)) {=0A=
              if (optional) break;=0A=
              attrs[attrName] =3D undefined;=0A=
            }=0A=
            if (optional &amp;&amp; !attrs[attrName]) break;=0A=
=0A=
            parentGet =3D $parse(attrs[attrName]);=0A=
            var deepWatch =3D parentGet.literal;=0A=
=0A=
            var initialValue =3D destination[scopeName] =3D =
parentGet(scope);=0A=
            initialChanges[scopeName] =3D new =
SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);=0A=
=0A=
            removeWatch =3D scope.$watch(parentGet, function =
parentValueWatchAction(newValue, oldValue) {=0A=
              if (oldValue =3D=3D=3D newValue) {=0A=
                if (oldValue =3D=3D=3D initialValue || (deepWatch =
&amp;&amp; equals(oldValue, initialValue))) {=0A=
                  return;=0A=
                }=0A=
                oldValue =3D initialValue;=0A=
              }=0A=
              recordChanges(scopeName, newValue, oldValue);=0A=
              destination[scopeName] =3D newValue;=0A=
            }, deepWatch);=0A=
=0A=
            removeWatchCollection.push(removeWatch);=0A=
            break;=0A=
=0A=
          case '&amp;':=0A=
            // Don't assign Object.prototype method to scope=0A=
            parentGet =3D attrs.hasOwnProperty(attrName) ? =
$parse(attrs[attrName]) : noop;=0A=
=0A=
            // Don't assign noop to destination if expression is not =
valid=0A=
            if (parentGet =3D=3D=3D noop &amp;&amp; optional) break;=0A=
=0A=
            destination[scopeName] =3D function(locals) {=0A=
              return parentGet(scope, locals);=0A=
            };=0A=
            break;=0A=
        }=0A=
      });=0A=
=0A=
      function recordChanges(key, currentValue, previousValue) {=0A=
        if (isFunction(destination.$onChanges) &amp;&amp; =
!simpleCompare(currentValue, previousValue)) {=0A=
          // If we have not already scheduled the top level =
onChangesQueue handler then do so now=0A=
          if (!onChangesQueue) {=0A=
            scope.$$postDigest(flushOnChangesQueue);=0A=
            onChangesQueue =3D [];=0A=
          }=0A=
          // If we have not already queued a trigger of onChanges for =
this controller then do so now=0A=
          if (!changes) {=0A=
            changes =3D {};=0A=
            onChangesQueue.push(triggerOnChangesHook);=0A=
          }=0A=
          // If the has been a change on this property already then we =
need to reuse the previous value=0A=
          if (changes[key]) {=0A=
            previousValue =3D changes[key].previousValue;=0A=
          }=0A=
          // Store this change=0A=
          changes[key] =3D new SimpleChange(previousValue, currentValue);=0A=
        }=0A=
      }=0A=
=0A=
      function triggerOnChangesHook() {=0A=
        destination.$onChanges(changes);=0A=
        // Now clear the changes so that we schedule onChanges when more =
changes arrive=0A=
        changes =3D undefined;=0A=
      }=0A=
=0A=
      return {=0A=
        initialChanges: initialChanges,=0A=
        removeWatches: removeWatchCollection.length &amp;&amp; function =
removeWatches() {=0A=
          for (var i =3D 0, ii =3D removeWatchCollection.length; i &lt; =
ii; ++i) {=0A=
            removeWatchCollection[i]();=0A=
          }=0A=
        }=0A=
      };=0A=
    }=0A=
  }];=0A=
}=0A=
=0A=
function SimpleChange(previous, current) {=0A=
  this.previousValue =3D previous;=0A=
  this.currentValue =3D current;=0A=
}=0A=
SimpleChange.prototype.isFirstChange =3D function() { return =
this.previousValue =3D=3D=3D _UNINITIALIZED_VALUE; };=0A=
=0A=
=0A=
var PREFIX_REGEXP =3D /^((?:x|data)[:\-_])/i;=0A=
var SPECIAL_CHARS_REGEXP =3D /[:\-_]+(.)/g;=0A=
=0A=
/**=0A=
 * Converts all accepted directives format into proper directive name.=0A=
 * @param name Name to normalize=0A=
 */=0A=
function directiveNormalize(name) {=0A=
  return name=0A=
    .replace(PREFIX_REGEXP, '')=0A=
    .replace(SPECIAL_CHARS_REGEXP, fnCamelCaseReplace);=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc type=0A=
 * @name $compile.directive.Attributes=0A=
 *=0A=
 * @description=0A=
 * A shared object between directive compile / linking functions which =
contains normalized DOM=0A=
 * element attributes. The values reflect current binding state `{{ }}`. =
The normalization is=0A=
 * needed since all of these are treated as equivalent in Angular:=0A=
 *=0A=
 * ```=0A=
 *    &lt;span ng:bind=3D"a" ng-bind=3D"a" data-ng-bind=3D"a" =
x-ng-bind=3D"a"&gt;=0A=
 * ```=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc property=0A=
 * @name $compile.directive.Attributes#$attr=0A=
 *=0A=
 * @description=0A=
 * A map of DOM element attribute names to the normalized name. This is=0A=
 * needed to do reverse lookup from normalized name back to actual name.=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $compile.directive.Attributes#$set=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Set DOM element attribute value.=0A=
 *=0A=
 *=0A=
 * @param {string} name Normalized element attribute name of the =
property to modify. The name is=0A=
 *          reverse-translated using the {@link =
ng.$compile.directive.Attributes#$attr $attr}=0A=
 *          property to the original name.=0A=
 * @param {string} value Value to set the attribute to. The value can be =
an interpolated string.=0A=
 */=0A=
=0A=
=0A=
=0A=
/**=0A=
 * Closure compiler type information=0A=
 */=0A=
=0A=
function nodesetLinkingFn(=0A=
  /* angular.Scope */ scope,=0A=
  /* NodeList */ nodeList,=0A=
  /* Element */ rootElement,=0A=
  /* function(Function) */ boundTranscludeFn=0A=
) {}=0A=
=0A=
function directiveLinkingFn(=0A=
  /* nodesetLinkingFn */ nodesetLinkingFn,=0A=
  /* angular.Scope */ scope,=0A=
  /* Node */ node,=0A=
  /* Element */ rootElement,=0A=
  /* function(Function) */ boundTranscludeFn=0A=
) {}=0A=
=0A=
function tokenDifference(str1, str2) {=0A=
  var values =3D '',=0A=
      tokens1 =3D str1.split(/\s+/),=0A=
      tokens2 =3D str2.split(/\s+/);=0A=
=0A=
  outer:=0A=
  for (var i =3D 0; i &lt; tokens1.length; i++) {=0A=
    var token =3D tokens1[i];=0A=
    for (var j =3D 0; j &lt; tokens2.length; j++) {=0A=
      if (token =3D=3D=3D tokens2[j]) continue outer;=0A=
    }=0A=
    values +=3D (values.length &gt; 0 ? ' ' : '') + token;=0A=
  }=0A=
  return values;=0A=
}=0A=
=0A=
function removeComments(jqNodes) {=0A=
  jqNodes =3D jqLite(jqNodes);=0A=
  var i =3D jqNodes.length;=0A=
=0A=
  if (i &lt;=3D 1) {=0A=
    return jqNodes;=0A=
  }=0A=
=0A=
  while (i--) {=0A=
    var node =3D jqNodes[i];=0A=
    if (node.nodeType =3D=3D=3D NODE_TYPE_COMMENT ||=0A=
       (node.nodeType =3D=3D=3D NODE_TYPE_TEXT &amp;&amp; =
node.nodeValue.trim() =3D=3D=3D '')) {=0A=
         splice.call(jqNodes, i, 1);=0A=
    }=0A=
  }=0A=
  return jqNodes;=0A=
}=0A=
=0A=
var $controllerMinErr =3D minErr('$controller');=0A=
=0A=
=0A=
var CNTRL_REG =3D /^(\S+)(\s+as\s+([\w$]+))?$/;=0A=
function identifierForController(controller, ident) {=0A=
  if (ident &amp;&amp; isString(ident)) return ident;=0A=
  if (isString(controller)) {=0A=
    var match =3D CNTRL_REG.exec(controller);=0A=
    if (match) return match[3];=0A=
  }=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $controllerProvider=0A=
 * @this=0A=
 *=0A=
 * @description=0A=
 * The {@link ng.$controller $controller service} is used by Angular to =
create new=0A=
 * controllers.=0A=
 *=0A=
 * This provider allows controller registration via the=0A=
 * {@link ng.$controllerProvider#register register} method.=0A=
 */=0A=
function $ControllerProvider() {=0A=
  var controllers =3D {},=0A=
      globals =3D false;=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $controllerProvider#has=0A=
   * @param {string} name Controller name to check.=0A=
   */=0A=
  this.has =3D function(name) {=0A=
    return controllers.hasOwnProperty(name);=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $controllerProvider#register=0A=
   * @param {string|Object} name Controller name, or an object map of =
controllers where the keys are=0A=
   *    the names and the values are the constructors.=0A=
   * @param {Function|Array} constructor Controller constructor fn =
(optionally decorated with DI=0A=
   *    annotations in the array notation).=0A=
   */=0A=
  this.register =3D function(name, constructor) {=0A=
    assertNotHasOwnProperty(name, 'controller');=0A=
    if (isObject(name)) {=0A=
      extend(controllers, name);=0A=
    } else {=0A=
      controllers[name] =3D constructor;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $controllerProvider#allowGlobals=0A=
   * @description If called, allows `$controller` to find controller =
constructors on `window`=0A=
   *=0A=
   * @deprecated=0A=
   * sinceVersion=3D"v1.3.0"=0A=
   * removeVersion=3D"v1.7.0"=0A=
   * This method of finding controllers has been deprecated.=0A=
   */=0A=
  this.allowGlobals =3D function() {=0A=
    globals =3D true;=0A=
  };=0A=
=0A=
=0A=
  this.$get =3D ['$injector', '$window', function($injector, $window) {=0A=
=0A=
    /**=0A=
     * @ngdoc service=0A=
     * @name $controller=0A=
     * @requires $injector=0A=
     *=0A=
     * @param {Function|string} constructor If called with a function =
then it's considered to be the=0A=
     *    controller constructor function. Otherwise it's considered to =
be a string which is used=0A=
     *    to retrieve the controller constructor using the following =
steps:=0A=
     *=0A=
     *    * check if a controller with given name is registered via =
`$controllerProvider`=0A=
     *    * check if evaluating the string on the current scope returns =
a constructor=0A=
     *    * if $controllerProvider#allowGlobals, check =
`window[constructor]` on the global=0A=
     *      `window` object (deprecated, not recommended)=0A=
     *=0A=
     *    The string can use the `controller as property` syntax, where =
the controller instance is published=0A=
     *    as the specified property on the `scope`; the `scope` must be =
injected into `locals` param for this=0A=
     *    to work correctly.=0A=
     *=0A=
     * @param {Object} locals Injection locals for Controller.=0A=
     * @return {Object} Instance of given controller.=0A=
     *=0A=
     * @description=0A=
     * `$controller` service is responsible for instantiating =
controllers.=0A=
     *=0A=
     * It's just a simple call to {@link auto.$injector $injector}, but =
extracted into=0A=
     * a service, so that one can override this service with [BC =
version](https://gist.github.com/1649788).=0A=
     */=0A=
    return function $controller(expression, locals, later, ident) {=0A=
      // PRIVATE API:=0A=
      //   param `later` --- indicates that the controller's constructor =
is invoked at a later time.=0A=
      //                     If true, $controller will allocate the =
object with the correct=0A=
      //                     prototype chain, but will not invoke the =
controller until a returned=0A=
      //                     callback is invoked.=0A=
      //   param `ident` --- An optional label which overrides the label =
parsed from the controller=0A=
      //                     expression, if any.=0A=
      var instance, match, constructor, identifier;=0A=
      later =3D later =3D=3D=3D true;=0A=
      if (ident &amp;&amp; isString(ident)) {=0A=
        identifier =3D ident;=0A=
      }=0A=
=0A=
      if (isString(expression)) {=0A=
        match =3D expression.match(CNTRL_REG);=0A=
        if (!match) {=0A=
          throw $controllerMinErr('ctrlfmt',=0A=
            'Badly formed controller string \'{0}\'. ' +=0A=
            'Must match `__name__ as __id__` or `__name__`.', =
expression);=0A=
        }=0A=
        constructor =3D match[1];=0A=
        identifier =3D identifier || match[3];=0A=
        expression =3D controllers.hasOwnProperty(constructor)=0A=
            ? controllers[constructor]=0A=
            : getter(locals.$scope, constructor, true) ||=0A=
                (globals ? getter($window, constructor, true) : =
undefined);=0A=
=0A=
        if (!expression) {=0A=
          throw $controllerMinErr('ctrlreg',=0A=
            'The controller with the name \'{0}\' is not registered.', =
constructor);=0A=
        }=0A=
=0A=
        assertArgFn(expression, constructor, true);=0A=
      }=0A=
=0A=
      if (later) {=0A=
        // Instantiate controller later:=0A=
        // This machinery is used to create an instance of the object =
before calling the=0A=
        // controller's constructor itself.=0A=
        //=0A=
        // This allows properties to be added to the controller before =
the constructor is=0A=
        // invoked. Primarily, this is used for isolate scope bindings =
in $compile.=0A=
        //=0A=
        // This feature is not intended for use by applications, and is =
thus not documented=0A=
        // publicly.=0A=
        // Object creation: http://jsperf.com/create-constructor/2=0A=
        var controllerPrototype =3D (isArray(expression) ?=0A=
          expression[expression.length - 1] : expression).prototype;=0A=
        instance =3D Object.create(controllerPrototype || null);=0A=
=0A=
        if (identifier) {=0A=
          addIdentifier(locals, identifier, instance, constructor || =
expression.name);=0A=
        }=0A=
=0A=
        return extend(function $controllerInit() {=0A=
          var result =3D $injector.invoke(expression, instance, locals, =
constructor);=0A=
          if (result !=3D=3D instance &amp;&amp; (isObject(result) || =
isFunction(result))) {=0A=
            instance =3D result;=0A=
            if (identifier) {=0A=
              // If result changed, re-assign controllerAs value to =
scope.=0A=
              addIdentifier(locals, identifier, instance, constructor || =
expression.name);=0A=
            }=0A=
          }=0A=
          return instance;=0A=
        }, {=0A=
          instance: instance,=0A=
          identifier: identifier=0A=
        });=0A=
      }=0A=
=0A=
      instance =3D $injector.instantiate(expression, locals, =
constructor);=0A=
=0A=
      if (identifier) {=0A=
        addIdentifier(locals, identifier, instance, constructor || =
expression.name);=0A=
      }=0A=
=0A=
      return instance;=0A=
    };=0A=
=0A=
    function addIdentifier(locals, identifier, instance, name) {=0A=
      if (!(locals &amp;&amp; isObject(locals.$scope))) {=0A=
        throw minErr('$controller')('noscp',=0A=
          'Cannot export controller \'{0}\' as \'{1}\'! No $scope object =
provided via `locals`.',=0A=
          name, identifier);=0A=
      }=0A=
=0A=
      locals.$scope[identifier] =3D instance;=0A=
    }=0A=
  }];=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $document=0A=
 * @requires $window=0A=
 * @this=0A=
 *=0A=
 * @description=0A=
 * A {@link angular.element jQuery or jqLite} wrapper for the browser's =
`window.document` object.=0A=
 *=0A=
 * @example=0A=
   &lt;example module=3D"documentExample" name=3D"document"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
         &lt;p&gt;$document title: &lt;b =
ng-bind=3D"title"&gt;&lt;/b&gt;&lt;/p&gt;=0A=
         &lt;p&gt;window.document title: &lt;b =
ng-bind=3D"windowTitle"&gt;&lt;/b&gt;&lt;/p&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"script.js"&gt;=0A=
       angular.module('documentExample', [])=0A=
         .controller('ExampleController', ['$scope', '$document', =
function($scope, $document) {=0A=
           $scope.title =3D $document[0].title;=0A=
           $scope.windowTitle =3D =
angular.element(window.document)[0].title;=0A=
         }]);=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
function $DocumentProvider() {=0A=
  this.$get =3D ['$window', function(window) {=0A=
    return jqLite(window.document);=0A=
  }];=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @private=0A=
 * @this=0A=
 * Listens for document visibility change and makes the current status =
accessible.=0A=
 */=0A=
function $$IsDocumentHiddenProvider() {=0A=
  this.$get =3D ['$document', '$rootScope', function($document, =
$rootScope) {=0A=
    var doc =3D $document[0];=0A=
    var hidden =3D doc &amp;&amp; doc.hidden;=0A=
=0A=
    $document.on('visibilitychange', changeListener);=0A=
=0A=
    $rootScope.$on('$destroy', function() {=0A=
      $document.off('visibilitychange', changeListener);=0A=
    });=0A=
=0A=
    function changeListener() {=0A=
      hidden =3D doc.hidden;=0A=
    }=0A=
=0A=
    return function() {=0A=
      return hidden;=0A=
    };=0A=
  }];=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $exceptionHandler=0A=
 * @requires ng.$log=0A=
 * @this=0A=
 *=0A=
 * @description=0A=
 * Any uncaught exception in angular expressions is delegated to this =
service.=0A=
 * The default implementation simply delegates to `$log.error` which =
logs it into=0A=
 * the browser console.=0A=
 *=0A=
 * In unit tests, if `angular-mocks.js` is loaded, this service is =
overridden by=0A=
 * {@link ngMock.$exceptionHandler mock $exceptionHandler} which aids in =
testing.=0A=
 *=0A=
 * ## Example:=0A=
 *=0A=
 * The example below will overwrite the default `$exceptionHandler` in =
order to (a) log uncaught=0A=
 * errors to the backend for later inspection by the developers and (b) =
to use `$log.warn()` instead=0A=
 * of `$log.error()`.=0A=
 *=0A=
 * ```js=0A=
 *   angular.=0A=
 *     module('exceptionOverwrite', []).=0A=
 *     factory('$exceptionHandler', ['$log', 'logErrorsToBackend', =
function($log, logErrorsToBackend) {=0A=
 *       return function myExceptionHandler(exception, cause) {=0A=
 *         logErrorsToBackend(exception, cause);=0A=
 *         $log.warn(exception, cause);=0A=
 *       };=0A=
 *     }]);=0A=
 * ```=0A=
 *=0A=
 * &lt;hr /&gt;=0A=
 * Note, that code executed in event-listeners (even those registered =
using jqLite's `on`/`bind`=0A=
 * methods) does not delegate exceptions to the {@link =
ng.$exceptionHandler $exceptionHandler}=0A=
 * (unless executed during a digest).=0A=
 *=0A=
 * If you wish, you can manually delegate exceptions, e.g.=0A=
 * `try { ... } catch(e) { $exceptionHandler(e); }`=0A=
 *=0A=
 * @param {Error} exception Exception associated with the error.=0A=
 * @param {string=3D} cause Optional information about the context in =
which=0A=
 *       the error was thrown.=0A=
 *=0A=
 */=0A=
function $ExceptionHandlerProvider() {=0A=
  this.$get =3D ['$log', function($log) {=0A=
    return function(exception, cause) {=0A=
      $log.error.apply($log, arguments);=0A=
    };=0A=
  }];=0A=
}=0A=
=0A=
var $$ForceReflowProvider =3D /** @this */ function() {=0A=
  this.$get =3D ['$document', function($document) {=0A=
    return function(domNode) {=0A=
      //the line below will force the browser to perform a repaint so=0A=
      //that all the animated elements within the animation frame will=0A=
      //be properly updated and drawn on screen. This is required to=0A=
      //ensure that the preparation animation is properly flushed so that=0A=
      //the active state picks up from there. DO NOT REMOVE THIS LINE.=0A=
      //DO NOT OPTIMIZE THIS LINE. THE MINIFIER WILL REMOVE IT OTHERWISE =
WHICH=0A=
      //WILL RESULT IN AN UNPREDICTABLE BUG THAT IS VERY HARD TO TRACK =
DOWN AND=0A=
      //WILL TAKE YEARS AWAY FROM YOUR LIFE.=0A=
      if (domNode) {=0A=
        if (!domNode.nodeType &amp;&amp; domNode instanceof jqLite) {=0A=
          domNode =3D domNode[0];=0A=
        }=0A=
      } else {=0A=
        domNode =3D $document[0].body;=0A=
      }=0A=
      return domNode.offsetWidth + 1;=0A=
    };=0A=
  }];=0A=
};=0A=
=0A=
var APPLICATION_JSON =3D 'application/json';=0A=
var CONTENT_TYPE_APPLICATION_JSON =3D {'Content-Type': APPLICATION_JSON =
+ ';charset=3Dutf-8'};=0A=
var JSON_START =3D /^\[|^\{(?!\{)/;=0A=
var JSON_ENDS =3D {=0A=
  '[': /]$/,=0A=
  '{': /}$/=0A=
};=0A=
var JSON_PROTECTION_PREFIX =3D /^\)]\}',?\n/;=0A=
var $httpMinErr =3D minErr('$http');=0A=
=0A=
function serializeValue(v) {=0A=
  if (isObject(v)) {=0A=
    return isDate(v) ? v.toISOString() : toJson(v);=0A=
  }=0A=
  return v;=0A=
}=0A=
=0A=
=0A=
/** @this */=0A=
function $HttpParamSerializerProvider() {=0A=
  /**=0A=
   * @ngdoc service=0A=
   * @name $httpParamSerializer=0A=
   * @description=0A=
   *=0A=
   * Default {@link $http `$http`} params serializer that converts =
objects to strings=0A=
   * according to the following rules:=0A=
   *=0A=
   * * `{'foo': 'bar'}` results in `foo=3Dbar`=0A=
   * * `{'foo': Date.now()}` results in =
`foo=3D2015-04-01T09%3A50%3A49.262Z` (`toISOString()` and encoded =
representation of a Date object)=0A=
   * * `{'foo': ['bar', 'baz']}` results in `foo=3Dbar&amp;foo=3Dbaz` =
(repeated key for each array element)=0A=
   * * `{'foo': {'bar':'baz'}}` results in =
`foo=3D%7B%22bar%22%3A%22baz%22%7D` (stringified and encoded =
representation of an object)=0A=
   *=0A=
   * Note that serializer will sort the request parameters =
alphabetically.=0A=
   * */=0A=
=0A=
  this.$get =3D function() {=0A=
    return function ngParamSerializer(params) {=0A=
      if (!params) return '';=0A=
      var parts =3D [];=0A=
      forEachSorted(params, function(value, key) {=0A=
        if (value =3D=3D=3D null || isUndefined(value)) return;=0A=
        if (isArray(value)) {=0A=
          forEach(value, function(v) {=0A=
            parts.push(encodeUriQuery(key)  + '=3D' + =
encodeUriQuery(serializeValue(v)));=0A=
          });=0A=
        } else {=0A=
          parts.push(encodeUriQuery(key) + '=3D' + =
encodeUriQuery(serializeValue(value)));=0A=
        }=0A=
      });=0A=
=0A=
      return parts.join('&amp;');=0A=
    };=0A=
  };=0A=
}=0A=
=0A=
/** @this */=0A=
function $HttpParamSerializerJQLikeProvider() {=0A=
  /**=0A=
   * @ngdoc service=0A=
   * @name $httpParamSerializerJQLike=0A=
   *=0A=
   * @description=0A=
   *=0A=
   * Alternative {@link $http `$http`} params serializer that follows=0A=
   * jQuery's [`param()`](http://api.jquery.com/jquery.param/) method =
logic.=0A=
   * The serializer will also sort the params alphabetically.=0A=
   *=0A=
   * To use it for serializing `$http` request parameters, set it as the =
`paramSerializer` property:=0A=
   *=0A=
   * ```js=0A=
   * $http({=0A=
   *   url: myUrl,=0A=
   *   method: 'GET',=0A=
   *   params: myParams,=0A=
   *   paramSerializer: '$httpParamSerializerJQLike'=0A=
   * });=0A=
   * ```=0A=
   *=0A=
   * It is also possible to set it as the default `paramSerializer` in =
the=0A=
   * {@link $httpProvider#defaults `$httpProvider`}.=0A=
   *=0A=
   * Additionally, you can inject the serializer and use it explicitly, =
for example to serialize=0A=
   * form data for submission:=0A=
   *=0A=
   * ```js=0A=
   * .controller(function($http, $httpParamSerializerJQLike) {=0A=
   *   //...=0A=
   *=0A=
   *   $http({=0A=
   *     url: myUrl,=0A=
   *     method: 'POST',=0A=
   *     data: $httpParamSerializerJQLike(myData),=0A=
   *     headers: {=0A=
   *       'Content-Type': 'application/x-www-form-urlencoded'=0A=
   *     }=0A=
   *   });=0A=
   *=0A=
   * });=0A=
   * ```=0A=
   *=0A=
   * */=0A=
  this.$get =3D function() {=0A=
    return function jQueryLikeParamSerializer(params) {=0A=
      if (!params) return '';=0A=
      var parts =3D [];=0A=
      serialize(params, '', true);=0A=
      return parts.join('&amp;');=0A=
=0A=
      function serialize(toSerialize, prefix, topLevel) {=0A=
        if (toSerialize =3D=3D=3D null || isUndefined(toSerialize)) =
return;=0A=
        if (isArray(toSerialize)) {=0A=
          forEach(toSerialize, function(value, index) {=0A=
            serialize(value, prefix + '[' + (isObject(value) ? index : =
'') + ']');=0A=
          });=0A=
        } else if (isObject(toSerialize) &amp;&amp; =
!isDate(toSerialize)) {=0A=
          forEachSorted(toSerialize, function(value, key) {=0A=
            serialize(value, prefix +=0A=
                (topLevel ? '' : '[') +=0A=
                key +=0A=
                (topLevel ? '' : ']'));=0A=
          });=0A=
        } else {=0A=
          parts.push(encodeUriQuery(prefix) + '=3D' + =
encodeUriQuery(serializeValue(toSerialize)));=0A=
        }=0A=
      }=0A=
    };=0A=
  };=0A=
}=0A=
=0A=
function defaultHttpResponseTransform(data, headers) {=0A=
  if (isString(data)) {=0A=
    // Strip json vulnerability protection prefix and trim whitespace=0A=
    var tempData =3D data.replace(JSON_PROTECTION_PREFIX, '').trim();=0A=
=0A=
    if (tempData) {=0A=
      var contentType =3D headers('Content-Type');=0A=
      if ((contentType &amp;&amp; (contentType.indexOf(APPLICATION_JSON) =
=3D=3D=3D 0)) || isJsonLike(tempData)) {=0A=
        try {=0A=
          data =3D fromJson(tempData);=0A=
        } catch (e) {=0A=
          throw $httpMinErr('baddata', 'Data must be a valid JSON =
object. Received: "{0}". ' +=0A=
          'Parse error: "{1}"', data, e);=0A=
        }=0A=
      }=0A=
    }=0A=
  }=0A=
=0A=
  return data;=0A=
}=0A=
=0A=
function isJsonLike(str) {=0A=
    var jsonStart =3D str.match(JSON_START);=0A=
    return jsonStart &amp;&amp; JSON_ENDS[jsonStart[0]].test(str);=0A=
}=0A=
=0A=
/**=0A=
 * Parse headers into key value object=0A=
 *=0A=
 * @param {string} headers Raw headers as a string=0A=
 * @returns {Object} Parsed headers as key value object=0A=
 */=0A=
function parseHeaders(headers) {=0A=
  var parsed =3D createMap(), i;=0A=
=0A=
  function fillInParsed(key, val) {=0A=
    if (key) {=0A=
      parsed[key] =3D parsed[key] ? parsed[key] + ', ' + val : val;=0A=
    }=0A=
  }=0A=
=0A=
  if (isString(headers)) {=0A=
    forEach(headers.split('\n'), function(line) {=0A=
      i =3D line.indexOf(':');=0A=
      fillInParsed(lowercase(trim(line.substr(0, i))), =
trim(line.substr(i + 1)));=0A=
    });=0A=
  } else if (isObject(headers)) {=0A=
    forEach(headers, function(headerVal, headerKey) {=0A=
      fillInParsed(lowercase(headerKey), trim(headerVal));=0A=
    });=0A=
  }=0A=
=0A=
  return parsed;=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * Returns a function that provides access to parsed headers.=0A=
 *=0A=
 * Headers are lazy parsed when first requested.=0A=
 * @see parseHeaders=0A=
 *=0A=
 * @param {(string|Object)} headers Headers to provide access to.=0A=
 * @returns {function(string=3D)} Returns a getter function which if =
called with:=0A=
 *=0A=
 *   - if called with an argument returns a single header value or null=0A=
 *   - if called with no arguments returns an object containing all =
headers.=0A=
 */=0A=
function headersGetter(headers) {=0A=
  var headersObj;=0A=
=0A=
  return function(name) {=0A=
    if (!headersObj) headersObj =3D  parseHeaders(headers);=0A=
=0A=
    if (name) {=0A=
      var value =3D headersObj[lowercase(name)];=0A=
      if (value =3D=3D=3D undefined) {=0A=
        value =3D null;=0A=
      }=0A=
      return value;=0A=
    }=0A=
=0A=
    return headersObj;=0A=
  };=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * Chain all given functions=0A=
 *=0A=
 * This function is used for both request and response transforming=0A=
 *=0A=
 * @param {*} data Data to transform.=0A=
 * @param {function(string=3D)} headers HTTP headers getter fn.=0A=
 * @param {number} status HTTP status code of the response.=0A=
 * @param {(Function|Array.&lt;Function&gt;)} fns Function or an array =
of functions.=0A=
 * @returns {*} Transformed data.=0A=
 */=0A=
function transformData(data, headers, status, fns) {=0A=
  if (isFunction(fns)) {=0A=
    return fns(data, headers, status);=0A=
  }=0A=
=0A=
  forEach(fns, function(fn) {=0A=
    data =3D fn(data, headers, status);=0A=
  });=0A=
=0A=
  return data;=0A=
}=0A=
=0A=
=0A=
function isSuccess(status) {=0A=
  return 200 &lt;=3D status &amp;&amp; status &lt; 300;=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $httpProvider=0A=
 * @this=0A=
 *=0A=
 * @description=0A=
 * Use `$httpProvider` to change the default behavior of the {@link =
ng.$http $http} service.=0A=
 * */=0A=
function $HttpProvider() {=0A=
  /**=0A=
   * @ngdoc property=0A=
   * @name $httpProvider#defaults=0A=
   * @description=0A=
   *=0A=
   * Object containing default values for all {@link ng.$http $http} =
requests.=0A=
   *=0A=
   * - **`defaults.cache`** - {boolean|Object} - A boolean value or =
object created with=0A=
   * {@link ng.$cacheFactory `$cacheFactory`} to enable or disable =
caching of HTTP responses=0A=
   * by default. See {@link $http#caching $http Caching} for more =
information.=0A=
   *=0A=
   * - **`defaults.headers`** - {Object} - Default headers for all $http =
requests.=0A=
   * Refer to {@link ng.$http#setting-http-headers $http} for =
documentation on=0A=
   * setting default headers.=0A=
   *     - **`defaults.headers.common`**=0A=
   *     - **`defaults.headers.post`**=0A=
   *     - **`defaults.headers.put`**=0A=
   *     - **`defaults.headers.patch`**=0A=
   *=0A=
   * - **`defaults.jsonpCallbackParam`** - `{string}` - the name of the =
query parameter that passes the name of the=0A=
   * callback in a JSONP request. The value of this parameter will be =
replaced with the expression generated by the=0A=
   * {@link $jsonpCallbacks} service. Defaults to `'callback'`.=0A=
   *=0A=
   * - **`defaults.paramSerializer`** - =
`{string|function(Object&lt;string,string&gt;):string}` - A function=0A=
   *  used to the prepare string representation of request parameters =
(specified as an object).=0A=
   *  If specified as string, it is interpreted as a function registered =
with the {@link auto.$injector $injector}.=0A=
   *  Defaults to {@link ng.$httpParamSerializer $httpParamSerializer}.=0A=
   *=0A=
   * - **`defaults.transformRequest`** -=0A=
   * `{Array&lt;function(data, headersGetter)&gt;|function(data, =
headersGetter)}` -=0A=
   * An array of functions (or a single function) which are applied to =
the request data.=0A=
   * By default, this is an array with one request transformation =
function:=0A=
   *=0A=
   *   - If the `data` property of the request configuration object =
contains an object, serialize it=0A=
   *     into JSON format.=0A=
   *=0A=
   * - **`defaults.transformResponse`** -=0A=
   * `{Array&lt;function(data, headersGetter, status)&gt;|function(data, =
headersGetter, status)}` -=0A=
   * An array of functions (or a single function) which are applied to =
the response data. By default,=0A=
   * this is an array which applies one response transformation function =
that does two things:=0A=
   *=0A=
   *  - If XSRF prefix is detected, strip it=0A=
   *    (see {@link ng.$http#security-considerations Security =
Considerations in the $http docs}).=0A=
   *  - If the `Content-Type` is `application/json` or the response =
looks like JSON,=0A=
   *    deserialize it using a JSON parser.=0A=
   *=0A=
   * - **`defaults.xsrfCookieName`** - {string} - Name of cookie =
containing the XSRF token.=0A=
   * Defaults value is `'XSRF-TOKEN'`.=0A=
   *=0A=
   * - **`defaults.xsrfHeaderName`** - {string} - Name of HTTP header to =
populate with the=0A=
   * XSRF token. Defaults value is `'X-XSRF-TOKEN'`.=0A=
   *=0A=
   **/=0A=
  var defaults =3D this.defaults =3D {=0A=
    // transform incoming response data=0A=
    transformResponse: [defaultHttpResponseTransform],=0A=
=0A=
    // transform outgoing request data=0A=
    transformRequest: [function(d) {=0A=
      return isObject(d) &amp;&amp; !isFile(d) &amp;&amp; !isBlob(d) =
&amp;&amp; !isFormData(d) ? toJson(d) : d;=0A=
    }],=0A=
=0A=
    // default headers=0A=
    headers: {=0A=
      common: {=0A=
        'Accept': 'application/json, text/plain, */*'=0A=
      },=0A=
      post:   shallowCopy(CONTENT_TYPE_APPLICATION_JSON),=0A=
      put:    shallowCopy(CONTENT_TYPE_APPLICATION_JSON),=0A=
      patch:  shallowCopy(CONTENT_TYPE_APPLICATION_JSON)=0A=
    },=0A=
=0A=
    xsrfCookieName: 'XSRF-TOKEN',=0A=
    xsrfHeaderName: 'X-XSRF-TOKEN',=0A=
=0A=
    paramSerializer: '$httpParamSerializer',=0A=
=0A=
    jsonpCallbackParam: 'callback'=0A=
  };=0A=
=0A=
  var useApplyAsync =3D false;=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $httpProvider#useApplyAsync=0A=
   * @description=0A=
   *=0A=
   * Configure $http service to combine processing of multiple http =
responses received at around=0A=
   * the same time via {@link ng.$rootScope.Scope#$applyAsync =
$rootScope.$applyAsync}. This can result in=0A=
   * significant performance improvement for bigger applications that =
make many HTTP requests=0A=
   * concurrently (common during application bootstrap).=0A=
   *=0A=
   * Defaults to false. If no value is specified, returns the current =
configured value.=0A=
   *=0A=
   * @param {boolean=3D} value If true, when requests are loaded, they =
will schedule a deferred=0A=
   *    "apply" on the next tick, giving time for subsequent requests in =
a roughly ~10ms window=0A=
   *    to load and share the same digest cycle.=0A=
   *=0A=
   * @returns {boolean|Object} If a value is specified, returns the =
$httpProvider for chaining.=0A=
   *    otherwise, returns the current configured value.=0A=
   **/=0A=
  this.useApplyAsync =3D function(value) {=0A=
    if (isDefined(value)) {=0A=
      useApplyAsync =3D !!value;=0A=
      return this;=0A=
    }=0A=
    return useApplyAsync;=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc property=0A=
   * @name $httpProvider#interceptors=0A=
   * @description=0A=
   *=0A=
   * Array containing service factories for all synchronous or =
asynchronous {@link ng.$http $http}=0A=
   * pre-processing of request or postprocessing of responses.=0A=
   *=0A=
   * These service factories are ordered by request, i.e. they are =
applied in the same order as the=0A=
   * array, on request, but reverse order, on response.=0A=
   *=0A=
   * {@link ng.$http#interceptors Interceptors detailed info}=0A=
   **/=0A=
  var interceptorFactories =3D this.interceptors =3D [];=0A=
=0A=
  this.$get =3D ['$browser', '$httpBackend', '$$cookieReader', =
'$cacheFactory', '$rootScope', '$q', '$injector', '$sce',=0A=
      function($browser, $httpBackend, $$cookieReader, $cacheFactory, =
$rootScope, $q, $injector, $sce) {=0A=
=0A=
    var defaultCache =3D $cacheFactory('$http');=0A=
=0A=
    /**=0A=
     * Make sure that default param serializer is exposed as a function=0A=
     */=0A=
    defaults.paramSerializer =3D isString(defaults.paramSerializer) ?=0A=
      $injector.get(defaults.paramSerializer) : defaults.paramSerializer;=0A=
=0A=
    /**=0A=
     * Interceptors stored in reverse order. Inner interceptors before =
outer interceptors.=0A=
     * The reversal is needed so that we can build up the interception =
chain around the=0A=
     * server request.=0A=
     */=0A=
    var reversedInterceptors =3D [];=0A=
=0A=
    forEach(interceptorFactories, function(interceptorFactory) {=0A=
      reversedInterceptors.unshift(isString(interceptorFactory)=0A=
          ? $injector.get(interceptorFactory) : =
$injector.invoke(interceptorFactory));=0A=
    });=0A=
=0A=
    /**=0A=
     * @ngdoc service=0A=
     * @kind function=0A=
     * @name $http=0A=
     * @requires ng.$httpBackend=0A=
     * @requires $cacheFactory=0A=
     * @requires $rootScope=0A=
     * @requires $q=0A=
     * @requires $injector=0A=
     *=0A=
     * @description=0A=
     * The `$http` service is a core Angular service that facilitates =
communication with the remote=0A=
     * HTTP servers via the browser's =
[XMLHttpRequest](https://developer.mozilla.org/en/xmlhttprequest)=0A=
     * object or via [JSONP](http://en.wikipedia.org/wiki/JSONP).=0A=
     *=0A=
     * For unit testing applications that use `$http` service, see=0A=
     * {@link ngMock.$httpBackend $httpBackend mock}.=0A=
     *=0A=
     * For a higher level of abstraction, please check out the {@link =
ngResource.$resource=0A=
     * $resource} service.=0A=
     *=0A=
     * The $http API is based on the {@link ng.$q deferred/promise APIs} =
exposed by=0A=
     * the $q service. While for simple usage patterns this doesn't =
matter much, for advanced usage=0A=
     * it is important to familiarize yourself with these APIs and the =
guarantees they provide.=0A=
     *=0A=
     *=0A=
     * ## General usage=0A=
     * The `$http` service is a function which takes a single argument =
=E2=80&#65533; a {@link $http#usage configuration object} =E2=80&#65533;=0A=
     * that is used to generate an HTTP request and returns  a {@link =
ng.$q promise}.=0A=
     *=0A=
     * ```js=0A=
     *   // Simple GET request example:=0A=
     *   $http({=0A=
     *     method: 'GET',=0A=
     *     url: '/someUrl'=0A=
     *   }).then(function successCallback(response) {=0A=
     *       // this callback will be called asynchronously=0A=
     *       // when the response is available=0A=
     *     }, function errorCallback(response) {=0A=
     *       // called asynchronously if an error occurs=0A=
     *       // or server returns response with an error status.=0A=
     *     });=0A=
     * ```=0A=
     *=0A=
     * The response object has these properties:=0A=
     *=0A=
     *   - **data** =E2=80&#65533; `{string|Object}` =E2=80&#65533; The =
response body transformed with the transform=0A=
     *     functions.=0A=
     *   - **status** =E2=80&#65533; `{number}` =E2=80&#65533; HTTP =
status code of the response.=0A=
     *   - **headers** =E2=80&#65533; `{function([headerName])}` =
=E2=80&#65533; Header getter function.=0A=
     *   - **config** =E2=80&#65533; `{Object}` =E2=80&#65533; The =
configuration object that was used to generate the request.=0A=
     *   - **statusText** =E2=80&#65533; `{string}` =E2=80&#65533; HTTP =
status text of the response.=0A=
     *=0A=
     * A response status code between 200 and 299 is considered a =
success status and will result in=0A=
     * the success callback being called. Any response status code =
outside of that range is=0A=
     * considered an error status and will result in the error callback =
being called.=0A=
     * Also, status codes less than -1 are normalized to zero. -1 =
usually means the request was=0A=
     * aborted, e.g. using a `config.timeout`.=0A=
     * Note that if the response is a redirect, XMLHttpRequest will =
transparently follow it, meaning=0A=
     * that the outcome (success or error) will be determined by the =
final response status code.=0A=
     *=0A=
     *=0A=
     * ## Shortcut methods=0A=
     *=0A=
     * Shortcut methods are also available. All shortcut methods require =
passing in the URL, and=0A=
     * request data must be passed in for POST/PUT requests. An optional =
config can be passed as the=0A=
     * last argument.=0A=
     *=0A=
     * ```js=0A=
     *   $http.get('/someUrl', config).then(successCallback, =
errorCallback);=0A=
     *   $http.post('/someUrl', data, config).then(successCallback, =
errorCallback);=0A=
     * ```=0A=
     *=0A=
     * Complete list of shortcut methods:=0A=
     *=0A=
     * - {@link ng.$http#get $http.get}=0A=
     * - {@link ng.$http#head $http.head}=0A=
     * - {@link ng.$http#post $http.post}=0A=
     * - {@link ng.$http#put $http.put}=0A=
     * - {@link ng.$http#delete $http.delete}=0A=
     * - {@link ng.$http#jsonp $http.jsonp}=0A=
     * - {@link ng.$http#patch $http.patch}=0A=
     *=0A=
     *=0A=
     * ## Writing Unit Tests that use $http=0A=
     * When unit testing (using {@link ngMock ngMock}), it is necessary =
to call=0A=
     * {@link ngMock.$httpBackend#flush $httpBackend.flush()} to flush =
each pending=0A=
     * request using trained responses.=0A=
     *=0A=
     * ```=0A=
     * $httpBackend.expectGET(...);=0A=
     * $http.get(...);=0A=
     * $httpBackend.flush();=0A=
     * ```=0A=
     *=0A=
     * ## Setting HTTP Headers=0A=
     *=0A=
     * The $http service will automatically add certain HTTP headers to =
all requests. These defaults=0A=
     * can be fully configured by accessing the =
`$httpProvider.defaults.headers` configuration=0A=
     * object, which currently contains this default configuration:=0A=
     *=0A=
     * - `$httpProvider.defaults.headers.common` (headers that are =
common for all requests):=0A=
     *   - &lt;code&gt;Accept: application/json, text/plain, =
\*&amp;#65279;/&amp;#65279;\*&lt;/code&gt;=0A=
     * - `$httpProvider.defaults.headers.post`: (header defaults for =
POST requests)=0A=
     *   - `Content-Type: application/json`=0A=
     * - `$httpProvider.defaults.headers.put` (header defaults for PUT =
requests)=0A=
     *   - `Content-Type: application/json`=0A=
     *=0A=
     * To add or overwrite these defaults, simply add or remove a =
property from these configuration=0A=
     * objects. To add headers for an HTTP method other than POST or =
PUT, simply add a new object=0A=
     * with the lowercased HTTP method name as the key, e.g.=0A=
     * `$httpProvider.defaults.headers.get =3D { 'My-Header' : 'value' =
}`.=0A=
     *=0A=
     * The defaults can also be set at runtime via the `$http.defaults` =
object in the same=0A=
     * fashion. For example:=0A=
     *=0A=
     * ```=0A=
     * module.run(function($http) {=0A=
     *   $http.defaults.headers.common.Authorization =3D 'Basic =
YmVlcDpib29w';=0A=
     * });=0A=
     * ```=0A=
     *=0A=
     * In addition, you can supply a `headers` property in the config =
object passed when=0A=
     * calling `$http(config)`, which overrides the defaults without =
changing them globally.=0A=
     *=0A=
     * To explicitly remove a header automatically added via =
$httpProvider.defaults.headers on a per request basis,=0A=
     * Use the `headers` property, setting the desired header to =
`undefined`. For example:=0A=
     *=0A=
     * ```js=0A=
     * var req =3D {=0A=
     *  method: 'POST',=0A=
     *  url: 'http://example.com',=0A=
     *  headers: {=0A=
     *    'Content-Type': undefined=0A=
     *  },=0A=
     *  data: { test: 'test' }=0A=
     * }=0A=
     *=0A=
     * $http(req).then(function(){...}, function(){...});=0A=
     * ```=0A=
     *=0A=
     * ## Transforming Requests and Responses=0A=
     *=0A=
     * Both requests and responses can be transformed using =
transformation functions: `transformRequest`=0A=
     * and `transformResponse`. These properties can be a single =
function that returns=0A=
     * the transformed value (`function(data, headersGetter, status)`) =
or an array of such transformation functions,=0A=
     * which allows you to `push` or `unshift` a new transformation =
function into the transformation chain.=0A=
     *=0A=
     * &lt;div class=3D"alert alert-warning"&gt;=0A=
     * **Note:** Angular does not make a copy of the `data` parameter =
before it is passed into the `transformRequest` pipeline.=0A=
     * That means changes to the properties of `data` are not local to =
the transform function (since Javascript passes objects by reference).=0A=
     * For example, when calling `$http.get(url, $scope.myObject)`, =
modifications to the object's properties in a transformRequest=0A=
     * function will be reflected on the scope and in any templates =
where the object is data-bound.=0A=
     * To prevent this, transform functions should have no side-effects.=0A=
     * If you need to modify properties, it is recommended to make a =
copy of the data, or create new object to return.=0A=
     * &lt;/div&gt;=0A=
     *=0A=
     * ### Default Transformations=0A=
     *=0A=
     * The `$httpProvider` provider and `$http` service expose =
`defaults.transformRequest` and=0A=
     * `defaults.transformResponse` properties. If a request does not =
provide its own transformations=0A=
     * then these will be applied.=0A=
     *=0A=
     * You can augment or replace the default transformations by =
modifying these properties by adding to or=0A=
     * replacing the array.=0A=
     *=0A=
     * Angular provides the following default transformations:=0A=
     *=0A=
     * Request transformations =
(`$httpProvider.defaults.transformRequest` and =
`$http.defaults.transformRequest`) is=0A=
     * an array with one function that does the following:=0A=
     *=0A=
     * - If the `data` property of the request configuration object =
contains an object, serialize it=0A=
     *   into JSON format.=0A=
     *=0A=
     * Response transformations =
(`$httpProvider.defaults.transformResponse` and =
`$http.defaults.transformResponse`) is=0A=
     * an array with one function that does the following:=0A=
     *=0A=
     *  - If XSRF prefix is detected, strip it (see Security =
Considerations section below).=0A=
     *  - If the `Content-Type` is `application/json` or the response =
looks like JSON,=0A=
   *      deserialize it using a JSON parser.=0A=
     *=0A=
     *=0A=
     * ### Overriding the Default Transformations Per Request=0A=
     *=0A=
     * If you wish to override the request/response transformations only =
for a single request then provide=0A=
     * `transformRequest` and/or `transformResponse` properties on the =
configuration object passed=0A=
     * into `$http`.=0A=
     *=0A=
     * Note that if you provide these properties on the config object =
the default transformations will be=0A=
     * overwritten. If you wish to augment the default transformations =
then you must include them in your=0A=
     * local transformation array.=0A=
     *=0A=
     * The following code demonstrates adding a new response =
transformation to be run after the default response=0A=
     * transformations have been run.=0A=
     *=0A=
     * ```js=0A=
     * function appendTransform(defaults, transform) {=0A=
     *=0A=
     *   // We can't guarantee that the default transformation is an =
array=0A=
     *   defaults =3D angular.isArray(defaults) ? defaults : [defaults];=0A=
     *=0A=
     *   // Append the new transformation to the defaults=0A=
     *   return defaults.concat(transform);=0A=
     * }=0A=
     *=0A=
     * $http({=0A=
     *   url: '...',=0A=
     *   method: 'GET',=0A=
     *   transformResponse: =
appendTransform($http.defaults.transformResponse, function(value) {=0A=
     *     return doTransform(value);=0A=
     *   })=0A=
     * });=0A=
     * ```=0A=
     *=0A=
     *=0A=
     * ## Caching=0A=
     *=0A=
     * {@link ng.$http `$http`} responses are not cached by default. To =
enable caching, you must=0A=
     * set the config.cache value or the default cache value to TRUE or =
to a cache object (created=0A=
     * with {@link ng.$cacheFactory `$cacheFactory`}). If defined, the =
value of config.cache takes=0A=
     * precedence over the default cache value.=0A=
     *=0A=
     * In order to:=0A=
     *   * cache all responses - set the default cache value to TRUE or =
to a cache object=0A=
     *   * cache a specific response - set config.cache value to TRUE or =
to a cache object=0A=
     *=0A=
     * If caching is enabled, but neither the default cache nor =
config.cache are set to a cache object,=0A=
     * then the default `$cacheFactory("$http")` object is used.=0A=
     *=0A=
     * The default cache value can be set by updating the=0A=
     * {@link ng.$http#defaults `$http.defaults.cache`} property or the=0A=
     * {@link $httpProvider#defaults `$httpProvider.defaults.cache`} =
property.=0A=
     *=0A=
     * When caching is enabled, {@link ng.$http `$http`} stores the =
response from the server using=0A=
     * the relevant cache object. The next time the same request is =
made, the response is returned=0A=
     * from the cache without sending a request to the server.=0A=
     *=0A=
     * Take note that:=0A=
     *=0A=
     *   * Only GET and JSONP requests are cached.=0A=
     *   * The cache key is the request URL including search parameters; =
headers are not considered.=0A=
     *   * Cached responses are returned asynchronously, in the same way =
as responses from the server.=0A=
     *   * If multiple identical requests are made using the same cache, =
which is not yet populated,=0A=
     *     one request will be made to the server and remaining requests =
will return the same response.=0A=
     *   * A cache-control header on the response does not affect if or =
how responses are cached.=0A=
     *=0A=
     *=0A=
     * ## Interceptors=0A=
     *=0A=
     * Before you start creating interceptors, be sure to understand the=0A=
     * {@link ng.$q $q and deferred/promise APIs}.=0A=
     *=0A=
     * For purposes of global error handling, authentication, or any =
kind of synchronous or=0A=
     * asynchronous pre-processing of request or postprocessing of =
responses, it is desirable to be=0A=
     * able to intercept requests before they are handed to the server =
and=0A=
     * responses before they are handed over to the application code that=0A=
     * initiated these requests. The interceptors leverage the {@link =
ng.$q=0A=
     * promise APIs} to fulfill this need for both synchronous and =
asynchronous pre-processing.=0A=
     *=0A=
     * The interceptors are service factories that are registered with =
the `$httpProvider` by=0A=
     * adding them to the `$httpProvider.interceptors` array. The =
factory is called and=0A=
     * injected with dependencies (if specified) and returns the =
interceptor.=0A=
     *=0A=
     * There are two kinds of interceptors (and two kinds of rejection =
interceptors):=0A=
     *=0A=
     *   * `request`: interceptors get called with a http {@link =
$http#usage config} object. The function is free to=0A=
     *     modify the `config` object or create a new one. The function =
needs to return the `config`=0A=
     *     object directly, or a promise containing the `config` or a =
new `config` object.=0A=
     *   * `requestError`: interceptor gets called when a previous =
interceptor threw an error or=0A=
     *     resolved with a rejection.=0A=
     *   * `response`: interceptors get called with http `response` =
object. The function is free to=0A=
     *     modify the `response` object or create a new one. The =
function needs to return the `response`=0A=
     *     object directly, or as a promise containing the `response` or =
a new `response` object.=0A=
     *   * `responseError`: interceptor gets called when a previous =
interceptor threw an error or=0A=
     *     resolved with a rejection.=0A=
     *=0A=
     *=0A=
     * ```js=0A=
     *   // register the interceptor as a service=0A=
     *   $provide.factory('myHttpInterceptor', function($q, dependency1, =
dependency2) {=0A=
     *     return {=0A=
     *       // optional method=0A=
     *       'request': function(config) {=0A=
     *         // do something on success=0A=
     *         return config;=0A=
     *       },=0A=
     *=0A=
     *       // optional method=0A=
     *      'requestError': function(rejection) {=0A=
     *         // do something on error=0A=
     *         if (canRecover(rejection)) {=0A=
     *           return responseOrNewPromise=0A=
     *         }=0A=
     *         return $q.reject(rejection);=0A=
     *       },=0A=
     *=0A=
     *=0A=
     *=0A=
     *       // optional method=0A=
     *       'response': function(response) {=0A=
     *         // do something on success=0A=
     *         return response;=0A=
     *       },=0A=
     *=0A=
     *       // optional method=0A=
     *      'responseError': function(rejection) {=0A=
     *         // do something on error=0A=
     *         if (canRecover(rejection)) {=0A=
     *           return responseOrNewPromise=0A=
     *         }=0A=
     *         return $q.reject(rejection);=0A=
     *       }=0A=
     *     };=0A=
     *   });=0A=
     *=0A=
     *   $httpProvider.interceptors.push('myHttpInterceptor');=0A=
     *=0A=
     *=0A=
     *   // alternatively, register the interceptor via an anonymous =
factory=0A=
     *   $httpProvider.interceptors.push(function($q, dependency1, =
dependency2) {=0A=
     *     return {=0A=
     *      'request': function(config) {=0A=
     *          // same as above=0A=
     *       },=0A=
     *=0A=
     *       'response': function(response) {=0A=
     *          // same as above=0A=
     *       }=0A=
     *     };=0A=
     *   });=0A=
     * ```=0A=
     *=0A=
     * ## Security Considerations=0A=
     *=0A=
     * When designing web applications, consider security threats from:=0A=
     *=0A=
     * - [JSON =
vulnerability](http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-=
json-vulnerability.aspx)=0A=
     * - [XSRF](http://en.wikipedia.org/wiki/Cross-site_request_forgery)=0A=
     *=0A=
     * Both server and the client must cooperate in order to eliminate =
these threats. Angular comes=0A=
     * pre-configured with strategies that address these issues, but for =
this to work backend server=0A=
     * cooperation is required.=0A=
     *=0A=
     * ### JSON Vulnerability Protection=0A=
     *=0A=
     * A [JSON =
vulnerability](http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-=
json-vulnerability.aspx)=0A=
     * allows third party website to turn your JSON resource URL into=0A=
     * [JSONP](http://en.wikipedia.org/wiki/JSONP) request under some =
conditions. To=0A=
     * counter this your server can prefix all JSON requests with =
following string `")]}',\n"`.=0A=
     * Angular will automatically strip the prefix before processing it =
as JSON.=0A=
     *=0A=
     * For example if your server needs to return:=0A=
     * ```js=0A=
     * ['one','two']=0A=
     * ```=0A=
     *=0A=
     * which is vulnerable to attack, your server can return:=0A=
     * ```js=0A=
     * )]}',=0A=
     * ['one','two']=0A=
     * ```=0A=
     *=0A=
     * Angular will strip the prefix, before processing the JSON.=0A=
     *=0A=
     *=0A=
     * ### Cross Site Request Forgery (XSRF) Protection=0A=
     *=0A=
     * [XSRF](http://en.wikipedia.org/wiki/Cross-site_request_forgery) =
is an attack technique by=0A=
     * which the attacker can trick an authenticated user into =
unknowingly executing actions on your=0A=
     * website. Angular provides a mechanism to counter XSRF. When =
performing XHR requests, the=0A=
     * $http service reads a token from a cookie (by default, =
`XSRF-TOKEN`) and sets it as an HTTP=0A=
     * header (`X-XSRF-TOKEN`). Since only JavaScript that runs on your =
domain could read the=0A=
     * cookie, your server can be assured that the XHR came from =
JavaScript running on your domain.=0A=
     * The header will not be set for cross-domain requests.=0A=
     *=0A=
     * To take advantage of this, your server needs to set a token in a =
JavaScript readable session=0A=
     * cookie called `XSRF-TOKEN` on the first HTTP GET request. On =
subsequent XHR requests the=0A=
     * server can verify that the cookie matches `X-XSRF-TOKEN` HTTP =
header, and therefore be sure=0A=
     * that only JavaScript running on your domain could have sent the =
request. The token must be=0A=
     * unique for each user and must be verifiable by the server (to =
prevent the JavaScript from=0A=
     * making up its own tokens). We recommend that the token is a =
digest of your site's=0A=
     * authentication cookie with a =
[salt](https://en.wikipedia.org/wiki/Salt_(cryptography&amp;#41;)=0A=
     * for added security.=0A=
     *=0A=
     * The name of the headers can be specified using the xsrfHeaderName =
and xsrfCookieName=0A=
     * properties of either $httpProvider.defaults at config-time, =
$http.defaults at run-time,=0A=
     * or the per-request config object.=0A=
     *=0A=
     * In order to prevent collisions in environments where multiple =
Angular apps share the=0A=
     * same domain or subdomain, we recommend that each application uses =
unique cookie name.=0A=
     *=0A=
     * @param {object} config Object describing the request to be made =
and how it should be=0A=
     *    processed. The object has following properties:=0A=
     *=0A=
     *    - **method** =E2=80&#65533; `{string}` =E2=80&#65533; HTTP =
method (e.g. 'GET', 'POST', etc)=0A=
     *    - **url** =E2=80&#65533; `{string|TrustedObject}` =
=E2=80&#65533; Absolute or relative URL of the resource that is being =
requested;=0A=
     *      or an object created by a call to =
`$sce.trustAsResourceUrl(url)`.=0A=
     *    - **params** =E2=80&#65533; `{Object.&lt;string|Object&gt;}` =
=E2=80&#65533; Map of strings or objects which will be serialized=0A=
     *      with the `paramSerializer` and appended as GET parameters.=0A=
     *    - **data** =E2=80&#65533; `{string|Object}` =E2=80&#65533; =
Data to be sent as the request message data.=0A=
     *    - **headers** =E2=80&#65533; `{Object}` =E2=80&#65533; Map of =
strings or functions which return strings representing=0A=
     *      HTTP headers to send to the server. If the return value of a =
function is null, the=0A=
     *      header will not be sent. Functions accept a config object as =
an argument.=0A=
     *    - **eventHandlers** - `{Object}` - Event listeners to be bound =
to the XMLHttpRequest object.=0A=
     *      To bind events to the XMLHttpRequest upload object, use =
`uploadEventHandlers`.=0A=
     *      The handler will be called in the context of a `$apply` =
block.=0A=
     *    - **uploadEventHandlers** - `{Object}` - Event listeners to be =
bound to the XMLHttpRequest upload=0A=
     *      object. To bind events to the XMLHttpRequest object, use =
`eventHandlers`.=0A=
     *      The handler will be called in the context of a `$apply` =
block.=0A=
     *    - **xsrfHeaderName** =E2=80&#65533; `{string}` =E2=80&#65533; =
Name of HTTP header to populate with the XSRF token.=0A=
     *    - **xsrfCookieName** =E2=80&#65533; `{string}` =E2=80&#65533; =
Name of cookie containing the XSRF token.=0A=
     *    - **transformRequest** =E2=80&#65533;=0A=
     *      `{function(data, headersGetter)|Array.&lt;function(data, =
headersGetter)&gt;}` =E2=80&#65533;=0A=
     *      transform function or an array of such functions. The =
transform function takes the http=0A=
     *      request body and headers and returns its transformed =
(typically serialized) version.=0A=
     *      See {@link =
ng.$http#overriding-the-default-transformations-per-request=0A=
     *      Overriding the Default Transformations}=0A=
     *    - **transformResponse** =E2=80&#65533;=0A=
     *      `{function(data, headersGetter, =
status)|Array.&lt;function(data, headersGetter, status)&gt;}` =
=E2=80&#65533;=0A=
     *      transform function or an array of such functions. The =
transform function takes the http=0A=
     *      response body, headers and status and returns its =
transformed (typically deserialized) version.=0A=
     *      See {@link =
ng.$http#overriding-the-default-transformations-per-request=0A=
     *      Overriding the Default Transformations}=0A=
     *    - **paramSerializer** - =
`{string|function(Object&lt;string,string&gt;):string}` - A function =
used to=0A=
     *      prepare the string representation of request parameters =
(specified as an object).=0A=
     *      If specified as string, it is interpreted as function =
registered with the=0A=
     *      {@link $injector $injector}, which means you can create your =
own serializer=0A=
     *      by registering it as a {@link auto.$provide#service service}.=0A=
     *      The default serializer is the {@link $httpParamSerializer =
$httpParamSerializer};=0A=
     *      alternatively, you can use the {@link =
$httpParamSerializerJQLike $httpParamSerializerJQLike}=0A=
     *    - **cache** =E2=80&#65533; `{boolean|Object}` =E2=80&#65533; A =
boolean value or object created with=0A=
     *      {@link ng.$cacheFactory `$cacheFactory`} to enable or =
disable caching of the HTTP response.=0A=
     *      See {@link $http#caching $http Caching} for more information.=0A=
     *    - **timeout** =E2=80&#65533; `{number|Promise}` =E2=80&#65533; =
timeout in milliseconds, or {@link ng.$q promise}=0A=
     *      that should abort the request when resolved.=0A=
     *    - **withCredentials** - `{boolean}` - whether to set the =
`withCredentials` flag on the=0A=
     *      XHR object. See [requests with =
credentials](https://developer.mozilla.org/docs/Web/HTTP/Access_control_C=
ORS#Requests_with_credentials)=0A=
     *      for more information.=0A=
     *    - **responseType** - `{string}` - see=0A=
     *      =
[XMLHttpRequest.responseType](https://developer.mozilla.org/en-US/docs/We=
b/API/XMLHttpRequest#xmlhttprequest-responsetype).=0A=
     *=0A=
     * @returns {HttpPromise} Returns a {@link ng.$q `Promise}` that =
will be resolved to a response object=0A=
     *                        when the request succeeds or fails.=0A=
     *=0A=
     *=0A=
     * @property {Array.&lt;Object&gt;} pendingRequests Array of config =
objects for currently pending=0A=
     *   requests. This is primarily meant to be used for debugging =
purposes.=0A=
     *=0A=
     *=0A=
     * @example=0A=
&lt;example module=3D"httpExample" name=3D"http-service"&gt;=0A=
&lt;file name=3D"index.html"&gt;=0A=
  &lt;div ng-controller=3D"FetchController"&gt;=0A=
    &lt;select ng-model=3D"method" aria-label=3D"Request method"&gt;=0A=
      &lt;option&gt;GET&lt;/option&gt;=0A=
      &lt;option&gt;JSONP&lt;/option&gt;=0A=
    &lt;/select&gt;=0A=
    &lt;input type=3D"text" ng-model=3D"url" size=3D"80" =
aria-label=3D"URL" /&gt;=0A=
    &lt;button id=3D"fetchbtn" =
ng-click=3D"fetch()"&gt;fetch&lt;/button&gt;&lt;br&gt;=0A=
    &lt;button id=3D"samplegetbtn" ng-click=3D"updateModel('GET', =
'http-hello.html')"&gt;Sample GET&lt;/button&gt;=0A=
    &lt;button id=3D"samplejsonpbtn"=0A=
      ng-click=3D"updateModel('JSONP',=0A=
                    =
'https://angularjs.org/greet.php?name=3DSuper%20Hero')"&gt;=0A=
      Sample JSONP=0A=
    &lt;/button&gt;=0A=
    &lt;button id=3D"invalidjsonpbtn"=0A=
      ng-click=3D"updateModel('JSONP', =
'https://angularjs.org/doesntexist')"&gt;=0A=
        Invalid JSONP=0A=
      &lt;/button&gt;=0A=
    &lt;pre&gt;http status code: {{status}}&lt;/pre&gt;=0A=
    &lt;pre&gt;http response data: {{data}}&lt;/pre&gt;=0A=
  &lt;/div&gt;=0A=
&lt;/file&gt;=0A=
&lt;file name=3D"script.js"&gt;=0A=
  angular.module('httpExample', [])=0A=
    .config(['$sceDelegateProvider', function($sceDelegateProvider) {=0A=
      // We must whitelist the JSONP endpoint that we are using to show =
that we trust it=0A=
      $sceDelegateProvider.resourceUrlWhitelist([=0A=
        'self',=0A=
        'https://angularjs.org/**'=0A=
      ]);=0A=
    }])=0A=
    .controller('FetchController', ['$scope', '$http', '$templateCache',=0A=
      function($scope, $http, $templateCache) {=0A=
        $scope.method =3D 'GET';=0A=
        $scope.url =3D 'http-hello.html';=0A=
=0A=
        $scope.fetch =3D function() {=0A=
          $scope.code =3D null;=0A=
          $scope.response =3D null;=0A=
=0A=
          $http({method: $scope.method, url: $scope.url, cache: =
$templateCache}).=0A=
            then(function(response) {=0A=
              $scope.status =3D response.status;=0A=
              $scope.data =3D response.data;=0A=
            }, function(response) {=0A=
              $scope.data =3D response.data || 'Request failed';=0A=
              $scope.status =3D response.status;=0A=
          });=0A=
        };=0A=
=0A=
        $scope.updateModel =3D function(method, url) {=0A=
          $scope.method =3D method;=0A=
          $scope.url =3D url;=0A=
        };=0A=
      }]);=0A=
&lt;/file&gt;=0A=
&lt;file name=3D"http-hello.html"&gt;=0A=
  Hello, $http!=0A=
&lt;/file&gt;=0A=
&lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
  var status =3D element(by.binding('status'));=0A=
  var data =3D element(by.binding('data'));=0A=
  var fetchBtn =3D element(by.id('fetchbtn'));=0A=
  var sampleGetBtn =3D element(by.id('samplegetbtn'));=0A=
  var invalidJsonpBtn =3D element(by.id('invalidjsonpbtn'));=0A=
=0A=
  it('should make an xhr GET request', function() {=0A=
    sampleGetBtn.click();=0A=
    fetchBtn.click();=0A=
    expect(status.getText()).toMatch('200');=0A=
    expect(data.getText()).toMatch(/Hello, \$http!/);=0A=
  });=0A=
=0A=
// Commented out due to flakes. See =
https://github.com/angular/angular.js/issues/9185=0A=
// it('should make a JSONP request to angularjs.org', function() {=0A=
//   var sampleJsonpBtn =3D element(by.id('samplejsonpbtn'));=0A=
//   sampleJsonpBtn.click();=0A=
//   fetchBtn.click();=0A=
//   expect(status.getText()).toMatch('200');=0A=
//   expect(data.getText()).toMatch(/Super Hero!/);=0A=
// });=0A=
=0A=
  it('should make JSONP request to invalid URL and invoke the error =
handler',=0A=
      function() {=0A=
    invalidJsonpBtn.click();=0A=
    fetchBtn.click();=0A=
    expect(status.getText()).toMatch('0');=0A=
    expect(data.getText()).toMatch('Request failed');=0A=
  });=0A=
&lt;/file&gt;=0A=
&lt;/example&gt;=0A=
     */=0A=
    function $http(requestConfig) {=0A=
=0A=
      if (!isObject(requestConfig)) {=0A=
        throw minErr('$http')('badreq', 'Http request configuration must =
be an object.  Received: {0}', requestConfig);=0A=
      }=0A=
=0A=
      if (!isString($sce.valueOf(requestConfig.url))) {=0A=
        throw minErr('$http')('badreq', 'Http request configuration url =
must be a string or a $sce trusted object.  Received: {0}', =
requestConfig.url);=0A=
      }=0A=
=0A=
      var config =3D extend({=0A=
        method: 'get',=0A=
        transformRequest: defaults.transformRequest,=0A=
        transformResponse: defaults.transformResponse,=0A=
        paramSerializer: defaults.paramSerializer,=0A=
        jsonpCallbackParam: defaults.jsonpCallbackParam=0A=
      }, requestConfig);=0A=
=0A=
      config.headers =3D mergeHeaders(requestConfig);=0A=
      config.method =3D uppercase(config.method);=0A=
      config.paramSerializer =3D isString(config.paramSerializer) ?=0A=
          $injector.get(config.paramSerializer) : config.paramSerializer;=0A=
=0A=
      $browser.$$incOutstandingRequestCount();=0A=
=0A=
      var requestInterceptors =3D [];=0A=
      var responseInterceptors =3D [];=0A=
      var promise =3D $q.resolve(config);=0A=
=0A=
      // apply interceptors=0A=
      forEach(reversedInterceptors, function(interceptor) {=0A=
        if (interceptor.request || interceptor.requestError) {=0A=
          requestInterceptors.unshift(interceptor.request, =
interceptor.requestError);=0A=
        }=0A=
        if (interceptor.response || interceptor.responseError) {=0A=
          responseInterceptors.push(interceptor.response, =
interceptor.responseError);=0A=
        }=0A=
      });=0A=
=0A=
      promise =3D chainInterceptors(promise, requestInterceptors);=0A=
      promise =3D promise.then(serverRequest);=0A=
      promise =3D chainInterceptors(promise, responseInterceptors);=0A=
      promise =3D promise.finally(completeOutstandingRequest);=0A=
=0A=
      return promise;=0A=
=0A=
=0A=
      function chainInterceptors(promise, interceptors) {=0A=
        for (var i =3D 0, ii =3D interceptors.length; i &lt; ii;) {=0A=
          var thenFn =3D interceptors[i++];=0A=
          var rejectFn =3D interceptors[i++];=0A=
=0A=
          promise =3D promise.then(thenFn, rejectFn);=0A=
        }=0A=
=0A=
        interceptors.length =3D 0;=0A=
=0A=
        return promise;=0A=
      }=0A=
=0A=
      function completeOutstandingRequest() {=0A=
        $browser.$$completeOutstandingRequest(noop);=0A=
      }=0A=
=0A=
      function executeHeaderFns(headers, config) {=0A=
        var headerContent, processedHeaders =3D {};=0A=
=0A=
        forEach(headers, function(headerFn, header) {=0A=
          if (isFunction(headerFn)) {=0A=
            headerContent =3D headerFn(config);=0A=
            if (headerContent !=3D null) {=0A=
              processedHeaders[header] =3D headerContent;=0A=
            }=0A=
          } else {=0A=
            processedHeaders[header] =3D headerFn;=0A=
          }=0A=
        });=0A=
=0A=
        return processedHeaders;=0A=
      }=0A=
=0A=
      function mergeHeaders(config) {=0A=
        var defHeaders =3D defaults.headers,=0A=
            reqHeaders =3D extend({}, config.headers),=0A=
            defHeaderName, lowercaseDefHeaderName, reqHeaderName;=0A=
=0A=
        defHeaders =3D extend({}, defHeaders.common, =
defHeaders[lowercase(config.method)]);=0A=
=0A=
        // using for-in instead of forEach to avoid unnecessary =
iteration after header has been found=0A=
        defaultHeadersIteration:=0A=
        for (defHeaderName in defHeaders) {=0A=
          lowercaseDefHeaderName =3D lowercase(defHeaderName);=0A=
=0A=
          for (reqHeaderName in reqHeaders) {=0A=
            if (lowercase(reqHeaderName) =3D=3D=3D =
lowercaseDefHeaderName) {=0A=
              continue defaultHeadersIteration;=0A=
            }=0A=
          }=0A=
=0A=
          reqHeaders[defHeaderName] =3D defHeaders[defHeaderName];=0A=
        }=0A=
=0A=
        // execute if header value is a function for merged headers=0A=
        return executeHeaderFns(reqHeaders, shallowCopy(config));=0A=
      }=0A=
=0A=
      function serverRequest(config) {=0A=
        var headers =3D config.headers;=0A=
        var reqData =3D transformData(config.data, =
headersGetter(headers), undefined, config.transformRequest);=0A=
=0A=
        // strip content-type if data is undefined=0A=
        if (isUndefined(reqData)) {=0A=
          forEach(headers, function(value, header) {=0A=
            if (lowercase(header) =3D=3D=3D 'content-type') {=0A=
              delete headers[header];=0A=
            }=0A=
          });=0A=
        }=0A=
=0A=
        if (isUndefined(config.withCredentials) &amp;&amp; =
!isUndefined(defaults.withCredentials)) {=0A=
          config.withCredentials =3D defaults.withCredentials;=0A=
        }=0A=
=0A=
        // send request=0A=
        return sendReq(config, reqData).then(transformResponse, =
transformResponse);=0A=
      }=0A=
=0A=
      function transformResponse(response) {=0A=
        // make a copy since the response must be cacheable=0A=
        var resp =3D extend({}, response);=0A=
        resp.data =3D transformData(response.data, response.headers, =
response.status,=0A=
                                  config.transformResponse);=0A=
        return (isSuccess(response.status))=0A=
          ? resp=0A=
          : $q.reject(resp);=0A=
      }=0A=
    }=0A=
=0A=
    $http.pendingRequests =3D [];=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $http#get=0A=
     *=0A=
     * @description=0A=
     * Shortcut method to perform `GET` request.=0A=
     *=0A=
     * @param {string|TrustedObject} url Absolute or relative URL of the =
resource that is being requested;=0A=
     *                                   or an object created by a call =
to `$sce.trustAsResourceUrl(url)`.=0A=
     * @param {Object=3D} config Optional configuration object=0A=
     * @returns {HttpPromise} Future object=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $http#delete=0A=
     *=0A=
     * @description=0A=
     * Shortcut method to perform `DELETE` request.=0A=
     *=0A=
     * @param {string|TrustedObject} url Absolute or relative URL of the =
resource that is being requested;=0A=
     *                                   or an object created by a call =
to `$sce.trustAsResourceUrl(url)`.=0A=
     * @param {Object=3D} config Optional configuration object=0A=
     * @returns {HttpPromise} Future object=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $http#head=0A=
     *=0A=
     * @description=0A=
     * Shortcut method to perform `HEAD` request.=0A=
     *=0A=
     * @param {string|TrustedObject} url Absolute or relative URL of the =
resource that is being requested;=0A=
     *                                   or an object created by a call =
to `$sce.trustAsResourceUrl(url)`.=0A=
     * @param {Object=3D} config Optional configuration object=0A=
     * @returns {HttpPromise} Future object=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $http#jsonp=0A=
     *=0A=
     * @description=0A=
     * Shortcut method to perform `JSONP` request.=0A=
     *=0A=
     * Note that, since JSONP requests are sensitive because the =
response is given full access to the browser,=0A=
     * the url must be declared, via {@link $sce} as a trusted resource =
URL.=0A=
     * You can trust a URL by adding it to the whitelist via=0A=
     * {@link $sceDelegateProvider#resourceUrlWhitelist  =
`$sceDelegateProvider.resourceUrlWhitelist`} or=0A=
     * by explicitly trusting the URL via {@link $sce#trustAsResourceUrl =
`$sce.trustAsResourceUrl(url)`}.=0A=
     *=0A=
     * JSONP requests must specify a callback to be used in the response =
from the server. This callback=0A=
     * is passed as a query parameter in the request. You must specify =
the name of this parameter by=0A=
     * setting the `jsonpCallbackParam` property on the request config =
object.=0A=
     *=0A=
     * ```=0A=
     * $http.jsonp('some/trusted/url', {jsonpCallbackParam: 'callback'})=0A=
     * ```=0A=
     *=0A=
     * You can also specify a default callback parameter name in =
`$http.defaults.jsonpCallbackParam`.=0A=
     * Initially this is set to `'callback'`.=0A=
     *=0A=
     * &lt;div class=3D"alert alert-danger"&gt;=0A=
     * You can no longer use the `JSON_CALLBACK` string as a placeholder =
for specifying where the callback=0A=
     * parameter value should go.=0A=
     * &lt;/div&gt;=0A=
     *=0A=
     * If you would like to customise where and how the callbacks are =
stored then try overriding=0A=
     * or decorating the {@link $jsonpCallbacks} service.=0A=
     *=0A=
     * @param {string|TrustedObject} url Absolute or relative URL of the =
resource that is being requested;=0A=
     *                                   or an object created by a call =
to `$sce.trustAsResourceUrl(url)`.=0A=
     * @param {Object=3D} config Optional configuration object=0A=
     * @returns {HttpPromise} Future object=0A=
     */=0A=
    createShortMethods('get', 'delete', 'head', 'jsonp');=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $http#post=0A=
     *=0A=
     * @description=0A=
     * Shortcut method to perform `POST` request.=0A=
     *=0A=
     * @param {string} url Relative or absolute URL specifying the =
destination of the request=0A=
     * @param {*} data Request content=0A=
     * @param {Object=3D} config Optional configuration object=0A=
     * @returns {HttpPromise} Future object=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $http#put=0A=
     *=0A=
     * @description=0A=
     * Shortcut method to perform `PUT` request.=0A=
     *=0A=
     * @param {string} url Relative or absolute URL specifying the =
destination of the request=0A=
     * @param {*} data Request content=0A=
     * @param {Object=3D} config Optional configuration object=0A=
     * @returns {HttpPromise} Future object=0A=
     */=0A=
=0A=
     /**=0A=
      * @ngdoc method=0A=
      * @name $http#patch=0A=
      *=0A=
      * @description=0A=
      * Shortcut method to perform `PATCH` request.=0A=
      *=0A=
      * @param {string} url Relative or absolute URL specifying the =
destination of the request=0A=
      * @param {*} data Request content=0A=
      * @param {Object=3D} config Optional configuration object=0A=
      * @returns {HttpPromise} Future object=0A=
      */=0A=
    createShortMethodsWithData('post', 'put', 'patch');=0A=
=0A=
        /**=0A=
         * @ngdoc property=0A=
         * @name $http#defaults=0A=
         *=0A=
         * @description=0A=
         * Runtime equivalent of the `$httpProvider.defaults` property. =
Allows configuration of=0A=
         * default headers, withCredentials as well as request and =
response transformations.=0A=
         *=0A=
         * See "Setting HTTP Headers" and "Transforming Requests and =
Responses" sections above.=0A=
         */=0A=
    $http.defaults =3D defaults;=0A=
=0A=
=0A=
    return $http;=0A=
=0A=
=0A=
    function createShortMethods(names) {=0A=
      forEach(arguments, function(name) {=0A=
        $http[name] =3D function(url, config) {=0A=
          return $http(extend({}, config || {}, {=0A=
            method: name,=0A=
            url: url=0A=
          }));=0A=
        };=0A=
      });=0A=
    }=0A=
=0A=
=0A=
    function createShortMethodsWithData(name) {=0A=
      forEach(arguments, function(name) {=0A=
        $http[name] =3D function(url, data, config) {=0A=
          return $http(extend({}, config || {}, {=0A=
            method: name,=0A=
            url: url,=0A=
            data: data=0A=
          }));=0A=
        };=0A=
      });=0A=
    }=0A=
=0A=
=0A=
    /**=0A=
     * Makes the request.=0A=
     *=0A=
     * !!! ACCESSES CLOSURE VARS:=0A=
     * $httpBackend, defaults, $log, $rootScope, defaultCache, =
$http.pendingRequests=0A=
     */=0A=
    function sendReq(config, reqData) {=0A=
      var deferred =3D $q.defer(),=0A=
          promise =3D deferred.promise,=0A=
          cache,=0A=
          cachedResp,=0A=
          reqHeaders =3D config.headers,=0A=
          isJsonp =3D lowercase(config.method) =3D=3D=3D 'jsonp',=0A=
          url =3D config.url;=0A=
=0A=
      if (isJsonp) {=0A=
        // JSONP is a pretty sensitive operation where we're allowing a =
script to have full access to=0A=
        // our DOM and JS space.  So we require that the URL satisfies =
SCE.RESOURCE_URL.=0A=
        url =3D $sce.getTrustedResourceUrl(url);=0A=
      } else if (!isString(url)) {=0A=
        // If it is not a string then the URL must be a $sce trusted =
object=0A=
        url =3D $sce.valueOf(url);=0A=
      }=0A=
=0A=
      url =3D buildUrl(url, config.paramSerializer(config.params));=0A=
=0A=
      if (isJsonp) {=0A=
        // Check the url and add the JSONP callback placeholder=0A=
        url =3D sanitizeJsonpCallbackParam(url, =
config.jsonpCallbackParam);=0A=
      }=0A=
=0A=
      $http.pendingRequests.push(config);=0A=
      promise.then(removePendingReq, removePendingReq);=0A=
=0A=
      if ((config.cache || defaults.cache) &amp;&amp; config.cache =
!=3D=3D false &amp;&amp;=0A=
          (config.method =3D=3D=3D 'GET' || config.method =3D=3D=3D =
'JSONP')) {=0A=
        cache =3D isObject(config.cache) ? config.cache=0A=
            : isObject(/** @type {?} */ (defaults).cache)=0A=
              ? /** @type {?} */ (defaults).cache=0A=
              : defaultCache;=0A=
      }=0A=
=0A=
      if (cache) {=0A=
        cachedResp =3D cache.get(url);=0A=
        if (isDefined(cachedResp)) {=0A=
          if (isPromiseLike(cachedResp)) {=0A=
            // cached request has already been sent, but there is no =
response yet=0A=
            cachedResp.then(resolvePromiseWithResult, =
resolvePromiseWithResult);=0A=
          } else {=0A=
            // serving from cache=0A=
            if (isArray(cachedResp)) {=0A=
              resolvePromise(cachedResp[1], cachedResp[0], =
shallowCopy(cachedResp[2]), cachedResp[3]);=0A=
            } else {=0A=
              resolvePromise(cachedResp, 200, {}, 'OK');=0A=
            }=0A=
          }=0A=
        } else {=0A=
          // put the promise for the non-transformed response into cache =
as a placeholder=0A=
          cache.put(url, promise);=0A=
        }=0A=
      }=0A=
=0A=
=0A=
      // if we won't have the response in cache, set the xsrf headers and=0A=
      // send the request to the backend=0A=
      if (isUndefined(cachedResp)) {=0A=
        var xsrfValue =3D urlIsSameOrigin(config.url)=0A=
            ? $$cookieReader()[config.xsrfCookieName || =
defaults.xsrfCookieName]=0A=
            : undefined;=0A=
        if (xsrfValue) {=0A=
          reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] =
=3D xsrfValue;=0A=
        }=0A=
=0A=
        $httpBackend(config.method, url, reqData, done, reqHeaders, =
config.timeout,=0A=
            config.withCredentials, config.responseType,=0A=
            createApplyHandlers(config.eventHandlers),=0A=
            createApplyHandlers(config.uploadEventHandlers));=0A=
      }=0A=
=0A=
      return promise;=0A=
=0A=
      function createApplyHandlers(eventHandlers) {=0A=
        if (eventHandlers) {=0A=
          var applyHandlers =3D {};=0A=
          forEach(eventHandlers, function(eventHandler, key) {=0A=
            applyHandlers[key] =3D function(event) {=0A=
              if (useApplyAsync) {=0A=
                $rootScope.$applyAsync(callEventHandler);=0A=
              } else if ($rootScope.$$phase) {=0A=
                callEventHandler();=0A=
              } else {=0A=
                $rootScope.$apply(callEventHandler);=0A=
              }=0A=
=0A=
              function callEventHandler() {=0A=
                eventHandler(event);=0A=
              }=0A=
            };=0A=
          });=0A=
          return applyHandlers;=0A=
        }=0A=
      }=0A=
=0A=
=0A=
      /**=0A=
       * Callback registered to $httpBackend():=0A=
       *  - caches the response if desired=0A=
       *  - resolves the raw $http promise=0A=
       *  - calls $apply=0A=
       */=0A=
      function done(status, response, headersString, statusText) {=0A=
        if (cache) {=0A=
          if (isSuccess(status)) {=0A=
            cache.put(url, [status, response, =
parseHeaders(headersString), statusText]);=0A=
          } else {=0A=
            // remove promise from the cache=0A=
            cache.remove(url);=0A=
          }=0A=
        }=0A=
=0A=
        function resolveHttpPromise() {=0A=
          resolvePromise(response, status, headersString, statusText);=0A=
        }=0A=
=0A=
        if (useApplyAsync) {=0A=
          $rootScope.$applyAsync(resolveHttpPromise);=0A=
        } else {=0A=
          resolveHttpPromise();=0A=
          if (!$rootScope.$$phase) $rootScope.$apply();=0A=
        }=0A=
      }=0A=
=0A=
=0A=
      /**=0A=
       * Resolves the raw $http promise.=0A=
       */=0A=
      function resolvePromise(response, status, headers, statusText) {=0A=
        //status: HTTP response status code, 0, -1 (aborted by timeout / =
promise)=0A=
        status =3D status &gt;=3D -1 ? status : 0;=0A=
=0A=
        (isSuccess(status) ? deferred.resolve : deferred.reject)({=0A=
          data: response,=0A=
          status: status,=0A=
          headers: headersGetter(headers),=0A=
          config: config,=0A=
          statusText: statusText=0A=
        });=0A=
      }=0A=
=0A=
      function resolvePromiseWithResult(result) {=0A=
        resolvePromise(result.data, result.status, =
shallowCopy(result.headers()), result.statusText);=0A=
      }=0A=
=0A=
      function removePendingReq() {=0A=
        var idx =3D $http.pendingRequests.indexOf(config);=0A=
        if (idx !=3D=3D -1) $http.pendingRequests.splice(idx, 1);=0A=
      }=0A=
    }=0A=
=0A=
=0A=
    function buildUrl(url, serializedParams) {=0A=
      if (serializedParams.length &gt; 0) {=0A=
        url +=3D ((url.indexOf('?') =3D=3D=3D -1) ? '?' : '&amp;') + =
serializedParams;=0A=
      }=0A=
      return url;=0A=
    }=0A=
=0A=
    function sanitizeJsonpCallbackParam(url, key) {=0A=
      if (/[&amp;?][^=3D]+=3DJSON_CALLBACK/.test(url)) {=0A=
        // Throw if the url already contains a reference to JSON_CALLBACK=0A=
        throw $httpMinErr('badjsonp', 'Illegal use of JSON_CALLBACK in =
url, "{0}"', url);=0A=
      }=0A=
=0A=
      var callbackParamRegex =3D new RegExp('[&amp;?]' + key + '=3D');=0A=
      if (callbackParamRegex.test(url)) {=0A=
        // Throw if the callback param was already provided=0A=
        throw $httpMinErr('badjsonp', 'Illegal use of callback param, =
"{0}", in url, "{1}"', key, url);=0A=
      }=0A=
=0A=
      // Add in the JSON_CALLBACK callback param value=0A=
      url +=3D ((url.indexOf('?') =3D=3D=3D -1) ? '?' : '&amp;') + key + =
'=3DJSON_CALLBACK';=0A=
=0A=
      return url;=0A=
    }=0A=
  }];=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $xhrFactory=0A=
 * @this=0A=
 *=0A=
 * @description=0A=
 * Factory function used to create XMLHttpRequest objects.=0A=
 *=0A=
 * Replace or decorate this service to create your own custom =
XMLHttpRequest objects.=0A=
 *=0A=
 * ```=0A=
 * angular.module('myApp', [])=0A=
 * .factory('$xhrFactory', function() {=0A=
 *   return function createXhr(method, url) {=0A=
 *     return new window.XMLHttpRequest({mozSystem: true});=0A=
 *   };=0A=
 * });=0A=
 * ```=0A=
 *=0A=
 * @param {string} method HTTP method of the request (GET, POST, PUT, ..)=0A=
 * @param {string} url URL of the request.=0A=
 */=0A=
function $xhrFactoryProvider() {=0A=
  this.$get =3D function() {=0A=
    return function createXhr() {=0A=
      return new window.XMLHttpRequest();=0A=
    };=0A=
  };=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $httpBackend=0A=
 * @requires $jsonpCallbacks=0A=
 * @requires $document=0A=
 * @requires $xhrFactory=0A=
 * @this=0A=
 *=0A=
 * @description=0A=
 * HTTP backend used by the {@link ng.$http service} that delegates to=0A=
 * XMLHttpRequest object or JSONP and deals with browser =
incompatibilities.=0A=
 *=0A=
 * You should never need to use this service directly, instead use the =
higher-level abstractions:=0A=
 * {@link ng.$http $http} or {@link ngResource.$resource $resource}.=0A=
 *=0A=
 * During testing this implementation is swapped with {@link =
ngMock.$httpBackend mock=0A=
 * $httpBackend} which can be trained with responses.=0A=
 */=0A=
function $HttpBackendProvider() {=0A=
  this.$get =3D ['$browser', '$jsonpCallbacks', '$document', =
'$xhrFactory', function($browser, $jsonpCallbacks, $document, =
$xhrFactory) {=0A=
    return createHttpBackend($browser, $xhrFactory, $browser.defer, =
$jsonpCallbacks, $document[0]);=0A=
  }];=0A=
}=0A=
=0A=
function createHttpBackend($browser, createXhr, $browserDefer, =
callbacks, rawDocument) {=0A=
  // TODO(vojta): fix the signature=0A=
  return function(method, url, post, callback, headers, timeout, =
withCredentials, responseType, eventHandlers, uploadEventHandlers) {=0A=
    url =3D url || $browser.url();=0A=
=0A=
    if (lowercase(method) =3D=3D=3D 'jsonp') {=0A=
      var callbackPath =3D callbacks.createCallback(url);=0A=
      var jsonpDone =3D jsonpReq(url, callbackPath, function(status, =
text) {=0A=
        // jsonpReq only ever sets status to 200 (OK), 404 (ERROR) or -1 =
(WAITING)=0A=
        var response =3D (status =3D=3D=3D 200) &amp;&amp; =
callbacks.getResponse(callbackPath);=0A=
        completeRequest(callback, status, response, '', text);=0A=
        callbacks.removeCallback(callbackPath);=0A=
      });=0A=
    } else {=0A=
=0A=
      var xhr =3D createXhr(method, url);=0A=
=0A=
      xhr.open(method, url, true);=0A=
      forEach(headers, function(value, key) {=0A=
        if (isDefined(value)) {=0A=
            xhr.setRequestHeader(key, value);=0A=
        }=0A=
      });=0A=
=0A=
      xhr.onload =3D function requestLoaded() {=0A=
        var statusText =3D xhr.statusText || '';=0A=
=0A=
        // responseText is the old-school way of retrieving response =
(supported by IE9)=0A=
        // response/responseType properties were introduced in XHR =
Level2 spec (supported by IE10)=0A=
        var response =3D ('response' in xhr) ? xhr.response : =
xhr.responseText;=0A=
=0A=
        // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)=0A=
        var status =3D xhr.status =3D=3D=3D 1223 ? 204 : xhr.status;=0A=
=0A=
        // fix status code when it is 0 (0 status is undocumented).=0A=
        // Occurs when accessing file resources or on Android 4.1 stock =
browser=0A=
        // while retrieving files from application cache.=0A=
        if (status =3D=3D=3D 0) {=0A=
          status =3D response ? 200 : urlResolve(url).protocol =3D=3D=3D =
'file' ? 404 : 0;=0A=
        }=0A=
=0A=
        completeRequest(callback,=0A=
            status,=0A=
            response,=0A=
            xhr.getAllResponseHeaders(),=0A=
            statusText);=0A=
      };=0A=
=0A=
      var requestError =3D function() {=0A=
        // The response is always empty=0A=
        // See https://xhr.spec.whatwg.org/#request-error-steps and =
https://fetch.spec.whatwg.org/#concept-network-error=0A=
        completeRequest(callback, -1, null, null, '');=0A=
      };=0A=
=0A=
      xhr.onerror =3D requestError;=0A=
      xhr.onabort =3D requestError;=0A=
      xhr.ontimeout =3D requestError;=0A=
=0A=
      forEach(eventHandlers, function(value, key) {=0A=
          xhr.addEventListener(key, value);=0A=
      });=0A=
=0A=
      forEach(uploadEventHandlers, function(value, key) {=0A=
        xhr.upload.addEventListener(key, value);=0A=
      });=0A=
=0A=
      if (withCredentials) {=0A=
        xhr.withCredentials =3D true;=0A=
      }=0A=
=0A=
      if (responseType) {=0A=
        try {=0A=
          xhr.responseType =3D responseType;=0A=
        } catch (e) {=0A=
          // WebKit added support for the json responseType value on =
09/03/2013=0A=
          // https://bugs.webkit.org/show_bug.cgi?id=3D73648. Versions =
of Safari prior to 7 are=0A=
          // known to throw when setting the value "json" as the =
response type. Other older=0A=
          // browsers implementing the responseType=0A=
          //=0A=
          // The json response type can be ignored if not supported, =
because JSON payloads are=0A=
          // parsed on the client-side regardless.=0A=
          if (responseType !=3D=3D 'json') {=0A=
            throw e;=0A=
          }=0A=
        }=0A=
      }=0A=
=0A=
      xhr.send(isUndefined(post) ? null : post);=0A=
    }=0A=
=0A=
    if (timeout &gt; 0) {=0A=
      var timeoutId =3D $browserDefer(timeoutRequest, timeout);=0A=
    } else if (isPromiseLike(timeout)) {=0A=
      timeout.then(timeoutRequest);=0A=
    }=0A=
=0A=
=0A=
    function timeoutRequest() {=0A=
      if (jsonpDone) {=0A=
        jsonpDone();=0A=
      }=0A=
      if (xhr) {=0A=
        xhr.abort();=0A=
      }=0A=
    }=0A=
=0A=
    function completeRequest(callback, status, response, headersString, =
statusText) {=0A=
      // cancel timeout and subsequent timeout promise resolution=0A=
      if (isDefined(timeoutId)) {=0A=
        $browserDefer.cancel(timeoutId);=0A=
      }=0A=
      jsonpDone =3D xhr =3D null;=0A=
=0A=
      callback(status, response, headersString, statusText);=0A=
    }=0A=
  };=0A=
=0A=
  function jsonpReq(url, callbackPath, done) {=0A=
    url =3D url.replace('JSON_CALLBACK', callbackPath);=0A=
    // we can't use jQuery/jqLite here because jQuery does crazy stuff =
with script elements, e.g.:=0A=
    // - fetches local scripts via XHR and evals them=0A=
    // - adds and immediately removes script elements from the document=0A=
    var script =3D rawDocument.createElement('script'), callback =3D =
null;=0A=
    script.type =3D 'text/javascript';=0A=
    script.src =3D url;=0A=
    script.async =3D true;=0A=
=0A=
    callback =3D function(event) {=0A=
      script.removeEventListener('load', callback);=0A=
      script.removeEventListener('error', callback);=0A=
      rawDocument.body.removeChild(script);=0A=
      script =3D null;=0A=
      var status =3D -1;=0A=
      var text =3D 'unknown';=0A=
=0A=
      if (event) {=0A=
        if (event.type =3D=3D=3D 'load' &amp;&amp; =
!callbacks.wasCalled(callbackPath)) {=0A=
          event =3D { type: 'error' };=0A=
        }=0A=
        text =3D event.type;=0A=
        status =3D event.type =3D=3D=3D 'error' ? 404 : 200;=0A=
      }=0A=
=0A=
      if (done) {=0A=
        done(status, text);=0A=
      }=0A=
    };=0A=
=0A=
    script.addEventListener('load', callback);=0A=
    script.addEventListener('error', callback);=0A=
    rawDocument.body.appendChild(script);=0A=
    return callback;=0A=
  }=0A=
}=0A=
=0A=
var $interpolateMinErr =3D angular.$interpolateMinErr =3D =
minErr('$interpolate');=0A=
$interpolateMinErr.throwNoconcat =3D function(text) {=0A=
  throw $interpolateMinErr('noconcat',=0A=
      'Error while interpolating: {0}\nStrict Contextual Escaping =
disallows ' +=0A=
      'interpolations that concatenate multiple expressions when a =
trusted value is ' +=0A=
      'required.  See http://docs.angularjs.org/api/ng.$sce', text);=0A=
};=0A=
=0A=
$interpolateMinErr.interr =3D function(text, err) {=0A=
  return $interpolateMinErr('interr', 'Can\'t interpolate: {0}\n{1}', =
text, err.toString());=0A=
};=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $interpolateProvider=0A=
 * @this=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * Used for configuring the interpolation markup. Defaults to `{{` and =
`}}`.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-danger"&gt;=0A=
 * This feature is sometimes used to mix different markup languages, =
e.g. to wrap an Angular=0A=
 * template within a Python Jinja template (or any other template =
language). Mixing templating=0A=
 * languages is **very dangerous**. The embedding template language will =
not safely escape Angular=0A=
 * expressions, so any user-controlled values in the template will cause =
Cross Site Scripting (XSS)=0A=
 * security bugs!=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * @example=0A=
&lt;example name=3D"custom-interpolation-markup" =
module=3D"customInterpolationApp"&gt;=0A=
&lt;file name=3D"index.html"&gt;=0A=
&lt;script&gt;=0A=
  var customInterpolationApp =3D =
angular.module('customInterpolationApp', []);=0A=
=0A=
  customInterpolationApp.config(function($interpolateProvider) {=0A=
    $interpolateProvider.startSymbol('//');=0A=
    $interpolateProvider.endSymbol('//');=0A=
  });=0A=
=0A=
=0A=
  customInterpolationApp.controller('DemoController', function() {=0A=
      this.label =3D "This binding is brought you by // interpolation =
symbols.";=0A=
  });=0A=
&lt;/script&gt;=0A=
&lt;div ng-controller=3D"DemoController as demo"&gt;=0A=
    //demo.label//=0A=
&lt;/div&gt;=0A=
&lt;/file&gt;=0A=
&lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
  it('should interpolate binding with custom symbols', function() {=0A=
    expect(element(by.binding('demo.label')).getText()).toBe('This =
binding is brought you by // interpolation symbols.');=0A=
  });=0A=
&lt;/file&gt;=0A=
&lt;/example&gt;=0A=
 */=0A=
function $InterpolateProvider() {=0A=
  var startSymbol =3D '{{';=0A=
  var endSymbol =3D '}}';=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $interpolateProvider#startSymbol=0A=
   * @description=0A=
   * Symbol to denote start of expression in the interpolated string. =
Defaults to `{{`.=0A=
   *=0A=
   * @param {string=3D} value new value to set the starting symbol to.=0A=
   * @returns {string|self} Returns the symbol when used as getter and =
self if used as setter.=0A=
   */=0A=
  this.startSymbol =3D function(value) {=0A=
    if (value) {=0A=
      startSymbol =3D value;=0A=
      return this;=0A=
    } else {=0A=
      return startSymbol;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $interpolateProvider#endSymbol=0A=
   * @description=0A=
   * Symbol to denote the end of expression in the interpolated string. =
Defaults to `}}`.=0A=
   *=0A=
   * @param {string=3D} value new value to set the ending symbol to.=0A=
   * @returns {string|self} Returns the symbol when used as getter and =
self if used as setter.=0A=
   */=0A=
  this.endSymbol =3D function(value) {=0A=
    if (value) {=0A=
      endSymbol =3D value;=0A=
      return this;=0A=
    } else {=0A=
      return endSymbol;=0A=
    }=0A=
  };=0A=
=0A=
=0A=
  this.$get =3D ['$parse', '$exceptionHandler', '$sce', function($parse, =
$exceptionHandler, $sce) {=0A=
    var startSymbolLength =3D startSymbol.length,=0A=
        endSymbolLength =3D endSymbol.length,=0A=
        escapedStartRegexp =3D new RegExp(startSymbol.replace(/./g, =
escape), 'g'),=0A=
        escapedEndRegexp =3D new RegExp(endSymbol.replace(/./g, escape), =
'g');=0A=
=0A=
    function escape(ch) {=0A=
      return '\\\\\\' + ch;=0A=
    }=0A=
=0A=
    function unescapeText(text) {=0A=
      return text.replace(escapedStartRegexp, startSymbol).=0A=
        replace(escapedEndRegexp, endSymbol);=0A=
    }=0A=
=0A=
    // TODO: this is the same as the constantWatchDelegate in parse.js=0A=
    function constantWatchDelegate(scope, listener, objectEquality, =
constantInterp) {=0A=
      var unwatch =3D scope.$watch(function =
constantInterpolateWatch(scope) {=0A=
        unwatch();=0A=
        return constantInterp(scope);=0A=
      }, listener, objectEquality);=0A=
      return unwatch;=0A=
    }=0A=
=0A=
    /**=0A=
     * @ngdoc service=0A=
     * @name $interpolate=0A=
     * @kind function=0A=
     *=0A=
     * @requires $parse=0A=
     * @requires $sce=0A=
     *=0A=
     * @description=0A=
     *=0A=
     * Compiles a string with markup into an interpolation function. =
This service is used by the=0A=
     * HTML {@link ng.$compile $compile} service for data binding. See=0A=
     * {@link ng.$interpolateProvider $interpolateProvider} for =
configuring the=0A=
     * interpolation markup.=0A=
     *=0A=
     *=0A=
     * ```js=0A=
     *   var $interpolate =3D ...; // injected=0A=
     *   var exp =3D $interpolate('Hello {{name | uppercase}}!');=0A=
     *   expect(exp({name:'Angular'})).toEqual('Hello ANGULAR!');=0A=
     * ```=0A=
     *=0A=
     * `$interpolate` takes an optional fourth argument, `allOrNothing`. =
If `allOrNothing` is=0A=
     * `true`, the interpolation function will return `undefined` unless =
all embedded expressions=0A=
     * evaluate to a value other than `undefined`.=0A=
     *=0A=
     * ```js=0A=
     *   var $interpolate =3D ...; // injected=0A=
     *   var context =3D {greeting: 'Hello', name: undefined };=0A=
     *=0A=
     *   // default "forgiving" mode=0A=
     *   var exp =3D $interpolate('{{greeting}} {{name}}!');=0A=
     *   expect(exp(context)).toEqual('Hello !');=0A=
     *=0A=
     *   // "allOrNothing" mode=0A=
     *   exp =3D $interpolate('{{greeting}} {{name}}!', false, null, =
true);=0A=
     *   expect(exp(context)).toBeUndefined();=0A=
     *   context.name =3D 'Angular';=0A=
     *   expect(exp(context)).toEqual('Hello Angular!');=0A=
     * ```=0A=
     *=0A=
     * `allOrNothing` is useful for interpolating URLs. `ngSrc` and =
`ngSrcset` use this behavior.=0A=
     *=0A=
     * #### Escaped Interpolation=0A=
     * $interpolate provides a mechanism for escaping interpolation =
markers. Start and end markers=0A=
     * can be escaped by preceding each of their characters with a =
REVERSE SOLIDUS U+005C (backslash).=0A=
     * It will be rendered as a regular start/end marker, and will not =
be interpreted as an expression=0A=
     * or binding.=0A=
     *=0A=
     * This enables web-servers to prevent script injection attacks and =
defacing attacks, to some=0A=
     * degree, while also enabling code examples to work without relying =
on the=0A=
     * {@link ng.directive:ngNonBindable ngNonBindable} directive.=0A=
     *=0A=
     * **For security purposes, it is strongly encouraged that web =
servers escape user-supplied data,=0A=
     * replacing angle brackets (&amp;lt;, &amp;gt;) with &amp;amp;lt; =
and &amp;amp;gt; respectively, and replacing all=0A=
     * interpolation start/end markers with their escaped counterparts.**=0A=
     *=0A=
     * Escaped interpolation markers are only replaced with the actual =
interpolation markers in rendered=0A=
     * output when the $interpolate service processes the text. So, for =
HTML elements interpolated=0A=
     * by {@link ng.$compile $compile}, or otherwise interpolated with =
the `mustHaveExpression` parameter=0A=
     * set to `true`, the interpolated text must contain an unescaped =
interpolation expression. As such,=0A=
     * this is typically useful only when user-data is used in rendering =
a template from the server, or=0A=
     * when otherwise untrusted data is used by a directive.=0A=
     *=0A=
     * &lt;example name=3D"interpolation"&gt;=0A=
     *  &lt;file name=3D"index.html"&gt;=0A=
     *    &lt;div ng-init=3D"username=3D'A user'"&gt;=0A=
     *      &lt;p ng-init=3D"apptitle=3D'Escaping =
demo'"&gt;{{apptitle}}: \{\{ username =3D "defaced value"; \}\}=0A=
     *        &lt;/p&gt;=0A=
     *      &lt;p&gt;&lt;strong&gt;{{username}}&lt;/strong&gt; attempts =
to inject code which will deface the=0A=
     *        application, but fails to accomplish their task, because =
the server has correctly=0A=
     *        escaped the interpolation start/end markers with REVERSE =
SOLIDUS U+005C (backslash)=0A=
     *        characters.&lt;/p&gt;=0A=
     *      &lt;p&gt;Instead, the result of the attempted script =
injection is visible, and can be removed=0A=
     *        from the database by an administrator.&lt;/p&gt;=0A=
     *    &lt;/div&gt;=0A=
     *  &lt;/file&gt;=0A=
     * &lt;/example&gt;=0A=
     *=0A=
     * @knownIssue=0A=
     * It is currently not possible for an interpolated expression to =
contain the interpolation end=0A=
     * symbol. For example, `{{ '}}' }}` will be incorrectly interpreted =
as `{{ ' }}` + `' }}`, i.e.=0A=
     * an interpolated expression consisting of a single-quote (`'`) and =
the `' }}` string.=0A=
     *=0A=
     * @knownIssue=0A=
     * All directives and components must use the standard `{{` `}}` =
interpolation symbols=0A=
     * in their templates. If you change the application interpolation =
symbols the {@link $compile}=0A=
     * service will attempt to denormalize the standard symbols to the =
custom symbols.=0A=
     * The denormalization process is not clever enough to know not to =
replace instances of the standard=0A=
     * symbols where they would not normally be treated as interpolation =
symbols. For example in the following=0A=
     * code snippet the closing braces of the literal object will get =
incorrectly denormalized:=0A=
     *=0A=
     * ```=0A=
     * &lt;div data-context=3D'{"context":{"id":3,"type":"page"}}"&gt;=0A=
     * ```=0A=
     *=0A=
     * The workaround is to ensure that such instances are separated by =
whitespace:=0A=
     * ```=0A=
     * &lt;div data-context=3D'{"context":{"id":3,"type":"page"} }"&gt;=0A=
     * ```=0A=
     *=0A=
     * See =
https://github.com/angular/angular.js/pull/14610#issuecomment-219401099 =
for more information.=0A=
     *=0A=
     * @param {string} text The text with markup to interpolate.=0A=
     * @param {boolean=3D} mustHaveExpression if set to true then the =
interpolation string must have=0A=
     *    embedded expression in order to return an interpolation =
function. Strings with no=0A=
     *    embedded expression will return null for the interpolation =
function.=0A=
     * @param {string=3D} trustedContext when provided, the returned =
function passes the interpolated=0A=
     *    result through {@link ng.$sce#getTrusted =
$sce.getTrusted(interpolatedResult,=0A=
     *    trustedContext)} before returning it.  Refer to the {@link =
ng.$sce $sce} service that=0A=
     *    provides Strict Contextual Escaping for details.=0A=
     * @param {boolean=3D} allOrNothing if `true`, then the returned =
function returns undefined=0A=
     *    unless all embedded expressions evaluate to a value other than =
`undefined`.=0A=
     * @returns {function(context)} an interpolation function which is =
used to compute the=0A=
     *    interpolated string. The function has these parameters:=0A=
     *=0A=
     * - `context`: evaluation context for all expressions embedded in =
the interpolated text=0A=
     */=0A=
    function $interpolate(text, mustHaveExpression, trustedContext, =
allOrNothing) {=0A=
      // Provide a quick exit and simplified result function for text =
with no interpolation=0A=
      if (!text.length || text.indexOf(startSymbol) =3D=3D=3D -1) {=0A=
        var constantInterp;=0A=
        if (!mustHaveExpression) {=0A=
          var unescapedText =3D unescapeText(text);=0A=
          constantInterp =3D valueFn(unescapedText);=0A=
          constantInterp.exp =3D text;=0A=
          constantInterp.expressions =3D [];=0A=
          constantInterp.$$watchDelegate =3D constantWatchDelegate;=0A=
        }=0A=
        return constantInterp;=0A=
      }=0A=
=0A=
      allOrNothing =3D !!allOrNothing;=0A=
      var startIndex,=0A=
          endIndex,=0A=
          index =3D 0,=0A=
          expressions =3D [],=0A=
          parseFns =3D [],=0A=
          textLength =3D text.length,=0A=
          exp,=0A=
          concat =3D [],=0A=
          expressionPositions =3D [];=0A=
=0A=
      while (index &lt; textLength) {=0A=
        if (((startIndex =3D text.indexOf(startSymbol, index)) !=3D=3D =
-1) &amp;&amp;=0A=
             ((endIndex =3D text.indexOf(endSymbol, startIndex + =
startSymbolLength)) !=3D=3D -1)) {=0A=
          if (index !=3D=3D startIndex) {=0A=
            concat.push(unescapeText(text.substring(index, startIndex)));=0A=
          }=0A=
          exp =3D text.substring(startIndex + startSymbolLength, =
endIndex);=0A=
          expressions.push(exp);=0A=
          parseFns.push($parse(exp, parseStringifyInterceptor));=0A=
          index =3D endIndex + endSymbolLength;=0A=
          expressionPositions.push(concat.length);=0A=
          concat.push('');=0A=
        } else {=0A=
          // we did not find an interpolation, so we have to add the =
remainder to the separators array=0A=
          if (index !=3D=3D textLength) {=0A=
            concat.push(unescapeText(text.substring(index)));=0A=
          }=0A=
          break;=0A=
        }=0A=
      }=0A=
=0A=
      // Concatenating expressions makes it hard to reason about whether =
some combination of=0A=
      // concatenated values are unsafe to use and could easily lead to =
XSS.  By requiring that a=0A=
      // single expression be used for iframe[src], object[src], etc., =
we ensure that the value=0A=
      // that's used is assigned or constructed by some JS code =
somewhere that is more testable or=0A=
      // make it obvious that you bound the value to some user =
controlled value.  This helps reduce=0A=
      // the load when auditing for XSS issues.=0A=
      if (trustedContext &amp;&amp; concat.length &gt; 1) {=0A=
          $interpolateMinErr.throwNoconcat(text);=0A=
      }=0A=
=0A=
      if (!mustHaveExpression || expressions.length) {=0A=
        var compute =3D function(values) {=0A=
          for (var i =3D 0, ii =3D expressions.length; i &lt; ii; i++) {=0A=
            if (allOrNothing &amp;&amp; isUndefined(values[i])) return;=0A=
            concat[expressionPositions[i]] =3D values[i];=0A=
          }=0A=
          return concat.join('');=0A=
        };=0A=
=0A=
        var getValue =3D function(value) {=0A=
          return trustedContext ?=0A=
            $sce.getTrusted(trustedContext, value) :=0A=
            $sce.valueOf(value);=0A=
        };=0A=
=0A=
        return extend(function interpolationFn(context) {=0A=
            var i =3D 0;=0A=
            var ii =3D expressions.length;=0A=
            var values =3D new Array(ii);=0A=
=0A=
            try {=0A=
              for (; i &lt; ii; i++) {=0A=
                values[i] =3D parseFns[i](context);=0A=
              }=0A=
=0A=
              return compute(values);=0A=
            } catch (err) {=0A=
              $exceptionHandler($interpolateMinErr.interr(text, err));=0A=
            }=0A=
=0A=
          }, {=0A=
          // all of these properties are undocumented for now=0A=
          exp: text, //just for compatibility with regular watchers =
created via $watch=0A=
          expressions: expressions,=0A=
          $$watchDelegate: function(scope, listener) {=0A=
            var lastValue;=0A=
            return scope.$watchGroup(parseFns, /** @this */ function =
interpolateFnWatcher(values, oldValues) {=0A=
              var currValue =3D compute(values);=0A=
              if (isFunction(listener)) {=0A=
                listener.call(this, currValue, values !=3D=3D oldValues =
? lastValue : currValue, scope);=0A=
              }=0A=
              lastValue =3D currValue;=0A=
            });=0A=
          }=0A=
        });=0A=
      }=0A=
=0A=
      function parseStringifyInterceptor(value) {=0A=
        try {=0A=
          value =3D getValue(value);=0A=
          return allOrNothing &amp;&amp; !isDefined(value) ? value : =
stringify(value);=0A=
        } catch (err) {=0A=
          $exceptionHandler($interpolateMinErr.interr(text, err));=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $interpolate#startSymbol=0A=
     * @description=0A=
     * Symbol to denote the start of expression in the interpolated =
string. Defaults to `{{`.=0A=
     *=0A=
     * Use {@link ng.$interpolateProvider#startSymbol =
`$interpolateProvider.startSymbol`} to change=0A=
     * the symbol.=0A=
     *=0A=
     * @returns {string} start symbol.=0A=
     */=0A=
    $interpolate.startSymbol =3D function() {=0A=
      return startSymbol;=0A=
    };=0A=
=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $interpolate#endSymbol=0A=
     * @description=0A=
     * Symbol to denote the end of expression in the interpolated =
string. Defaults to `}}`.=0A=
     *=0A=
     * Use {@link ng.$interpolateProvider#endSymbol =
`$interpolateProvider.endSymbol`} to change=0A=
     * the symbol.=0A=
     *=0A=
     * @returns {string} end symbol.=0A=
     */=0A=
    $interpolate.endSymbol =3D function() {=0A=
      return endSymbol;=0A=
    };=0A=
=0A=
    return $interpolate;=0A=
  }];=0A=
}=0A=
=0A=
/** @this */=0A=
function $IntervalProvider() {=0A=
  this.$get =3D ['$rootScope', '$window', '$q', '$$q', '$browser',=0A=
       function($rootScope,   $window,   $q,   $$q,   $browser) {=0A=
    var intervals =3D {};=0A=
=0A=
=0A=
     /**=0A=
      * @ngdoc service=0A=
      * @name $interval=0A=
      *=0A=
      * @description=0A=
      * Angular's wrapper for `window.setInterval`. The `fn` function is =
executed every `delay`=0A=
      * milliseconds.=0A=
      *=0A=
      * The return value of registering an interval function is a =
promise. This promise will be=0A=
      * notified upon each tick of the interval, and will be resolved =
after `count` iterations, or=0A=
      * run indefinitely if `count` is not defined. The value of the =
notification will be the=0A=
      * number of iterations that have run.=0A=
      * To cancel an interval, call `$interval.cancel(promise)`.=0A=
      *=0A=
      * In tests you can use {@link ngMock.$interval#flush =
`$interval.flush(millis)`} to=0A=
      * move forward by `millis` milliseconds and trigger any functions =
scheduled to run in that=0A=
      * time.=0A=
      *=0A=
      * &lt;div class=3D"alert alert-warning"&gt;=0A=
      * **Note**: Intervals created by this service must be explicitly =
destroyed when you are finished=0A=
      * with them.  In particular they are not automatically destroyed =
when a controller's scope or a=0A=
      * directive's element are destroyed.=0A=
      * You should take this into consideration and make sure to always =
cancel the interval at the=0A=
      * appropriate moment.  See the example below for more details on =
how and when to do this.=0A=
      * &lt;/div&gt;=0A=
      *=0A=
      * @param {function()} fn A function that should be called =
repeatedly. If no additional arguments=0A=
      *   are passed (see below), the function is called with the =
current iteration count.=0A=
      * @param {number} delay Number of milliseconds between each =
function call.=0A=
      * @param {number=3D} [count=3D0] Number of times to repeat. If not =
set, or 0, will repeat=0A=
      *   indefinitely.=0A=
      * @param {boolean=3D} [invokeApply=3Dtrue] If set to `false` skips =
model dirty checking, otherwise=0A=
      *   will invoke `fn` within the {@link ng.$rootScope.Scope#$apply =
$apply} block.=0A=
      * @param {...*=3D} Pass additional parameters to the executed =
function.=0A=
      * @returns {promise} A promise which will be notified on each =
iteration. It will resolve once all iterations of the interval complete.=0A=
      *=0A=
      * @example=0A=
      * &lt;example module=3D"intervalExample" =
name=3D"interval-service"&gt;=0A=
      * &lt;file name=3D"index.html"&gt;=0A=
      *   &lt;script&gt;=0A=
      *     angular.module('intervalExample', [])=0A=
      *       .controller('ExampleController', ['$scope', '$interval',=0A=
      *         function($scope, $interval) {=0A=
      *           $scope.format =3D 'M/d/yy h:mm:ss a';=0A=
      *           $scope.blood_1 =3D 100;=0A=
      *           $scope.blood_2 =3D 120;=0A=
      *=0A=
      *           var stop;=0A=
      *           $scope.fight =3D function() {=0A=
      *             // Don't start a new fight if we are already fighting=0A=
      *             if ( angular.isDefined(stop) ) return;=0A=
      *=0A=
      *             stop =3D $interval(function() {=0A=
      *               if ($scope.blood_1 &gt; 0 &amp;&amp; =
$scope.blood_2 &gt; 0) {=0A=
      *                 $scope.blood_1 =3D $scope.blood_1 - 3;=0A=
      *                 $scope.blood_2 =3D $scope.blood_2 - 4;=0A=
      *               } else {=0A=
      *                 $scope.stopFight();=0A=
      *               }=0A=
      *             }, 100);=0A=
      *           };=0A=
      *=0A=
      *           $scope.stopFight =3D function() {=0A=
      *             if (angular.isDefined(stop)) {=0A=
      *               $interval.cancel(stop);=0A=
      *               stop =3D undefined;=0A=
      *             }=0A=
      *           };=0A=
      *=0A=
      *           $scope.resetFight =3D function() {=0A=
      *             $scope.blood_1 =3D 100;=0A=
      *             $scope.blood_2 =3D 120;=0A=
      *           };=0A=
      *=0A=
      *           $scope.$on('$destroy', function() {=0A=
      *             // Make sure that the interval is destroyed too=0A=
      *             $scope.stopFight();=0A=
      *           });=0A=
      *         }])=0A=
      *       // Register the 'myCurrentTime' directive factory method.=0A=
      *       // We inject $interval and dateFilter service since the =
factory method is DI.=0A=
      *       .directive('myCurrentTime', ['$interval', 'dateFilter',=0A=
      *         function($interval, dateFilter) {=0A=
      *           // return the directive link function. (compile =
function not needed)=0A=
      *           return function(scope, element, attrs) {=0A=
      *             var format,  // date format=0A=
      *                 stopTime; // so that we can cancel the time =
updates=0A=
      *=0A=
      *             // used to update the UI=0A=
      *             function updateTime() {=0A=
      *               element.text(dateFilter(new Date(), format));=0A=
      *             }=0A=
      *=0A=
      *             // watch the expression, and update the UI on change.=0A=
      *             scope.$watch(attrs.myCurrentTime, function(value) {=0A=
      *               format =3D value;=0A=
      *               updateTime();=0A=
      *             });=0A=
      *=0A=
      *             stopTime =3D $interval(updateTime, 1000);=0A=
      *=0A=
      *             // listen on DOM destroy (removal) event, and cancel =
the next UI update=0A=
      *             // to prevent updating time after the DOM element =
was removed.=0A=
      *             element.on('$destroy', function() {=0A=
      *               $interval.cancel(stopTime);=0A=
      *             });=0A=
      *           }=0A=
      *         }]);=0A=
      *   &lt;/script&gt;=0A=
      *=0A=
      *   &lt;div&gt;=0A=
      *     &lt;div ng-controller=3D"ExampleController"&gt;=0A=
      *       &lt;label&gt;Date format: &lt;input =
ng-model=3D"format"&gt;&lt;/label&gt; &lt;hr/&gt;=0A=
      *       Current time is: &lt;span =
my-current-time=3D"format"&gt;&lt;/span&gt;=0A=
      *       &lt;hr/&gt;=0A=
      *       Blood 1 : &lt;font =
color=3D'red'&gt;{{blood_1}}&lt;/font&gt;=0A=
      *       Blood 2 : &lt;font =
color=3D'red'&gt;{{blood_2}}&lt;/font&gt;=0A=
      *       &lt;button type=3D"button" =
data-ng-click=3D"fight()"&gt;Fight&lt;/button&gt;=0A=
      *       &lt;button type=3D"button" =
data-ng-click=3D"stopFight()"&gt;StopFight&lt;/button&gt;=0A=
      *       &lt;button type=3D"button" =
data-ng-click=3D"resetFight()"&gt;resetFight&lt;/button&gt;=0A=
      *     &lt;/div&gt;=0A=
      *   &lt;/div&gt;=0A=
      *=0A=
      * &lt;/file&gt;=0A=
      * &lt;/example&gt;=0A=
      */=0A=
    function interval(fn, delay, count, invokeApply) {=0A=
      var hasParams =3D arguments.length &gt; 4,=0A=
          args =3D hasParams ? sliceArgs(arguments, 4) : [],=0A=
          setInterval =3D $window.setInterval,=0A=
          clearInterval =3D $window.clearInterval,=0A=
          iteration =3D 0,=0A=
          skipApply =3D (isDefined(invokeApply) &amp;&amp; !invokeApply),=0A=
          deferred =3D (skipApply ? $$q : $q).defer(),=0A=
          promise =3D deferred.promise;=0A=
=0A=
      count =3D isDefined(count) ? count : 0;=0A=
=0A=
      promise.$$intervalId =3D setInterval(function tick() {=0A=
        if (skipApply) {=0A=
          $browser.defer(callback);=0A=
        } else {=0A=
          $rootScope.$evalAsync(callback);=0A=
        }=0A=
        deferred.notify(iteration++);=0A=
=0A=
        if (count &gt; 0 &amp;&amp; iteration &gt;=3D count) {=0A=
          deferred.resolve(iteration);=0A=
          clearInterval(promise.$$intervalId);=0A=
          delete intervals[promise.$$intervalId];=0A=
        }=0A=
=0A=
        if (!skipApply) $rootScope.$apply();=0A=
=0A=
      }, delay);=0A=
=0A=
      intervals[promise.$$intervalId] =3D deferred;=0A=
=0A=
      return promise;=0A=
=0A=
      function callback() {=0A=
        if (!hasParams) {=0A=
          fn(iteration);=0A=
        } else {=0A=
          fn.apply(null, args);=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
=0A=
     /**=0A=
      * @ngdoc method=0A=
      * @name $interval#cancel=0A=
      *=0A=
      * @description=0A=
      * Cancels a task associated with the `promise`.=0A=
      *=0A=
      * @param {Promise=3D} promise returned by the `$interval` function.=0A=
      * @returns {boolean} Returns `true` if the task was successfully =
canceled.=0A=
      */=0A=
    interval.cancel =3D function(promise) {=0A=
      if (promise &amp;&amp; promise.$$intervalId in intervals) {=0A=
        // Interval cancels should not report as unhandled promise.=0A=
        markQExceptionHandled(intervals[promise.$$intervalId].promise);=0A=
        intervals[promise.$$intervalId].reject('canceled');=0A=
        $window.clearInterval(promise.$$intervalId);=0A=
        delete intervals[promise.$$intervalId];=0A=
        return true;=0A=
      }=0A=
      return false;=0A=
    };=0A=
=0A=
    return interval;=0A=
  }];=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $jsonpCallbacks=0A=
 * @requires $window=0A=
 * @description=0A=
 * This service handles the lifecycle of callbacks to handle JSONP =
requests.=0A=
 * Override this service if you wish to customise where the callbacks =
are stored and=0A=
 * how they vary compared to the requested url.=0A=
 */=0A=
var $jsonpCallbacksProvider =3D /** @this */ function() {=0A=
  this.$get =3D function() {=0A=
    var callbacks =3D angular.callbacks;=0A=
    var callbackMap =3D {};=0A=
=0A=
    function createCallback(callbackId) {=0A=
      var callback =3D function(data) {=0A=
        callback.data =3D data;=0A=
        callback.called =3D true;=0A=
      };=0A=
      callback.id =3D callbackId;=0A=
      return callback;=0A=
    }=0A=
=0A=
    return {=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $jsonpCallbacks#createCallback=0A=
       * @param {string} url the url of the JSONP request=0A=
       * @returns {string} the callback path to send to the server as =
part of the JSONP request=0A=
       * @description=0A=
       * {@link $httpBackend} calls this method to create a callback and =
get hold of the path to the callback=0A=
       * to pass to the server, which will be used to call the callback =
with its payload in the JSONP response.=0A=
       */=0A=
      createCallback: function(url) {=0A=
        var callbackId =3D '_' + (callbacks.$$counter++).toString(36);=0A=
        var callbackPath =3D 'angular.callbacks.' + callbackId;=0A=
        var callback =3D createCallback(callbackId);=0A=
        callbackMap[callbackPath] =3D callbacks[callbackId] =3D callback;=0A=
        return callbackPath;=0A=
      },=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $jsonpCallbacks#wasCalled=0A=
       * @param {string} callbackPath the path to the callback that was =
sent in the JSONP request=0A=
       * @returns {boolean} whether the callback has been called, as a =
result of the JSONP response=0A=
       * @description=0A=
       * {@link $httpBackend} calls this method to find out whether the =
JSONP response actually called the=0A=
       * callback that was passed in the request.=0A=
       */=0A=
      wasCalled: function(callbackPath) {=0A=
        return callbackMap[callbackPath].called;=0A=
      },=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $jsonpCallbacks#getResponse=0A=
       * @param {string} callbackPath the path to the callback that was =
sent in the JSONP request=0A=
       * @returns {*} the data received from the response via the =
registered callback=0A=
       * @description=0A=
       * {@link $httpBackend} calls this method to get hold of the data =
that was provided to the callback=0A=
       * in the JSONP response.=0A=
       */=0A=
      getResponse: function(callbackPath) {=0A=
        return callbackMap[callbackPath].data;=0A=
      },=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $jsonpCallbacks#removeCallback=0A=
       * @param {string} callbackPath the path to the callback that was =
sent in the JSONP request=0A=
       * @description=0A=
       * {@link $httpBackend} calls this method to remove the callback =
after the JSONP request has=0A=
       * completed or timed-out.=0A=
       */=0A=
      removeCallback: function(callbackPath) {=0A=
        var callback =3D callbackMap[callbackPath];=0A=
        delete callbacks[callback.id];=0A=
        delete callbackMap[callbackPath];=0A=
      }=0A=
    };=0A=
  };=0A=
};=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $locale=0A=
 *=0A=
 * @description=0A=
 * $locale service provides localization rules for various Angular =
components. As of right now the=0A=
 * only public api is:=0A=
 *=0A=
 * * `id` =E2=80&#65533; `{string}` =E2=80&#65533; locale id formatted =
as `languageId-countryId` (e.g. `en-us`)=0A=
 */=0A=
=0A=
var PATH_MATCH =3D /^([^?#]*)(\?([^#]*))?(#(.*))?$/,=0A=
    DEFAULT_PORTS =3D {'http': 80, 'https': 443, 'ftp': 21};=0A=
var $locationMinErr =3D minErr('$location');=0A=
=0A=
=0A=
/**=0A=
 * Encode path using encodeUriSegment, ignoring forward slashes=0A=
 *=0A=
 * @param {string} path Path to encode=0A=
 * @returns {string}=0A=
 */=0A=
function encodePath(path) {=0A=
  var segments =3D path.split('/'),=0A=
      i =3D segments.length;=0A=
=0A=
  while (i--) {=0A=
    segments[i] =3D encodeUriSegment(segments[i]);=0A=
  }=0A=
=0A=
  return segments.join('/');=0A=
}=0A=
=0A=
function parseAbsoluteUrl(absoluteUrl, locationObj) {=0A=
  var parsedUrl =3D urlResolve(absoluteUrl);=0A=
=0A=
  locationObj.$$protocol =3D parsedUrl.protocol;=0A=
  locationObj.$$host =3D parsedUrl.hostname;=0A=
  locationObj.$$port =3D toInt(parsedUrl.port) || =
DEFAULT_PORTS[parsedUrl.protocol] || null;=0A=
}=0A=
=0A=
var DOUBLE_SLASH_REGEX =3D /^\s*[\\/]{2,}/;=0A=
function parseAppUrl(url, locationObj) {=0A=
=0A=
  if (DOUBLE_SLASH_REGEX.test(url)) {=0A=
    throw $locationMinErr('badpath', 'Invalid url "{0}".', url);=0A=
  }=0A=
=0A=
  var prefixed =3D (url.charAt(0) !=3D=3D '/');=0A=
  if (prefixed) {=0A=
    url =3D '/' + url;=0A=
  }=0A=
  var match =3D urlResolve(url);=0A=
  locationObj.$$path =3D decodeURIComponent(prefixed &amp;&amp; =
match.pathname.charAt(0) =3D=3D=3D '/' ?=0A=
      match.pathname.substring(1) : match.pathname);=0A=
  locationObj.$$search =3D parseKeyValue(match.search);=0A=
  locationObj.$$hash =3D decodeURIComponent(match.hash);=0A=
=0A=
  // make sure path starts with '/';=0A=
  if (locationObj.$$path &amp;&amp; locationObj.$$path.charAt(0) !=3D=3D =
'/') {=0A=
    locationObj.$$path =3D '/' + locationObj.$$path;=0A=
  }=0A=
}=0A=
=0A=
function startsWith(str, search) {=0A=
  return str.slice(0, search.length) =3D=3D=3D search;=0A=
}=0A=
=0A=
/**=0A=
 *=0A=
 * @param {string} base=0A=
 * @param {string} url=0A=
 * @returns {string} returns text from `url` after `base` or `undefined` =
if it does not begin with=0A=
 *                   the expected string.=0A=
 */=0A=
function stripBaseUrl(base, url) {=0A=
  if (startsWith(url, base)) {=0A=
    return url.substr(base.length);=0A=
  }=0A=
}=0A=
=0A=
=0A=
function stripHash(url) {=0A=
  var index =3D url.indexOf('#');=0A=
  return index =3D=3D=3D -1 ? url : url.substr(0, index);=0A=
}=0A=
=0A=
function trimEmptyHash(url) {=0A=
  return url.replace(/(#.+)|#$/, '$1');=0A=
}=0A=
=0A=
=0A=
function stripFile(url) {=0A=
  return url.substr(0, stripHash(url).lastIndexOf('/') + 1);=0A=
}=0A=
=0A=
/* return the server only (scheme://host:port) */=0A=
function serverBase(url) {=0A=
  return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * LocationHtml5Url represents a URL=0A=
 * This object is exposed as $location service when HTML5 mode is =
enabled and supported=0A=
 *=0A=
 * @constructor=0A=
 * @param {string} appBase application base URL=0A=
 * @param {string} appBaseNoFile application base URL stripped of any =
filename=0A=
 * @param {string} basePrefix URL path prefix=0A=
 */=0A=
function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {=0A=
  this.$$html5 =3D true;=0A=
  basePrefix =3D basePrefix || '';=0A=
  parseAbsoluteUrl(appBase, this);=0A=
=0A=
=0A=
  /**=0A=
   * Parse given HTML5 (regular) URL string into properties=0A=
   * @param {string} url HTML5 URL=0A=
   * @private=0A=
   */=0A=
  this.$$parse =3D function(url) {=0A=
    var pathUrl =3D stripBaseUrl(appBaseNoFile, url);=0A=
    if (!isString(pathUrl)) {=0A=
      throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path =
prefix "{1}".', url,=0A=
          appBaseNoFile);=0A=
    }=0A=
=0A=
    parseAppUrl(pathUrl, this);=0A=
=0A=
    if (!this.$$path) {=0A=
      this.$$path =3D '/';=0A=
    }=0A=
=0A=
    this.$$compose();=0A=
  };=0A=
=0A=
  /**=0A=
   * Compose url and update `absUrl` property=0A=
   * @private=0A=
   */=0A=
  this.$$compose =3D function() {=0A=
    var search =3D toKeyValue(this.$$search),=0A=
        hash =3D this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';=0A=
=0A=
    this.$$url =3D encodePath(this.$$path) + (search ? '?' + search : =
'') + hash;=0A=
    this.$$absUrl =3D appBaseNoFile + this.$$url.substr(1); // first =
char is always '/'=0A=
=0A=
    this.$$urlUpdatedByLocation =3D true;=0A=
  };=0A=
=0A=
  this.$$parseLinkUrl =3D function(url, relHref) {=0A=
    if (relHref &amp;&amp; relHref[0] =3D=3D=3D '#') {=0A=
      // special case for links to hash fragments:=0A=
      // keep the old url and only replace the hash fragment=0A=
      this.hash(relHref.slice(1));=0A=
      return true;=0A=
    }=0A=
    var appUrl, prevAppUrl;=0A=
    var rewrittenUrl;=0A=
=0A=
=0A=
    if (isDefined(appUrl =3D stripBaseUrl(appBase, url))) {=0A=
      prevAppUrl =3D appUrl;=0A=
      if (basePrefix &amp;&amp; isDefined(appUrl =3D =
stripBaseUrl(basePrefix, appUrl))) {=0A=
        rewrittenUrl =3D appBaseNoFile + (stripBaseUrl('/', appUrl) || =
appUrl);=0A=
      } else {=0A=
        rewrittenUrl =3D appBase + prevAppUrl;=0A=
      }=0A=
    } else if (isDefined(appUrl =3D stripBaseUrl(appBaseNoFile, url))) {=0A=
      rewrittenUrl =3D appBaseNoFile + appUrl;=0A=
    } else if (appBaseNoFile =3D=3D=3D url + '/') {=0A=
      rewrittenUrl =3D appBaseNoFile;=0A=
    }=0A=
    if (rewrittenUrl) {=0A=
      this.$$parse(rewrittenUrl);=0A=
    }=0A=
    return !!rewrittenUrl;=0A=
  };=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * LocationHashbangUrl represents URL=0A=
 * This object is exposed as $location service when developer doesn't =
opt into html5 mode.=0A=
 * It also serves as the base class for html5 mode fallback on legacy =
browsers.=0A=
 *=0A=
 * @constructor=0A=
 * @param {string} appBase application base URL=0A=
 * @param {string} appBaseNoFile application base URL stripped of any =
filename=0A=
 * @param {string} hashPrefix hashbang prefix=0A=
 */=0A=
function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {=0A=
=0A=
  parseAbsoluteUrl(appBase, this);=0A=
=0A=
=0A=
  /**=0A=
   * Parse given hashbang URL into properties=0A=
   * @param {string} url Hashbang URL=0A=
   * @private=0A=
   */=0A=
  this.$$parse =3D function(url) {=0A=
    var withoutBaseUrl =3D stripBaseUrl(appBase, url) || =
stripBaseUrl(appBaseNoFile, url);=0A=
    var withoutHashUrl;=0A=
=0A=
    if (!isUndefined(withoutBaseUrl) &amp;&amp; withoutBaseUrl.charAt(0) =
=3D=3D=3D '#') {=0A=
=0A=
      // The rest of the URL starts with a hash so we have=0A=
      // got either a hashbang path or a plain hash fragment=0A=
      withoutHashUrl =3D stripBaseUrl(hashPrefix, withoutBaseUrl);=0A=
      if (isUndefined(withoutHashUrl)) {=0A=
        // There was no hashbang prefix so we just have a hash fragment=0A=
        withoutHashUrl =3D withoutBaseUrl;=0A=
      }=0A=
=0A=
    } else {=0A=
      // There was no hashbang path nor hash fragment:=0A=
      // If we are in HTML5 mode we use what is left as the path;=0A=
      // Otherwise we ignore what is left=0A=
      if (this.$$html5) {=0A=
        withoutHashUrl =3D withoutBaseUrl;=0A=
      } else {=0A=
        withoutHashUrl =3D '';=0A=
        if (isUndefined(withoutBaseUrl)) {=0A=
          appBase =3D url;=0A=
          /** @type {?} */ (this).replace();=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    parseAppUrl(withoutHashUrl, this);=0A=
=0A=
    this.$$path =3D removeWindowsDriveName(this.$$path, withoutHashUrl, =
appBase);=0A=
=0A=
    this.$$compose();=0A=
=0A=
    /*=0A=
     * In Windows, on an anchor node on documents loaded from=0A=
     * the filesystem, the browser will return a pathname=0A=
     * prefixed with the drive name ('/C:/path') when a=0A=
     * pathname without a drive is set:=0A=
     *  * a.setAttribute('href', '/foo')=0A=
     *   * a.pathname =3D=3D=3D '/C:/foo' //true=0A=
     *=0A=
     * Inside of Angular, we're always using pathnames that=0A=
     * do not include drive names for routing.=0A=
     */=0A=
    function removeWindowsDriveName(path, url, base) {=0A=
      /*=0A=
      Matches paths for file protocol on windows,=0A=
      such as /C:/foo/bar, and captures only /foo/bar.=0A=
      */=0A=
      var windowsFilePathExp =3D /^\/[A-Z]:(\/.*)/;=0A=
=0A=
      var firstPathSegmentMatch;=0A=
=0A=
      //Get the relative path from the input URL.=0A=
      if (startsWith(url, base)) {=0A=
        url =3D url.replace(base, '');=0A=
      }=0A=
=0A=
      // The input URL intentionally contains a first path segment that =
ends with a colon.=0A=
      if (windowsFilePathExp.exec(url)) {=0A=
        return path;=0A=
      }=0A=
=0A=
      firstPathSegmentMatch =3D windowsFilePathExp.exec(path);=0A=
      return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Compose hashbang URL and update `absUrl` property=0A=
   * @private=0A=
   */=0A=
  this.$$compose =3D function() {=0A=
    var search =3D toKeyValue(this.$$search),=0A=
        hash =3D this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';=0A=
=0A=
    this.$$url =3D encodePath(this.$$path) + (search ? '?' + search : =
'') + hash;=0A=
    this.$$absUrl =3D appBase + (this.$$url ? hashPrefix + this.$$url : =
'');=0A=
=0A=
    this.$$urlUpdatedByLocation =3D true;=0A=
  };=0A=
=0A=
  this.$$parseLinkUrl =3D function(url, relHref) {=0A=
    if (stripHash(appBase) =3D=3D=3D stripHash(url)) {=0A=
      this.$$parse(url);=0A=
      return true;=0A=
    }=0A=
    return false;=0A=
  };=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * LocationHashbangUrl represents URL=0A=
 * This object is exposed as $location service when html5 history api is =
enabled but the browser=0A=
 * does not support it.=0A=
 *=0A=
 * @constructor=0A=
 * @param {string} appBase application base URL=0A=
 * @param {string} appBaseNoFile application base URL stripped of any =
filename=0A=
 * @param {string} hashPrefix hashbang prefix=0A=
 */=0A=
function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {=0A=
  this.$$html5 =3D true;=0A=
  LocationHashbangUrl.apply(this, arguments);=0A=
=0A=
  this.$$parseLinkUrl =3D function(url, relHref) {=0A=
    if (relHref &amp;&amp; relHref[0] =3D=3D=3D '#') {=0A=
      // special case for links to hash fragments:=0A=
      // keep the old url and only replace the hash fragment=0A=
      this.hash(relHref.slice(1));=0A=
      return true;=0A=
    }=0A=
=0A=
    var rewrittenUrl;=0A=
    var appUrl;=0A=
=0A=
    if (appBase =3D=3D=3D stripHash(url)) {=0A=
      rewrittenUrl =3D url;=0A=
    } else if ((appUrl =3D stripBaseUrl(appBaseNoFile, url))) {=0A=
      rewrittenUrl =3D appBase + hashPrefix + appUrl;=0A=
    } else if (appBaseNoFile =3D=3D=3D url + '/') {=0A=
      rewrittenUrl =3D appBaseNoFile;=0A=
    }=0A=
    if (rewrittenUrl) {=0A=
      this.$$parse(rewrittenUrl);=0A=
    }=0A=
    return !!rewrittenUrl;=0A=
  };=0A=
=0A=
  this.$$compose =3D function() {=0A=
    var search =3D toKeyValue(this.$$search),=0A=
        hash =3D this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';=0A=
=0A=
    this.$$url =3D encodePath(this.$$path) + (search ? '?' + search : =
'') + hash;=0A=
    // include hashPrefix in $$absUrl when $$url is empty so IE9 does =
not reload page because of removal of '#'=0A=
    this.$$absUrl =3D appBase + hashPrefix + this.$$url;=0A=
=0A=
    this.$$urlUpdatedByLocation =3D true;=0A=
  };=0A=
=0A=
}=0A=
=0A=
=0A=
var locationPrototype =3D {=0A=
=0A=
  /**=0A=
   * Ensure absolute URL is initialized.=0A=
   * @private=0A=
   */=0A=
  $$absUrl:'',=0A=
=0A=
  /**=0A=
   * Are we in html5 mode?=0A=
   * @private=0A=
   */=0A=
  $$html5: false,=0A=
=0A=
  /**=0A=
   * Has any change been replacing?=0A=
   * @private=0A=
   */=0A=
  $$replace: false,=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $location#absUrl=0A=
   *=0A=
   * @description=0A=
   * This method is getter only.=0A=
   *=0A=
   * Return full URL representation with all segments encoded according =
to rules specified in=0A=
   * [RFC 3986](http://www.ietf.org/rfc/rfc3986.txt).=0A=
   *=0A=
   *=0A=
   * ```js=0A=
   * // given URL http://example.com/#/some/path?foo=3Dbar&amp;baz=3Dxoxo=0A=
   * var absUrl =3D $location.absUrl();=0A=
   * // =3D&gt; "http://example.com/#/some/path?foo=3Dbar&amp;baz=3Dxoxo"=0A=
   * ```=0A=
   *=0A=
   * @return {string} full URL=0A=
   */=0A=
  absUrl: locationGetter('$$absUrl'),=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $location#url=0A=
   *=0A=
   * @description=0A=
   * This method is getter / setter.=0A=
   *=0A=
   * Return URL (e.g. `/path?a=3Db#hash`) when called without any =
parameter.=0A=
   *=0A=
   * Change path, search and hash, when called with parameter and return =
`$location`.=0A=
   *=0A=
   *=0A=
   * ```js=0A=
   * // given URL http://example.com/#/some/path?foo=3Dbar&amp;baz=3Dxoxo=0A=
   * var url =3D $location.url();=0A=
   * // =3D&gt; "/some/path?foo=3Dbar&amp;baz=3Dxoxo"=0A=
   * ```=0A=
   *=0A=
   * @param {string=3D} url New URL without base prefix (e.g. =
`/path?a=3Db#hash`)=0A=
   * @return {string} url=0A=
   */=0A=
  url: function(url) {=0A=
    if (isUndefined(url)) {=0A=
      return this.$$url;=0A=
    }=0A=
=0A=
    var match =3D PATH_MATCH.exec(url);=0A=
    if (match[1] || url =3D=3D=3D '') =
this.path(decodeURIComponent(match[1]));=0A=
    if (match[2] || match[1] || url =3D=3D=3D '') this.search(match[3] =
|| '');=0A=
    this.hash(match[5] || '');=0A=
=0A=
    return this;=0A=
  },=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $location#protocol=0A=
   *=0A=
   * @description=0A=
   * This method is getter only.=0A=
   *=0A=
   * Return protocol of current URL.=0A=
   *=0A=
   *=0A=
   * ```js=0A=
   * // given URL http://example.com/#/some/path?foo=3Dbar&amp;baz=3Dxoxo=0A=
   * var protocol =3D $location.protocol();=0A=
   * // =3D&gt; "http"=0A=
   * ```=0A=
   *=0A=
   * @return {string} protocol of current URL=0A=
   */=0A=
  protocol: locationGetter('$$protocol'),=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $location#host=0A=
   *=0A=
   * @description=0A=
   * This method is getter only.=0A=
   *=0A=
   * Return host of current URL.=0A=
   *=0A=
   * Note: compared to the non-angular version `location.host` which =
returns `hostname:port`, this returns the `hostname` portion only.=0A=
   *=0A=
   *=0A=
   * ```js=0A=
   * // given URL http://example.com/#/some/path?foo=3Dbar&amp;baz=3Dxoxo=0A=
   * var host =3D $location.host();=0A=
   * // =3D&gt; "example.com"=0A=
   *=0A=
   * // given URL =
http://user:password@example.com:8080/#/some/path?foo=3Dbar&amp;baz=3Dxox=
o=0A=
   * host =3D $location.host();=0A=
   * // =3D&gt; "example.com"=0A=
   * host =3D location.host;=0A=
   * // =3D&gt; "example.com:8080"=0A=
   * ```=0A=
   *=0A=
   * @return {string} host of current URL.=0A=
   */=0A=
  host: locationGetter('$$host'),=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $location#port=0A=
   *=0A=
   * @description=0A=
   * This method is getter only.=0A=
   *=0A=
   * Return port of current URL.=0A=
   *=0A=
   *=0A=
   * ```js=0A=
   * // given URL http://example.com/#/some/path?foo=3Dbar&amp;baz=3Dxoxo=0A=
   * var port =3D $location.port();=0A=
   * // =3D&gt; 80=0A=
   * ```=0A=
   *=0A=
   * @return {Number} port=0A=
   */=0A=
  port: locationGetter('$$port'),=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $location#path=0A=
   *=0A=
   * @description=0A=
   * This method is getter / setter.=0A=
   *=0A=
   * Return path of current URL when called without any parameter.=0A=
   *=0A=
   * Change path when called with parameter and return `$location`.=0A=
   *=0A=
   * Note: Path should always begin with forward slash (/), this method =
will add the forward slash=0A=
   * if it is missing.=0A=
   *=0A=
   *=0A=
   * ```js=0A=
   * // given URL http://example.com/#/some/path?foo=3Dbar&amp;baz=3Dxoxo=0A=
   * var path =3D $location.path();=0A=
   * // =3D&gt; "/some/path"=0A=
   * ```=0A=
   *=0A=
   * @param {(string|number)=3D} path New path=0A=
   * @return {(string|object)} path if called with no parameters, or =
`$location` if called with a parameter=0A=
   */=0A=
  path: locationGetterSetter('$$path', function(path) {=0A=
    path =3D path !=3D=3D null ? path.toString() : '';=0A=
    return path.charAt(0) =3D=3D=3D '/' ? path : '/' + path;=0A=
  }),=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $location#search=0A=
   *=0A=
   * @description=0A=
   * This method is getter / setter.=0A=
   *=0A=
   * Return search part (as object) of current URL when called without =
any parameter.=0A=
   *=0A=
   * Change search part when called with parameter and return =
`$location`.=0A=
   *=0A=
   *=0A=
   * ```js=0A=
   * // given URL http://example.com/#/some/path?foo=3Dbar&amp;baz=3Dxoxo=0A=
   * var searchObject =3D $location.search();=0A=
   * // =3D&gt; {foo: 'bar', baz: 'xoxo'}=0A=
   *=0A=
   * // set foo to 'yipee'=0A=
   * $location.search('foo', 'yipee');=0A=
   * // $location.search() =3D&gt; {foo: 'yipee', baz: 'xoxo'}=0A=
   * ```=0A=
   *=0A=
   * @param =
{string|Object.&lt;string&gt;|Object.&lt;Array.&lt;string&gt;&gt;} =
search New search params - string or=0A=
   * hash object.=0A=
   *=0A=
   * When called with a single argument the method acts as a setter, =
setting the `search` component=0A=
   * of `$location` to the specified value.=0A=
   *=0A=
   * If the argument is a hash object containing an array of values, =
these values will be encoded=0A=
   * as duplicate search parameters in the URL.=0A=
   *=0A=
   * @param {(string|Number|Array&lt;string&gt;|boolean)=3D} paramValue =
If `search` is a string or number, then `paramValue`=0A=
   * will override only a single search property.=0A=
   *=0A=
   * If `paramValue` is an array, it will override the property of the =
`search` component of=0A=
   * `$location` specified via the first argument.=0A=
   *=0A=
   * If `paramValue` is `null`, the property specified via the first =
argument will be deleted.=0A=
   *=0A=
   * If `paramValue` is `true`, the property specified via the first =
argument will be added with no=0A=
   * value nor trailing equal sign.=0A=
   *=0A=
   * @return {Object} If called with no arguments returns the parsed =
`search` object. If called with=0A=
   * one or more arguments returns `$location` object itself.=0A=
   */=0A=
  search: function(search, paramValue) {=0A=
    switch (arguments.length) {=0A=
      case 0:=0A=
        return this.$$search;=0A=
      case 1:=0A=
        if (isString(search) || isNumber(search)) {=0A=
          search =3D search.toString();=0A=
          this.$$search =3D parseKeyValue(search);=0A=
        } else if (isObject(search)) {=0A=
          search =3D copy(search, {});=0A=
          // remove object undefined or null properties=0A=
          forEach(search, function(value, key) {=0A=
            if (value =3D=3D null) delete search[key];=0A=
          });=0A=
=0A=
          this.$$search =3D search;=0A=
        } else {=0A=
          throw $locationMinErr('isrcharg',=0A=
              'The first argument of the `$location#search()` call must =
be a string or an object.');=0A=
        }=0A=
        break;=0A=
      default:=0A=
        if (isUndefined(paramValue) || paramValue =3D=3D=3D null) {=0A=
          delete this.$$search[search];=0A=
        } else {=0A=
          this.$$search[search] =3D paramValue;=0A=
        }=0A=
    }=0A=
=0A=
    this.$$compose();=0A=
    return this;=0A=
  },=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $location#hash=0A=
   *=0A=
   * @description=0A=
   * This method is getter / setter.=0A=
   *=0A=
   * Returns the hash fragment when called without any parameters.=0A=
   *=0A=
   * Changes the hash fragment when called with a parameter and returns =
`$location`.=0A=
   *=0A=
   *=0A=
   * ```js=0A=
   * // given URL =
http://example.com/#/some/path?foo=3Dbar&amp;baz=3Dxoxo#hashValue=0A=
   * var hash =3D $location.hash();=0A=
   * // =3D&gt; "hashValue"=0A=
   * ```=0A=
   *=0A=
   * @param {(string|number)=3D} hash New hash fragment=0A=
   * @return {string} hash=0A=
   */=0A=
  hash: locationGetterSetter('$$hash', function(hash) {=0A=
    return hash !=3D=3D null ? hash.toString() : '';=0A=
  }),=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $location#replace=0A=
   *=0A=
   * @description=0A=
   * If called, all changes to $location during the current `$digest` =
will replace the current history=0A=
   * record, instead of adding a new one.=0A=
   */=0A=
  replace: function() {=0A=
    this.$$replace =3D true;=0A=
    return this;=0A=
  }=0A=
};=0A=
=0A=
forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, =
LocationHtml5Url], function(Location) {=0A=
  Location.prototype =3D Object.create(locationPrototype);=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $location#state=0A=
   *=0A=
   * @description=0A=
   * This method is getter / setter.=0A=
   *=0A=
   * Return the history state object when called without any parameter.=0A=
   *=0A=
   * Change the history state object when called with one parameter and =
return `$location`.=0A=
   * The state object is later passed to `pushState` or `replaceState`.=0A=
   *=0A=
   * NOTE: This method is supported only in HTML5 mode and only in =
browsers supporting=0A=
   * the HTML5 History API (i.e. methods `pushState` and =
`replaceState`). If you need to support=0A=
   * older browsers (like IE9 or Android &lt; 4.0), don't use this =
method.=0A=
   *=0A=
   * @param {object=3D} state State object for pushState or replaceState=0A=
   * @return {object} state=0A=
   */=0A=
  Location.prototype.state =3D function(state) {=0A=
    if (!arguments.length) {=0A=
      return this.$$state;=0A=
    }=0A=
=0A=
    if (Location !=3D=3D LocationHtml5Url || !this.$$html5) {=0A=
      throw $locationMinErr('nostate', 'History API state support is =
available only ' +=0A=
        'in HTML5 mode and only in browsers supporting HTML5 History =
API');=0A=
    }=0A=
    // The user might modify `stateObject` after invoking =
`$location.state(stateObject)`=0A=
    // but we're changing the $$state reference to $browser.state() =
during the $digest=0A=
    // so the modification window is narrow.=0A=
    this.$$state =3D isUndefined(state) ? null : state;=0A=
    this.$$urlUpdatedByLocation =3D true;=0A=
=0A=
    return this;=0A=
  };=0A=
});=0A=
=0A=
=0A=
function locationGetter(property) {=0A=
  return /** @this */ function() {=0A=
    return this[property];=0A=
  };=0A=
}=0A=
=0A=
=0A=
function locationGetterSetter(property, preprocess) {=0A=
  return /** @this */ function(value) {=0A=
    if (isUndefined(value)) {=0A=
      return this[property];=0A=
    }=0A=
=0A=
    this[property] =3D preprocess(value);=0A=
    this.$$compose();=0A=
=0A=
    return this;=0A=
  };=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $location=0A=
 *=0A=
 * @requires $rootElement=0A=
 *=0A=
 * @description=0A=
 * The $location service parses the URL in the browser address bar =
(based on the=0A=
 * [window.location](https://developer.mozilla.org/en/window.location)) =
and makes the URL=0A=
 * available to your application. Changes to the URL in the address bar =
are reflected into=0A=
 * $location service and changes to $location are reflected into the =
browser address bar.=0A=
 *=0A=
 * **The $location service:**=0A=
 *=0A=
 * - Exposes the current URL in the browser address bar, so you can=0A=
 *   - Watch and observe the URL.=0A=
 *   - Change the URL.=0A=
 * - Synchronizes the URL with the browser when the user=0A=
 *   - Changes the address bar.=0A=
 *   - Clicks the back or forward button (or clicks a History link).=0A=
 *   - Clicks on a link.=0A=
 * - Represents the URL object as a set of methods (protocol, host, =
port, path, search, hash).=0A=
 *=0A=
 * For more information see {@link guide/$location Developer Guide: =
Using $location}=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $locationProvider=0A=
 * @this=0A=
 *=0A=
 * @description=0A=
 * Use the `$locationProvider` to configure how the application deep =
linking paths are stored.=0A=
 */=0A=
function $LocationProvider() {=0A=
  var hashPrefix =3D '!',=0A=
      html5Mode =3D {=0A=
        enabled: false,=0A=
        requireBase: true,=0A=
        rewriteLinks: true=0A=
      };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $locationProvider#hashPrefix=0A=
   * @description=0A=
   * The default value for the prefix is `'!'`.=0A=
   * @param {string=3D} prefix Prefix for hash part (containing path and =
search)=0A=
   * @returns {*} current value if used as getter or itself (chaining) =
if used as setter=0A=
   */=0A=
  this.hashPrefix =3D function(prefix) {=0A=
    if (isDefined(prefix)) {=0A=
      hashPrefix =3D prefix;=0A=
      return this;=0A=
    } else {=0A=
      return hashPrefix;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $locationProvider#html5Mode=0A=
   * @description=0A=
   * @param {(boolean|Object)=3D} mode If boolean, sets =
`html5Mode.enabled` to value.=0A=
   *   If object, sets `enabled`, `requireBase` and `rewriteLinks` to =
respective values. Supported=0A=
   *   properties:=0A=
   *   - **enabled** =E2=80&#65533; `{boolean}` =E2=80&#65533; (default: =
false) If true, will rely on `history.pushState` to=0A=
   *     change urls where supported. Will fall back to hash-prefixed =
paths in browsers that do not=0A=
   *     support `pushState`.=0A=
   *   - **requireBase** - `{boolean}` - (default: `true`) When =
html5Mode is enabled, specifies=0A=
   *     whether or not a &lt;base&gt; tag is required to be present. If =
`enabled` and `requireBase` are=0A=
   *     true, and a base tag is not present, an error will be thrown =
when `$location` is injected.=0A=
   *     See the {@link guide/$location $location guide for more =
information}=0A=
   *   - **rewriteLinks** - `{boolean|string}` - (default: `true`) When =
html5Mode is enabled,=0A=
   *     enables/disables URL rewriting for relative links. If set to a =
string, URL rewriting will=0A=
   *     only happen on links with an attribute that matches the given =
string. For example, if set=0A=
   *     to `'internal-link'`, then the URL will only be rewritten for =
`&lt;a internal-link&gt;` links.=0A=
   *     Note that [attribute name =
normalization](guide/directive#normalization) does not apply=0A=
   *     here, so `'internalLink'` will **not** match `'internal-link'`.=0A=
   *=0A=
   * @returns {Object} html5Mode object if used as getter or itself =
(chaining) if used as setter=0A=
   */=0A=
  this.html5Mode =3D function(mode) {=0A=
    if (isBoolean(mode)) {=0A=
      html5Mode.enabled =3D mode;=0A=
      return this;=0A=
    } else if (isObject(mode)) {=0A=
=0A=
      if (isBoolean(mode.enabled)) {=0A=
        html5Mode.enabled =3D mode.enabled;=0A=
      }=0A=
=0A=
      if (isBoolean(mode.requireBase)) {=0A=
        html5Mode.requireBase =3D mode.requireBase;=0A=
      }=0A=
=0A=
      if (isBoolean(mode.rewriteLinks) || isString(mode.rewriteLinks)) {=0A=
        html5Mode.rewriteLinks =3D mode.rewriteLinks;=0A=
      }=0A=
=0A=
      return this;=0A=
    } else {=0A=
      return html5Mode;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc event=0A=
   * @name $location#$locationChangeStart=0A=
   * @eventType broadcast on root scope=0A=
   * @description=0A=
   * Broadcasted before a URL will change.=0A=
   *=0A=
   * This change can be prevented by calling=0A=
   * `preventDefault` method of the event. See {@link =
ng.$rootScope.Scope#$on} for more=0A=
   * details about event object. Upon successful change=0A=
   * {@link ng.$location#$locationChangeSuccess $locationChangeSuccess} =
is fired.=0A=
   *=0A=
   * The `newState` and `oldState` parameters may be defined only in =
HTML5 mode and when=0A=
   * the browser supports the HTML5 History API.=0A=
   *=0A=
   * @param {Object} angularEvent Synthetic event object.=0A=
   * @param {string} newUrl New URL=0A=
   * @param {string=3D} oldUrl URL that was before it was changed.=0A=
   * @param {string=3D} newState New history state object=0A=
   * @param {string=3D} oldState History state object that was before it =
was changed.=0A=
   */=0A=
=0A=
  /**=0A=
   * @ngdoc event=0A=
   * @name $location#$locationChangeSuccess=0A=
   * @eventType broadcast on root scope=0A=
   * @description=0A=
   * Broadcasted after a URL was changed.=0A=
   *=0A=
   * The `newState` and `oldState` parameters may be defined only in =
HTML5 mode and when=0A=
   * the browser supports the HTML5 History API.=0A=
   *=0A=
   * @param {Object} angularEvent Synthetic event object.=0A=
   * @param {string} newUrl New URL=0A=
   * @param {string=3D} oldUrl URL that was before it was changed.=0A=
   * @param {string=3D} newState New history state object=0A=
   * @param {string=3D} oldState History state object that was before it =
was changed.=0A=
   */=0A=
=0A=
  this.$get =3D ['$rootScope', '$browser', '$sniffer', '$rootElement', =
'$window',=0A=
      function($rootScope, $browser, $sniffer, $rootElement, $window) {=0A=
    var $location,=0A=
        LocationMode,=0A=
        baseHref =3D $browser.baseHref(), // if base[href] is undefined, =
it defaults to ''=0A=
        initialUrl =3D $browser.url(),=0A=
        appBase;=0A=
=0A=
    if (html5Mode.enabled) {=0A=
      if (!baseHref &amp;&amp; html5Mode.requireBase) {=0A=
        throw $locationMinErr('nobase',=0A=
          '$location in HTML5 mode requires a &lt;base&gt; tag to be =
present!');=0A=
      }=0A=
      appBase =3D serverBase(initialUrl) + (baseHref || '/');=0A=
      LocationMode =3D $sniffer.history ? LocationHtml5Url : =
LocationHashbangInHtml5Url;=0A=
    } else {=0A=
      appBase =3D stripHash(initialUrl);=0A=
      LocationMode =3D LocationHashbangUrl;=0A=
    }=0A=
    var appBaseNoFile =3D stripFile(appBase);=0A=
=0A=
    $location =3D new LocationMode(appBase, appBaseNoFile, '#' + =
hashPrefix);=0A=
    $location.$$parseLinkUrl(initialUrl, initialUrl);=0A=
=0A=
    $location.$$state =3D $browser.state();=0A=
=0A=
    var IGNORE_URI_REGEXP =3D /^\s*(javascript|mailto):/i;=0A=
=0A=
    function setBrowserUrlWithFallback(url, replace, state) {=0A=
      var oldUrl =3D $location.url();=0A=
      var oldState =3D $location.$$state;=0A=
      try {=0A=
        $browser.url(url, replace, state);=0A=
=0A=
        // Make sure $location.state() returns referentially identical =
(not just deeply equal)=0A=
        // state object; this makes possible quick checking if the state =
changed in the digest=0A=
        // loop. Checking deep equality would be too expensive.=0A=
        $location.$$state =3D $browser.state();=0A=
      } catch (e) {=0A=
        // Restore old values if pushState fails=0A=
        $location.url(oldUrl);=0A=
        $location.$$state =3D oldState;=0A=
=0A=
        throw e;=0A=
      }=0A=
    }=0A=
=0A=
    $rootElement.on('click', function(event) {=0A=
      var rewriteLinks =3D html5Mode.rewriteLinks;=0A=
      // TODO(vojta): rewrite link when opening in new tab/window (in =
legacy browser)=0A=
      // currently we open nice url link and redirect then=0A=
=0A=
      if (!rewriteLinks || event.ctrlKey || event.metaKey || =
event.shiftKey || event.which =3D=3D=3D 2 || event.button =3D=3D=3D 2) =
return;=0A=
=0A=
      var elm =3D jqLite(event.target);=0A=
=0A=
      // traverse the DOM up to find first A tag=0A=
      while (nodeName_(elm[0]) !=3D=3D 'a') {=0A=
        // ignore rewriting if no A tag (reached root element, or no =
parent - removed from document)=0A=
        if (elm[0] =3D=3D=3D $rootElement[0] || !(elm =3D =
elm.parent())[0]) return;=0A=
      }=0A=
=0A=
      if (isString(rewriteLinks) &amp;&amp; =
isUndefined(elm.attr(rewriteLinks))) return;=0A=
=0A=
      var absHref =3D elm.prop('href');=0A=
      // get the actual href attribute - see=0A=
      // =
http://msdn.microsoft.com/en-us/library/ie/dd347148(v=3Dvs.85).aspx=0A=
      var relHref =3D elm.attr('href') || elm.attr('xlink:href');=0A=
=0A=
      if (isObject(absHref) &amp;&amp; absHref.toString() =3D=3D=3D =
'[object SVGAnimatedString]') {=0A=
        // SVGAnimatedString.animVal should be identical to =
SVGAnimatedString.baseVal, unless during=0A=
        // an animation.=0A=
        absHref =3D urlResolve(absHref.animVal).href;=0A=
      }=0A=
=0A=
      // Ignore when url is started with javascript: or mailto:=0A=
      if (IGNORE_URI_REGEXP.test(absHref)) return;=0A=
=0A=
      if (absHref &amp;&amp; !elm.attr('target') &amp;&amp; =
!event.isDefaultPrevented()) {=0A=
        if ($location.$$parseLinkUrl(absHref, relHref)) {=0A=
          // We do a preventDefault for all urls that are part of the =
angular application,=0A=
          // in html5mode and also without, so that we are able to abort =
navigation without=0A=
          // getting double entries in the location history.=0A=
          event.preventDefault();=0A=
          // update location manually=0A=
          if ($location.absUrl() !=3D=3D $browser.url()) {=0A=
            $rootScope.$apply();=0A=
            // hack to work around FF6 bug 684208 when scenario runner =
clicks on links=0A=
            $window.angular['ff-684208-preventDefault'] =3D true;=0A=
          }=0A=
        }=0A=
      }=0A=
    });=0A=
=0A=
=0A=
    // rewrite hashbang url &lt;&gt; html5 url=0A=
    if (trimEmptyHash($location.absUrl()) !=3D=3D =
trimEmptyHash(initialUrl)) {=0A=
      $browser.url($location.absUrl(), true);=0A=
    }=0A=
=0A=
    var initializing =3D true;=0A=
=0A=
    // update $location when $browser url changes=0A=
    $browser.onUrlChange(function(newUrl, newState) {=0A=
=0A=
      if (!startsWith(newUrl, appBaseNoFile)) {=0A=
        // If we are navigating outside of the app then force a reload=0A=
        $window.location.href =3D newUrl;=0A=
        return;=0A=
      }=0A=
=0A=
      $rootScope.$evalAsync(function() {=0A=
        var oldUrl =3D $location.absUrl();=0A=
        var oldState =3D $location.$$state;=0A=
        var defaultPrevented;=0A=
        newUrl =3D trimEmptyHash(newUrl);=0A=
        $location.$$parse(newUrl);=0A=
        $location.$$state =3D newState;=0A=
=0A=
        defaultPrevented =3D =
$rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl,=0A=
            newState, oldState).defaultPrevented;=0A=
=0A=
        // if the location was changed by a `$locationChangeStart` =
handler then stop=0A=
        // processing this location change=0A=
        if ($location.absUrl() !=3D=3D newUrl) return;=0A=
=0A=
        if (defaultPrevented) {=0A=
          $location.$$parse(oldUrl);=0A=
          $location.$$state =3D oldState;=0A=
          setBrowserUrlWithFallback(oldUrl, false, oldState);=0A=
        } else {=0A=
          initializing =3D false;=0A=
          afterLocationChange(oldUrl, oldState);=0A=
        }=0A=
      });=0A=
      if (!$rootScope.$$phase) $rootScope.$digest();=0A=
    });=0A=
=0A=
    // update browser=0A=
    $rootScope.$watch(function $locationWatch() {=0A=
      if (initializing || $location.$$urlUpdatedByLocation) {=0A=
        $location.$$urlUpdatedByLocation =3D false;=0A=
=0A=
        var oldUrl =3D trimEmptyHash($browser.url());=0A=
        var newUrl =3D trimEmptyHash($location.absUrl());=0A=
        var oldState =3D $browser.state();=0A=
        var currentReplace =3D $location.$$replace;=0A=
        var urlOrStateChanged =3D oldUrl !=3D=3D newUrl ||=0A=
          ($location.$$html5 &amp;&amp; $sniffer.history &amp;&amp; =
oldState !=3D=3D $location.$$state);=0A=
=0A=
        if (initializing || urlOrStateChanged) {=0A=
          initializing =3D false;=0A=
=0A=
          $rootScope.$evalAsync(function() {=0A=
            var newUrl =3D $location.absUrl();=0A=
            var defaultPrevented =3D =
$rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl,=0A=
                $location.$$state, oldState).defaultPrevented;=0A=
=0A=
            // if the location was changed by a `$locationChangeStart` =
handler then stop=0A=
            // processing this location change=0A=
            if ($location.absUrl() !=3D=3D newUrl) return;=0A=
=0A=
            if (defaultPrevented) {=0A=
              $location.$$parse(oldUrl);=0A=
              $location.$$state =3D oldState;=0A=
            } else {=0A=
              if (urlOrStateChanged) {=0A=
                setBrowserUrlWithFallback(newUrl, currentReplace,=0A=
                                          oldState =3D=3D=3D =
$location.$$state ? null : $location.$$state);=0A=
              }=0A=
              afterLocationChange(oldUrl, oldState);=0A=
            }=0A=
          });=0A=
        }=0A=
      }=0A=
=0A=
      $location.$$replace =3D false;=0A=
=0A=
      // we don't need to return anything because $evalAsync will make =
the digest loop dirty when=0A=
      // there is a change=0A=
    });=0A=
=0A=
    return $location;=0A=
=0A=
    function afterLocationChange(oldUrl, oldState) {=0A=
      $rootScope.$broadcast('$locationChangeSuccess', =
$location.absUrl(), oldUrl,=0A=
        $location.$$state, oldState);=0A=
    }=0A=
}];=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $log=0A=
 * @requires $window=0A=
 *=0A=
 * @description=0A=
 * Simple service for logging. Default implementation safely writes the =
message=0A=
 * into the browser's console (if present).=0A=
 *=0A=
 * The main purpose of this service is to simplify debugging and =
troubleshooting.=0A=
 *=0A=
 * To reveal the location of the calls to `$log` in the JavaScript =
console,=0A=
 * you can "blackbox" the AngularJS source in your browser:=0A=
 *=0A=
 * [Mozilla description of =
blackboxing](https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_=
to/Black_box_a_source).=0A=
 * [Chrome description of =
blackboxing](https://developer.chrome.com/devtools/docs/blackboxing).=0A=
 *=0A=
 * Note: Not all browsers support blackboxing.=0A=
 *=0A=
 * The default is to log `debug` messages. You can use=0A=
 * {@link ng.$logProvider ng.$logProvider#debugEnabled} to change this.=0A=
 *=0A=
 * @example=0A=
   &lt;example module=3D"logExample" name=3D"log-service"&gt;=0A=
     &lt;file name=3D"script.js"&gt;=0A=
       angular.module('logExample', [])=0A=
         .controller('LogController', ['$scope', '$log', =
function($scope, $log) {=0A=
           $scope.$log =3D $log;=0A=
           $scope.message =3D 'Hello World!';=0A=
         }]);=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
       &lt;div ng-controller=3D"LogController"&gt;=0A=
         &lt;p&gt;Reload this page with open console, enter text and hit =
the log button...&lt;/p&gt;=0A=
         &lt;label&gt;Message:=0A=
         &lt;input type=3D"text" ng-model=3D"message" /&gt;&lt;/label&gt;=0A=
         &lt;button ng-click=3D"$log.log(message)"&gt;log&lt;/button&gt;=0A=
         &lt;button =
ng-click=3D"$log.warn(message)"&gt;warn&lt;/button&gt;=0A=
         &lt;button =
ng-click=3D"$log.info(message)"&gt;info&lt;/button&gt;=0A=
         &lt;button =
ng-click=3D"$log.error(message)"&gt;error&lt;/button&gt;=0A=
         &lt;button =
ng-click=3D"$log.debug(message)"&gt;debug&lt;/button&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $logProvider=0A=
 * @this=0A=
 *=0A=
 * @description=0A=
 * Use the `$logProvider` to configure how the application logs messages=0A=
 */=0A=
function $LogProvider() {=0A=
  var debug =3D true,=0A=
      self =3D this;=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $logProvider#debugEnabled=0A=
   * @description=0A=
   * @param {boolean=3D} flag enable or disable debug level messages=0A=
   * @returns {*} current value if used as getter or itself (chaining) =
if used as setter=0A=
   */=0A=
  this.debugEnabled =3D function(flag) {=0A=
    if (isDefined(flag)) {=0A=
      debug =3D flag;=0A=
      return this;=0A=
    } else {=0A=
      return debug;=0A=
    }=0A=
  };=0A=
=0A=
  this.$get =3D ['$window', function($window) {=0A=
    // Support: IE 9-11, Edge 12-14+=0A=
    // IE/Edge display errors in such a way that it requires the user to =
click in 4 places=0A=
    // to see the stack trace. There is no way to feature-detect it so =
there's a chance=0A=
    // of the user agent sniffing to go wrong but since it's only about =
logging, this shouldn't=0A=
    // break apps. Other browsers display errors in a sensible way and =
some of them map stack=0A=
    // traces along source maps if available so it makes sense to let =
browsers display it=0A=
    // as they want.=0A=
    var formatStackTrace =3D msie || /\bEdge\//.test($window.navigator =
&amp;&amp; $window.navigator.userAgent);=0A=
=0A=
    return {=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $log#log=0A=
       *=0A=
       * @description=0A=
       * Write a log message=0A=
       */=0A=
      log: consoleLog('log'),=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $log#info=0A=
       *=0A=
       * @description=0A=
       * Write an information message=0A=
       */=0A=
      info: consoleLog('info'),=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $log#warn=0A=
       *=0A=
       * @description=0A=
       * Write a warning message=0A=
       */=0A=
      warn: consoleLog('warn'),=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $log#error=0A=
       *=0A=
       * @description=0A=
       * Write an error message=0A=
       */=0A=
      error: consoleLog('error'),=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $log#debug=0A=
       *=0A=
       * @description=0A=
       * Write a debug message=0A=
       */=0A=
      debug: (function() {=0A=
        var fn =3D consoleLog('debug');=0A=
=0A=
        return function() {=0A=
          if (debug) {=0A=
            fn.apply(self, arguments);=0A=
          }=0A=
        };=0A=
      })()=0A=
    };=0A=
=0A=
    function formatError(arg) {=0A=
      if (isError(arg)) {=0A=
        if (arg.stack &amp;&amp; formatStackTrace) {=0A=
          arg =3D (arg.message &amp;&amp; arg.stack.indexOf(arg.message) =
=3D=3D=3D -1)=0A=
              ? 'Error: ' + arg.message + '\n' + arg.stack=0A=
              : arg.stack;=0A=
        } else if (arg.sourceURL) {=0A=
          arg =3D arg.message + '\n' + arg.sourceURL + ':' + arg.line;=0A=
        }=0A=
      }=0A=
      return arg;=0A=
    }=0A=
=0A=
    function consoleLog(type) {=0A=
      var console =3D $window.console || {},=0A=
          logFn =3D console[type] || console.log || noop;=0A=
=0A=
      return function() {=0A=
        var args =3D [];=0A=
        forEach(arguments, function(arg) {=0A=
          args.push(formatError(arg));=0A=
        });=0A=
        // Support: IE 9 only=0A=
        // console methods don't inherit from Function.prototype in IE 9 =
so we can't=0A=
        // call `logFn.apply(console, args)` directly.=0A=
        return Function.prototype.apply.call(logFn, console, args);=0A=
      };=0A=
    }=0A=
  }];=0A=
}=0A=
=0A=
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * =
* *=0A=
 *     Any commits to this file should be reviewed with security in =
mind.  *=0A=
 *   Changes to this file can potentially create security =
vulnerabilities. *=0A=
 *          An approval from 2 Core members with history of modifying    =
  *=0A=
 *                         this file is required.                        =
  *=0A=
 *                                                                       =
  *=0A=
 *  Does the change somehow allow for arbitrary javascript to be =
executed? *=0A=
 *    Or allows for someone to change the prototype of built-in objects? =
  *=0A=
 *     Or gives undesired access to variables likes document or window?  =
  *=0A=
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * =
* */=0A=
=0A=
var $parseMinErr =3D minErr('$parse');=0A=
=0A=
var objectValueOf =3D {}.constructor.prototype.valueOf;=0A=
=0A=
// Sandboxing Angular Expressions=0A=
// ------------------------------=0A=
// Angular expressions are no longer sandboxed. So it is now even easier =
to access arbitrary JS code by=0A=
// various means such as obtaining a reference to native JS functions =
like the Function constructor.=0A=
//=0A=
// As an example, consider the following Angular expression:=0A=
//=0A=
//   {}.toString.constructor('alert("evil JS code")')=0A=
//=0A=
// It is important to realize that if you create an expression from a =
string that contains user provided=0A=
// content then it is possible that your application contains a security =
vulnerability to an XSS style attack.=0A=
//=0A=
// See https://docs.angularjs.org/guide/security=0A=
=0A=
=0A=
function getStringValue(name) {=0A=
  // Property names must be strings. This means that non-string objects =
cannot be used=0A=
  // as keys in an object. Any non-string object, including a number, is =
typecasted=0A=
  // into a string via the toString method.=0A=
  // -- MDN, =
https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/=
Property_accessors#Property_names=0A=
  //=0A=
  // So, to ensure that we are checking the same `name` that JavaScript =
would use, we cast it=0A=
  // to a string. It's not always possible. If `name` is an object and =
its `toString` method is=0A=
  // 'broken' (doesn't return a string, isn't a function, etc.), an =
error will be thrown:=0A=
  //=0A=
  // TypeError: Cannot convert object to primitive value=0A=
  //=0A=
  // For performance reasons, we don't catch this error here and allow =
it to propagate up the call=0A=
  // stack. Note that you'll get the same error in JavaScript if you try =
to access a property using=0A=
  // such a 'broken' object as a key.=0A=
  return name + '';=0A=
}=0A=
=0A=
=0A=
var OPERATORS =3D createMap();=0A=
forEach('+ - * / % =3D=3D=3D !=3D=3D =3D=3D !=3D &lt; &gt; &lt;=3D =
&gt;=3D &amp;&amp; || ! =3D |'.split(' '), function(operator) { =
OPERATORS[operator] =3D true; });=0A=
var ESCAPE =3D {'n':'\n', 'f':'\f', 'r':'\r', 't':'\t', 'v':'\v', =
'\'':'\'', '"':'"'};=0A=
=0A=
=0A=
/////////////////////////////////////////=0A=
=0A=
=0A=
/**=0A=
 * @constructor=0A=
 */=0A=
var Lexer =3D function Lexer(options) {=0A=
  this.options =3D options;=0A=
};=0A=
=0A=
Lexer.prototype =3D {=0A=
  constructor: Lexer,=0A=
=0A=
  lex: function(text) {=0A=
    this.text =3D text;=0A=
    this.index =3D 0;=0A=
    this.tokens =3D [];=0A=
=0A=
    while (this.index &lt; this.text.length) {=0A=
      var ch =3D this.text.charAt(this.index);=0A=
      if (ch =3D=3D=3D '"' || ch =3D=3D=3D '\'') {=0A=
        this.readString(ch);=0A=
      } else if (this.isNumber(ch) || ch =3D=3D=3D '.' &amp;&amp; =
this.isNumber(this.peek())) {=0A=
        this.readNumber();=0A=
      } else if (this.isIdentifierStart(this.peekMultichar())) {=0A=
        this.readIdent();=0A=
      } else if (this.is(ch, '(){}[].,;:?')) {=0A=
        this.tokens.push({index: this.index, text: ch});=0A=
        this.index++;=0A=
      } else if (this.isWhitespace(ch)) {=0A=
        this.index++;=0A=
      } else {=0A=
        var ch2 =3D ch + this.peek();=0A=
        var ch3 =3D ch2 + this.peek(2);=0A=
        var op1 =3D OPERATORS[ch];=0A=
        var op2 =3D OPERATORS[ch2];=0A=
        var op3 =3D OPERATORS[ch3];=0A=
        if (op1 || op2 || op3) {=0A=
          var token =3D op3 ? ch3 : (op2 ? ch2 : ch);=0A=
          this.tokens.push({index: this.index, text: token, operator: =
true});=0A=
          this.index +=3D token.length;=0A=
        } else {=0A=
          this.throwError('Unexpected next character ', this.index, =
this.index + 1);=0A=
        }=0A=
      }=0A=
    }=0A=
    return this.tokens;=0A=
  },=0A=
=0A=
  is: function(ch, chars) {=0A=
    return chars.indexOf(ch) !=3D=3D -1;=0A=
  },=0A=
=0A=
  peek: function(i) {=0A=
    var num =3D i || 1;=0A=
    return (this.index + num &lt; this.text.length) ? =
this.text.charAt(this.index + num) : false;=0A=
  },=0A=
=0A=
  isNumber: function(ch) {=0A=
    return ('0' &lt;=3D ch &amp;&amp; ch &lt;=3D '9') &amp;&amp; typeof =
ch =3D=3D=3D 'string';=0A=
  },=0A=
=0A=
  isWhitespace: function(ch) {=0A=
    // IE treats non-breaking space as \u00A0=0A=
    return (ch =3D=3D=3D ' ' || ch =3D=3D=3D '\r' || ch =3D=3D=3D '\t' ||=0A=
            ch =3D=3D=3D '\n' || ch =3D=3D=3D '\v' || ch =3D=3D=3D =
'\u00A0');=0A=
  },=0A=
=0A=
  isIdentifierStart: function(ch) {=0A=
    return this.options.isIdentifierStart ?=0A=
        this.options.isIdentifierStart(ch, this.codePointAt(ch)) :=0A=
        this.isValidIdentifierStart(ch);=0A=
  },=0A=
=0A=
  isValidIdentifierStart: function(ch) {=0A=
    return ('a' &lt;=3D ch &amp;&amp; ch &lt;=3D 'z' ||=0A=
            'A' &lt;=3D ch &amp;&amp; ch &lt;=3D 'Z' ||=0A=
            '_' =3D=3D=3D ch || ch =3D=3D=3D '$');=0A=
  },=0A=
=0A=
  isIdentifierContinue: function(ch) {=0A=
    return this.options.isIdentifierContinue ?=0A=
        this.options.isIdentifierContinue(ch, this.codePointAt(ch)) :=0A=
        this.isValidIdentifierContinue(ch);=0A=
  },=0A=
=0A=
  isValidIdentifierContinue: function(ch, cp) {=0A=
    return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);=0A=
  },=0A=
=0A=
  codePointAt: function(ch) {=0A=
    if (ch.length =3D=3D=3D 1) return ch.charCodeAt(0);=0A=
    // eslint-disable-next-line no-bitwise=0A=
    return (ch.charCodeAt(0) &lt;&lt; 10) + ch.charCodeAt(1) - 0x35FDC00;=0A=
  },=0A=
=0A=
  peekMultichar: function() {=0A=
    var ch =3D this.text.charAt(this.index);=0A=
    var peek =3D this.peek();=0A=
    if (!peek) {=0A=
      return ch;=0A=
    }=0A=
    var cp1 =3D ch.charCodeAt(0);=0A=
    var cp2 =3D peek.charCodeAt(0);=0A=
    if (cp1 &gt;=3D 0xD800 &amp;&amp; cp1 &lt;=3D 0xDBFF &amp;&amp; cp2 =
&gt;=3D 0xDC00 &amp;&amp; cp2 &lt;=3D 0xDFFF) {=0A=
      return ch + peek;=0A=
    }=0A=
    return ch;=0A=
  },=0A=
=0A=
  isExpOperator: function(ch) {=0A=
    return (ch =3D=3D=3D '-' || ch =3D=3D=3D '+' || this.isNumber(ch));=0A=
  },=0A=
=0A=
  throwError: function(error, start, end) {=0A=
    end =3D end || this.index;=0A=
    var colStr =3D (isDefined(start)=0A=
            ? 's ' + start +  '-' + this.index + ' [' + =
this.text.substring(start, end) + ']'=0A=
            : ' ' + end);=0A=
    throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in =
expression [{2}].',=0A=
        error, colStr, this.text);=0A=
  },=0A=
=0A=
  readNumber: function() {=0A=
    var number =3D '';=0A=
    var start =3D this.index;=0A=
    while (this.index &lt; this.text.length) {=0A=
      var ch =3D lowercase(this.text.charAt(this.index));=0A=
      if (ch =3D=3D=3D '.' || this.isNumber(ch)) {=0A=
        number +=3D ch;=0A=
      } else {=0A=
        var peekCh =3D this.peek();=0A=
        if (ch =3D=3D=3D 'e' &amp;&amp; this.isExpOperator(peekCh)) {=0A=
          number +=3D ch;=0A=
        } else if (this.isExpOperator(ch) &amp;&amp;=0A=
            peekCh &amp;&amp; this.isNumber(peekCh) &amp;&amp;=0A=
            number.charAt(number.length - 1) =3D=3D=3D 'e') {=0A=
          number +=3D ch;=0A=
        } else if (this.isExpOperator(ch) &amp;&amp;=0A=
            (!peekCh || !this.isNumber(peekCh)) &amp;&amp;=0A=
            number.charAt(number.length - 1) =3D=3D=3D 'e') {=0A=
          this.throwError('Invalid exponent');=0A=
        } else {=0A=
          break;=0A=
        }=0A=
      }=0A=
      this.index++;=0A=
    }=0A=
    this.tokens.push({=0A=
      index: start,=0A=
      text: number,=0A=
      constant: true,=0A=
      value: Number(number)=0A=
    });=0A=
  },=0A=
=0A=
  readIdent: function() {=0A=
    var start =3D this.index;=0A=
    this.index +=3D this.peekMultichar().length;=0A=
    while (this.index &lt; this.text.length) {=0A=
      var ch =3D this.peekMultichar();=0A=
      if (!this.isIdentifierContinue(ch)) {=0A=
        break;=0A=
      }=0A=
      this.index +=3D ch.length;=0A=
    }=0A=
    this.tokens.push({=0A=
      index: start,=0A=
      text: this.text.slice(start, this.index),=0A=
      identifier: true=0A=
    });=0A=
  },=0A=
=0A=
  readString: function(quote) {=0A=
    var start =3D this.index;=0A=
    this.index++;=0A=
    var string =3D '';=0A=
    var rawString =3D quote;=0A=
    var escape =3D false;=0A=
    while (this.index &lt; this.text.length) {=0A=
      var ch =3D this.text.charAt(this.index);=0A=
      rawString +=3D ch;=0A=
      if (escape) {=0A=
        if (ch =3D=3D=3D 'u') {=0A=
          var hex =3D this.text.substring(this.index + 1, this.index + =
5);=0A=
          if (!hex.match(/[\da-f]{4}/i)) {=0A=
            this.throwError('Invalid unicode escape [\\u' + hex + ']');=0A=
          }=0A=
          this.index +=3D 4;=0A=
          string +=3D String.fromCharCode(parseInt(hex, 16));=0A=
        } else {=0A=
          var rep =3D ESCAPE[ch];=0A=
          string =3D string + (rep || ch);=0A=
        }=0A=
        escape =3D false;=0A=
      } else if (ch =3D=3D=3D '\\') {=0A=
        escape =3D true;=0A=
      } else if (ch =3D=3D=3D quote) {=0A=
        this.index++;=0A=
        this.tokens.push({=0A=
          index: start,=0A=
          text: rawString,=0A=
          constant: true,=0A=
          value: string=0A=
        });=0A=
        return;=0A=
      } else {=0A=
        string +=3D ch;=0A=
      }=0A=
      this.index++;=0A=
    }=0A=
    this.throwError('Unterminated quote', start);=0A=
  }=0A=
};=0A=
=0A=
var AST =3D function AST(lexer, options) {=0A=
  this.lexer =3D lexer;=0A=
  this.options =3D options;=0A=
};=0A=
=0A=
AST.Program =3D 'Program';=0A=
AST.ExpressionStatement =3D 'ExpressionStatement';=0A=
AST.AssignmentExpression =3D 'AssignmentExpression';=0A=
AST.ConditionalExpression =3D 'ConditionalExpression';=0A=
AST.LogicalExpression =3D 'LogicalExpression';=0A=
AST.BinaryExpression =3D 'BinaryExpression';=0A=
AST.UnaryExpression =3D 'UnaryExpression';=0A=
AST.CallExpression =3D 'CallExpression';=0A=
AST.MemberExpression =3D 'MemberExpression';=0A=
AST.Identifier =3D 'Identifier';=0A=
AST.Literal =3D 'Literal';=0A=
AST.ArrayExpression =3D 'ArrayExpression';=0A=
AST.Property =3D 'Property';=0A=
AST.ObjectExpression =3D 'ObjectExpression';=0A=
AST.ThisExpression =3D 'ThisExpression';=0A=
AST.LocalsExpression =3D 'LocalsExpression';=0A=
=0A=
// Internal use only=0A=
AST.NGValueParameter =3D 'NGValueParameter';=0A=
=0A=
AST.prototype =3D {=0A=
  ast: function(text) {=0A=
    this.text =3D text;=0A=
    this.tokens =3D this.lexer.lex(text);=0A=
=0A=
    var value =3D this.program();=0A=
=0A=
    if (this.tokens.length !=3D=3D 0) {=0A=
      this.throwError('is an unexpected token', this.tokens[0]);=0A=
    }=0A=
=0A=
    return value;=0A=
  },=0A=
=0A=
  program: function() {=0A=
    var body =3D [];=0A=
    while (true) {=0A=
      if (this.tokens.length &gt; 0 &amp;&amp; !this.peek('}', ')', ';', =
']'))=0A=
        body.push(this.expressionStatement());=0A=
      if (!this.expect(';')) {=0A=
        return { type: AST.Program, body: body};=0A=
      }=0A=
    }=0A=
  },=0A=
=0A=
  expressionStatement: function() {=0A=
    return { type: AST.ExpressionStatement, expression: =
this.filterChain() };=0A=
  },=0A=
=0A=
  filterChain: function() {=0A=
    var left =3D this.expression();=0A=
    while (this.expect('|')) {=0A=
      left =3D this.filter(left);=0A=
    }=0A=
    return left;=0A=
  },=0A=
=0A=
  expression: function() {=0A=
    return this.assignment();=0A=
  },=0A=
=0A=
  assignment: function() {=0A=
    var result =3D this.ternary();=0A=
    if (this.expect('=3D')) {=0A=
      if (!isAssignable(result)) {=0A=
        throw $parseMinErr('lval', 'Trying to assign a value to a non =
l-value');=0A=
      }=0A=
=0A=
      result =3D { type: AST.AssignmentExpression, left: result, right: =
this.assignment(), operator: '=3D'};=0A=
    }=0A=
    return result;=0A=
  },=0A=
=0A=
  ternary: function() {=0A=
    var test =3D this.logicalOR();=0A=
    var alternate;=0A=
    var consequent;=0A=
    if (this.expect('?')) {=0A=
      alternate =3D this.expression();=0A=
      if (this.consume(':')) {=0A=
        consequent =3D this.expression();=0A=
        return { type: AST.ConditionalExpression, test: test, alternate: =
alternate, consequent: consequent};=0A=
      }=0A=
    }=0A=
    return test;=0A=
  },=0A=
=0A=
  logicalOR: function() {=0A=
    var left =3D this.logicalAND();=0A=
    while (this.expect('||')) {=0A=
      left =3D { type: AST.LogicalExpression, operator: '||', left: =
left, right: this.logicalAND() };=0A=
    }=0A=
    return left;=0A=
  },=0A=
=0A=
  logicalAND: function() {=0A=
    var left =3D this.equality();=0A=
    while (this.expect('&amp;&amp;')) {=0A=
      left =3D { type: AST.LogicalExpression, operator: '&amp;&amp;', =
left: left, right: this.equality()};=0A=
    }=0A=
    return left;=0A=
  },=0A=
=0A=
  equality: function() {=0A=
    var left =3D this.relational();=0A=
    var token;=0A=
    while ((token =3D =
this.expect('=3D=3D','!=3D','=3D=3D=3D','!=3D=3D'))) {=0A=
      left =3D { type: AST.BinaryExpression, operator: token.text, left: =
left, right: this.relational() };=0A=
    }=0A=
    return left;=0A=
  },=0A=
=0A=
  relational: function() {=0A=
    var left =3D this.additive();=0A=
    var token;=0A=
    while ((token =3D this.expect('&lt;', '&gt;', '&lt;=3D', =
'&gt;=3D'))) {=0A=
      left =3D { type: AST.BinaryExpression, operator: token.text, left: =
left, right: this.additive() };=0A=
    }=0A=
    return left;=0A=
  },=0A=
=0A=
  additive: function() {=0A=
    var left =3D this.multiplicative();=0A=
    var token;=0A=
    while ((token =3D this.expect('+','-'))) {=0A=
      left =3D { type: AST.BinaryExpression, operator: token.text, left: =
left, right: this.multiplicative() };=0A=
    }=0A=
    return left;=0A=
  },=0A=
=0A=
  multiplicative: function() {=0A=
    var left =3D this.unary();=0A=
    var token;=0A=
    while ((token =3D this.expect('*','/','%'))) {=0A=
      left =3D { type: AST.BinaryExpression, operator: token.text, left: =
left, right: this.unary() };=0A=
    }=0A=
    return left;=0A=
  },=0A=
=0A=
  unary: function() {=0A=
    var token;=0A=
    if ((token =3D this.expect('+', '-', '!'))) {=0A=
      return { type: AST.UnaryExpression, operator: token.text, prefix: =
true, argument: this.unary() };=0A=
    } else {=0A=
      return this.primary();=0A=
    }=0A=
  },=0A=
=0A=
  primary: function() {=0A=
    var primary;=0A=
    if (this.expect('(')) {=0A=
      primary =3D this.filterChain();=0A=
      this.consume(')');=0A=
    } else if (this.expect('[')) {=0A=
      primary =3D this.arrayDeclaration();=0A=
    } else if (this.expect('{')) {=0A=
      primary =3D this.object();=0A=
    } else if (this.selfReferential.hasOwnProperty(this.peek().text)) {=0A=
      primary =3D copy(this.selfReferential[this.consume().text]);=0A=
    } else if (this.options.literals.hasOwnProperty(this.peek().text)) {=0A=
      primary =3D { type: AST.Literal, value: =
this.options.literals[this.consume().text]};=0A=
    } else if (this.peek().identifier) {=0A=
      primary =3D this.identifier();=0A=
    } else if (this.peek().constant) {=0A=
      primary =3D this.constant();=0A=
    } else {=0A=
      this.throwError('not a primary expression', this.peek());=0A=
    }=0A=
=0A=
    var next;=0A=
    while ((next =3D this.expect('(', '[', '.'))) {=0A=
      if (next.text =3D=3D=3D '(') {=0A=
        primary =3D {type: AST.CallExpression, callee: primary, =
arguments: this.parseArguments() };=0A=
        this.consume(')');=0A=
      } else if (next.text =3D=3D=3D '[') {=0A=
        primary =3D { type: AST.MemberExpression, object: primary, =
property: this.expression(), computed: true };=0A=
        this.consume(']');=0A=
      } else if (next.text =3D=3D=3D '.') {=0A=
        primary =3D { type: AST.MemberExpression, object: primary, =
property: this.identifier(), computed: false };=0A=
      } else {=0A=
        this.throwError('IMPOSSIBLE');=0A=
      }=0A=
    }=0A=
    return primary;=0A=
  },=0A=
=0A=
  filter: function(baseExpression) {=0A=
    var args =3D [baseExpression];=0A=
    var result =3D {type: AST.CallExpression, callee: this.identifier(), =
arguments: args, filter: true};=0A=
=0A=
    while (this.expect(':')) {=0A=
      args.push(this.expression());=0A=
    }=0A=
=0A=
    return result;=0A=
  },=0A=
=0A=
  parseArguments: function() {=0A=
    var args =3D [];=0A=
    if (this.peekToken().text !=3D=3D ')') {=0A=
      do {=0A=
        args.push(this.filterChain());=0A=
      } while (this.expect(','));=0A=
    }=0A=
    return args;=0A=
  },=0A=
=0A=
  identifier: function() {=0A=
    var token =3D this.consume();=0A=
    if (!token.identifier) {=0A=
      this.throwError('is not a valid identifier', token);=0A=
    }=0A=
    return { type: AST.Identifier, name: token.text };=0A=
  },=0A=
=0A=
  constant: function() {=0A=
    // TODO check that it is a constant=0A=
    return { type: AST.Literal, value: this.consume().value };=0A=
  },=0A=
=0A=
  arrayDeclaration: function() {=0A=
    var elements =3D [];=0A=
    if (this.peekToken().text !=3D=3D ']') {=0A=
      do {=0A=
        if (this.peek(']')) {=0A=
          // Support trailing commas per ES5.1.=0A=
          break;=0A=
        }=0A=
        elements.push(this.expression());=0A=
      } while (this.expect(','));=0A=
    }=0A=
    this.consume(']');=0A=
=0A=
    return { type: AST.ArrayExpression, elements: elements };=0A=
  },=0A=
=0A=
  object: function() {=0A=
    var properties =3D [], property;=0A=
    if (this.peekToken().text !=3D=3D '}') {=0A=
      do {=0A=
        if (this.peek('}')) {=0A=
          // Support trailing commas per ES5.1.=0A=
          break;=0A=
        }=0A=
        property =3D {type: AST.Property, kind: 'init'};=0A=
        if (this.peek().constant) {=0A=
          property.key =3D this.constant();=0A=
          property.computed =3D false;=0A=
          this.consume(':');=0A=
          property.value =3D this.expression();=0A=
        } else if (this.peek().identifier) {=0A=
          property.key =3D this.identifier();=0A=
          property.computed =3D false;=0A=
          if (this.peek(':')) {=0A=
            this.consume(':');=0A=
            property.value =3D this.expression();=0A=
          } else {=0A=
            property.value =3D property.key;=0A=
          }=0A=
        } else if (this.peek('[')) {=0A=
          this.consume('[');=0A=
          property.key =3D this.expression();=0A=
          this.consume(']');=0A=
          property.computed =3D true;=0A=
          this.consume(':');=0A=
          property.value =3D this.expression();=0A=
        } else {=0A=
          this.throwError('invalid key', this.peek());=0A=
        }=0A=
        properties.push(property);=0A=
      } while (this.expect(','));=0A=
    }=0A=
    this.consume('}');=0A=
=0A=
    return {type: AST.ObjectExpression, properties: properties };=0A=
  },=0A=
=0A=
  throwError: function(msg, token) {=0A=
    throw $parseMinErr('syntax',=0A=
        'Syntax Error: Token \'{0}\' {1} at column {2} of the expression =
[{3}] starting at [{4}].',=0A=
          token.text, msg, (token.index + 1), this.text, =
this.text.substring(token.index));=0A=
  },=0A=
=0A=
  consume: function(e1) {=0A=
    if (this.tokens.length =3D=3D=3D 0) {=0A=
      throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', =
this.text);=0A=
    }=0A=
=0A=
    var token =3D this.expect(e1);=0A=
    if (!token) {=0A=
      this.throwError('is unexpected, expecting [' + e1 + ']', =
this.peek());=0A=
    }=0A=
    return token;=0A=
  },=0A=
=0A=
  peekToken: function() {=0A=
    if (this.tokens.length =3D=3D=3D 0) {=0A=
      throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', =
this.text);=0A=
    }=0A=
    return this.tokens[0];=0A=
  },=0A=
=0A=
  peek: function(e1, e2, e3, e4) {=0A=
    return this.peekAhead(0, e1, e2, e3, e4);=0A=
  },=0A=
=0A=
  peekAhead: function(i, e1, e2, e3, e4) {=0A=
    if (this.tokens.length &gt; i) {=0A=
      var token =3D this.tokens[i];=0A=
      var t =3D token.text;=0A=
      if (t =3D=3D=3D e1 || t =3D=3D=3D e2 || t =3D=3D=3D e3 || t =
=3D=3D=3D e4 ||=0A=
          (!e1 &amp;&amp; !e2 &amp;&amp; !e3 &amp;&amp; !e4)) {=0A=
        return token;=0A=
      }=0A=
    }=0A=
    return false;=0A=
  },=0A=
=0A=
  expect: function(e1, e2, e3, e4) {=0A=
    var token =3D this.peek(e1, e2, e3, e4);=0A=
    if (token) {=0A=
      this.tokens.shift();=0A=
      return token;=0A=
    }=0A=
    return false;=0A=
  },=0A=
=0A=
  selfReferential: {=0A=
    'this': {type: AST.ThisExpression },=0A=
    '$locals': {type: AST.LocalsExpression }=0A=
  }=0A=
};=0A=
=0A=
function ifDefined(v, d) {=0A=
  return typeof v !=3D=3D 'undefined' ? v : d;=0A=
}=0A=
=0A=
function plusFn(l, r) {=0A=
  if (typeof l =3D=3D=3D 'undefined') return r;=0A=
  if (typeof r =3D=3D=3D 'undefined') return l;=0A=
  return l + r;=0A=
}=0A=
=0A=
function isStateless($filter, filterName) {=0A=
  var fn =3D $filter(filterName);=0A=
  return !fn.$stateful;=0A=
}=0A=
=0A=
var PURITY_ABSOLUTE =3D 1;=0A=
var PURITY_RELATIVE =3D 2;=0A=
=0A=
// Detect nodes which could depend on non-shallow state of objects=0A=
function isPure(node, parentIsPure) {=0A=
  switch (node.type) {=0A=
    // Computed members might invoke a stateful toString()=0A=
    case AST.MemberExpression:=0A=
      if (node.computed) {=0A=
        return false;=0A=
      }=0A=
      break;=0A=
=0A=
    // Unary always convert to primative=0A=
    case AST.UnaryExpression:=0A=
      return PURITY_ABSOLUTE;=0A=
=0A=
    // The binary + operator can invoke a stateful toString().=0A=
    case AST.BinaryExpression:=0A=
      return node.operator !=3D=3D '+' ? PURITY_ABSOLUTE : false;=0A=
=0A=
    // Functions / filters probably read state from within objects=0A=
    case AST.CallExpression:=0A=
      return false;=0A=
  }=0A=
=0A=
  return (undefined =3D=3D=3D parentIsPure) ? PURITY_RELATIVE : =
parentIsPure;=0A=
}=0A=
=0A=
function findConstantAndWatchExpressions(ast, $filter, parentIsPure) {=0A=
  var allConstants;=0A=
  var argsToWatch;=0A=
  var isStatelessFilter;=0A=
=0A=
  var astIsPure =3D ast.isPure =3D isPure(ast, parentIsPure);=0A=
=0A=
  switch (ast.type) {=0A=
  case AST.Program:=0A=
    allConstants =3D true;=0A=
    forEach(ast.body, function(expr) {=0A=
      findConstantAndWatchExpressions(expr.expression, $filter, =
astIsPure);=0A=
      allConstants =3D allConstants &amp;&amp; expr.expression.constant;=0A=
    });=0A=
    ast.constant =3D allConstants;=0A=
    break;=0A=
  case AST.Literal:=0A=
    ast.constant =3D true;=0A=
    ast.toWatch =3D [];=0A=
    break;=0A=
  case AST.UnaryExpression:=0A=
    findConstantAndWatchExpressions(ast.argument, $filter, astIsPure);=0A=
    ast.constant =3D ast.argument.constant;=0A=
    ast.toWatch =3D ast.argument.toWatch;=0A=
    break;=0A=
  case AST.BinaryExpression:=0A=
    findConstantAndWatchExpressions(ast.left, $filter, astIsPure);=0A=
    findConstantAndWatchExpressions(ast.right, $filter, astIsPure);=0A=
    ast.constant =3D ast.left.constant &amp;&amp; ast.right.constant;=0A=
    ast.toWatch =3D ast.left.toWatch.concat(ast.right.toWatch);=0A=
    break;=0A=
  case AST.LogicalExpression:=0A=
    findConstantAndWatchExpressions(ast.left, $filter, astIsPure);=0A=
    findConstantAndWatchExpressions(ast.right, $filter, astIsPure);=0A=
    ast.constant =3D ast.left.constant &amp;&amp; ast.right.constant;=0A=
    ast.toWatch =3D ast.constant ? [] : [ast];=0A=
    break;=0A=
  case AST.ConditionalExpression:=0A=
    findConstantAndWatchExpressions(ast.test, $filter, astIsPure);=0A=
    findConstantAndWatchExpressions(ast.alternate, $filter, astIsPure);=0A=
    findConstantAndWatchExpressions(ast.consequent, $filter, astIsPure);=0A=
    ast.constant =3D ast.test.constant &amp;&amp; ast.alternate.constant =
&amp;&amp; ast.consequent.constant;=0A=
    ast.toWatch =3D ast.constant ? [] : [ast];=0A=
    break;=0A=
  case AST.Identifier:=0A=
    ast.constant =3D false;=0A=
    ast.toWatch =3D [ast];=0A=
    break;=0A=
  case AST.MemberExpression:=0A=
    findConstantAndWatchExpressions(ast.object, $filter, astIsPure);=0A=
    if (ast.computed) {=0A=
      findConstantAndWatchExpressions(ast.property, $filter, astIsPure);=0A=
    }=0A=
    ast.constant =3D ast.object.constant &amp;&amp; (!ast.computed || =
ast.property.constant);=0A=
    ast.toWatch =3D [ast];=0A=
    break;=0A=
  case AST.CallExpression:=0A=
    isStatelessFilter =3D ast.filter ? isStateless($filter, =
ast.callee.name) : false;=0A=
    allConstants =3D isStatelessFilter;=0A=
    argsToWatch =3D [];=0A=
    forEach(ast.arguments, function(expr) {=0A=
      findConstantAndWatchExpressions(expr, $filter, astIsPure);=0A=
      allConstants =3D allConstants &amp;&amp; expr.constant;=0A=
      if (!expr.constant) {=0A=
        argsToWatch.push.apply(argsToWatch, expr.toWatch);=0A=
      }=0A=
    });=0A=
    ast.constant =3D allConstants;=0A=
    ast.toWatch =3D isStatelessFilter ? argsToWatch : [ast];=0A=
    break;=0A=
  case AST.AssignmentExpression:=0A=
    findConstantAndWatchExpressions(ast.left, $filter, astIsPure);=0A=
    findConstantAndWatchExpressions(ast.right, $filter, astIsPure);=0A=
    ast.constant =3D ast.left.constant &amp;&amp; ast.right.constant;=0A=
    ast.toWatch =3D [ast];=0A=
    break;=0A=
  case AST.ArrayExpression:=0A=
    allConstants =3D true;=0A=
    argsToWatch =3D [];=0A=
    forEach(ast.elements, function(expr) {=0A=
      findConstantAndWatchExpressions(expr, $filter, astIsPure);=0A=
      allConstants =3D allConstants &amp;&amp; expr.constant;=0A=
      if (!expr.constant) {=0A=
        argsToWatch.push.apply(argsToWatch, expr.toWatch);=0A=
      }=0A=
    });=0A=
    ast.constant =3D allConstants;=0A=
    ast.toWatch =3D argsToWatch;=0A=
    break;=0A=
  case AST.ObjectExpression:=0A=
    allConstants =3D true;=0A=
    argsToWatch =3D [];=0A=
    forEach(ast.properties, function(property) {=0A=
      findConstantAndWatchExpressions(property.value, $filter, =
astIsPure);=0A=
      allConstants =3D allConstants &amp;&amp; property.value.constant =
&amp;&amp; !property.computed;=0A=
      if (!property.value.constant) {=0A=
        argsToWatch.push.apply(argsToWatch, property.value.toWatch);=0A=
      }=0A=
      if (property.computed) {=0A=
        findConstantAndWatchExpressions(property.key, $filter, =
astIsPure);=0A=
        if (!property.key.constant) {=0A=
          argsToWatch.push.apply(argsToWatch, property.key.toWatch);=0A=
        }=0A=
      }=0A=
=0A=
    });=0A=
    ast.constant =3D allConstants;=0A=
    ast.toWatch =3D argsToWatch;=0A=
    break;=0A=
  case AST.ThisExpression:=0A=
    ast.constant =3D false;=0A=
    ast.toWatch =3D [];=0A=
    break;=0A=
  case AST.LocalsExpression:=0A=
    ast.constant =3D false;=0A=
    ast.toWatch =3D [];=0A=
    break;=0A=
  }=0A=
}=0A=
=0A=
function getInputs(body) {=0A=
  if (body.length !=3D=3D 1) return;=0A=
  var lastExpression =3D body[0].expression;=0A=
  var candidate =3D lastExpression.toWatch;=0A=
  if (candidate.length !=3D=3D 1) return candidate;=0A=
  return candidate[0] !=3D=3D lastExpression ? candidate : undefined;=0A=
}=0A=
=0A=
function isAssignable(ast) {=0A=
  return ast.type =3D=3D=3D AST.Identifier || ast.type =3D=3D=3D =
AST.MemberExpression;=0A=
}=0A=
=0A=
function assignableAST(ast) {=0A=
  if (ast.body.length =3D=3D=3D 1 &amp;&amp; =
isAssignable(ast.body[0].expression)) {=0A=
    return {type: AST.AssignmentExpression, left: =
ast.body[0].expression, right: {type: AST.NGValueParameter}, operator: =
'=3D'};=0A=
  }=0A=
}=0A=
=0A=
function isLiteral(ast) {=0A=
  return ast.body.length =3D=3D=3D 0 ||=0A=
      ast.body.length =3D=3D=3D 1 &amp;&amp; (=0A=
      ast.body[0].expression.type =3D=3D=3D AST.Literal ||=0A=
      ast.body[0].expression.type =3D=3D=3D AST.ArrayExpression ||=0A=
      ast.body[0].expression.type =3D=3D=3D AST.ObjectExpression);=0A=
}=0A=
=0A=
function isConstant(ast) {=0A=
  return ast.constant;=0A=
}=0A=
=0A=
function ASTCompiler($filter) {=0A=
  this.$filter =3D $filter;=0A=
}=0A=
=0A=
ASTCompiler.prototype =3D {=0A=
  compile: function(ast) {=0A=
    var self =3D this;=0A=
    this.state =3D {=0A=
      nextId: 0,=0A=
      filters: {},=0A=
      fn: {vars: [], body: [], own: {}},=0A=
      assign: {vars: [], body: [], own: {}},=0A=
      inputs: []=0A=
    };=0A=
    findConstantAndWatchExpressions(ast, self.$filter);=0A=
    var extra =3D '';=0A=
    var assignable;=0A=
    this.stage =3D 'assign';=0A=
    if ((assignable =3D assignableAST(ast))) {=0A=
      this.state.computing =3D 'assign';=0A=
      var result =3D this.nextId();=0A=
      this.recurse(assignable, result);=0A=
      this.return_(result);=0A=
      extra =3D 'fn.assign=3D' + this.generateFunction('assign', =
's,v,l');=0A=
    }=0A=
    var toWatch =3D getInputs(ast.body);=0A=
    self.stage =3D 'inputs';=0A=
    forEach(toWatch, function(watch, key) {=0A=
      var fnKey =3D 'fn' + key;=0A=
      self.state[fnKey] =3D {vars: [], body: [], own: {}};=0A=
      self.state.computing =3D fnKey;=0A=
      var intoId =3D self.nextId();=0A=
      self.recurse(watch, intoId);=0A=
      self.return_(intoId);=0A=
      self.state.inputs.push({name: fnKey, isPure: watch.isPure});=0A=
      watch.watchId =3D key;=0A=
    });=0A=
    this.state.computing =3D 'fn';=0A=
    this.stage =3D 'main';=0A=
    this.recurse(ast);=0A=
    var fnString =3D=0A=
      // The build and minification steps remove the string "use strict" =
from the code, but this is done using a regex.=0A=
      // This is a workaround for this until we do a better job at only =
removing the prefix only when we should.=0A=
      '"' + this.USE + ' ' + this.STRICT + '";\n' +=0A=
      this.filterPrefix() +=0A=
      'var fn=3D' + this.generateFunction('fn', 's,l,a,i') +=0A=
      extra +=0A=
      this.watchFns() +=0A=
      'return fn;';=0A=
=0A=
    // eslint-disable-next-line no-new-func=0A=
    var fn =3D (new Function('$filter',=0A=
        'getStringValue',=0A=
        'ifDefined',=0A=
        'plus',=0A=
        fnString))(=0A=
          this.$filter,=0A=
          getStringValue,=0A=
          ifDefined,=0A=
          plusFn);=0A=
    this.state =3D this.stage =3D undefined;=0A=
    return fn;=0A=
  },=0A=
=0A=
  USE: 'use',=0A=
=0A=
  STRICT: 'strict',=0A=
=0A=
  watchFns: function() {=0A=
    var result =3D [];=0A=
    var inputs =3D this.state.inputs;=0A=
    var self =3D this;=0A=
    forEach(inputs, function(input) {=0A=
      result.push('var ' + input.name + '=3D' + =
self.generateFunction(input.name, 's'));=0A=
      if (input.isPure) {=0A=
        result.push(input.name, '.isPure=3D' + =
JSON.stringify(input.isPure) + ';');=0A=
      }=0A=
    });=0A=
    if (inputs.length) {=0A=
      result.push('fn.inputs=3D[' + inputs.map(function(i) { return =
i.name; }).join(',') + '];');=0A=
    }=0A=
    return result.join('');=0A=
  },=0A=
=0A=
  generateFunction: function(name, params) {=0A=
    return 'function(' + params + '){' +=0A=
        this.varsPrefix(name) +=0A=
        this.body(name) +=0A=
        '};';=0A=
  },=0A=
=0A=
  filterPrefix: function() {=0A=
    var parts =3D [];=0A=
    var self =3D this;=0A=
    forEach(this.state.filters, function(id, filter) {=0A=
      parts.push(id + '=3D$filter(' + self.escape(filter) + ')');=0A=
    });=0A=
    if (parts.length) return 'var ' + parts.join(',') + ';';=0A=
    return '';=0A=
  },=0A=
=0A=
  varsPrefix: function(section) {=0A=
    return this.state[section].vars.length ? 'var ' + =
this.state[section].vars.join(',') + ';' : '';=0A=
  },=0A=
=0A=
  body: function(section) {=0A=
    return this.state[section].body.join('');=0A=
  },=0A=
=0A=
  recurse: function(ast, intoId, nameId, recursionFn, create, =
skipWatchIdCheck) {=0A=
    var left, right, self =3D this, args, expression, computed;=0A=
    recursionFn =3D recursionFn || noop;=0A=
    if (!skipWatchIdCheck &amp;&amp; isDefined(ast.watchId)) {=0A=
      intoId =3D intoId || this.nextId();=0A=
      this.if_('i',=0A=
        this.lazyAssign(intoId, this.computedMember('i', ast.watchId)),=0A=
        this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true)=0A=
      );=0A=
      return;=0A=
    }=0A=
    switch (ast.type) {=0A=
    case AST.Program:=0A=
      forEach(ast.body, function(expression, pos) {=0A=
        self.recurse(expression.expression, undefined, undefined, =
function(expr) { right =3D expr; });=0A=
        if (pos !=3D=3D ast.body.length - 1) {=0A=
          self.current().body.push(right, ';');=0A=
        } else {=0A=
          self.return_(right);=0A=
        }=0A=
      });=0A=
      break;=0A=
    case AST.Literal:=0A=
      expression =3D this.escape(ast.value);=0A=
      this.assign(intoId, expression);=0A=
      recursionFn(intoId || expression);=0A=
      break;=0A=
    case AST.UnaryExpression:=0A=
      this.recurse(ast.argument, undefined, undefined, function(expr) { =
right =3D expr; });=0A=
      expression =3D ast.operator + '(' + this.ifDefined(right, 0) + ')';=0A=
      this.assign(intoId, expression);=0A=
      recursionFn(expression);=0A=
      break;=0A=
    case AST.BinaryExpression:=0A=
      this.recurse(ast.left, undefined, undefined, function(expr) { left =
=3D expr; });=0A=
      this.recurse(ast.right, undefined, undefined, function(expr) { =
right =3D expr; });=0A=
      if (ast.operator =3D=3D=3D '+') {=0A=
        expression =3D this.plus(left, right);=0A=
      } else if (ast.operator =3D=3D=3D '-') {=0A=
        expression =3D this.ifDefined(left, 0) + ast.operator + =
this.ifDefined(right, 0);=0A=
      } else {=0A=
        expression =3D '(' + left + ')' + ast.operator + '(' + right + =
')';=0A=
      }=0A=
      this.assign(intoId, expression);=0A=
      recursionFn(expression);=0A=
      break;=0A=
    case AST.LogicalExpression:=0A=
      intoId =3D intoId || this.nextId();=0A=
      self.recurse(ast.left, intoId);=0A=
      self.if_(ast.operator =3D=3D=3D '&amp;&amp;' ? intoId : =
self.not(intoId), self.lazyRecurse(ast.right, intoId));=0A=
      recursionFn(intoId);=0A=
      break;=0A=
    case AST.ConditionalExpression:=0A=
      intoId =3D intoId || this.nextId();=0A=
      self.recurse(ast.test, intoId);=0A=
      self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), =
self.lazyRecurse(ast.consequent, intoId));=0A=
      recursionFn(intoId);=0A=
      break;=0A=
    case AST.Identifier:=0A=
      intoId =3D intoId || this.nextId();=0A=
      if (nameId) {=0A=
        nameId.context =3D self.stage =3D=3D=3D 'inputs' ? 's' : =
this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + =
'?l:s');=0A=
        nameId.computed =3D false;=0A=
        nameId.name =3D ast.name;=0A=
      }=0A=
      self.if_(self.stage =3D=3D=3D 'inputs' || =
self.not(self.getHasOwnProperty('l', ast.name)),=0A=
        function() {=0A=
          self.if_(self.stage =3D=3D=3D 'inputs' || 's', function() {=0A=
            if (create &amp;&amp; create !=3D=3D 1) {=0A=
              self.if_(=0A=
                self.isNull(self.nonComputedMember('s', ast.name)),=0A=
                self.lazyAssign(self.nonComputedMember('s', ast.name), =
'{}'));=0A=
            }=0A=
            self.assign(intoId, self.nonComputedMember('s', ast.name));=0A=
          });=0A=
        }, intoId &amp;&amp; self.lazyAssign(intoId, =
self.nonComputedMember('l', ast.name))=0A=
        );=0A=
      recursionFn(intoId);=0A=
      break;=0A=
    case AST.MemberExpression:=0A=
      left =3D nameId &amp;&amp; (nameId.context =3D this.nextId()) || =
this.nextId();=0A=
      intoId =3D intoId || this.nextId();=0A=
      self.recurse(ast.object, left, undefined, function() {=0A=
        self.if_(self.notNull(left), function() {=0A=
          if (ast.computed) {=0A=
            right =3D self.nextId();=0A=
            self.recurse(ast.property, right);=0A=
            self.getStringValue(right);=0A=
            if (create &amp;&amp; create !=3D=3D 1) {=0A=
              self.if_(self.not(self.computedMember(left, right)), =
self.lazyAssign(self.computedMember(left, right), '{}'));=0A=
            }=0A=
            expression =3D self.computedMember(left, right);=0A=
            self.assign(intoId, expression);=0A=
            if (nameId) {=0A=
              nameId.computed =3D true;=0A=
              nameId.name =3D right;=0A=
            }=0A=
          } else {=0A=
            if (create &amp;&amp; create !=3D=3D 1) {=0A=
              self.if_(self.isNull(self.nonComputedMember(left, =
ast.property.name)), self.lazyAssign(self.nonComputedMember(left, =
ast.property.name), '{}'));=0A=
            }=0A=
            expression =3D self.nonComputedMember(left, =
ast.property.name);=0A=
            self.assign(intoId, expression);=0A=
            if (nameId) {=0A=
              nameId.computed =3D false;=0A=
              nameId.name =3D ast.property.name;=0A=
            }=0A=
          }=0A=
        }, function() {=0A=
          self.assign(intoId, 'undefined');=0A=
        });=0A=
        recursionFn(intoId);=0A=
      }, !!create);=0A=
      break;=0A=
    case AST.CallExpression:=0A=
      intoId =3D intoId || this.nextId();=0A=
      if (ast.filter) {=0A=
        right =3D self.filter(ast.callee.name);=0A=
        args =3D [];=0A=
        forEach(ast.arguments, function(expr) {=0A=
          var argument =3D self.nextId();=0A=
          self.recurse(expr, argument);=0A=
          args.push(argument);=0A=
        });=0A=
        expression =3D right + '(' + args.join(',') + ')';=0A=
        self.assign(intoId, expression);=0A=
        recursionFn(intoId);=0A=
      } else {=0A=
        right =3D self.nextId();=0A=
        left =3D {};=0A=
        args =3D [];=0A=
        self.recurse(ast.callee, right, left, function() {=0A=
          self.if_(self.notNull(right), function() {=0A=
            forEach(ast.arguments, function(expr) {=0A=
              self.recurse(expr, ast.constant ? undefined : =
self.nextId(), undefined, function(argument) {=0A=
                args.push(argument);=0A=
              });=0A=
            });=0A=
            if (left.name) {=0A=
              expression =3D self.member(left.context, left.name, =
left.computed) + '(' + args.join(',') + ')';=0A=
            } else {=0A=
              expression =3D right + '(' + args.join(',') + ')';=0A=
            }=0A=
            self.assign(intoId, expression);=0A=
          }, function() {=0A=
            self.assign(intoId, 'undefined');=0A=
          });=0A=
          recursionFn(intoId);=0A=
        });=0A=
      }=0A=
      break;=0A=
    case AST.AssignmentExpression:=0A=
      right =3D this.nextId();=0A=
      left =3D {};=0A=
      this.recurse(ast.left, undefined, left, function() {=0A=
        self.if_(self.notNull(left.context), function() {=0A=
          self.recurse(ast.right, right);=0A=
          expression =3D self.member(left.context, left.name, =
left.computed) + ast.operator + right;=0A=
          self.assign(intoId, expression);=0A=
          recursionFn(intoId || expression);=0A=
        });=0A=
      }, 1);=0A=
      break;=0A=
    case AST.ArrayExpression:=0A=
      args =3D [];=0A=
      forEach(ast.elements, function(expr) {=0A=
        self.recurse(expr, ast.constant ? undefined : self.nextId(), =
undefined, function(argument) {=0A=
          args.push(argument);=0A=
        });=0A=
      });=0A=
      expression =3D '[' + args.join(',') + ']';=0A=
      this.assign(intoId, expression);=0A=
      recursionFn(intoId || expression);=0A=
      break;=0A=
    case AST.ObjectExpression:=0A=
      args =3D [];=0A=
      computed =3D false;=0A=
      forEach(ast.properties, function(property) {=0A=
        if (property.computed) {=0A=
          computed =3D true;=0A=
        }=0A=
      });=0A=
      if (computed) {=0A=
        intoId =3D intoId || this.nextId();=0A=
        this.assign(intoId, '{}');=0A=
        forEach(ast.properties, function(property) {=0A=
          if (property.computed) {=0A=
            left =3D self.nextId();=0A=
            self.recurse(property.key, left);=0A=
          } else {=0A=
            left =3D property.key.type =3D=3D=3D AST.Identifier ?=0A=
                       property.key.name :=0A=
                       ('' + property.key.value);=0A=
          }=0A=
          right =3D self.nextId();=0A=
          self.recurse(property.value, right);=0A=
          self.assign(self.member(intoId, left, property.computed), =
right);=0A=
        });=0A=
      } else {=0A=
        forEach(ast.properties, function(property) {=0A=
          self.recurse(property.value, ast.constant ? undefined : =
self.nextId(), undefined, function(expr) {=0A=
            args.push(self.escape(=0A=
                property.key.type =3D=3D=3D AST.Identifier ? =
property.key.name :=0A=
                  ('' + property.key.value)) +=0A=
                ':' + expr);=0A=
          });=0A=
        });=0A=
        expression =3D '{' + args.join(',') + '}';=0A=
        this.assign(intoId, expression);=0A=
      }=0A=
      recursionFn(intoId || expression);=0A=
      break;=0A=
    case AST.ThisExpression:=0A=
      this.assign(intoId, 's');=0A=
      recursionFn(intoId || 's');=0A=
      break;=0A=
    case AST.LocalsExpression:=0A=
      this.assign(intoId, 'l');=0A=
      recursionFn(intoId || 'l');=0A=
      break;=0A=
    case AST.NGValueParameter:=0A=
      this.assign(intoId, 'v');=0A=
      recursionFn(intoId || 'v');=0A=
      break;=0A=
    }=0A=
  },=0A=
=0A=
  getHasOwnProperty: function(element, property) {=0A=
    var key =3D element + '.' + property;=0A=
    var own =3D this.current().own;=0A=
    if (!own.hasOwnProperty(key)) {=0A=
      own[key] =3D this.nextId(false, element + '&amp;&amp;(' + =
this.escape(property) + ' in ' + element + ')');=0A=
    }=0A=
    return own[key];=0A=
  },=0A=
=0A=
  assign: function(id, value) {=0A=
    if (!id) return;=0A=
    this.current().body.push(id, '=3D', value, ';');=0A=
    return id;=0A=
  },=0A=
=0A=
  filter: function(filterName) {=0A=
    if (!this.state.filters.hasOwnProperty(filterName)) {=0A=
      this.state.filters[filterName] =3D this.nextId(true);=0A=
    }=0A=
    return this.state.filters[filterName];=0A=
  },=0A=
=0A=
  ifDefined: function(id, defaultValue) {=0A=
    return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';=0A=
  },=0A=
=0A=
  plus: function(left, right) {=0A=
    return 'plus(' + left + ',' + right + ')';=0A=
  },=0A=
=0A=
  return_: function(id) {=0A=
    this.current().body.push('return ', id, ';');=0A=
  },=0A=
=0A=
  if_: function(test, alternate, consequent) {=0A=
    if (test =3D=3D=3D true) {=0A=
      alternate();=0A=
    } else {=0A=
      var body =3D this.current().body;=0A=
      body.push('if(', test, '){');=0A=
      alternate();=0A=
      body.push('}');=0A=
      if (consequent) {=0A=
        body.push('else{');=0A=
        consequent();=0A=
        body.push('}');=0A=
      }=0A=
    }=0A=
  },=0A=
=0A=
  not: function(expression) {=0A=
    return '!(' + expression + ')';=0A=
  },=0A=
=0A=
  isNull: function(expression) {=0A=
    return expression + '=3D=3Dnull';=0A=
  },=0A=
=0A=
  notNull: function(expression) {=0A=
    return expression + '!=3Dnull';=0A=
  },=0A=
=0A=
  nonComputedMember: function(left, right) {=0A=
    var SAFE_IDENTIFIER =3D /^[$_a-zA-Z][$_a-zA-Z0-9]*$/;=0A=
    var UNSAFE_CHARACTERS =3D /[^$_a-zA-Z0-9]/g;=0A=
    if (SAFE_IDENTIFIER.test(right)) {=0A=
      return left + '.' + right;=0A=
    } else {=0A=
      return left  + '["' + right.replace(UNSAFE_CHARACTERS, =
this.stringEscapeFn) + '"]';=0A=
    }=0A=
  },=0A=
=0A=
  computedMember: function(left, right) {=0A=
    return left + '[' + right + ']';=0A=
  },=0A=
=0A=
  member: function(left, right, computed) {=0A=
    if (computed) return this.computedMember(left, right);=0A=
    return this.nonComputedMember(left, right);=0A=
  },=0A=
=0A=
  getStringValue: function(item) {=0A=
    this.assign(item, 'getStringValue(' + item + ')');=0A=
  },=0A=
=0A=
  lazyRecurse: function(ast, intoId, nameId, recursionFn, create, =
skipWatchIdCheck) {=0A=
    var self =3D this;=0A=
    return function() {=0A=
      self.recurse(ast, intoId, nameId, recursionFn, create, =
skipWatchIdCheck);=0A=
    };=0A=
  },=0A=
=0A=
  lazyAssign: function(id, value) {=0A=
    var self =3D this;=0A=
    return function() {=0A=
      self.assign(id, value);=0A=
    };=0A=
  },=0A=
=0A=
  stringEscapeRegex: /[^ a-zA-Z0-9]/g,=0A=
=0A=
  stringEscapeFn: function(c) {=0A=
    return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);=0A=
  },=0A=
=0A=
  escape: function(value) {=0A=
    if (isString(value)) return '\'' + =
value.replace(this.stringEscapeRegex, this.stringEscapeFn) + '\'';=0A=
    if (isNumber(value)) return value.toString();=0A=
    if (value =3D=3D=3D true) return 'true';=0A=
    if (value =3D=3D=3D false) return 'false';=0A=
    if (value =3D=3D=3D null) return 'null';=0A=
    if (typeof value =3D=3D=3D 'undefined') return 'undefined';=0A=
=0A=
    throw $parseMinErr('esc', 'IMPOSSIBLE');=0A=
  },=0A=
=0A=
  nextId: function(skip, init) {=0A=
    var id =3D 'v' + (this.state.nextId++);=0A=
    if (!skip) {=0A=
      this.current().vars.push(id + (init ? '=3D' + init : ''));=0A=
    }=0A=
    return id;=0A=
  },=0A=
=0A=
  current: function() {=0A=
    return this.state[this.state.computing];=0A=
  }=0A=
};=0A=
=0A=
=0A=
function ASTInterpreter($filter) {=0A=
  this.$filter =3D $filter;=0A=
}=0A=
=0A=
ASTInterpreter.prototype =3D {=0A=
  compile: function(ast) {=0A=
    var self =3D this;=0A=
    findConstantAndWatchExpressions(ast, self.$filter);=0A=
    var assignable;=0A=
    var assign;=0A=
    if ((assignable =3D assignableAST(ast))) {=0A=
      assign =3D this.recurse(assignable);=0A=
    }=0A=
    var toWatch =3D getInputs(ast.body);=0A=
    var inputs;=0A=
    if (toWatch) {=0A=
      inputs =3D [];=0A=
      forEach(toWatch, function(watch, key) {=0A=
        var input =3D self.recurse(watch);=0A=
        input.isPure =3D watch.isPure;=0A=
        watch.input =3D input;=0A=
        inputs.push(input);=0A=
        watch.watchId =3D key;=0A=
      });=0A=
    }=0A=
    var expressions =3D [];=0A=
    forEach(ast.body, function(expression) {=0A=
      expressions.push(self.recurse(expression.expression));=0A=
    });=0A=
    var fn =3D ast.body.length =3D=3D=3D 0 ? noop :=0A=
             ast.body.length =3D=3D=3D 1 ? expressions[0] :=0A=
             function(scope, locals) {=0A=
               var lastValue;=0A=
               forEach(expressions, function(exp) {=0A=
                 lastValue =3D exp(scope, locals);=0A=
               });=0A=
               return lastValue;=0A=
             };=0A=
    if (assign) {=0A=
      fn.assign =3D function(scope, value, locals) {=0A=
        return assign(scope, locals, value);=0A=
      };=0A=
    }=0A=
    if (inputs) {=0A=
      fn.inputs =3D inputs;=0A=
    }=0A=
    return fn;=0A=
  },=0A=
=0A=
  recurse: function(ast, context, create) {=0A=
    var left, right, self =3D this, args;=0A=
    if (ast.input) {=0A=
      return this.inputs(ast.input, ast.watchId);=0A=
    }=0A=
    switch (ast.type) {=0A=
    case AST.Literal:=0A=
      return this.value(ast.value, context);=0A=
    case AST.UnaryExpression:=0A=
      right =3D this.recurse(ast.argument);=0A=
      return this['unary' + ast.operator](right, context);=0A=
    case AST.BinaryExpression:=0A=
      left =3D this.recurse(ast.left);=0A=
      right =3D this.recurse(ast.right);=0A=
      return this['binary' + ast.operator](left, right, context);=0A=
    case AST.LogicalExpression:=0A=
      left =3D this.recurse(ast.left);=0A=
      right =3D this.recurse(ast.right);=0A=
      return this['binary' + ast.operator](left, right, context);=0A=
    case AST.ConditionalExpression:=0A=
      return this['ternary?:'](=0A=
        this.recurse(ast.test),=0A=
        this.recurse(ast.alternate),=0A=
        this.recurse(ast.consequent),=0A=
        context=0A=
      );=0A=
    case AST.Identifier:=0A=
      return self.identifier(ast.name, context, create);=0A=
    case AST.MemberExpression:=0A=
      left =3D this.recurse(ast.object, false, !!create);=0A=
      if (!ast.computed) {=0A=
        right =3D ast.property.name;=0A=
      }=0A=
      if (ast.computed) right =3D this.recurse(ast.property);=0A=
      return ast.computed ?=0A=
        this.computedMember(left, right, context, create) :=0A=
        this.nonComputedMember(left, right, context, create);=0A=
    case AST.CallExpression:=0A=
      args =3D [];=0A=
      forEach(ast.arguments, function(expr) {=0A=
        args.push(self.recurse(expr));=0A=
      });=0A=
      if (ast.filter) right =3D this.$filter(ast.callee.name);=0A=
      if (!ast.filter) right =3D this.recurse(ast.callee, true);=0A=
      return ast.filter ?=0A=
        function(scope, locals, assign, inputs) {=0A=
          var values =3D [];=0A=
          for (var i =3D 0; i &lt; args.length; ++i) {=0A=
            values.push(args[i](scope, locals, assign, inputs));=0A=
          }=0A=
          var value =3D right.apply(undefined, values, inputs);=0A=
          return context ? {context: undefined, name: undefined, value: =
value} : value;=0A=
        } :=0A=
        function(scope, locals, assign, inputs) {=0A=
          var rhs =3D right(scope, locals, assign, inputs);=0A=
          var value;=0A=
          if (rhs.value !=3D null) {=0A=
            var values =3D [];=0A=
            for (var i =3D 0; i &lt; args.length; ++i) {=0A=
              values.push(args[i](scope, locals, assign, inputs));=0A=
            }=0A=
            value =3D rhs.value.apply(rhs.context, values);=0A=
          }=0A=
          return context ? {value: value} : value;=0A=
        };=0A=
    case AST.AssignmentExpression:=0A=
      left =3D this.recurse(ast.left, true, 1);=0A=
      right =3D this.recurse(ast.right);=0A=
      return function(scope, locals, assign, inputs) {=0A=
        var lhs =3D left(scope, locals, assign, inputs);=0A=
        var rhs =3D right(scope, locals, assign, inputs);=0A=
        lhs.context[lhs.name] =3D rhs;=0A=
        return context ? {value: rhs} : rhs;=0A=
      };=0A=
    case AST.ArrayExpression:=0A=
      args =3D [];=0A=
      forEach(ast.elements, function(expr) {=0A=
        args.push(self.recurse(expr));=0A=
      });=0A=
      return function(scope, locals, assign, inputs) {=0A=
        var value =3D [];=0A=
        for (var i =3D 0; i &lt; args.length; ++i) {=0A=
          value.push(args[i](scope, locals, assign, inputs));=0A=
        }=0A=
        return context ? {value: value} : value;=0A=
      };=0A=
    case AST.ObjectExpression:=0A=
      args =3D [];=0A=
      forEach(ast.properties, function(property) {=0A=
        if (property.computed) {=0A=
          args.push({key: self.recurse(property.key),=0A=
                     computed: true,=0A=
                     value: self.recurse(property.value)=0A=
          });=0A=
        } else {=0A=
          args.push({key: property.key.type =3D=3D=3D AST.Identifier ?=0A=
                          property.key.name :=0A=
                          ('' + property.key.value),=0A=
                     computed: false,=0A=
                     value: self.recurse(property.value)=0A=
          });=0A=
        }=0A=
      });=0A=
      return function(scope, locals, assign, inputs) {=0A=
        var value =3D {};=0A=
        for (var i =3D 0; i &lt; args.length; ++i) {=0A=
          if (args[i].computed) {=0A=
            value[args[i].key(scope, locals, assign, inputs)] =3D =
args[i].value(scope, locals, assign, inputs);=0A=
          } else {=0A=
            value[args[i].key] =3D args[i].value(scope, locals, assign, =
inputs);=0A=
          }=0A=
        }=0A=
        return context ? {value: value} : value;=0A=
      };=0A=
    case AST.ThisExpression:=0A=
      return function(scope) {=0A=
        return context ? {value: scope} : scope;=0A=
      };=0A=
    case AST.LocalsExpression:=0A=
      return function(scope, locals) {=0A=
        return context ? {value: locals} : locals;=0A=
      };=0A=
    case AST.NGValueParameter:=0A=
      return function(scope, locals, assign) {=0A=
        return context ? {value: assign} : assign;=0A=
      };=0A=
    }=0A=
  },=0A=
=0A=
  'unary+': function(argument, context) {=0A=
    return function(scope, locals, assign, inputs) {=0A=
      var arg =3D argument(scope, locals, assign, inputs);=0A=
      if (isDefined(arg)) {=0A=
        arg =3D +arg;=0A=
      } else {=0A=
        arg =3D 0;=0A=
      }=0A=
      return context ? {value: arg} : arg;=0A=
    };=0A=
  },=0A=
  'unary-': function(argument, context) {=0A=
    return function(scope, locals, assign, inputs) {=0A=
      var arg =3D argument(scope, locals, assign, inputs);=0A=
      if (isDefined(arg)) {=0A=
        arg =3D -arg;=0A=
      } else {=0A=
        arg =3D -0;=0A=
      }=0A=
      return context ? {value: arg} : arg;=0A=
    };=0A=
  },=0A=
  'unary!': function(argument, context) {=0A=
    return function(scope, locals, assign, inputs) {=0A=
      var arg =3D !argument(scope, locals, assign, inputs);=0A=
      return context ? {value: arg} : arg;=0A=
    };=0A=
  },=0A=
  'binary+': function(left, right, context) {=0A=
    return function(scope, locals, assign, inputs) {=0A=
      var lhs =3D left(scope, locals, assign, inputs);=0A=
      var rhs =3D right(scope, locals, assign, inputs);=0A=
      var arg =3D plusFn(lhs, rhs);=0A=
      return context ? {value: arg} : arg;=0A=
    };=0A=
  },=0A=
  'binary-': function(left, right, context) {=0A=
    return function(scope, locals, assign, inputs) {=0A=
      var lhs =3D left(scope, locals, assign, inputs);=0A=
      var rhs =3D right(scope, locals, assign, inputs);=0A=
      var arg =3D (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : =
0);=0A=
      return context ? {value: arg} : arg;=0A=
    };=0A=
  },=0A=
  'binary*': function(left, right, context) {=0A=
    return function(scope, locals, assign, inputs) {=0A=
      var arg =3D left(scope, locals, assign, inputs) * right(scope, =
locals, assign, inputs);=0A=
      return context ? {value: arg} : arg;=0A=
    };=0A=
  },=0A=
  'binary/': function(left, right, context) {=0A=
    return function(scope, locals, assign, inputs) {=0A=
      var arg =3D left(scope, locals, assign, inputs) / right(scope, =
locals, assign, inputs);=0A=
      return context ? {value: arg} : arg;=0A=
    };=0A=
  },=0A=
  'binary%': function(left, right, context) {=0A=
    return function(scope, locals, assign, inputs) {=0A=
      var arg =3D left(scope, locals, assign, inputs) % right(scope, =
locals, assign, inputs);=0A=
      return context ? {value: arg} : arg;=0A=
    };=0A=
  },=0A=
  'binary=3D=3D=3D': function(left, right, context) {=0A=
    return function(scope, locals, assign, inputs) {=0A=
      var arg =3D left(scope, locals, assign, inputs) =3D=3D=3D =
right(scope, locals, assign, inputs);=0A=
      return context ? {value: arg} : arg;=0A=
    };=0A=
  },=0A=
  'binary!=3D=3D': function(left, right, context) {=0A=
    return function(scope, locals, assign, inputs) {=0A=
      var arg =3D left(scope, locals, assign, inputs) !=3D=3D =
right(scope, locals, assign, inputs);=0A=
      return context ? {value: arg} : arg;=0A=
    };=0A=
  },=0A=
  'binary=3D=3D': function(left, right, context) {=0A=
    return function(scope, locals, assign, inputs) {=0A=
      // eslint-disable-next-line eqeqeq=0A=
      var arg =3D left(scope, locals, assign, inputs) =3D=3D =
right(scope, locals, assign, inputs);=0A=
      return context ? {value: arg} : arg;=0A=
    };=0A=
  },=0A=
  'binary!=3D': function(left, right, context) {=0A=
    return function(scope, locals, assign, inputs) {=0A=
      // eslint-disable-next-line eqeqeq=0A=
      var arg =3D left(scope, locals, assign, inputs) !=3D right(scope, =
locals, assign, inputs);=0A=
      return context ? {value: arg} : arg;=0A=
    };=0A=
  },=0A=
  'binary&lt;': function(left, right, context) {=0A=
    return function(scope, locals, assign, inputs) {=0A=
      var arg =3D left(scope, locals, assign, inputs) &lt; right(scope, =
locals, assign, inputs);=0A=
      return context ? {value: arg} : arg;=0A=
    };=0A=
  },=0A=
  'binary&gt;': function(left, right, context) {=0A=
    return function(scope, locals, assign, inputs) {=0A=
      var arg =3D left(scope, locals, assign, inputs) &gt; right(scope, =
locals, assign, inputs);=0A=
      return context ? {value: arg} : arg;=0A=
    };=0A=
  },=0A=
  'binary&lt;=3D': function(left, right, context) {=0A=
    return function(scope, locals, assign, inputs) {=0A=
      var arg =3D left(scope, locals, assign, inputs) &lt;=3D =
right(scope, locals, assign, inputs);=0A=
      return context ? {value: arg} : arg;=0A=
    };=0A=
  },=0A=
  'binary&gt;=3D': function(left, right, context) {=0A=
    return function(scope, locals, assign, inputs) {=0A=
      var arg =3D left(scope, locals, assign, inputs) &gt;=3D =
right(scope, locals, assign, inputs);=0A=
      return context ? {value: arg} : arg;=0A=
    };=0A=
  },=0A=
  'binary&amp;&amp;': function(left, right, context) {=0A=
    return function(scope, locals, assign, inputs) {=0A=
      var arg =3D left(scope, locals, assign, inputs) &amp;&amp; =
right(scope, locals, assign, inputs);=0A=
      return context ? {value: arg} : arg;=0A=
    };=0A=
  },=0A=
  'binary||': function(left, right, context) {=0A=
    return function(scope, locals, assign, inputs) {=0A=
      var arg =3D left(scope, locals, assign, inputs) || right(scope, =
locals, assign, inputs);=0A=
      return context ? {value: arg} : arg;=0A=
    };=0A=
  },=0A=
  'ternary?:': function(test, alternate, consequent, context) {=0A=
    return function(scope, locals, assign, inputs) {=0A=
      var arg =3D test(scope, locals, assign, inputs) ? alternate(scope, =
locals, assign, inputs) : consequent(scope, locals, assign, inputs);=0A=
      return context ? {value: arg} : arg;=0A=
    };=0A=
  },=0A=
  value: function(value, context) {=0A=
    return function() { return context ? {context: undefined, name: =
undefined, value: value} : value; };=0A=
  },=0A=
  identifier: function(name, context, create) {=0A=
    return function(scope, locals, assign, inputs) {=0A=
      var base =3D locals &amp;&amp; (name in locals) ? locals : scope;=0A=
      if (create &amp;&amp; create !=3D=3D 1 &amp;&amp; base &amp;&amp; =
base[name] =3D=3D null) {=0A=
        base[name] =3D {};=0A=
      }=0A=
      var value =3D base ? base[name] : undefined;=0A=
      if (context) {=0A=
        return {context: base, name: name, value: value};=0A=
      } else {=0A=
        return value;=0A=
      }=0A=
    };=0A=
  },=0A=
  computedMember: function(left, right, context, create) {=0A=
    return function(scope, locals, assign, inputs) {=0A=
      var lhs =3D left(scope, locals, assign, inputs);=0A=
      var rhs;=0A=
      var value;=0A=
      if (lhs !=3D null) {=0A=
        rhs =3D right(scope, locals, assign, inputs);=0A=
        rhs =3D getStringValue(rhs);=0A=
        if (create &amp;&amp; create !=3D=3D 1) {=0A=
          if (lhs &amp;&amp; !(lhs[rhs])) {=0A=
            lhs[rhs] =3D {};=0A=
          }=0A=
        }=0A=
        value =3D lhs[rhs];=0A=
      }=0A=
      if (context) {=0A=
        return {context: lhs, name: rhs, value: value};=0A=
      } else {=0A=
        return value;=0A=
      }=0A=
    };=0A=
  },=0A=
  nonComputedMember: function(left, right, context, create) {=0A=
    return function(scope, locals, assign, inputs) {=0A=
      var lhs =3D left(scope, locals, assign, inputs);=0A=
      if (create &amp;&amp; create !=3D=3D 1) {=0A=
        if (lhs &amp;&amp; lhs[right] =3D=3D null) {=0A=
          lhs[right] =3D {};=0A=
        }=0A=
      }=0A=
      var value =3D lhs !=3D null ? lhs[right] : undefined;=0A=
      if (context) {=0A=
        return {context: lhs, name: right, value: value};=0A=
      } else {=0A=
        return value;=0A=
      }=0A=
    };=0A=
  },=0A=
  inputs: function(input, watchId) {=0A=
    return function(scope, value, locals, inputs) {=0A=
      if (inputs) return inputs[watchId];=0A=
      return input(scope, value, locals);=0A=
    };=0A=
  }=0A=
};=0A=
=0A=
/**=0A=
 * @constructor=0A=
 */=0A=
function Parser(lexer, $filter, options) {=0A=
  this.ast =3D new AST(lexer, options);=0A=
  this.astCompiler =3D options.csp ? new ASTInterpreter($filter) :=0A=
                                   new ASTCompiler($filter);=0A=
}=0A=
=0A=
Parser.prototype =3D {=0A=
  constructor: Parser,=0A=
=0A=
  parse: function(text) {=0A=
    var ast =3D this.ast.ast(text);=0A=
    var fn =3D this.astCompiler.compile(ast);=0A=
    fn.literal =3D isLiteral(ast);=0A=
    fn.constant =3D isConstant(ast);=0A=
    return fn;=0A=
  }=0A=
};=0A=
=0A=
function getValueOf(value) {=0A=
  return isFunction(value.valueOf) ? value.valueOf() : =
objectValueOf.call(value);=0A=
}=0A=
=0A=
///////////////////////////////////=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $parse=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * Converts Angular {@link guide/expression expression} into a function.=0A=
 *=0A=
 * ```js=0A=
 *   var getter =3D $parse('user.name');=0A=
 *   var setter =3D getter.assign;=0A=
 *   var context =3D {user:{name:'angular'}};=0A=
 *   var locals =3D {user:{name:'local'}};=0A=
 *=0A=
 *   expect(getter(context)).toEqual('angular');=0A=
 *   setter(context, 'newValue');=0A=
 *   expect(context.user.name).toEqual('newValue');=0A=
 *   expect(getter(context, locals)).toEqual('local');=0A=
 * ```=0A=
 *=0A=
 *=0A=
 * @param {string} expression String expression to compile.=0A=
 * @returns {function(context, locals)} a function which represents the =
compiled expression:=0A=
 *=0A=
 *    * `context` =E2=80&#65533; `{object}` =E2=80&#65533; an object =
against which any expressions embedded in the strings=0A=
 *      are evaluated against (typically a scope object).=0A=
 *    * `locals` =E2=80&#65533; `{object=3D}` =E2=80&#65533; local =
variables context object, useful for overriding values in=0A=
 *      `context`.=0A=
 *=0A=
 *    The returned function also has the following properties:=0A=
 *      * `literal` =E2=80&#65533; `{boolean}` =E2=80&#65533; whether =
the expression's top-level node is a JavaScript=0A=
 *        literal.=0A=
 *      * `constant` =E2=80&#65533; `{boolean}` =E2=80&#65533; whether =
the expression is made entirely of JavaScript=0A=
 *        constant literals.=0A=
 *      * `assign` =E2=80&#65533; `{?function(context, value)}` =
=E2=80&#65533; if the expression is assignable, this will be=0A=
 *        set to a function to change its value on the given context.=0A=
 *=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $parseProvider=0A=
 * @this=0A=
 *=0A=
 * @description=0A=
 * `$parseProvider` can be used for configuring the default behavior of =
the {@link ng.$parse $parse}=0A=
 *  service.=0A=
 */=0A=
function $ParseProvider() {=0A=
  var cache =3D createMap();=0A=
  var literals =3D {=0A=
    'true': true,=0A=
    'false': false,=0A=
    'null': null,=0A=
    'undefined': undefined=0A=
  };=0A=
  var identStart, identContinue;=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $parseProvider#addLiteral=0A=
   * @description=0A=
   *=0A=
   * Configure $parse service to add literal values that will be present =
as literal at expressions.=0A=
   *=0A=
   * @param {string} literalName Token for the literal value. The =
literal name value must be a valid literal name.=0A=
   * @param {*} literalValue Value for this literal. All literal values =
must be primitives or `undefined`.=0A=
   *=0A=
   **/=0A=
  this.addLiteral =3D function(literalName, literalValue) {=0A=
    literals[literalName] =3D literalValue;=0A=
  };=0A=
=0A=
 /**=0A=
  * @ngdoc method=0A=
  * @name $parseProvider#setIdentifierFns=0A=
  *=0A=
  * @description=0A=
  *=0A=
  * Allows defining the set of characters that are allowed in Angular =
expressions. The function=0A=
  * `identifierStart` will get called to know if a given character is a =
valid character to be the=0A=
  * first character for an identifier. The function `identifierContinue` =
will get called to know if=0A=
  * a given character is a valid character to be a follow-up identifier =
character. The functions=0A=
  * `identifierStart` and `identifierContinue` will receive as arguments =
the single character to be=0A=
  * identifier and the character code point. These arguments will be =
`string` and `numeric`. Keep in=0A=
  * mind that the `string` parameter can be two characters long =
depending on the character=0A=
  * representation. It is expected for the function to return `true` or =
`false`, whether that=0A=
  * character is allowed or not.=0A=
  *=0A=
  * Since this function will be called extensively, keep the =
implementation of these functions fast,=0A=
  * as the performance of these functions have a direct impact on the =
expressions parsing speed.=0A=
  *=0A=
  * @param {function=3D} identifierStart The function that will decide =
whether the given character is=0A=
  *   a valid identifier start character.=0A=
  * @param {function=3D} identifierContinue The function that will =
decide whether the given character is=0A=
  *   a valid identifier continue character.=0A=
  */=0A=
  this.setIdentifierFns =3D function(identifierStart, =
identifierContinue) {=0A=
    identStart =3D identifierStart;=0A=
    identContinue =3D identifierContinue;=0A=
    return this;=0A=
  };=0A=
=0A=
  this.$get =3D ['$filter', function($filter) {=0A=
    var noUnsafeEval =3D csp().noUnsafeEval;=0A=
    var $parseOptions =3D {=0A=
          csp: noUnsafeEval,=0A=
          literals: copy(literals),=0A=
          isIdentifierStart: isFunction(identStart) &amp;&amp; =
identStart,=0A=
          isIdentifierContinue: isFunction(identContinue) &amp;&amp; =
identContinue=0A=
        };=0A=
    return $parse;=0A=
=0A=
    function $parse(exp, interceptorFn) {=0A=
      var parsedExpression, oneTime, cacheKey;=0A=
=0A=
      switch (typeof exp) {=0A=
        case 'string':=0A=
          exp =3D exp.trim();=0A=
          cacheKey =3D exp;=0A=
=0A=
          parsedExpression =3D cache[cacheKey];=0A=
=0A=
          if (!parsedExpression) {=0A=
            if (exp.charAt(0) =3D=3D=3D ':' &amp;&amp; exp.charAt(1) =
=3D=3D=3D ':') {=0A=
              oneTime =3D true;=0A=
              exp =3D exp.substring(2);=0A=
            }=0A=
            var lexer =3D new Lexer($parseOptions);=0A=
            var parser =3D new Parser(lexer, $filter, $parseOptions);=0A=
            parsedExpression =3D parser.parse(exp);=0A=
            if (parsedExpression.constant) {=0A=
              parsedExpression.$$watchDelegate =3D constantWatchDelegate;=0A=
            } else if (oneTime) {=0A=
              parsedExpression.$$watchDelegate =3D =
parsedExpression.literal ?=0A=
                  oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;=0A=
            } else if (parsedExpression.inputs) {=0A=
              parsedExpression.$$watchDelegate =3D inputsWatchDelegate;=0A=
            }=0A=
            cache[cacheKey] =3D parsedExpression;=0A=
          }=0A=
          return addInterceptor(parsedExpression, interceptorFn);=0A=
=0A=
        case 'function':=0A=
          return addInterceptor(exp, interceptorFn);=0A=
=0A=
        default:=0A=
          return addInterceptor(noop, interceptorFn);=0A=
      }=0A=
    }=0A=
=0A=
    function expressionInputDirtyCheck(newValue, oldValueOfValue, =
compareObjectIdentity) {=0A=
=0A=
      if (newValue =3D=3D null || oldValueOfValue =3D=3D null) { // =
null/undefined=0A=
        return newValue =3D=3D=3D oldValueOfValue;=0A=
      }=0A=
=0A=
      if (typeof newValue =3D=3D=3D 'object') {=0A=
=0A=
        // attempt to convert the value to a primitive type=0A=
        // TODO(docs): add a note to docs that by implementing valueOf =
even objects and arrays can=0A=
        //             be cheaply dirty-checked=0A=
        newValue =3D getValueOf(newValue);=0A=
=0A=
        if (typeof newValue =3D=3D=3D 'object' &amp;&amp; =
!compareObjectIdentity) {=0A=
          // objects/arrays are not supported - deep-watching them would =
be too expensive=0A=
          return false;=0A=
        }=0A=
=0A=
        // fall-through to the primitive equality check=0A=
      }=0A=
=0A=
      //Primitive or NaN=0A=
      // eslint-disable-next-line no-self-compare=0A=
      return newValue =3D=3D=3D oldValueOfValue || (newValue !=3D=3D =
newValue &amp;&amp; oldValueOfValue !=3D=3D oldValueOfValue);=0A=
    }=0A=
=0A=
    function inputsWatchDelegate(scope, listener, objectEquality, =
parsedExpression, prettyPrintExpression) {=0A=
      var inputExpressions =3D parsedExpression.inputs;=0A=
      var lastResult;=0A=
=0A=
      if (inputExpressions.length =3D=3D=3D 1) {=0A=
        var oldInputValueOf =3D expressionInputDirtyCheck; // init to =
something unique so that equals check fails=0A=
        inputExpressions =3D inputExpressions[0];=0A=
        return scope.$watch(function expressionInputWatch(scope) {=0A=
          var newInputValue =3D inputExpressions(scope);=0A=
          if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf, =
inputExpressions.isPure)) {=0A=
            lastResult =3D parsedExpression(scope, undefined, undefined, =
[newInputValue]);=0A=
            oldInputValueOf =3D newInputValue &amp;&amp; =
getValueOf(newInputValue);=0A=
          }=0A=
          return lastResult;=0A=
        }, listener, objectEquality, prettyPrintExpression);=0A=
      }=0A=
=0A=
      var oldInputValueOfValues =3D [];=0A=
      var oldInputValues =3D [];=0A=
      for (var i =3D 0, ii =3D inputExpressions.length; i &lt; ii; i++) {=0A=
        oldInputValueOfValues[i] =3D expressionInputDirtyCheck; // init =
to something unique so that equals check fails=0A=
        oldInputValues[i] =3D null;=0A=
      }=0A=
=0A=
      return scope.$watch(function expressionInputsWatch(scope) {=0A=
        var changed =3D false;=0A=
=0A=
        for (var i =3D 0, ii =3D inputExpressions.length; i &lt; ii; =
i++) {=0A=
          var newInputValue =3D inputExpressions[i](scope);=0A=
          if (changed || (changed =3D =
!expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i], =
inputExpressions[i].isPure))) {=0A=
            oldInputValues[i] =3D newInputValue;=0A=
            oldInputValueOfValues[i] =3D newInputValue &amp;&amp; =
getValueOf(newInputValue);=0A=
          }=0A=
        }=0A=
=0A=
        if (changed) {=0A=
          lastResult =3D parsedExpression(scope, undefined, undefined, =
oldInputValues);=0A=
        }=0A=
=0A=
        return lastResult;=0A=
      }, listener, objectEquality, prettyPrintExpression);=0A=
    }=0A=
=0A=
    function oneTimeWatchDelegate(scope, listener, objectEquality, =
parsedExpression, prettyPrintExpression) {=0A=
      var unwatch, lastValue;=0A=
      if (parsedExpression.inputs) {=0A=
        unwatch =3D inputsWatchDelegate(scope, oneTimeListener, =
objectEquality, parsedExpression, prettyPrintExpression);=0A=
      } else {=0A=
        unwatch =3D scope.$watch(oneTimeWatch, oneTimeListener, =
objectEquality);=0A=
      }=0A=
      return unwatch;=0A=
=0A=
      function oneTimeWatch(scope) {=0A=
        return parsedExpression(scope);=0A=
      }=0A=
      function oneTimeListener(value, old, scope) {=0A=
        lastValue =3D value;=0A=
        if (isFunction(listener)) {=0A=
          listener(value, old, scope);=0A=
        }=0A=
        if (isDefined(value)) {=0A=
          scope.$$postDigest(function() {=0A=
            if (isDefined(lastValue)) {=0A=
              unwatch();=0A=
            }=0A=
          });=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    function oneTimeLiteralWatchDelegate(scope, listener, =
objectEquality, parsedExpression) {=0A=
      var unwatch, lastValue;=0A=
      unwatch =3D scope.$watch(function oneTimeWatch(scope) {=0A=
        return parsedExpression(scope);=0A=
      }, function oneTimeListener(value, old, scope) {=0A=
        lastValue =3D value;=0A=
        if (isFunction(listener)) {=0A=
          listener(value, old, scope);=0A=
        }=0A=
        if (isAllDefined(value)) {=0A=
          scope.$$postDigest(function() {=0A=
            if (isAllDefined(lastValue)) unwatch();=0A=
          });=0A=
        }=0A=
      }, objectEquality);=0A=
=0A=
      return unwatch;=0A=
=0A=
      function isAllDefined(value) {=0A=
        var allDefined =3D true;=0A=
        forEach(value, function(val) {=0A=
          if (!isDefined(val)) allDefined =3D false;=0A=
        });=0A=
        return allDefined;=0A=
      }=0A=
    }=0A=
=0A=
    function constantWatchDelegate(scope, listener, objectEquality, =
parsedExpression) {=0A=
      var unwatch =3D scope.$watch(function constantWatch(scope) {=0A=
        unwatch();=0A=
        return parsedExpression(scope);=0A=
      }, listener, objectEquality);=0A=
      return unwatch;=0A=
    }=0A=
=0A=
    function addInterceptor(parsedExpression, interceptorFn) {=0A=
      if (!interceptorFn) return parsedExpression;=0A=
      var watchDelegate =3D parsedExpression.$$watchDelegate;=0A=
      var useInputs =3D false;=0A=
=0A=
      var regularWatch =3D=0A=
          watchDelegate !=3D=3D oneTimeLiteralWatchDelegate &amp;&amp;=0A=
          watchDelegate !=3D=3D oneTimeWatchDelegate;=0A=
=0A=
      var fn =3D regularWatch ? function =
regularInterceptedExpression(scope, locals, assign, inputs) {=0A=
        var value =3D useInputs &amp;&amp; inputs ? inputs[0] : =
parsedExpression(scope, locals, assign, inputs);=0A=
        return interceptorFn(value, scope, locals);=0A=
      } : function oneTimeInterceptedExpression(scope, locals, assign, =
inputs) {=0A=
        var value =3D parsedExpression(scope, locals, assign, inputs);=0A=
        var result =3D interceptorFn(value, scope, locals);=0A=
        // we only return the interceptor's result if the=0A=
        // initial value is defined (for bind-once)=0A=
        return isDefined(value) ? result : value;=0A=
      };=0A=
=0A=
      // Propagate $$watchDelegates other then inputsWatchDelegate=0A=
      useInputs =3D !parsedExpression.inputs;=0A=
      if (watchDelegate &amp;&amp; watchDelegate !=3D=3D =
inputsWatchDelegate) {=0A=
        fn.$$watchDelegate =3D watchDelegate;=0A=
        fn.inputs =3D parsedExpression.inputs;=0A=
      } else if (!interceptorFn.$stateful) {=0A=
        // Treat interceptor like filters - assume non-stateful by =
default and use the inputsWatchDelegate=0A=
        fn.$$watchDelegate =3D inputsWatchDelegate;=0A=
        fn.inputs =3D parsedExpression.inputs ? parsedExpression.inputs =
: [parsedExpression];=0A=
      }=0A=
=0A=
      if (fn.inputs) {=0A=
        fn.inputs =3D fn.inputs.map(function(e) {=0A=
              // Remove the isPure flag of inputs when it is not =
absolute because they are now wrapped in a=0A=
              // potentially non-pure interceptor function.=0A=
              if (e.isPure =3D=3D=3D PURITY_RELATIVE) {=0A=
                return function depurifier(s) { return e(s); };=0A=
              }=0A=
              return e;=0A=
            });=0A=
      }=0A=
=0A=
      return fn;=0A=
    }=0A=
  }];=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $q=0A=
 * @requires $rootScope=0A=
 *=0A=
 * @description=0A=
 * A service that helps you run functions asynchronously, and use their =
return values (or exceptions)=0A=
 * when they are done processing.=0A=
 *=0A=
 * This is a [Promises/A+](https://promisesaplus.com/)-compliant =
implementation of promises/deferred=0A=
 * objects inspired by [Kris Kowal's Q](https://github.com/kriskowal/q).=0A=
 *=0A=
 * $q can be used in two fashions --- one which is more similar to Kris =
Kowal's Q or jQuery's Deferred=0A=
 * implementations, and the other which resembles ES6 (ES2015) promises =
to some degree.=0A=
 *=0A=
 * # $q constructor=0A=
 *=0A=
 * The streamlined ES6 style promise is essentially just using $q as a =
constructor which takes a `resolver`=0A=
 * function as the first argument. This is similar to the native Promise =
implementation from ES6,=0A=
 * see =
[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/G=
lobal_Objects/Promise).=0A=
 *=0A=
 * While the constructor-style use is supported, not all of the =
supporting methods from ES6 promises are=0A=
 * available yet.=0A=
 *=0A=
 * It can be used like so:=0A=
 *=0A=
 * ```js=0A=
 *   // for the purpose of this example let's assume that variables `$q` =
and `okToGreet`=0A=
 *   // are available in the current lexical scope (they could have been =
injected or passed in).=0A=
 *=0A=
 *   function asyncGreet(name) {=0A=
 *     // perform some asynchronous operation, resolve or reject the =
promise when appropriate.=0A=
 *     return $q(function(resolve, reject) {=0A=
 *       setTimeout(function() {=0A=
 *         if (okToGreet(name)) {=0A=
 *           resolve('Hello, ' + name + '!');=0A=
 *         } else {=0A=
 *           reject('Greeting ' + name + ' is not allowed.');=0A=
 *         }=0A=
 *       }, 1000);=0A=
 *     });=0A=
 *   }=0A=
 *=0A=
 *   var promise =3D asyncGreet('Robin Hood');=0A=
 *   promise.then(function(greeting) {=0A=
 *     alert('Success: ' + greeting);=0A=
 *   }, function(reason) {=0A=
 *     alert('Failed: ' + reason);=0A=
 *   });=0A=
 * ```=0A=
 *=0A=
 * Note: progress/notify callbacks are not currently supported via the =
ES6-style interface.=0A=
 *=0A=
 * Note: unlike ES6 behavior, an exception thrown in the constructor =
function will NOT implicitly reject the promise.=0A=
 *=0A=
 * However, the more traditional CommonJS-style usage is still =
available, and documented below.=0A=
 *=0A=
 * [The CommonJS Promise =
proposal](http://wiki.commonjs.org/wiki/Promises) describes a promise as =
an=0A=
 * interface for interacting with an object that represents the result =
of an action that is=0A=
 * performed asynchronously, and may or may not be finished at any given =
point in time.=0A=
 *=0A=
 * From the perspective of dealing with error handling, deferred and =
promise APIs are to=0A=
 * asynchronous programming what `try`, `catch` and `throw` keywords are =
to synchronous programming.=0A=
 *=0A=
 * ```js=0A=
 *   // for the purpose of this example let's assume that variables `$q` =
and `okToGreet`=0A=
 *   // are available in the current lexical scope (they could have been =
injected or passed in).=0A=
 *=0A=
 *   function asyncGreet(name) {=0A=
 *     var deferred =3D $q.defer();=0A=
 *=0A=
 *     setTimeout(function() {=0A=
 *       deferred.notify('About to greet ' + name + '.');=0A=
 *=0A=
 *       if (okToGreet(name)) {=0A=
 *         deferred.resolve('Hello, ' + name + '!');=0A=
 *       } else {=0A=
 *         deferred.reject('Greeting ' + name + ' is not allowed.');=0A=
 *       }=0A=
 *     }, 1000);=0A=
 *=0A=
 *     return deferred.promise;=0A=
 *   }=0A=
 *=0A=
 *   var promise =3D asyncGreet('Robin Hood');=0A=
 *   promise.then(function(greeting) {=0A=
 *     alert('Success: ' + greeting);=0A=
 *   }, function(reason) {=0A=
 *     alert('Failed: ' + reason);=0A=
 *   }, function(update) {=0A=
 *     alert('Got notification: ' + update);=0A=
 *   });=0A=
 * ```=0A=
 *=0A=
 * At first it might not be obvious why this extra complexity is worth =
the trouble. The payoff=0A=
 * comes in the way of guarantees that promise and deferred APIs make, =
see=0A=
 * =
https://github.com/kriskowal/uncommonjs/blob/master/promises/specificatio=
n.md.=0A=
 *=0A=
 * Additionally the promise api allows for composition that is very hard =
to do with the=0A=
 * traditional callback =
([CPS](http://en.wikipedia.org/wiki/Continuation-passing_style)) =
approach.=0A=
 * For more on this please see the [Q =
documentation](https://github.com/kriskowal/q) especially the=0A=
 * section on serial or parallel joining of promises.=0A=
 *=0A=
 * # The Deferred API=0A=
 *=0A=
 * A new instance of deferred is constructed by calling `$q.defer()`.=0A=
 *=0A=
 * The purpose of the deferred object is to expose the associated =
Promise instance as well as APIs=0A=
 * that can be used for signaling the successful or unsuccessful =
completion, as well as the status=0A=
 * of the task.=0A=
 *=0A=
 * **Methods**=0A=
 *=0A=
 * - `resolve(value)` =E2=80&#65533; resolves the derived promise with =
the `value`. If the value is a rejection=0A=
 *   constructed via `$q.reject`, the promise will be rejected instead.=0A=
 * - `reject(reason)` =E2=80&#65533; rejects the derived promise with =
the `reason`. This is equivalent to=0A=
 *   resolving it with a rejection constructed via `$q.reject`.=0A=
 * - `notify(value)` - provides updates on the status of the promise's =
execution. This may be called=0A=
 *   multiple times before the promise is either resolved or rejected.=0A=
 *=0A=
 * **Properties**=0A=
 *=0A=
 * - promise =E2=80&#65533; `{Promise}` =E2=80&#65533; promise object =
associated with this deferred.=0A=
 *=0A=
 *=0A=
 * # The Promise API=0A=
 *=0A=
 * A new promise instance is created when a deferred instance is created =
and can be retrieved by=0A=
 * calling `deferred.promise`.=0A=
 *=0A=
 * The purpose of the promise object is to allow for interested parties =
to get access to the result=0A=
 * of the deferred task when it completes.=0A=
 *=0A=
 * **Methods**=0A=
 *=0A=
 * - `then(successCallback, [errorCallback], [notifyCallback])` =
=E2=80&#65533; regardless of when the promise was or=0A=
 *   will be resolved or rejected, `then` calls one of the success or =
error callbacks asynchronously=0A=
 *   as soon as the result is available. The callbacks are called with a =
single argument: the result=0A=
 *   or rejection reason. Additionally, the notify callback may be =
called zero or more times to=0A=
 *   provide a progress indication, before the promise is resolved or =
rejected.=0A=
 *=0A=
 *   This method *returns a new promise* which is resolved or rejected =
via the return value of the=0A=
 *   `successCallback`, `errorCallback` (unless that value is a promise, =
in which case it is resolved=0A=
 *   with the value which is resolved in that promise using=0A=
 *   [promise =
chaining](http://www.html5rocks.com/en/tutorials/es6/promises/#toc-promis=
es-queues)).=0A=
 *   It also notifies via the return value of the `notifyCallback` =
method. The promise cannot be=0A=
 *   resolved or rejected from the notifyCallback method. The =
errorCallback and notifyCallback=0A=
 *   arguments are optional.=0A=
 *=0A=
 * - `catch(errorCallback)` =E2=80&#65533; shorthand for =
`promise.then(null, errorCallback)`=0A=
 *=0A=
 * - `finally(callback, notifyCallback)` =E2=80&#65533; allows you to =
observe either the fulfillment or rejection of a promise,=0A=
 *   but to do so without modifying the final value. This is useful to =
release resources or do some=0A=
 *   clean-up that needs to be done whether the promise was rejected or =
resolved. See the [full=0A=
 *   =
specification](https://github.com/kriskowal/q/wiki/API-Reference#promisef=
inallycallback) for=0A=
 *   more information.=0A=
 *=0A=
 * # Chaining promises=0A=
 *=0A=
 * Because calling the `then` method of a promise returns a new derived =
promise, it is easily=0A=
 * possible to create a chain of promises:=0A=
 *=0A=
 * ```js=0A=
 *   promiseB =3D promiseA.then(function(result) {=0A=
 *     return result + 1;=0A=
 *   });=0A=
 *=0A=
 *   // promiseB will be resolved immediately after promiseA is resolved =
and its value=0A=
 *   // will be the result of promiseA incremented by 1=0A=
 * ```=0A=
 *=0A=
 * It is possible to create chains of any length and since a promise can =
be resolved with another=0A=
 * promise (which will defer its resolution further), it is possible to =
pause/defer resolution of=0A=
 * the promises at any point in the chain. This makes it possible to =
implement powerful APIs like=0A=
 * $http's response interceptors.=0A=
 *=0A=
 *=0A=
 * # Differences between Kris Kowal's Q and $q=0A=
 *=0A=
 *  There are two main differences:=0A=
 *=0A=
 * - $q is integrated with the {@link ng.$rootScope.Scope} Scope model =
observation=0A=
 *   mechanism in angular, which means faster propagation of resolution =
or rejection into your=0A=
 *   models and avoiding unnecessary browser repaints, which would =
result in flickering UI.=0A=
 * - Q has many more features than $q, but that comes at a cost of =
bytes. $q is tiny, but contains=0A=
 *   all the important functionality needed for common async tasks.=0A=
 *=0A=
 * # Testing=0A=
 *=0A=
 *  ```js=0A=
 *    it('should simulate promise', inject(function($q, $rootScope) {=0A=
 *      var deferred =3D $q.defer();=0A=
 *      var promise =3D deferred.promise;=0A=
 *      var resolvedValue;=0A=
 *=0A=
 *      promise.then(function(value) { resolvedValue =3D value; });=0A=
 *      expect(resolvedValue).toBeUndefined();=0A=
 *=0A=
 *      // Simulate resolving of promise=0A=
 *      deferred.resolve(123);=0A=
 *      // Note that the 'then' function does not get called =
synchronously.=0A=
 *      // This is because we want the promise API to always be async, =
whether or not=0A=
 *      // it got called synchronously or asynchronously.=0A=
 *      expect(resolvedValue).toBeUndefined();=0A=
 *=0A=
 *      // Propagate promise resolution to 'then' functions using =
$apply().=0A=
 *      $rootScope.$apply();=0A=
 *      expect(resolvedValue).toEqual(123);=0A=
 *    }));=0A=
 *  ```=0A=
 *=0A=
 * @param {function(function, function)} resolver Function which is =
responsible for resolving or=0A=
 *   rejecting the newly created promise. The first parameter is a =
function which resolves the=0A=
 *   promise, the second parameter is a function which rejects the =
promise.=0A=
 *=0A=
 * @returns {Promise} The newly created promise.=0A=
 */=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $qProvider=0A=
 * @this=0A=
 *=0A=
 * @description=0A=
 */=0A=
function $QProvider() {=0A=
  var errorOnUnhandledRejections =3D true;=0A=
  this.$get =3D ['$rootScope', '$exceptionHandler', function($rootScope, =
$exceptionHandler) {=0A=
    return qFactory(function(callback) {=0A=
      $rootScope.$evalAsync(callback);=0A=
    }, $exceptionHandler, errorOnUnhandledRejections);=0A=
  }];=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $qProvider#errorOnUnhandledRejections=0A=
   * @kind function=0A=
   *=0A=
   * @description=0A=
   * Retrieves or overrides whether to generate an error when a rejected =
promise is not handled.=0A=
   * This feature is enabled by default.=0A=
   *=0A=
   * @param {boolean=3D} value Whether to generate an error when a =
rejected promise is not handled.=0A=
   * @returns {boolean|ng.$qProvider} Current value when called without =
a new value or self for=0A=
   *    chaining otherwise.=0A=
   */=0A=
  this.errorOnUnhandledRejections =3D function(value) {=0A=
    if (isDefined(value)) {=0A=
      errorOnUnhandledRejections =3D value;=0A=
      return this;=0A=
    } else {=0A=
      return errorOnUnhandledRejections;=0A=
    }=0A=
  };=0A=
}=0A=
=0A=
/** @this */=0A=
function $$QProvider() {=0A=
  var errorOnUnhandledRejections =3D true;=0A=
  this.$get =3D ['$browser', '$exceptionHandler', function($browser, =
$exceptionHandler) {=0A=
    return qFactory(function(callback) {=0A=
      $browser.defer(callback);=0A=
    }, $exceptionHandler, errorOnUnhandledRejections);=0A=
  }];=0A=
=0A=
  this.errorOnUnhandledRejections =3D function(value) {=0A=
    if (isDefined(value)) {=0A=
      errorOnUnhandledRejections =3D value;=0A=
      return this;=0A=
    } else {=0A=
      return errorOnUnhandledRejections;=0A=
    }=0A=
  };=0A=
}=0A=
=0A=
/**=0A=
 * Constructs a promise manager.=0A=
 *=0A=
 * @param {function(function)} nextTick Function for executing functions =
in the next turn.=0A=
 * @param {function(...*)} exceptionHandler Function into which =
unexpected exceptions are passed for=0A=
 *     debugging purposes.=0A=
 * @param {boolean=3D} errorOnUnhandledRejections Whether an error =
should be generated on unhandled=0A=
 *     promises rejections.=0A=
 * @returns {object} Promise manager.=0A=
 */=0A=
function qFactory(nextTick, exceptionHandler, =
errorOnUnhandledRejections) {=0A=
  var $qMinErr =3D minErr('$q', TypeError);=0A=
  var queueSize =3D 0;=0A=
  var checkQueue =3D [];=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name ng.$q#defer=0A=
   * @kind function=0A=
   *=0A=
   * @description=0A=
   * Creates a `Deferred` object which represents a task which will =
finish in the future.=0A=
   *=0A=
   * @returns {Deferred} Returns a new instance of deferred.=0A=
   */=0A=
  function defer() {=0A=
    return new Deferred();=0A=
  }=0A=
=0A=
  function Deferred() {=0A=
    var promise =3D this.promise =3D new Promise();=0A=
    //Non prototype methods necessary to support unbound execution :/=0A=
    this.resolve =3D function(val) { resolvePromise(promise, val); };=0A=
    this.reject =3D function(reason) { rejectPromise(promise, reason); };=0A=
    this.notify =3D function(progress) { notifyPromise(promise, =
progress); };=0A=
  }=0A=
=0A=
=0A=
  function Promise() {=0A=
    this.$$state =3D { status: 0 };=0A=
  }=0A=
=0A=
  extend(Promise.prototype, {=0A=
    then: function(onFulfilled, onRejected, progressBack) {=0A=
      if (isUndefined(onFulfilled) &amp;&amp; isUndefined(onRejected) =
&amp;&amp; isUndefined(progressBack)) {=0A=
        return this;=0A=
      }=0A=
      var result =3D new Promise();=0A=
=0A=
      this.$$state.pending =3D this.$$state.pending || [];=0A=
      this.$$state.pending.push([result, onFulfilled, onRejected, =
progressBack]);=0A=
      if (this.$$state.status &gt; 0) scheduleProcessQueue(this.$$state);=0A=
=0A=
      return result;=0A=
    },=0A=
=0A=
    'catch': function(callback) {=0A=
      return this.then(null, callback);=0A=
    },=0A=
=0A=
    'finally': function(callback, progressBack) {=0A=
      return this.then(function(value) {=0A=
        return handleCallback(value, resolve, callback);=0A=
      }, function(error) {=0A=
        return handleCallback(error, reject, callback);=0A=
      }, progressBack);=0A=
    }=0A=
  });=0A=
=0A=
  function processQueue(state) {=0A=
    var fn, promise, pending;=0A=
=0A=
    pending =3D state.pending;=0A=
    state.processScheduled =3D false;=0A=
    state.pending =3D undefined;=0A=
    try {=0A=
      for (var i =3D 0, ii =3D pending.length; i &lt; ii; ++i) {=0A=
        markQStateExceptionHandled(state);=0A=
        promise =3D pending[i][0];=0A=
        fn =3D pending[i][state.status];=0A=
        try {=0A=
          if (isFunction(fn)) {=0A=
            resolvePromise(promise, fn(state.value));=0A=
          } else if (state.status =3D=3D=3D 1) {=0A=
            resolvePromise(promise, state.value);=0A=
          } else {=0A=
            rejectPromise(promise, state.value);=0A=
          }=0A=
        } catch (e) {=0A=
          rejectPromise(promise, e);=0A=
        }=0A=
      }=0A=
    } finally {=0A=
      --queueSize;=0A=
      if (errorOnUnhandledRejections &amp;&amp; queueSize =3D=3D=3D 0) {=0A=
        nextTick(processChecks);=0A=
      }=0A=
    }=0A=
  }=0A=
=0A=
  function processChecks() {=0A=
    // eslint-disable-next-line no-unmodified-loop-condition=0A=
    while (!queueSize &amp;&amp; checkQueue.length) {=0A=
      var toCheck =3D checkQueue.shift();=0A=
      if (!isStateExceptionHandled(toCheck)) {=0A=
        markQStateExceptionHandled(toCheck);=0A=
        var errorMessage =3D 'Possibly unhandled rejection: ' + =
toDebugString(toCheck.value);=0A=
        if (isError(toCheck.value)) {=0A=
          exceptionHandler(toCheck.value, errorMessage);=0A=
        } else {=0A=
          exceptionHandler(errorMessage);=0A=
        }=0A=
      }=0A=
    }=0A=
  }=0A=
=0A=
  function scheduleProcessQueue(state) {=0A=
    if (errorOnUnhandledRejections &amp;&amp; !state.pending &amp;&amp; =
state.status =3D=3D=3D 2 &amp;&amp; !isStateExceptionHandled(state)) {=0A=
      if (queueSize =3D=3D=3D 0 &amp;&amp; checkQueue.length =3D=3D=3D =
0) {=0A=
        nextTick(processChecks);=0A=
      }=0A=
      checkQueue.push(state);=0A=
    }=0A=
    if (state.processScheduled || !state.pending) return;=0A=
    state.processScheduled =3D true;=0A=
    ++queueSize;=0A=
    nextTick(function() { processQueue(state); });=0A=
  }=0A=
=0A=
  function resolvePromise(promise, val) {=0A=
    if (promise.$$state.status) return;=0A=
    if (val =3D=3D=3D promise) {=0A=
      $$reject(promise, $qMinErr(=0A=
        'qcycle',=0A=
        'Expected promise to be resolved with value other than itself =
\'{0}\'',=0A=
        val));=0A=
    } else {=0A=
      $$resolve(promise, val);=0A=
    }=0A=
=0A=
  }=0A=
=0A=
  function $$resolve(promise, val) {=0A=
    var then;=0A=
    var done =3D false;=0A=
    try {=0A=
      if (isObject(val) || isFunction(val)) then =3D val.then;=0A=
      if (isFunction(then)) {=0A=
        promise.$$state.status =3D -1;=0A=
        then.call(val, doResolve, doReject, doNotify);=0A=
      } else {=0A=
        promise.$$state.value =3D val;=0A=
        promise.$$state.status =3D 1;=0A=
        scheduleProcessQueue(promise.$$state);=0A=
      }=0A=
    } catch (e) {=0A=
      doReject(e);=0A=
    }=0A=
=0A=
    function doResolve(val) {=0A=
      if (done) return;=0A=
      done =3D true;=0A=
      $$resolve(promise, val);=0A=
    }=0A=
    function doReject(val) {=0A=
      if (done) return;=0A=
      done =3D true;=0A=
      $$reject(promise, val);=0A=
    }=0A=
    function doNotify(progress) {=0A=
      notifyPromise(promise, progress);=0A=
    }=0A=
  }=0A=
=0A=
  function rejectPromise(promise, reason) {=0A=
    if (promise.$$state.status) return;=0A=
    $$reject(promise, reason);=0A=
  }=0A=
=0A=
  function $$reject(promise, reason) {=0A=
    promise.$$state.value =3D reason;=0A=
    promise.$$state.status =3D 2;=0A=
    scheduleProcessQueue(promise.$$state);=0A=
  }=0A=
=0A=
  function notifyPromise(promise, progress) {=0A=
    var callbacks =3D promise.$$state.pending;=0A=
=0A=
    if ((promise.$$state.status &lt;=3D 0) &amp;&amp; callbacks =
&amp;&amp; callbacks.length) {=0A=
      nextTick(function() {=0A=
        var callback, result;=0A=
        for (var i =3D 0, ii =3D callbacks.length; i &lt; ii; i++) {=0A=
          result =3D callbacks[i][0];=0A=
          callback =3D callbacks[i][3];=0A=
          try {=0A=
            notifyPromise(result, isFunction(callback) ? =
callback(progress) : progress);=0A=
          } catch (e) {=0A=
            exceptionHandler(e);=0A=
          }=0A=
        }=0A=
      });=0A=
    }=0A=
  }=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $q#reject=0A=
   * @kind function=0A=
   *=0A=
   * @description=0A=
   * Creates a promise that is resolved as rejected with the specified =
`reason`. This api should be=0A=
   * used to forward rejection in a chain of promises. If you are =
dealing with the last promise in=0A=
   * a promise chain, you don't need to worry about it.=0A=
   *=0A=
   * When comparing deferreds/promises to the familiar behavior of =
try/catch/throw, think of=0A=
   * `reject` as the `throw` keyword in JavaScript. This also means that =
if you "catch" an error via=0A=
   * a promise error callback and you want to forward the error to the =
promise derived from the=0A=
   * current promise, you have to "rethrow" the error by returning a =
rejection constructed via=0A=
   * `reject`.=0A=
   *=0A=
   * ```js=0A=
   *   promiseB =3D promiseA.then(function(result) {=0A=
   *     // success: do something and resolve promiseB=0A=
   *     //          with the old or a new result=0A=
   *     return result;=0A=
   *   }, function(reason) {=0A=
   *     // error: handle the error if possible and=0A=
   *     //        resolve promiseB with newPromiseOrValue,=0A=
   *     //        otherwise forward the rejection to promiseB=0A=
   *     if (canHandle(reason)) {=0A=
   *      // handle the error and recover=0A=
   *      return newPromiseOrValue;=0A=
   *     }=0A=
   *     return $q.reject(reason);=0A=
   *   });=0A=
   * ```=0A=
   *=0A=
   * @param {*} reason Constant, message, exception or an object =
representing the rejection reason.=0A=
   * @returns {Promise} Returns a promise that was already resolved as =
rejected with the `reason`.=0A=
   */=0A=
  function reject(reason) {=0A=
    var result =3D new Promise();=0A=
    rejectPromise(result, reason);=0A=
    return result;=0A=
  }=0A=
=0A=
  function handleCallback(value, resolver, callback) {=0A=
    var callbackOutput =3D null;=0A=
    try {=0A=
      if (isFunction(callback)) callbackOutput =3D callback();=0A=
    } catch (e) {=0A=
      return reject(e);=0A=
    }=0A=
    if (isPromiseLike(callbackOutput)) {=0A=
      return callbackOutput.then(function() {=0A=
        return resolver(value);=0A=
      }, reject);=0A=
    } else {=0A=
      return resolver(value);=0A=
    }=0A=
  }=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $q#when=0A=
   * @kind function=0A=
   *=0A=
   * @description=0A=
   * Wraps an object that might be a value or a (3rd party) then-able =
promise into a $q promise.=0A=
   * This is useful when you are dealing with an object that might or =
might not be a promise, or if=0A=
   * the promise comes from a source that can't be trusted.=0A=
   *=0A=
   * @param {*} value Value or a promise=0A=
   * @param {Function=3D} successCallback=0A=
   * @param {Function=3D} errorCallback=0A=
   * @param {Function=3D} progressCallback=0A=
   * @returns {Promise} Returns a promise of the passed value or promise=0A=
   */=0A=
=0A=
=0A=
  function when(value, callback, errback, progressBack) {=0A=
    var result =3D new Promise();=0A=
    resolvePromise(result, value);=0A=
    return result.then(callback, errback, progressBack);=0A=
  }=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $q#resolve=0A=
   * @kind function=0A=
   *=0A=
   * @description=0A=
   * Alias of {@link ng.$q#when when} to maintain naming consistency =
with ES6.=0A=
   *=0A=
   * @param {*} value Value or a promise=0A=
   * @param {Function=3D} successCallback=0A=
   * @param {Function=3D} errorCallback=0A=
   * @param {Function=3D} progressCallback=0A=
   * @returns {Promise} Returns a promise of the passed value or promise=0A=
   */=0A=
  var resolve =3D when;=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $q#all=0A=
   * @kind function=0A=
   *=0A=
   * @description=0A=
   * Combines multiple promises into a single promise that is resolved =
when all of the input=0A=
   * promises are resolved.=0A=
   *=0A=
   * @param {Array.&lt;Promise&gt;|Object.&lt;Promise&gt;} promises An =
array or hash of promises.=0A=
   * @returns {Promise} Returns a single promise that will be resolved =
with an array/hash of values,=0A=
   *   each value corresponding to the promise at the same index/key in =
the `promises` array/hash.=0A=
   *   If any of the promises is resolved with a rejection, this =
resulting promise will be rejected=0A=
   *   with the same rejection value.=0A=
   */=0A=
=0A=
  function all(promises) {=0A=
    var result =3D new Promise(),=0A=
        counter =3D 0,=0A=
        results =3D isArray(promises) ? [] : {};=0A=
=0A=
    forEach(promises, function(promise, key) {=0A=
      counter++;=0A=
      when(promise).then(function(value) {=0A=
        results[key] =3D value;=0A=
        if (!(--counter)) resolvePromise(result, results);=0A=
      }, function(reason) {=0A=
        rejectPromise(result, reason);=0A=
      });=0A=
    });=0A=
=0A=
    if (counter =3D=3D=3D 0) {=0A=
      resolvePromise(result, results);=0A=
    }=0A=
=0A=
    return result;=0A=
  }=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $q#race=0A=
   * @kind function=0A=
   *=0A=
   * @description=0A=
   * Returns a promise that resolves or rejects as soon as one of those =
promises=0A=
   * resolves or rejects, with the value or reason from that promise.=0A=
   *=0A=
   * @param {Array.&lt;Promise&gt;|Object.&lt;Promise&gt;} promises An =
array or hash of promises.=0A=
   * @returns {Promise} a promise that resolves or rejects as soon as =
one of the `promises`=0A=
   * resolves or rejects, with the value or reason from that promise.=0A=
   */=0A=
=0A=
  function race(promises) {=0A=
    var deferred =3D defer();=0A=
=0A=
    forEach(promises, function(promise) {=0A=
      when(promise).then(deferred.resolve, deferred.reject);=0A=
    });=0A=
=0A=
    return deferred.promise;=0A=
  }=0A=
=0A=
  function $Q(resolver) {=0A=
    if (!isFunction(resolver)) {=0A=
      throw $qMinErr('norslvr', 'Expected resolverFn, got \'{0}\'', =
resolver);=0A=
    }=0A=
=0A=
    var promise =3D new Promise();=0A=
=0A=
    function resolveFn(value) {=0A=
      resolvePromise(promise, value);=0A=
    }=0A=
=0A=
    function rejectFn(reason) {=0A=
      rejectPromise(promise, reason);=0A=
    }=0A=
=0A=
    resolver(resolveFn, rejectFn);=0A=
=0A=
    return promise;=0A=
  }=0A=
=0A=
  // Let's make the instanceof operator work for promises, so that=0A=
  // `new $q(fn) instanceof $q` would evaluate to true.=0A=
  $Q.prototype =3D Promise.prototype;=0A=
=0A=
  $Q.defer =3D defer;=0A=
  $Q.reject =3D reject;=0A=
  $Q.when =3D when;=0A=
  $Q.resolve =3D resolve;=0A=
  $Q.all =3D all;=0A=
  $Q.race =3D race;=0A=
=0A=
  return $Q;=0A=
}=0A=
=0A=
function isStateExceptionHandled(state) {=0A=
  return !!state.pur;=0A=
}=0A=
function markQStateExceptionHandled(state) {=0A=
  state.pur =3D true;=0A=
}=0A=
function markQExceptionHandled(q) {=0A=
  markQStateExceptionHandled(q.$$state);=0A=
}=0A=
=0A=
/** @this */=0A=
function $$RAFProvider() { //rAF=0A=
  this.$get =3D ['$window', '$timeout', function($window, $timeout) {=0A=
    var requestAnimationFrame =3D $window.requestAnimationFrame ||=0A=
                                $window.webkitRequestAnimationFrame;=0A=
=0A=
    var cancelAnimationFrame =3D $window.cancelAnimationFrame ||=0A=
                               $window.webkitCancelAnimationFrame ||=0A=
                               $window.webkitCancelRequestAnimationFrame;=0A=
=0A=
    var rafSupported =3D !!requestAnimationFrame;=0A=
    var raf =3D rafSupported=0A=
      ? function(fn) {=0A=
          var id =3D requestAnimationFrame(fn);=0A=
          return function() {=0A=
            cancelAnimationFrame(id);=0A=
          };=0A=
        }=0A=
      : function(fn) {=0A=
          var timer =3D $timeout(fn, 16.66, false); // 1000 / 60 =3D =
16.666=0A=
          return function() {=0A=
            $timeout.cancel(timer);=0A=
          };=0A=
        };=0A=
=0A=
    raf.supported =3D rafSupported;=0A=
=0A=
    return raf;=0A=
  }];=0A=
}=0A=
=0A=
/**=0A=
 * DESIGN NOTES=0A=
 *=0A=
 * The design decisions behind the scope are heavily favored for speed =
and memory consumption.=0A=
 *=0A=
 * The typical use of scope is to watch the expressions, which most of =
the time return the same=0A=
 * value as last time so we optimize the operation.=0A=
 *=0A=
 * Closures construction is expensive in terms of speed as well as =
memory:=0A=
 *   - No closures, instead use prototypical inheritance for API=0A=
 *   - Internal state needs to be stored on scope directly, which means =
that private state is=0A=
 *     exposed as $$____ properties=0A=
 *=0A=
 * Loop operations are optimized by using while(count--) { ... }=0A=
 *   - This means that in order to keep the same order of execution as =
addition we have to add=0A=
 *     items to the array at the beginning (unshift) instead of at the =
end (push)=0A=
 *=0A=
 * Child scopes are created and removed often=0A=
 *   - Using an array would be slow since inserts in the middle are =
expensive; so we use linked lists=0A=
 *=0A=
 * There are fewer watches than observers. This is why you don't want =
the observer to be implemented=0A=
 * in the same way as watch. Watch requires return of the initialization =
function which is expensive=0A=
 * to construct.=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $rootScopeProvider=0A=
 * @description=0A=
 *=0A=
 * Provider for the $rootScope service.=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $rootScopeProvider#digestTtl=0A=
 * @description=0A=
 *=0A=
 * Sets the number of `$digest` iterations the scope should attempt to =
execute before giving up and=0A=
 * assuming that the model is unstable.=0A=
 *=0A=
 * The current default is 10 iterations.=0A=
 *=0A=
 * In complex applications it's possible that the dependencies between =
`$watch`s will result in=0A=
 * several digest iterations. However if an application needs more than =
the default 10 digest=0A=
 * iterations for its model to stabilize then you should investigate =
what is causing the model to=0A=
 * continuously change during the digest.=0A=
 *=0A=
 * Increasing the TTL could have performance implications, so you should =
not change it without=0A=
 * proper justification.=0A=
 *=0A=
 * @param {number} limit The number of digest iterations.=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $rootScope=0A=
 * @this=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * Every application has a single root {@link ng.$rootScope.Scope scope}.=0A=
 * All other scopes are descendant scopes of the root scope. Scopes =
provide separation=0A=
 * between the model and the view, via a mechanism for watching the =
model for changes.=0A=
 * They also provide event emission/broadcast and subscription facility. =
See the=0A=
 * {@link guide/scope developer guide on scopes}.=0A=
 */=0A=
function $RootScopeProvider() {=0A=
  var TTL =3D 10;=0A=
  var $rootScopeMinErr =3D minErr('$rootScope');=0A=
  var lastDirtyWatch =3D null;=0A=
  var applyAsyncId =3D null;=0A=
=0A=
  this.digestTtl =3D function(value) {=0A=
    if (arguments.length) {=0A=
      TTL =3D value;=0A=
    }=0A=
    return TTL;=0A=
  };=0A=
=0A=
  function createChildScopeClass(parent) {=0A=
    function ChildScope() {=0A=
      this.$$watchers =3D this.$$nextSibling =3D=0A=
          this.$$childHead =3D this.$$childTail =3D null;=0A=
      this.$$listeners =3D {};=0A=
      this.$$listenerCount =3D {};=0A=
      this.$$watchersCount =3D 0;=0A=
      this.$id =3D nextUid();=0A=
      this.$$ChildScope =3D null;=0A=
    }=0A=
    ChildScope.prototype =3D parent;=0A=
    return ChildScope;=0A=
  }=0A=
=0A=
  this.$get =3D ['$exceptionHandler', '$parse', '$browser',=0A=
      function($exceptionHandler, $parse, $browser) {=0A=
=0A=
    function destroyChildScope($event) {=0A=
        $event.currentScope.$$destroyed =3D true;=0A=
    }=0A=
=0A=
    function cleanUpScope($scope) {=0A=
=0A=
      // Support: IE 9 only=0A=
      if (msie =3D=3D=3D 9) {=0A=
        // There is a memory leak in IE9 if all child scopes are not =
disconnected=0A=
        // completely when a scope is destroyed. So this code will =
recurse up through=0A=
        // all this scopes children=0A=
        //=0A=
        // See issue https://github.com/angular/angular.js/issues/10706=0A=
        if ($scope.$$childHead) {=0A=
          cleanUpScope($scope.$$childHead);=0A=
        }=0A=
        if ($scope.$$nextSibling) {=0A=
          cleanUpScope($scope.$$nextSibling);=0A=
        }=0A=
      }=0A=
=0A=
      // The code below works around IE9 and V8's memory leaks=0A=
      //=0A=
      // See:=0A=
      // - https://code.google.com/p/v8/issues/detail?id=3D2073#c26=0A=
      // - =
https://github.com/angular/angular.js/issues/6794#issuecomment-38648909=0A=
      // - =
https://github.com/angular/angular.js/issues/1313#issuecomment-10378451=0A=
=0A=
      $scope.$parent =3D $scope.$$nextSibling =3D $scope.$$prevSibling =
=3D $scope.$$childHead =3D=0A=
          $scope.$$childTail =3D $scope.$root =3D $scope.$$watchers =3D =
null;=0A=
    }=0A=
=0A=
    /**=0A=
     * @ngdoc type=0A=
     * @name $rootScope.Scope=0A=
     *=0A=
     * @description=0A=
     * A root scope can be retrieved using the {@link ng.$rootScope =
$rootScope} key from the=0A=
     * {@link auto.$injector $injector}. Child scopes are created using =
the=0A=
     * {@link ng.$rootScope.Scope#$new $new()} method. (Most scopes are =
created automatically when=0A=
     * compiled HTML template is executed.) See also the {@link =
guide/scope Scopes guide} for=0A=
     * an in-depth introduction and usage examples.=0A=
     *=0A=
     *=0A=
     * # Inheritance=0A=
     * A scope can inherit from a parent scope, as in this example:=0A=
     * ```js=0A=
         var parent =3D $rootScope;=0A=
         var child =3D parent.$new();=0A=
=0A=
         parent.salutation =3D "Hello";=0A=
         expect(child.salutation).toEqual('Hello');=0A=
=0A=
         child.salutation =3D "Welcome";=0A=
         expect(child.salutation).toEqual('Welcome');=0A=
         expect(parent.salutation).toEqual('Hello');=0A=
     * ```=0A=
     *=0A=
     * When interacting with `Scope` in tests, additional helper methods =
are available on the=0A=
     * instances of `Scope` type. See {@link ngMock.$rootScope.Scope =
ngMock Scope} for additional=0A=
     * details.=0A=
     *=0A=
     *=0A=
     * @param {Object.&lt;string, function()&gt;=3D} providers Map of =
service factory which need to be=0A=
     *                                       provided for the current =
scope. Defaults to {@link ng}.=0A=
     * @param {Object.&lt;string, *&gt;=3D} instanceCache Provides =
pre-instantiated services which should=0A=
     *                              append/override services provided by =
`providers`. This is handy=0A=
     *                              when unit-testing and having the =
need to override a default=0A=
     *                              service.=0A=
     * @returns {Object} Newly created scope.=0A=
     *=0A=
     */=0A=
    function Scope() {=0A=
      this.$id =3D nextUid();=0A=
      this.$$phase =3D this.$parent =3D this.$$watchers =3D=0A=
                     this.$$nextSibling =3D this.$$prevSibling =3D=0A=
                     this.$$childHead =3D this.$$childTail =3D null;=0A=
      this.$root =3D this;=0A=
      this.$$destroyed =3D false;=0A=
      this.$$listeners =3D {};=0A=
      this.$$listenerCount =3D {};=0A=
      this.$$watchersCount =3D 0;=0A=
      this.$$isolateBindings =3D null;=0A=
    }=0A=
=0A=
    /**=0A=
     * @ngdoc property=0A=
     * @name $rootScope.Scope#$id=0A=
     *=0A=
     * @description=0A=
     * Unique scope ID (monotonically increasing) useful for debugging.=0A=
     */=0A=
=0A=
     /**=0A=
      * @ngdoc property=0A=
      * @name $rootScope.Scope#$parent=0A=
      *=0A=
      * @description=0A=
      * Reference to the parent scope.=0A=
      */=0A=
=0A=
      /**=0A=
       * @ngdoc property=0A=
       * @name $rootScope.Scope#$root=0A=
       *=0A=
       * @description=0A=
       * Reference to the root scope.=0A=
       */=0A=
=0A=
    Scope.prototype =3D {=0A=
      constructor: Scope,=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$new=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Creates a new child {@link ng.$rootScope.Scope scope}.=0A=
       *=0A=
       * The parent scope will propagate the {@link =
ng.$rootScope.Scope#$digest $digest()} event.=0A=
       * The scope can be removed from the scope hierarchy using {@link =
ng.$rootScope.Scope#$destroy $destroy()}.=0A=
       *=0A=
       * {@link ng.$rootScope.Scope#$destroy $destroy()} must be called =
on a scope when it is=0A=
       * desired for the scope and its child scopes to be permanently =
detached from the parent and=0A=
       * thus stop participating in model change detection and listener =
notification by invoking.=0A=
       *=0A=
       * @param {boolean} isolate If true, then the scope does not =
prototypically inherit from the=0A=
       *         parent scope. The scope is isolated, as it can not see =
parent scope properties.=0A=
       *         When creating widgets, it is useful for the widget to =
not accidentally read parent=0A=
       *         state.=0A=
       *=0A=
       * @param {Scope} [parent=3Dthis] The {@link ng.$rootScope.Scope =
`Scope`} that will be the `$parent`=0A=
       *                              of the newly created scope. =
Defaults to `this` scope if not provided.=0A=
       *                              This is used when creating a =
transclude scope to correctly place it=0A=
       *                              in the scope hierarchy while =
maintaining the correct prototypical=0A=
       *                              inheritance.=0A=
       *=0A=
       * @returns {Object} The newly created child scope.=0A=
       *=0A=
       */=0A=
      $new: function(isolate, parent) {=0A=
        var child;=0A=
=0A=
        parent =3D parent || this;=0A=
=0A=
        if (isolate) {=0A=
          child =3D new Scope();=0A=
          child.$root =3D this.$root;=0A=
        } else {=0A=
          // Only create a child scope class if somebody asks for one,=0A=
          // but cache it to allow the VM to optimize lookups.=0A=
          if (!this.$$ChildScope) {=0A=
            this.$$ChildScope =3D createChildScopeClass(this);=0A=
          }=0A=
          child =3D new this.$$ChildScope();=0A=
        }=0A=
        child.$parent =3D parent;=0A=
        child.$$prevSibling =3D parent.$$childTail;=0A=
        if (parent.$$childHead) {=0A=
          parent.$$childTail.$$nextSibling =3D child;=0A=
          parent.$$childTail =3D child;=0A=
        } else {=0A=
          parent.$$childHead =3D parent.$$childTail =3D child;=0A=
        }=0A=
=0A=
        // When the new scope is not isolated or we inherit from `this`, =
and=0A=
        // the parent scope is destroyed, the property `$$destroyed` is =
inherited=0A=
        // prototypically. In all other cases, this property needs to be =
set=0A=
        // when the parent scope is destroyed.=0A=
        // The listener needs to be added after the parent is set=0A=
        if (isolate || parent !=3D=3D this) child.$on('$destroy', =
destroyChildScope);=0A=
=0A=
        return child;=0A=
      },=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$watch=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Registers a `listener` callback to be executed whenever the =
`watchExpression` changes.=0A=
       *=0A=
       * - The `watchExpression` is called on every call to {@link =
ng.$rootScope.Scope#$digest=0A=
       *   $digest()} and should return the value that will be watched. =
(`watchExpression` should not change=0A=
       *   its value when executed multiple times with the same input =
because it may be executed multiple=0A=
       *   times by {@link ng.$rootScope.Scope#$digest $digest()}. That =
is, `watchExpression` should be=0A=
       *   [idempotent](http://en.wikipedia.org/wiki/Idempotence).)=0A=
       * - The `listener` is called only when the value from the current =
`watchExpression` and the=0A=
       *   previous call to `watchExpression` are not equal (with the =
exception of the initial run,=0A=
       *   see below). Inequality is determined according to reference =
inequality,=0A=
       *   [strict =
comparison](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Refer=
ence/Operators/Comparison_Operators)=0A=
       *    via the `!=3D=3D` Javascript operator, unless =
`objectEquality =3D=3D true`=0A=
       *   (see next point)=0A=
       * - When `objectEquality =3D=3D true`, inequality of the =
`watchExpression` is determined=0A=
       *   according to the {@link angular.equals} function. To save the =
value of the object for=0A=
       *   later comparison, the {@link angular.copy} function is used. =
This therefore means that=0A=
       *   watching complex objects will have adverse memory and =
performance implications.=0A=
       * - This should not be used to watch for changes in objects that =
are=0A=
       *   or contain =
[File](https://developer.mozilla.org/docs/Web/API/File) objects due to =
limitations with {@link angular.copy `angular.copy`}.=0A=
       * - The watch `listener` may change the model, which may trigger =
other `listener`s to fire.=0A=
       *   This is achieved by rerunning the watchers until no changes =
are detected. The rerun=0A=
       *   iteration limit is 10 to prevent an infinite loop deadlock.=0A=
       *=0A=
       *=0A=
       * If you want to be notified whenever {@link =
ng.$rootScope.Scope#$digest $digest} is called,=0A=
       * you can register a `watchExpression` function with no =
`listener`. (Be prepared for=0A=
       * multiple calls to your `watchExpression` because it will =
execute multiple times in a=0A=
       * single {@link ng.$rootScope.Scope#$digest $digest} cycle if a =
change is detected.)=0A=
       *=0A=
       * After a watcher is registered with the scope, the `listener` fn =
is called asynchronously=0A=
       * (via {@link ng.$rootScope.Scope#$evalAsync $evalAsync}) to =
initialize the=0A=
       * watcher. In rare cases, this is undesirable because the =
listener is called when the result=0A=
       * of `watchExpression` didn't change. To detect this scenario =
within the `listener` fn, you=0A=
       * can compare the `newVal` and `oldVal`. If these two values are =
identical (`=3D=3D=3D`) then the=0A=
       * listener was called due to initialization.=0A=
       *=0A=
       *=0A=
       *=0A=
       * # Example=0A=
       * ```js=0A=
           // let's assume that scope was dependency injected as the =
$rootScope=0A=
           var scope =3D $rootScope;=0A=
           scope.name =3D 'misko';=0A=
           scope.counter =3D 0;=0A=
=0A=
           expect(scope.counter).toEqual(0);=0A=
           scope.$watch('name', function(newValue, oldValue) {=0A=
             scope.counter =3D scope.counter + 1;=0A=
           });=0A=
           expect(scope.counter).toEqual(0);=0A=
=0A=
           scope.$digest();=0A=
           // the listener is always called during the first $digest =
loop after it was registered=0A=
           expect(scope.counter).toEqual(1);=0A=
=0A=
           scope.$digest();=0A=
           // but now it will not be called unless the value changes=0A=
           expect(scope.counter).toEqual(1);=0A=
=0A=
           scope.name =3D 'adam';=0A=
           scope.$digest();=0A=
           expect(scope.counter).toEqual(2);=0A=
=0A=
=0A=
=0A=
           // Using a function as a watchExpression=0A=
           var food;=0A=
           scope.foodCounter =3D 0;=0A=
           expect(scope.foodCounter).toEqual(0);=0A=
           scope.$watch(=0A=
             // This function returns the value being watched. It is =
called for each turn of the $digest loop=0A=
             function() { return food; },=0A=
             // This is the change listener, called when the value =
returned from the above function changes=0A=
             function(newValue, oldValue) {=0A=
               if ( newValue !=3D=3D oldValue ) {=0A=
                 // Only increment the counter if the value changed=0A=
                 scope.foodCounter =3D scope.foodCounter + 1;=0A=
               }=0A=
             }=0A=
           );=0A=
           // No digest has been run so the counter will be zero=0A=
           expect(scope.foodCounter).toEqual(0);=0A=
=0A=
           // Run the digest but since food has not changed count will =
still be zero=0A=
           scope.$digest();=0A=
           expect(scope.foodCounter).toEqual(0);=0A=
=0A=
           // Update food and run digest.  Now the counter will increment=0A=
           food =3D 'cheeseburger';=0A=
           scope.$digest();=0A=
           expect(scope.foodCounter).toEqual(1);=0A=
=0A=
       * ```=0A=
       *=0A=
       *=0A=
       *=0A=
       * @param {(function()|string)} watchExpression Expression that is =
evaluated on each=0A=
       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. A change =
in the return value triggers=0A=
       *    a call to the `listener`.=0A=
       *=0A=
       *    - `string`: Evaluated as {@link guide/expression expression}=0A=
       *    - `function(scope)`: called with current `scope` as a =
parameter.=0A=
       * @param {function(newVal, oldVal, scope)} listener Callback =
called whenever the value=0A=
       *    of `watchExpression` changes.=0A=
       *=0A=
       *    - `newVal` contains the current value of the =
`watchExpression`=0A=
       *    - `oldVal` contains the previous value of the =
`watchExpression`=0A=
       *    - `scope` refers to the current scope=0A=
       * @param {boolean=3D} [objectEquality=3Dfalse] Compare for object =
equality using {@link angular.equals} instead of=0A=
       *     comparing for reference equality.=0A=
       * @returns {function()} Returns a deregistration function for =
this listener.=0A=
       */=0A=
      $watch: function(watchExp, listener, objectEquality, =
prettyPrintExpression) {=0A=
        var get =3D $parse(watchExp);=0A=
=0A=
        if (get.$$watchDelegate) {=0A=
          return get.$$watchDelegate(this, listener, objectEquality, =
get, watchExp);=0A=
        }=0A=
        var scope =3D this,=0A=
            array =3D scope.$$watchers,=0A=
            watcher =3D {=0A=
              fn: listener,=0A=
              last: initWatchVal,=0A=
              get: get,=0A=
              exp: prettyPrintExpression || watchExp,=0A=
              eq: !!objectEquality=0A=
            };=0A=
=0A=
        lastDirtyWatch =3D null;=0A=
=0A=
        if (!isFunction(listener)) {=0A=
          watcher.fn =3D noop;=0A=
        }=0A=
=0A=
        if (!array) {=0A=
          array =3D scope.$$watchers =3D [];=0A=
          array.$$digestWatchIndex =3D -1;=0A=
        }=0A=
        // we use unshift since we use a while loop in $digest for speed.=0A=
        // the while loop reads in reverse order.=0A=
        array.unshift(watcher);=0A=
        array.$$digestWatchIndex++;=0A=
        incrementWatchersCount(this, 1);=0A=
=0A=
        return function deregisterWatch() {=0A=
          var index =3D arrayRemove(array, watcher);=0A=
          if (index &gt;=3D 0) {=0A=
            incrementWatchersCount(scope, -1);=0A=
            if (index &lt; array.$$digestWatchIndex) {=0A=
              array.$$digestWatchIndex--;=0A=
            }=0A=
          }=0A=
          lastDirtyWatch =3D null;=0A=
        };=0A=
      },=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$watchGroup=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * A variant of {@link ng.$rootScope.Scope#$watch $watch()} where =
it watches an array of `watchExpressions`.=0A=
       * If any one expression in the collection changes the `listener` =
is executed.=0A=
       *=0A=
       * - The items in the `watchExpressions` array are observed via =
the standard `$watch` operation. Their return=0A=
       *   values are examined for changes on every call to `$digest`.=0A=
       * - The `listener` is called whenever any expression in the =
`watchExpressions` array changes.=0A=
       *=0A=
       * `$watchGroup` is more performant than watching each expression =
individually, and should be=0A=
       * used when the listener does not need to know which expression =
has changed.=0A=
       * If the listener needs to know which expression has changed,=0A=
       * {@link ng.$rootScope.Scope#$watch $watch()} or=0A=
       * {@link ng.$rootScope.Scope#$watchCollection $watchCollection()} =
should be used.=0A=
       *=0A=
       * @param {Array.&lt;string|Function(scope)&gt;} watchExpressions =
Array of expressions that will be individually=0A=
       * watched using {@link ng.$rootScope.Scope#$watch $watch()}=0A=
       *=0A=
       * @param {function(newValues, oldValues, scope)} listener =
Callback called whenever the return value of any=0A=
       *    expression in `watchExpressions` changes=0A=
       *    The `newValues` array contains the current values of the =
`watchExpressions`, with the indexes matching=0A=
       *    those of `watchExpression`=0A=
       *    and the `oldValues` array contains the previous values of =
the `watchExpressions`, with the indexes matching=0A=
       *    those of `watchExpression`.=0A=
       *=0A=
       *    Note that `newValues` and `oldValues` reflect the =
differences in each **individual**=0A=
       *    expression, and not the difference of the values between =
each call of the listener.=0A=
       *    That means the difference between `newValues` and =
`oldValues` cannot be used to determine=0A=
       *    which expression has changed / remained stable:=0A=
       *=0A=
       *    ```js=0A=
       *=0A=
       *    $scope.$watchGroup(['v1', 'v2'], function(newValues, =
oldValues) {=0A=
       *      console.log(newValues, oldValues);=0A=
       *    });=0A=
       *=0A=
       *    // newValues, oldValues initially=0A=
       *    // [undefined, undefined], [undefined, undefined]=0A=
       *=0A=
       *    $scope.v1 =3D 'a';=0A=
       *    $scope.v2 =3D 'a';=0A=
       *=0A=
       *    // ['a', 'a'], [undefined, undefined]=0A=
       *=0A=
       *    $scope.v2 =3D 'b'=0A=
       *=0A=
       *    // v1 hasn't changed since it became `'a'`, therefore its =
oldValue is still `undefined`=0A=
       *    // ['a', 'b'], [undefined, 'a']=0A=
       *=0A=
       *    ```=0A=
       *=0A=
       *    The `scope` refers to the current scope.=0A=
       * @returns {function()} Returns a de-registration function for =
all listeners.=0A=
       */=0A=
      $watchGroup: function(watchExpressions, listener) {=0A=
        var oldValues =3D new Array(watchExpressions.length);=0A=
        var newValues =3D new Array(watchExpressions.length);=0A=
        var deregisterFns =3D [];=0A=
        var self =3D this;=0A=
        var changeReactionScheduled =3D false;=0A=
        var firstRun =3D true;=0A=
=0A=
        if (!watchExpressions.length) {=0A=
          // No expressions means we call the listener ASAP=0A=
          var shouldCall =3D true;=0A=
          self.$evalAsync(function() {=0A=
            if (shouldCall) listener(newValues, newValues, self);=0A=
          });=0A=
          return function deregisterWatchGroup() {=0A=
            shouldCall =3D false;=0A=
          };=0A=
        }=0A=
=0A=
        if (watchExpressions.length =3D=3D=3D 1) {=0A=
          // Special case size of one=0A=
          return this.$watch(watchExpressions[0], function =
watchGroupAction(value, oldValue, scope) {=0A=
            newValues[0] =3D value;=0A=
            oldValues[0] =3D oldValue;=0A=
            listener(newValues, (value =3D=3D=3D oldValue) ? newValues : =
oldValues, scope);=0A=
          });=0A=
        }=0A=
=0A=
        forEach(watchExpressions, function(expr, i) {=0A=
          var unwatchFn =3D self.$watch(expr, function =
watchGroupSubAction(value, oldValue) {=0A=
            newValues[i] =3D value;=0A=
            oldValues[i] =3D oldValue;=0A=
            if (!changeReactionScheduled) {=0A=
              changeReactionScheduled =3D true;=0A=
              self.$evalAsync(watchGroupAction);=0A=
            }=0A=
          });=0A=
          deregisterFns.push(unwatchFn);=0A=
        });=0A=
=0A=
        function watchGroupAction() {=0A=
          changeReactionScheduled =3D false;=0A=
=0A=
          if (firstRun) {=0A=
            firstRun =3D false;=0A=
            listener(newValues, newValues, self);=0A=
          } else {=0A=
            listener(newValues, oldValues, self);=0A=
          }=0A=
        }=0A=
=0A=
        return function deregisterWatchGroup() {=0A=
          while (deregisterFns.length) {=0A=
            deregisterFns.shift()();=0A=
          }=0A=
        };=0A=
      },=0A=
=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$watchCollection=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Shallow watches the properties of an object and fires whenever =
any of the properties change=0A=
       * (for arrays, this implies watching the array items; for object =
maps, this implies watching=0A=
       * the properties). If a change is detected, the `listener` =
callback is fired.=0A=
       *=0A=
       * - The `obj` collection is observed via standard $watch =
operation and is examined on every=0A=
       *   call to $digest() to see if any items have been added, =
removed, or moved.=0A=
       * - The `listener` is called whenever anything within the `obj` =
has changed. Examples include=0A=
       *   adding, removing, and moving items belonging to an object or =
array.=0A=
       *=0A=
       *=0A=
       * # Example=0A=
       * ```js=0A=
          $scope.names =3D ['igor', 'matias', 'misko', 'james'];=0A=
          $scope.dataCount =3D 4;=0A=
=0A=
          $scope.$watchCollection('names', function(newNames, oldNames) {=0A=
            $scope.dataCount =3D newNames.length;=0A=
          });=0A=
=0A=
          expect($scope.dataCount).toEqual(4);=0A=
          $scope.$digest();=0A=
=0A=
          //still at 4 ... no changes=0A=
          expect($scope.dataCount).toEqual(4);=0A=
=0A=
          $scope.names.pop();=0A=
          $scope.$digest();=0A=
=0A=
          //now there's been a change=0A=
          expect($scope.dataCount).toEqual(3);=0A=
       * ```=0A=
       *=0A=
       *=0A=
       * @param {string|function(scope)} obj Evaluated as {@link =
guide/expression expression}. The=0A=
       *    expression value should evaluate to an object or an array =
which is observed on each=0A=
       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. Any =
shallow change within the=0A=
       *    collection will trigger a call to the `listener`.=0A=
       *=0A=
       * @param {function(newCollection, oldCollection, scope)} listener =
a callback function called=0A=
       *    when a change is detected.=0A=
       *    - The `newCollection` object is the newly modified data =
obtained from the `obj` expression=0A=
       *    - The `oldCollection` object is a copy of the former =
collection data.=0A=
       *      Due to performance considerations, the`oldCollection` =
value is computed only if the=0A=
       *      `listener` function declares two or more arguments.=0A=
       *    - The `scope` argument refers to the current scope.=0A=
       *=0A=
       * @returns {function()} Returns a de-registration function for =
this listener. When the=0A=
       *    de-registration function is executed, the internal watch =
operation is terminated.=0A=
       */=0A=
      $watchCollection: function(obj, listener) {=0A=
        $watchCollectionInterceptor.$stateful =3D true;=0A=
=0A=
        var self =3D this;=0A=
        // the current value, updated on each dirty-check run=0A=
        var newValue;=0A=
        // a shallow copy of the newValue from the last dirty-check run,=0A=
        // updated to match newValue during dirty-check run=0A=
        var oldValue;=0A=
        // a shallow copy of the newValue from when the last change =
happened=0A=
        var veryOldValue;=0A=
        // only track veryOldValue if the listener is asking for it=0A=
        var trackVeryOldValue =3D (listener.length &gt; 1);=0A=
        var changeDetected =3D 0;=0A=
        var changeDetector =3D $parse(obj, $watchCollectionInterceptor);=0A=
        var internalArray =3D [];=0A=
        var internalObject =3D {};=0A=
        var initRun =3D true;=0A=
        var oldLength =3D 0;=0A=
=0A=
        function $watchCollectionInterceptor(_value) {=0A=
          newValue =3D _value;=0A=
          var newLength, key, bothNaN, newItem, oldItem;=0A=
=0A=
          // If the new value is undefined, then return undefined as the =
watch may be a one-time watch=0A=
          if (isUndefined(newValue)) return;=0A=
=0A=
          if (!isObject(newValue)) { // if primitive=0A=
            if (oldValue !=3D=3D newValue) {=0A=
              oldValue =3D newValue;=0A=
              changeDetected++;=0A=
            }=0A=
          } else if (isArrayLike(newValue)) {=0A=
            if (oldValue !=3D=3D internalArray) {=0A=
              // we are transitioning from something which was not an =
array into array.=0A=
              oldValue =3D internalArray;=0A=
              oldLength =3D oldValue.length =3D 0;=0A=
              changeDetected++;=0A=
            }=0A=
=0A=
            newLength =3D newValue.length;=0A=
=0A=
            if (oldLength !=3D=3D newLength) {=0A=
              // if lengths do not match we need to trigger change =
notification=0A=
              changeDetected++;=0A=
              oldValue.length =3D oldLength =3D newLength;=0A=
            }=0A=
            // copy the items to oldValue and look for changes.=0A=
            for (var i =3D 0; i &lt; newLength; i++) {=0A=
              oldItem =3D oldValue[i];=0A=
              newItem =3D newValue[i];=0A=
=0A=
              // eslint-disable-next-line no-self-compare=0A=
              bothNaN =3D (oldItem !=3D=3D oldItem) &amp;&amp; (newItem =
!=3D=3D newItem);=0A=
              if (!bothNaN &amp;&amp; (oldItem !=3D=3D newItem)) {=0A=
                changeDetected++;=0A=
                oldValue[i] =3D newItem;=0A=
              }=0A=
            }=0A=
          } else {=0A=
            if (oldValue !=3D=3D internalObject) {=0A=
              // we are transitioning from something which was not an =
object into object.=0A=
              oldValue =3D internalObject =3D {};=0A=
              oldLength =3D 0;=0A=
              changeDetected++;=0A=
            }=0A=
            // copy the items to oldValue and look for changes.=0A=
            newLength =3D 0;=0A=
            for (key in newValue) {=0A=
              if (hasOwnProperty.call(newValue, key)) {=0A=
                newLength++;=0A=
                newItem =3D newValue[key];=0A=
                oldItem =3D oldValue[key];=0A=
=0A=
                if (key in oldValue) {=0A=
                  // eslint-disable-next-line no-self-compare=0A=
                  bothNaN =3D (oldItem !=3D=3D oldItem) &amp;&amp; =
(newItem !=3D=3D newItem);=0A=
                  if (!bothNaN &amp;&amp; (oldItem !=3D=3D newItem)) {=0A=
                    changeDetected++;=0A=
                    oldValue[key] =3D newItem;=0A=
                  }=0A=
                } else {=0A=
                  oldLength++;=0A=
                  oldValue[key] =3D newItem;=0A=
                  changeDetected++;=0A=
                }=0A=
              }=0A=
            }=0A=
            if (oldLength &gt; newLength) {=0A=
              // we used to have more keys, need to find them and =
destroy them.=0A=
              changeDetected++;=0A=
              for (key in oldValue) {=0A=
                if (!hasOwnProperty.call(newValue, key)) {=0A=
                  oldLength--;=0A=
                  delete oldValue[key];=0A=
                }=0A=
              }=0A=
            }=0A=
          }=0A=
          return changeDetected;=0A=
        }=0A=
=0A=
        function $watchCollectionAction() {=0A=
          if (initRun) {=0A=
            initRun =3D false;=0A=
            listener(newValue, newValue, self);=0A=
          } else {=0A=
            listener(newValue, veryOldValue, self);=0A=
          }=0A=
=0A=
          // make a copy for the next time a collection is changed=0A=
          if (trackVeryOldValue) {=0A=
            if (!isObject(newValue)) {=0A=
              //primitive=0A=
              veryOldValue =3D newValue;=0A=
            } else if (isArrayLike(newValue)) {=0A=
              veryOldValue =3D new Array(newValue.length);=0A=
              for (var i =3D 0; i &lt; newValue.length; i++) {=0A=
                veryOldValue[i] =3D newValue[i];=0A=
              }=0A=
            } else { // if object=0A=
              veryOldValue =3D {};=0A=
              for (var key in newValue) {=0A=
                if (hasOwnProperty.call(newValue, key)) {=0A=
                  veryOldValue[key] =3D newValue[key];=0A=
                }=0A=
              }=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        return this.$watch(changeDetector, $watchCollectionAction);=0A=
      },=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$digest=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Processes all of the {@link ng.$rootScope.Scope#$watch =
watchers} of the current scope and=0A=
       * its children. Because a {@link ng.$rootScope.Scope#$watch =
watcher}'s listener can change=0A=
       * the model, the `$digest()` keeps calling the {@link =
ng.$rootScope.Scope#$watch watchers}=0A=
       * until no more listeners are firing. This means that it is =
possible to get into an infinite=0A=
       * loop. This function will throw `'Maximum iteration limit =
exceeded.'` if the number of=0A=
       * iterations exceeds 10.=0A=
       *=0A=
       * Usually, you don't call `$digest()` directly in=0A=
       * {@link ng.directive:ngController controllers} or in=0A=
       * {@link ng.$compileProvider#directive directives}.=0A=
       * Instead, you should call {@link ng.$rootScope.Scope#$apply =
$apply()} (typically from within=0A=
       * a {@link ng.$compileProvider#directive directive}), which will =
force a `$digest()`.=0A=
       *=0A=
       * If you want to be notified whenever `$digest()` is called,=0A=
       * you can register a `watchExpression` function with=0A=
       * {@link ng.$rootScope.Scope#$watch $watch()} with no `listener`.=0A=
       *=0A=
       * In unit tests, you may need to call `$digest()` to simulate the =
scope life cycle.=0A=
       *=0A=
       * # Example=0A=
       * ```js=0A=
           var scope =3D ...;=0A=
           scope.name =3D 'misko';=0A=
           scope.counter =3D 0;=0A=
=0A=
           expect(scope.counter).toEqual(0);=0A=
           scope.$watch('name', function(newValue, oldValue) {=0A=
             scope.counter =3D scope.counter + 1;=0A=
           });=0A=
           expect(scope.counter).toEqual(0);=0A=
=0A=
           scope.$digest();=0A=
           // the listener is always called during the first $digest =
loop after it was registered=0A=
           expect(scope.counter).toEqual(1);=0A=
=0A=
           scope.$digest();=0A=
           // but now it will not be called unless the value changes=0A=
           expect(scope.counter).toEqual(1);=0A=
=0A=
           scope.name =3D 'adam';=0A=
           scope.$digest();=0A=
           expect(scope.counter).toEqual(2);=0A=
       * ```=0A=
       *=0A=
       */=0A=
      $digest: function() {=0A=
        var watch, value, last, fn, get,=0A=
            watchers,=0A=
            dirty, ttl =3D TTL,=0A=
            next, current, target =3D this,=0A=
            watchLog =3D [],=0A=
            logIdx, asyncTask;=0A=
=0A=
        beginPhase('$digest');=0A=
        // Check for changes to browser url that happened in sync before =
the call to $digest=0A=
        $browser.$$checkUrlChange();=0A=
=0A=
        if (this =3D=3D=3D $rootScope &amp;&amp; applyAsyncId !=3D=3D =
null) {=0A=
          // If this is the root scope, and $applyAsync has scheduled a =
deferred $apply(), then=0A=
          // cancel the scheduled $apply and flush the queue of =
expressions to be evaluated.=0A=
          $browser.defer.cancel(applyAsyncId);=0A=
          flushApplyAsync();=0A=
        }=0A=
=0A=
        lastDirtyWatch =3D null;=0A=
=0A=
        do { // "while dirty" loop=0A=
          dirty =3D false;=0A=
          current =3D target;=0A=
=0A=
          // It's safe for asyncQueuePosition to be a local variable =
here because this loop can't=0A=
          // be reentered recursively. Calling $digest from a function =
passed to $evalAsync would=0A=
          // lead to a '$digest already in progress' error.=0A=
          for (var asyncQueuePosition =3D 0; asyncQueuePosition &lt; =
asyncQueue.length; asyncQueuePosition++) {=0A=
            try {=0A=
              asyncTask =3D asyncQueue[asyncQueuePosition];=0A=
              fn =3D asyncTask.fn;=0A=
              fn(asyncTask.scope, asyncTask.locals);=0A=
            } catch (e) {=0A=
              $exceptionHandler(e);=0A=
            }=0A=
            lastDirtyWatch =3D null;=0A=
          }=0A=
          asyncQueue.length =3D 0;=0A=
=0A=
          traverseScopesLoop:=0A=
          do { // "traverse the scopes" loop=0A=
            if ((watchers =3D current.$$watchers)) {=0A=
              // process our watches=0A=
              watchers.$$digestWatchIndex =3D watchers.length;=0A=
              while (watchers.$$digestWatchIndex--) {=0A=
                try {=0A=
                  watch =3D watchers[watchers.$$digestWatchIndex];=0A=
                  // Most common watches are on primitives, in which =
case we can short=0A=
                  // circuit it with =3D=3D=3D operator, only when =
=3D=3D=3D fails do we use .equals=0A=
                  if (watch) {=0A=
                    get =3D watch.get;=0A=
                    if ((value =3D get(current)) !=3D=3D (last =3D =
watch.last) &amp;&amp;=0A=
                        !(watch.eq=0A=
                            ? equals(value, last)=0A=
                            : (isNumberNaN(value) &amp;&amp; =
isNumberNaN(last)))) {=0A=
                      dirty =3D true;=0A=
                      lastDirtyWatch =3D watch;=0A=
                      watch.last =3D watch.eq ? copy(value, null) : =
value;=0A=
                      fn =3D watch.fn;=0A=
                      fn(value, ((last =3D=3D=3D initWatchVal) ? value : =
last), current);=0A=
                      if (ttl &lt; 5) {=0A=
                        logIdx =3D 4 - ttl;=0A=
                        if (!watchLog[logIdx]) watchLog[logIdx] =3D [];=0A=
                        watchLog[logIdx].push({=0A=
                          msg: isFunction(watch.exp) ? 'fn: ' + =
(watch.exp.name || watch.exp.toString()) : watch.exp,=0A=
                          newVal: value,=0A=
                          oldVal: last=0A=
                        });=0A=
                      }=0A=
                    } else if (watch =3D=3D=3D lastDirtyWatch) {=0A=
                      // If the most recently dirty watcher is now =
clean, short circuit since the remaining watchers=0A=
                      // have already been tested.=0A=
                      dirty =3D false;=0A=
                      break traverseScopesLoop;=0A=
                    }=0A=
                  }=0A=
                } catch (e) {=0A=
                  $exceptionHandler(e);=0A=
                }=0A=
              }=0A=
            }=0A=
=0A=
            // Insanity Warning: scope depth-first traversal=0A=
            // yes, this code is a bit crazy, but it works and we have =
tests to prove it!=0A=
            // this piece should be kept in sync with the traversal in =
$broadcast=0A=
            if (!(next =3D ((current.$$watchersCount &amp;&amp; =
current.$$childHead) ||=0A=
                (current !=3D=3D target &amp;&amp; =
current.$$nextSibling)))) {=0A=
              while (current !=3D=3D target &amp;&amp; !(next =3D =
current.$$nextSibling)) {=0A=
                current =3D current.$parent;=0A=
              }=0A=
            }=0A=
          } while ((current =3D next));=0A=
=0A=
          // `break traverseScopesLoop;` takes us to here=0A=
=0A=
          if ((dirty || asyncQueue.length) &amp;&amp; !(ttl--)) {=0A=
            clearPhase();=0A=
            throw $rootScopeMinErr('infdig',=0A=
                '{0} $digest() iterations reached. Aborting!\n' +=0A=
                'Watchers fired in the last 5 iterations: {1}',=0A=
                TTL, watchLog);=0A=
          }=0A=
=0A=
        } while (dirty || asyncQueue.length);=0A=
=0A=
        clearPhase();=0A=
=0A=
        // postDigestQueuePosition isn't local here because this loop =
can be reentered recursively.=0A=
        while (postDigestQueuePosition &lt; postDigestQueue.length) {=0A=
          try {=0A=
            postDigestQueue[postDigestQueuePosition++]();=0A=
          } catch (e) {=0A=
            $exceptionHandler(e);=0A=
          }=0A=
        }=0A=
        postDigestQueue.length =3D postDigestQueuePosition =3D 0;=0A=
=0A=
        // Check for changes to browser url that happened during the =
$digest=0A=
        // (for which no event is fired; e.g. via `history.pushState()`)=0A=
        $browser.$$checkUrlChange();=0A=
      },=0A=
=0A=
=0A=
      /**=0A=
       * @ngdoc event=0A=
       * @name $rootScope.Scope#$destroy=0A=
       * @eventType broadcast on scope being destroyed=0A=
       *=0A=
       * @description=0A=
       * Broadcasted when a scope and its children are being destroyed.=0A=
       *=0A=
       * Note that, in AngularJS, there is also a `$destroy` jQuery =
event, which can be used to=0A=
       * clean up DOM bindings before an element is removed from the DOM.=0A=
       */=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$destroy=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Removes the current scope (and all of its children) from the =
parent scope. Removal implies=0A=
       * that calls to {@link ng.$rootScope.Scope#$digest $digest()} =
will no longer=0A=
       * propagate to the current scope and its children. Removal also =
implies that the current=0A=
       * scope is eligible for garbage collection.=0A=
       *=0A=
       * The `$destroy()` is usually used by directives such as=0A=
       * {@link ng.directive:ngRepeat ngRepeat} for managing the=0A=
       * unrolling of the loop.=0A=
       *=0A=
       * Just before a scope is destroyed, a `$destroy` event is =
broadcasted on this scope.=0A=
       * Application code can register a `$destroy` event handler that =
will give it a chance to=0A=
       * perform any necessary cleanup.=0A=
       *=0A=
       * Note that, in AngularJS, there is also a `$destroy` jQuery =
event, which can be used to=0A=
       * clean up DOM bindings before an element is removed from the DOM.=0A=
       */=0A=
      $destroy: function() {=0A=
        // We can't destroy a scope that has been already destroyed.=0A=
        if (this.$$destroyed) return;=0A=
        var parent =3D this.$parent;=0A=
=0A=
        this.$broadcast('$destroy');=0A=
        this.$$destroyed =3D true;=0A=
=0A=
        if (this =3D=3D=3D $rootScope) {=0A=
          //Remove handlers attached to window when $rootScope is removed=0A=
          $browser.$$applicationDestroyed();=0A=
        }=0A=
=0A=
        incrementWatchersCount(this, -this.$$watchersCount);=0A=
        for (var eventName in this.$$listenerCount) {=0A=
          decrementListenerCount(this, this.$$listenerCount[eventName], =
eventName);=0A=
        }=0A=
=0A=
        // sever all the references to parent scopes (after this =
cleanup, the current scope should=0A=
        // not be retained by any of our references and should be =
eligible for garbage collection)=0A=
        if (parent &amp;&amp; parent.$$childHead =3D=3D=3D this) =
parent.$$childHead =3D this.$$nextSibling;=0A=
        if (parent &amp;&amp; parent.$$childTail =3D=3D=3D this) =
parent.$$childTail =3D this.$$prevSibling;=0A=
        if (this.$$prevSibling) this.$$prevSibling.$$nextSibling =3D =
this.$$nextSibling;=0A=
        if (this.$$nextSibling) this.$$nextSibling.$$prevSibling =3D =
this.$$prevSibling;=0A=
=0A=
        // Disable listeners, watchers and apply/digest methods=0A=
        this.$destroy =3D this.$digest =3D this.$apply =3D =
this.$evalAsync =3D this.$applyAsync =3D noop;=0A=
        this.$on =3D this.$watch =3D this.$watchGroup =3D function() { =
return noop; };=0A=
        this.$$listeners =3D {};=0A=
=0A=
        // Disconnect the next sibling to prevent `cleanUpScope` =
destroying those too=0A=
        this.$$nextSibling =3D null;=0A=
        cleanUpScope(this);=0A=
      },=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$eval=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Executes the `expression` on the current scope and returns the =
result. Any exceptions in=0A=
       * the expression are propagated (uncaught). This is useful when =
evaluating Angular=0A=
       * expressions.=0A=
       *=0A=
       * # Example=0A=
       * ```js=0A=
           var scope =3D ng.$rootScope.Scope();=0A=
           scope.a =3D 1;=0A=
           scope.b =3D 2;=0A=
=0A=
           expect(scope.$eval('a+b')).toEqual(3);=0A=
           expect(scope.$eval(function(scope){ return scope.a + scope.b; =
})).toEqual(3);=0A=
       * ```=0A=
       *=0A=
       * @param {(string|function())=3D} expression An angular =
expression to be executed.=0A=
       *=0A=
       *    - `string`: execute using the rules as defined in  {@link =
guide/expression expression}.=0A=
       *    - `function(scope)`: execute the function with the current =
`scope` parameter.=0A=
       *=0A=
       * @param {(object)=3D} locals Local variables object, useful for =
overriding values in scope.=0A=
       * @returns {*} The result of evaluating the expression.=0A=
       */=0A=
      $eval: function(expr, locals) {=0A=
        return $parse(expr)(this, locals);=0A=
      },=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$evalAsync=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Executes the expression on the current scope at a later point =
in time.=0A=
       *=0A=
       * The `$evalAsync` makes no guarantees as to when the =
`expression` will be executed, only=0A=
       * that:=0A=
       *=0A=
       *   - it will execute after the function that scheduled the =
evaluation (preferably before DOM=0A=
       *     rendering).=0A=
       *   - at least one {@link ng.$rootScope.Scope#$digest $digest =
cycle} will be performed after=0A=
       *     `expression` execution.=0A=
       *=0A=
       * Any exceptions from the execution of the expression are =
forwarded to the=0A=
       * {@link ng.$exceptionHandler $exceptionHandler} service.=0A=
       *=0A=
       * __Note:__ if this function is called outside of a `$digest` =
cycle, a new `$digest` cycle=0A=
       * will be scheduled. However, it is encouraged to always call =
code that changes the model=0A=
       * from within an `$apply` call. That includes code evaluated via =
`$evalAsync`.=0A=
       *=0A=
       * @param {(string|function())=3D} expression An angular =
expression to be executed.=0A=
       *=0A=
       *    - `string`: execute using the rules as defined in {@link =
guide/expression expression}.=0A=
       *    - `function(scope)`: execute the function with the current =
`scope` parameter.=0A=
       *=0A=
       * @param {(object)=3D} locals Local variables object, useful for =
overriding values in scope.=0A=
       */=0A=
      $evalAsync: function(expr, locals) {=0A=
        // if we are outside of an $digest loop and this is the first =
time we are scheduling async=0A=
        // task also schedule async auto-flush=0A=
        if (!$rootScope.$$phase &amp;&amp; !asyncQueue.length) {=0A=
          $browser.defer(function() {=0A=
            if (asyncQueue.length) {=0A=
              $rootScope.$digest();=0A=
            }=0A=
          });=0A=
        }=0A=
=0A=
        asyncQueue.push({scope: this, fn: $parse(expr), locals: locals});=0A=
      },=0A=
=0A=
      $$postDigest: function(fn) {=0A=
        postDigestQueue.push(fn);=0A=
      },=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$apply=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * `$apply()` is used to execute an expression in angular from =
outside of the angular=0A=
       * framework. (For example from browser DOM events, setTimeout, =
XHR or third party libraries).=0A=
       * Because we are calling into the angular framework we need to =
perform proper scope life=0A=
       * cycle of {@link ng.$exceptionHandler exception handling},=0A=
       * {@link ng.$rootScope.Scope#$digest executing watches}.=0A=
       *=0A=
       * ## Life cycle=0A=
       *=0A=
       * # Pseudo-Code of `$apply()`=0A=
       * ```js=0A=
           function $apply(expr) {=0A=
             try {=0A=
               return $eval(expr);=0A=
             } catch (e) {=0A=
               $exceptionHandler(e);=0A=
             } finally {=0A=
               $root.$digest();=0A=
             }=0A=
           }=0A=
       * ```=0A=
       *=0A=
       *=0A=
       * Scope's `$apply()` method transitions through the following =
stages:=0A=
       *=0A=
       * 1. The {@link guide/expression expression} is executed using the=0A=
       *    {@link ng.$rootScope.Scope#$eval $eval()} method.=0A=
       * 2. Any exceptions from the execution of the expression are =
forwarded to the=0A=
       *    {@link ng.$exceptionHandler $exceptionHandler} service.=0A=
       * 3. The {@link ng.$rootScope.Scope#$watch watch} listeners are =
fired immediately after the=0A=
       *    expression was executed using the {@link =
ng.$rootScope.Scope#$digest $digest()} method.=0A=
       *=0A=
       *=0A=
       * @param {(string|function())=3D} exp An angular expression to be =
executed.=0A=
       *=0A=
       *    - `string`: execute using the rules as defined in {@link =
guide/expression expression}.=0A=
       *    - `function(scope)`: execute the function with current =
`scope` parameter.=0A=
       *=0A=
       * @returns {*} The result of evaluating the expression.=0A=
       */=0A=
      $apply: function(expr) {=0A=
        try {=0A=
          beginPhase('$apply');=0A=
          try {=0A=
            return this.$eval(expr);=0A=
          } finally {=0A=
            clearPhase();=0A=
          }=0A=
        } catch (e) {=0A=
          $exceptionHandler(e);=0A=
        } finally {=0A=
          try {=0A=
            $rootScope.$digest();=0A=
          } catch (e) {=0A=
            $exceptionHandler(e);=0A=
            // eslint-disable-next-line no-unsafe-finally=0A=
            throw e;=0A=
          }=0A=
        }=0A=
      },=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$applyAsync=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Schedule the invocation of $apply to occur at a later time. The =
actual time difference=0A=
       * varies across browsers, but is typically around ~10 =
milliseconds.=0A=
       *=0A=
       * This can be used to queue up multiple expressions which need to =
be evaluated in the same=0A=
       * digest.=0A=
       *=0A=
       * @param {(string|function())=3D} exp An angular expression to be =
executed.=0A=
       *=0A=
       *    - `string`: execute using the rules as defined in {@link =
guide/expression expression}.=0A=
       *    - `function(scope)`: execute the function with current =
`scope` parameter.=0A=
       */=0A=
      $applyAsync: function(expr) {=0A=
        var scope =3D this;=0A=
        if (expr) {=0A=
          applyAsyncQueue.push($applyAsyncExpression);=0A=
        }=0A=
        expr =3D $parse(expr);=0A=
        scheduleApplyAsync();=0A=
=0A=
        function $applyAsyncExpression() {=0A=
          scope.$eval(expr);=0A=
        }=0A=
      },=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$on=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Listens on events of a given type. See {@link =
ng.$rootScope.Scope#$emit $emit} for=0A=
       * discussion of event life cycle.=0A=
       *=0A=
       * The event listener function format is: `function(event, =
args...)`. The `event` object=0A=
       * passed into the listener has the following attributes:=0A=
       *=0A=
       *   - `targetScope` - `{Scope}`: the scope on which the event was =
`$emit`-ed or=0A=
       *     `$broadcast`-ed.=0A=
       *   - `currentScope` - `{Scope}`: the scope that is currently =
handling the event. Once the=0A=
       *     event propagates through the scope hierarchy, this property =
is set to null.=0A=
       *   - `name` - `{string}`: name of the event.=0A=
       *   - `stopPropagation` - `{function=3D}`: calling =
`stopPropagation` function will cancel=0A=
       *     further event propagation (available only for events that =
were `$emit`-ed).=0A=
       *   - `preventDefault` - `{function}`: calling `preventDefault` =
sets `defaultPrevented` flag=0A=
       *     to true.=0A=
       *   - `defaultPrevented` - `{boolean}`: true if `preventDefault` =
was called.=0A=
       *=0A=
       * @param {string} name Event name to listen on.=0A=
       * @param {function(event, ...args)} listener Function to call =
when the event is emitted.=0A=
       * @returns {function()} Returns a deregistration function for =
this listener.=0A=
       */=0A=
      $on: function(name, listener) {=0A=
        var namedListeners =3D this.$$listeners[name];=0A=
        if (!namedListeners) {=0A=
          this.$$listeners[name] =3D namedListeners =3D [];=0A=
        }=0A=
        namedListeners.push(listener);=0A=
=0A=
        var current =3D this;=0A=
        do {=0A=
          if (!current.$$listenerCount[name]) {=0A=
            current.$$listenerCount[name] =3D 0;=0A=
          }=0A=
          current.$$listenerCount[name]++;=0A=
        } while ((current =3D current.$parent));=0A=
=0A=
        var self =3D this;=0A=
        return function() {=0A=
          var indexOfListener =3D namedListeners.indexOf(listener);=0A=
          if (indexOfListener !=3D=3D -1) {=0A=
            namedListeners[indexOfListener] =3D null;=0A=
            decrementListenerCount(self, 1, name);=0A=
          }=0A=
        };=0A=
      },=0A=
=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$emit=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Dispatches an event `name` upwards through the scope hierarchy =
notifying the=0A=
       * registered {@link ng.$rootScope.Scope#$on} listeners.=0A=
       *=0A=
       * The event life cycle starts at the scope on which `$emit` was =
called. All=0A=
       * {@link ng.$rootScope.Scope#$on listeners} listening for `name` =
event on this scope get=0A=
       * notified. Afterwards, the event traverses upwards toward the =
root scope and calls all=0A=
       * registered listeners along the way. The event will stop =
propagating if one of the listeners=0A=
       * cancels it.=0A=
       *=0A=
       * Any exception emitted from the {@link ng.$rootScope.Scope#$on =
listeners} will be passed=0A=
       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.=0A=
       *=0A=
       * @param {string} name Event name to emit.=0A=
       * @param {...*} args Optional one or more arguments which will be =
passed onto the event listeners.=0A=
       * @return {Object} Event object (see {@link =
ng.$rootScope.Scope#$on}).=0A=
       */=0A=
      $emit: function(name, args) {=0A=
        var empty =3D [],=0A=
            namedListeners,=0A=
            scope =3D this,=0A=
            stopPropagation =3D false,=0A=
            event =3D {=0A=
              name: name,=0A=
              targetScope: scope,=0A=
              stopPropagation: function() {stopPropagation =3D true;},=0A=
              preventDefault: function() {=0A=
                event.defaultPrevented =3D true;=0A=
              },=0A=
              defaultPrevented: false=0A=
            },=0A=
            listenerArgs =3D concat([event], arguments, 1),=0A=
            i, length;=0A=
=0A=
        do {=0A=
          namedListeners =3D scope.$$listeners[name] || empty;=0A=
          event.currentScope =3D scope;=0A=
          for (i =3D 0, length =3D namedListeners.length; i &lt; length; =
i++) {=0A=
=0A=
            // if listeners were deregistered, defragment the array=0A=
            if (!namedListeners[i]) {=0A=
              namedListeners.splice(i, 1);=0A=
              i--;=0A=
              length--;=0A=
              continue;=0A=
            }=0A=
            try {=0A=
              //allow all listeners attached to the current scope to run=0A=
              namedListeners[i].apply(null, listenerArgs);=0A=
            } catch (e) {=0A=
              $exceptionHandler(e);=0A=
            }=0A=
          }=0A=
          //if any listener on the current scope stops propagation, =
prevent bubbling=0A=
          if (stopPropagation) {=0A=
            event.currentScope =3D null;=0A=
            return event;=0A=
          }=0A=
          //traverse upwards=0A=
          scope =3D scope.$parent;=0A=
        } while (scope);=0A=
=0A=
        event.currentScope =3D null;=0A=
=0A=
        return event;=0A=
      },=0A=
=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$broadcast=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Dispatches an event `name` downwards to all child scopes (and =
their children) notifying the=0A=
       * registered {@link ng.$rootScope.Scope#$on} listeners.=0A=
       *=0A=
       * The event life cycle starts at the scope on which `$broadcast` =
was called. All=0A=
       * {@link ng.$rootScope.Scope#$on listeners} listening for `name` =
event on this scope get=0A=
       * notified. Afterwards, the event propagates to all direct and =
indirect scopes of the current=0A=
       * scope and calls all registered listeners along the way. The =
event cannot be canceled.=0A=
       *=0A=
       * Any exception emitted from the {@link ng.$rootScope.Scope#$on =
listeners} will be passed=0A=
       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.=0A=
       *=0A=
       * @param {string} name Event name to broadcast.=0A=
       * @param {...*} args Optional one or more arguments which will be =
passed onto the event listeners.=0A=
       * @return {Object} Event object, see {@link =
ng.$rootScope.Scope#$on}=0A=
       */=0A=
      $broadcast: function(name, args) {=0A=
        var target =3D this,=0A=
            current =3D target,=0A=
            next =3D target,=0A=
            event =3D {=0A=
              name: name,=0A=
              targetScope: target,=0A=
              preventDefault: function() {=0A=
                event.defaultPrevented =3D true;=0A=
              },=0A=
              defaultPrevented: false=0A=
            };=0A=
=0A=
        if (!target.$$listenerCount[name]) return event;=0A=
=0A=
        var listenerArgs =3D concat([event], arguments, 1),=0A=
            listeners, i, length;=0A=
=0A=
        //down while you can, then up and next sibling or up and next =
sibling until back at root=0A=
        while ((current =3D next)) {=0A=
          event.currentScope =3D current;=0A=
          listeners =3D current.$$listeners[name] || [];=0A=
          for (i =3D 0, length =3D listeners.length; i &lt; length; i++) =
{=0A=
            // if listeners were deregistered, defragment the array=0A=
            if (!listeners[i]) {=0A=
              listeners.splice(i, 1);=0A=
              i--;=0A=
              length--;=0A=
              continue;=0A=
            }=0A=
=0A=
            try {=0A=
              listeners[i].apply(null, listenerArgs);=0A=
            } catch (e) {=0A=
              $exceptionHandler(e);=0A=
            }=0A=
          }=0A=
=0A=
          // Insanity Warning: scope depth-first traversal=0A=
          // yes, this code is a bit crazy, but it works and we have =
tests to prove it!=0A=
          // this piece should be kept in sync with the traversal in =
$digest=0A=
          // (though it differs due to having the extra check for =
$$listenerCount)=0A=
          if (!(next =3D ((current.$$listenerCount[name] &amp;&amp; =
current.$$childHead) ||=0A=
              (current !=3D=3D target &amp;&amp; =
current.$$nextSibling)))) {=0A=
            while (current !=3D=3D target &amp;&amp; !(next =3D =
current.$$nextSibling)) {=0A=
              current =3D current.$parent;=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        event.currentScope =3D null;=0A=
        return event;=0A=
      }=0A=
    };=0A=
=0A=
    var $rootScope =3D new Scope();=0A=
=0A=
    //The internal queues. Expose them on the $rootScope for =
debugging/testing purposes.=0A=
    var asyncQueue =3D $rootScope.$$asyncQueue =3D [];=0A=
    var postDigestQueue =3D $rootScope.$$postDigestQueue =3D [];=0A=
    var applyAsyncQueue =3D $rootScope.$$applyAsyncQueue =3D [];=0A=
=0A=
    var postDigestQueuePosition =3D 0;=0A=
=0A=
    return $rootScope;=0A=
=0A=
=0A=
    function beginPhase(phase) {=0A=
      if ($rootScope.$$phase) {=0A=
        throw $rootScopeMinErr('inprog', '{0} already in progress', =
$rootScope.$$phase);=0A=
      }=0A=
=0A=
      $rootScope.$$phase =3D phase;=0A=
    }=0A=
=0A=
    function clearPhase() {=0A=
      $rootScope.$$phase =3D null;=0A=
    }=0A=
=0A=
    function incrementWatchersCount(current, count) {=0A=
      do {=0A=
        current.$$watchersCount +=3D count;=0A=
      } while ((current =3D current.$parent));=0A=
    }=0A=
=0A=
    function decrementListenerCount(current, count, name) {=0A=
      do {=0A=
        current.$$listenerCount[name] -=3D count;=0A=
=0A=
        if (current.$$listenerCount[name] =3D=3D=3D 0) {=0A=
          delete current.$$listenerCount[name];=0A=
        }=0A=
      } while ((current =3D current.$parent));=0A=
    }=0A=
=0A=
    /**=0A=
     * function used as an initial value for watchers.=0A=
     * because it's unique we can easily tell it apart from other values=0A=
     */=0A=
    function initWatchVal() {}=0A=
=0A=
    function flushApplyAsync() {=0A=
      while (applyAsyncQueue.length) {=0A=
        try {=0A=
          applyAsyncQueue.shift()();=0A=
        } catch (e) {=0A=
          $exceptionHandler(e);=0A=
        }=0A=
      }=0A=
      applyAsyncId =3D null;=0A=
    }=0A=
=0A=
    function scheduleApplyAsync() {=0A=
      if (applyAsyncId =3D=3D=3D null) {=0A=
        applyAsyncId =3D $browser.defer(function() {=0A=
          $rootScope.$apply(flushApplyAsync);=0A=
        });=0A=
      }=0A=
    }=0A=
  }];=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $rootElement=0A=
 *=0A=
 * @description=0A=
 * The root element of Angular application. This is either the element =
where {@link=0A=
 * ng.directive:ngApp ngApp} was declared or the element passed into=0A=
 * {@link angular.bootstrap}. The element represents the root element of =
application. It is also the=0A=
 * location where the application's {@link auto.$injector $injector} =
service gets=0A=
 * published, and can be retrieved using `$rootElement.injector()`.=0A=
 */=0A=
=0A=
=0A=
// the implementation is in angular.bootstrap=0A=
=0A=
/**=0A=
 * @this=0A=
 * @description=0A=
 * Private service to sanitize uris for links and images. Used by =
$compile and $sanitize.=0A=
 */=0A=
function $$SanitizeUriProvider() {=0A=
  var aHrefSanitizationWhitelist =3D /^\s*(https?|ftp|mailto|tel|file):/,=0A=
    imgSrcSanitizationWhitelist =3D =
/^\s*((https?|ftp|file|blob):|data:image\/)/;=0A=
=0A=
  /**=0A=
   * @description=0A=
   * Retrieves or overrides the default regular expression that is used =
for whitelisting of safe=0A=
   * urls during a[href] sanitization.=0A=
   *=0A=
   * The sanitization is a security measure aimed at prevent XSS attacks =
via html links.=0A=
   *=0A=
   * Any url about to be assigned to a[href] via data-binding is first =
normalized and turned into=0A=
   * an absolute url. Afterwards, the url is matched against the =
`aHrefSanitizationWhitelist`=0A=
   * regular expression. If a match is found, the original url is =
written into the dom. Otherwise,=0A=
   * the absolute url is prefixed with `'unsafe:'` string and only then =
is it written into the DOM.=0A=
   *=0A=
   * @param {RegExp=3D} regexp New regexp to whitelist urls with.=0A=
   * @returns {RegExp|ng.$compileProvider} Current RegExp if called =
without value or self for=0A=
   *    chaining otherwise.=0A=
   */=0A=
  this.aHrefSanitizationWhitelist =3D function(regexp) {=0A=
    if (isDefined(regexp)) {=0A=
      aHrefSanitizationWhitelist =3D regexp;=0A=
      return this;=0A=
    }=0A=
    return aHrefSanitizationWhitelist;=0A=
  };=0A=
=0A=
=0A=
  /**=0A=
   * @description=0A=
   * Retrieves or overrides the default regular expression that is used =
for whitelisting of safe=0A=
   * urls during img[src] sanitization.=0A=
   *=0A=
   * The sanitization is a security measure aimed at prevent XSS attacks =
via html links.=0A=
   *=0A=
   * Any url about to be assigned to img[src] via data-binding is first =
normalized and turned into=0A=
   * an absolute url. Afterwards, the url is matched against the =
`imgSrcSanitizationWhitelist`=0A=
   * regular expression. If a match is found, the original url is =
written into the dom. Otherwise,=0A=
   * the absolute url is prefixed with `'unsafe:'` string and only then =
is it written into the DOM.=0A=
   *=0A=
   * @param {RegExp=3D} regexp New regexp to whitelist urls with.=0A=
   * @returns {RegExp|ng.$compileProvider} Current RegExp if called =
without value or self for=0A=
   *    chaining otherwise.=0A=
   */=0A=
  this.imgSrcSanitizationWhitelist =3D function(regexp) {=0A=
    if (isDefined(regexp)) {=0A=
      imgSrcSanitizationWhitelist =3D regexp;=0A=
      return this;=0A=
    }=0A=
    return imgSrcSanitizationWhitelist;=0A=
  };=0A=
=0A=
  this.$get =3D function() {=0A=
    return function sanitizeUri(uri, isImage) {=0A=
      var regex =3D isImage ? imgSrcSanitizationWhitelist : =
aHrefSanitizationWhitelist;=0A=
      var normalizedVal;=0A=
      normalizedVal =3D urlResolve(uri).href;=0A=
      if (normalizedVal !=3D=3D '' &amp;&amp; =
!normalizedVal.match(regex)) {=0A=
        return 'unsafe:' + normalizedVal;=0A=
      }=0A=
      return uri;=0A=
    };=0A=
  };=0A=
}=0A=
=0A=
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * =
* *=0A=
 *     Any commits to this file should be reviewed with security in =
mind.  *=0A=
 *   Changes to this file can potentially create security =
vulnerabilities. *=0A=
 *          An approval from 2 Core members with history of modifying    =
  *=0A=
 *                         this file is required.                        =
  *=0A=
 *                                                                       =
  *=0A=
 *  Does the change somehow allow for arbitrary javascript to be =
executed? *=0A=
 *    Or allows for someone to change the prototype of built-in objects? =
  *=0A=
 *     Or gives undesired access to variables likes document or window?  =
  *=0A=
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * =
* */=0A=
=0A=
/* exported $SceProvider, $SceDelegateProvider */=0A=
=0A=
var $sceMinErr =3D minErr('$sce');=0A=
=0A=
var SCE_CONTEXTS =3D {=0A=
  // HTML is used when there's HTML rendered (e.g. ng-bind-html, iframe =
srcdoc binding).=0A=
  HTML: 'html',=0A=
=0A=
  // Style statements or stylesheets. Currently unused in AngularJS.=0A=
  CSS: 'css',=0A=
=0A=
  // An URL used in a context where it does not refer to a resource that =
loads code. Currently=0A=
  // unused in AngularJS.=0A=
  URL: 'url',=0A=
=0A=
  // RESOURCE_URL is a subtype of URL used where the referred-to =
resource could be interpreted as=0A=
  // code. (e.g. ng-include, script src binding, templateUrl)=0A=
  RESOURCE_URL: 'resourceUrl',=0A=
=0A=
  // Script. Currently unused in AngularJS.=0A=
  JS: 'js'=0A=
};=0A=
=0A=
// Helper functions follow.=0A=
=0A=
var UNDERSCORE_LOWERCASE_REGEXP =3D /_([a-z])/g;=0A=
=0A=
function snakeToCamel(name) {=0A=
  return name=0A=
    .replace(UNDERSCORE_LOWERCASE_REGEXP, fnCamelCaseReplace);=0A=
}=0A=
=0A=
function adjustMatcher(matcher) {=0A=
  if (matcher =3D=3D=3D 'self') {=0A=
    return matcher;=0A=
  } else if (isString(matcher)) {=0A=
    // Strings match exactly except for 2 wildcards - '*' and '**'.=0A=
    // '*' matches any character except those from the set ':/.?&amp;'.=0A=
    // '**' matches any character (like .* in a RegExp).=0A=
    // More than 2 *'s raises an error as it's ill defined.=0A=
    if (matcher.indexOf('***') &gt; -1) {=0A=
      throw $sceMinErr('iwcard',=0A=
          'Illegal sequence *** in string matcher.  String: {0}', =
matcher);=0A=
    }=0A=
    matcher =3D escapeForRegexp(matcher).=0A=
                  replace(/\\\*\\\*/g, '.*').=0A=
                  replace(/\\\*/g, '[^:/.?&amp;;]*');=0A=
    return new RegExp('^' + matcher + '$');=0A=
  } else if (isRegExp(matcher)) {=0A=
    // The only other type of matcher allowed is a Regexp.=0A=
    // Match entire URL / disallow partial matches.=0A=
    // Flags are reset (i.e. no global, ignoreCase or multiline)=0A=
    return new RegExp('^' + matcher.source + '$');=0A=
  } else {=0A=
    throw $sceMinErr('imatcher',=0A=
        'Matchers may only be "self", string patterns or RegExp =
objects');=0A=
  }=0A=
}=0A=
=0A=
=0A=
function adjustMatchers(matchers) {=0A=
  var adjustedMatchers =3D [];=0A=
  if (isDefined(matchers)) {=0A=
    forEach(matchers, function(matcher) {=0A=
      adjustedMatchers.push(adjustMatcher(matcher));=0A=
    });=0A=
  }=0A=
  return adjustedMatchers;=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $sceDelegate=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * `$sceDelegate` is a service that is used by the `$sce` service to =
provide {@link ng.$sce Strict=0A=
 * Contextual Escaping (SCE)} services to AngularJS.=0A=
 *=0A=
 * For an overview of this service and the functionnality it provides in =
AngularJS, see the main=0A=
 * page for {@link ng.$sce SCE}. The current page is targeted for =
developers who need to alter how=0A=
 * SCE works in their application, which shouldn't be needed in most =
cases.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-danger"&gt;=0A=
 * AngularJS strongly relies on contextual escaping for the security of =
bindings: disabling or=0A=
 * modifying this might cause cross site scripting (XSS) =
vulnerabilities. For libraries owners,=0A=
 * changes to this service will also influence users, so be extra =
careful and document your changes.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * Typically, you would configure or override the {@link ng.$sceDelegate =
$sceDelegate} instead of=0A=
 * the `$sce` service to customize the way Strict Contextual Escaping =
works in AngularJS.  This is=0A=
 * because, while the `$sce` provides numerous shorthand methods, etc., =
you really only need to=0A=
 * override 3 core functions (`trustAs`, `getTrusted` and `valueOf`) to =
replace the way things=0A=
 * work because `$sce` delegates to `$sceDelegate` for these operations.=0A=
 *=0A=
 * Refer {@link ng.$sceDelegateProvider $sceDelegateProvider} to =
configure this service.=0A=
 *=0A=
 * The default instance of `$sceDelegate` should work out of the box =
with little pain.  While you=0A=
 * can override it completely to change the behavior of `$sce`, the =
common case would=0A=
 * involve configuring the {@link ng.$sceDelegateProvider =
$sceDelegateProvider} instead by setting=0A=
 * your own whitelists and blacklists for trusting URLs used for loading =
AngularJS resources such as=0A=
 * templates.  Refer {@link ng.$sceDelegateProvider#resourceUrlWhitelist=0A=
 * $sceDelegateProvider.resourceUrlWhitelist} and {@link=0A=
 * ng.$sceDelegateProvider#resourceUrlBlacklist =
$sceDelegateProvider.resourceUrlBlacklist}=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $sceDelegateProvider=0A=
 * @this=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * The `$sceDelegateProvider` provider allows developers to configure =
the {@link ng.$sceDelegate=0A=
 * $sceDelegate service}, used as a delegate for {@link ng.$sce Strict =
Contextual Escaping (SCE)}.=0A=
 *=0A=
 * The `$sceDelegateProvider` allows one to get/set the whitelists and =
blacklists used to ensure=0A=
 * that the URLs used for sourcing AngularJS templates and other =
script-running URLs are safe (all=0A=
 * places that use the `$sce.RESOURCE_URL` context). See=0A=
 * {@link ng.$sceDelegateProvider#resourceUrlWhitelist =
$sceDelegateProvider.resourceUrlWhitelist}=0A=
 * and=0A=
 * {@link ng.$sceDelegateProvider#resourceUrlBlacklist =
$sceDelegateProvider.resourceUrlBlacklist},=0A=
 *=0A=
 * For the general details about this service in Angular, read the main =
page for {@link ng.$sce=0A=
 * Strict Contextual Escaping (SCE)}.=0A=
 *=0A=
 * **Example**:  Consider the following case. &lt;a =
name=3D"example"&gt;&lt;/a&gt;=0A=
 *=0A=
 * - your app is hosted at url `http://myapp.example.com/`=0A=
 * - but some of your templates are hosted on other domains you control =
such as=0A=
 *   `http://srv01.assets.example.com/`, =
`http://srv02.assets.example.com/`, etc.=0A=
 * - and you have an open redirect at =
`http://myapp.example.com/clickThru?...`.=0A=
 *=0A=
 * Here is what a secure configuration for this scenario might look like:=0A=
 *=0A=
 * ```=0A=
 *  angular.module('myApp', []).config(function($sceDelegateProvider) {=0A=
 *    $sceDelegateProvider.resourceUrlWhitelist([=0A=
 *      // Allow same origin resource loads.=0A=
 *      'self',=0A=
 *      // Allow loading from our assets domain.  Notice the difference =
between * and **.=0A=
 *      'http://srv*.assets.example.com/**'=0A=
 *    ]);=0A=
 *=0A=
 *    // The blacklist overrides the whitelist so the open redirect here =
is blocked.=0A=
 *    $sceDelegateProvider.resourceUrlBlacklist([=0A=
 *      'http://myapp.example.com/clickThru**'=0A=
 *    ]);=0A=
 *  });=0A=
 * ```=0A=
 * Note that an empty whitelist will block every resource URL from being =
loaded, and will require=0A=
 * you to manually mark each one as trusted with =
`$sce.trustAsResourceUrl`. However, templates=0A=
 * requested by {@link ng.$templateRequest $templateRequest} that are =
present in=0A=
 * {@link ng.$templateCache $templateCache} will not go through this =
check. If you have a mechanism=0A=
 * to populate your templates in that cache at config time, then it is a =
good idea to remove 'self'=0A=
 * from that whitelist. This helps to mitigate the security impact of =
certain types of issues, like=0A=
 * for instance attacker-controlled `ng-includes`.=0A=
 */=0A=
=0A=
function $SceDelegateProvider() {=0A=
  this.SCE_CONTEXTS =3D SCE_CONTEXTS;=0A=
=0A=
  // Resource URLs can also be trusted by policy.=0A=
  var resourceUrlWhitelist =3D ['self'],=0A=
      resourceUrlBlacklist =3D [];=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $sceDelegateProvider#resourceUrlWhitelist=0A=
   * @kind function=0A=
   *=0A=
   * @param {Array=3D} whitelist When provided, replaces the =
resourceUrlWhitelist with the value=0A=
   *     provided.  This must be an array or null.  A snapshot of this =
array is used so further=0A=
   *     changes to the array are ignored.=0A=
   *     Follow {@link ng.$sce#resourceUrlPatternItem this link} for a =
description of the items=0A=
   *     allowed in this array.=0A=
   *=0A=
   * @return {Array} The currently set whitelist array.=0A=
   *=0A=
   * @description=0A=
   * Sets/Gets the whitelist of trusted resource URLs.=0A=
   *=0A=
   * The **default value** when no whitelist has been explicitly set is =
`['self']` allowing only=0A=
   * same origin resource requests.=0A=
   *=0A=
   * &lt;div class=3D"alert alert-warning"&gt;=0A=
   * **Note:** the default whitelist of 'self' is not recommended if =
your app shares its origin=0A=
   * with other apps! It is a good idea to limit it to only your =
application's directory.=0A=
   * &lt;/div&gt;=0A=
   */=0A=
  this.resourceUrlWhitelist =3D function(value) {=0A=
    if (arguments.length) {=0A=
      resourceUrlWhitelist =3D adjustMatchers(value);=0A=
    }=0A=
    return resourceUrlWhitelist;=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $sceDelegateProvider#resourceUrlBlacklist=0A=
   * @kind function=0A=
   *=0A=
   * @param {Array=3D} blacklist When provided, replaces the =
resourceUrlBlacklist with the value=0A=
   *     provided.  This must be an array or null.  A snapshot of this =
array is used so further=0A=
   *     changes to the array are ignored.&lt;/p&gt;&lt;p&gt;=0A=
   *     Follow {@link ng.$sce#resourceUrlPatternItem this link} for a =
description of the items=0A=
   *     allowed in this array.&lt;/p&gt;&lt;p&gt;=0A=
   *     The typical usage for the blacklist is to **block=0A=
   *     [open =
redirects](http://cwe.mitre.org/data/definitions/601.html)** served by =
your domain as=0A=
   *     these would otherwise be trusted but actually return content =
from the redirected domain.=0A=
   *     &lt;/p&gt;&lt;p&gt;=0A=
   *     Finally, **the blacklist overrides the whitelist** and has the =
final say.=0A=
   *=0A=
   * @return {Array} The currently set blacklist array.=0A=
   *=0A=
   * @description=0A=
   * Sets/Gets the blacklist of trusted resource URLs.=0A=
   *=0A=
   * The **default value** when no whitelist has been explicitly set is =
the empty array (i.e. there=0A=
   * is no blacklist.)=0A=
   */=0A=
=0A=
  this.resourceUrlBlacklist =3D function(value) {=0A=
    if (arguments.length) {=0A=
      resourceUrlBlacklist =3D adjustMatchers(value);=0A=
    }=0A=
    return resourceUrlBlacklist;=0A=
  };=0A=
=0A=
  this.$get =3D ['$injector', function($injector) {=0A=
=0A=
    var htmlSanitizer =3D function htmlSanitizer(html) {=0A=
      throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a =
safe context.');=0A=
    };=0A=
=0A=
    if ($injector.has('$sanitize')) {=0A=
      htmlSanitizer =3D $injector.get('$sanitize');=0A=
    }=0A=
=0A=
=0A=
    function matchUrl(matcher, parsedUrl) {=0A=
      if (matcher =3D=3D=3D 'self') {=0A=
        return urlIsSameOrigin(parsedUrl);=0A=
      } else {=0A=
        // definitely a regex.  See adjustMatchers()=0A=
        return !!matcher.exec(parsedUrl.href);=0A=
      }=0A=
    }=0A=
=0A=
    function isResourceUrlAllowedByPolicy(url) {=0A=
      var parsedUrl =3D urlResolve(url.toString());=0A=
      var i, n, allowed =3D false;=0A=
      // Ensure that at least one item from the whitelist allows this =
url.=0A=
      for (i =3D 0, n =3D resourceUrlWhitelist.length; i &lt; n; i++) {=0A=
        if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {=0A=
          allowed =3D true;=0A=
          break;=0A=
        }=0A=
      }=0A=
      if (allowed) {=0A=
        // Ensure that no item from the blacklist blocked this url.=0A=
        for (i =3D 0, n =3D resourceUrlBlacklist.length; i &lt; n; i++) {=0A=
          if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {=0A=
            allowed =3D false;=0A=
            break;=0A=
          }=0A=
        }=0A=
      }=0A=
      return allowed;=0A=
    }=0A=
=0A=
    function generateHolderType(Base) {=0A=
      var holderType =3D function TrustedValueHolderType(trustedValue) {=0A=
        this.$$unwrapTrustedValue =3D function() {=0A=
          return trustedValue;=0A=
        };=0A=
      };=0A=
      if (Base) {=0A=
        holderType.prototype =3D new Base();=0A=
      }=0A=
      holderType.prototype.valueOf =3D function sceValueOf() {=0A=
        return this.$$unwrapTrustedValue();=0A=
      };=0A=
      holderType.prototype.toString =3D function sceToString() {=0A=
        return this.$$unwrapTrustedValue().toString();=0A=
      };=0A=
      return holderType;=0A=
    }=0A=
=0A=
    var trustedValueHolderBase =3D generateHolderType(),=0A=
        byType =3D {};=0A=
=0A=
    byType[SCE_CONTEXTS.HTML] =3D =
generateHolderType(trustedValueHolderBase);=0A=
    byType[SCE_CONTEXTS.CSS] =3D =
generateHolderType(trustedValueHolderBase);=0A=
    byType[SCE_CONTEXTS.URL] =3D =
generateHolderType(trustedValueHolderBase);=0A=
    byType[SCE_CONTEXTS.JS] =3D =
generateHolderType(trustedValueHolderBase);=0A=
    byType[SCE_CONTEXTS.RESOURCE_URL] =3D =
generateHolderType(byType[SCE_CONTEXTS.URL]);=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sceDelegate#trustAs=0A=
     *=0A=
     * @description=0A=
     * Returns a trusted representation of the parameter for the =
specified context. This trusted=0A=
     * object will later on be used as-is, without any security check, =
by bindings or directives=0A=
     * that require this security context.=0A=
     * For instance, marking a string as trusted for the `$sce.HTML` =
context will entirely bypass=0A=
     * the potential `$sanitize` call in corresponding `$sce.HTML` =
bindings or directives, such as=0A=
     * `ng-bind-html`. Note that in most cases you won't need to call =
this function: if you have the=0A=
     * sanitizer loaded, passing the value itself will render all the =
HTML that does not pose a=0A=
     * security risk.=0A=
     *=0A=
     * See {@link ng.$sceDelegate#getTrusted getTrusted} for the =
function that will consume those=0A=
     * trusted values, and {@link ng.$sce $sce} for general =
documentation about strict contextual=0A=
     * escaping.=0A=
     *=0A=
     * @param {string} type The context in which this value is safe for =
use, e.g. `$sce.URL`,=0A=
     *     `$sce.RESOURCE_URL`, `$sce.HTML`, `$sce.JS` or `$sce.CSS`.=0A=
     *=0A=
     * @param {*} value The value that should be considered trusted.=0A=
     * @return {*} A trusted representation of value, that can be used =
in the given context.=0A=
     */=0A=
    function trustAs(type, trustedValue) {=0A=
      var Constructor =3D (byType.hasOwnProperty(type) ? byType[type] : =
null);=0A=
      if (!Constructor) {=0A=
        throw $sceMinErr('icontext',=0A=
            'Attempted to trust a value in invalid context. Context: =
{0}; Value: {1}',=0A=
            type, trustedValue);=0A=
      }=0A=
      if (trustedValue =3D=3D=3D null || isUndefined(trustedValue) || =
trustedValue =3D=3D=3D '') {=0A=
        return trustedValue;=0A=
      }=0A=
      // All the current contexts in SCE_CONTEXTS happen to be strings.  =
In order to avoid trusting=0A=
      // mutable objects, we ensure here that the value passed in is =
actually a string.=0A=
      if (typeof trustedValue !=3D=3D 'string') {=0A=
        throw $sceMinErr('itype',=0A=
            'Attempted to trust a non-string value in a content =
requiring a string: Context: {0}',=0A=
            type);=0A=
      }=0A=
      return new Constructor(trustedValue);=0A=
    }=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sceDelegate#valueOf=0A=
     *=0A=
     * @description=0A=
     * If the passed parameter had been returned by a prior call to =
{@link ng.$sceDelegate#trustAs=0A=
     * `$sceDelegate.trustAs`}, returns the value that had been passed =
to {@link=0A=
     * ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}.=0A=
     *=0A=
     * If the passed parameter is not a value that had been returned by =
{@link=0A=
     * ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}, it must be =
returned as-is.=0A=
     *=0A=
     * @param {*} value The result of a prior {@link =
ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}=0A=
     *     call or anything else.=0A=
     * @return {*} The `value` that was originally provided to {@link =
ng.$sceDelegate#trustAs=0A=
     *     `$sceDelegate.trustAs`} if `value` is the result of such a =
call.  Otherwise, returns=0A=
     *     `value` unchanged.=0A=
     */=0A=
    function valueOf(maybeTrusted) {=0A=
      if (maybeTrusted instanceof trustedValueHolderBase) {=0A=
        return maybeTrusted.$$unwrapTrustedValue();=0A=
      } else {=0A=
        return maybeTrusted;=0A=
      }=0A=
    }=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sceDelegate#getTrusted=0A=
     *=0A=
     * @description=0A=
     * Takes any input, and either returns a value that's safe to use in =
the specified context, or=0A=
     * throws an exception.=0A=
     *=0A=
     * In practice, there are several cases. When given a string, this =
function runs checks=0A=
     * and sanitization to make it safe without prior assumptions. When =
given the result of a {@link=0A=
     * ng.$sceDelegate#trustAs `$sceDelegate.trustAs`} call, it returns =
the originally supplied=0A=
     * value if that value's context is valid for this call's context. =
Finally, this function can=0A=
     * also throw when there is no way to turn `maybeTrusted` in a safe =
value (e.g., no sanitization=0A=
     * is available or possible.)=0A=
     *=0A=
     * @param {string} type The context in which this value is to be =
used (such as `$sce.HTML`).=0A=
     * @param {*} maybeTrusted The result of a prior {@link =
ng.$sceDelegate#trustAs=0A=
     *     `$sceDelegate.trustAs`} call, or anything else (which will =
not be considered trusted.)=0A=
     * @return {*} A version of the value that's safe to use in the =
given context, or throws an=0A=
     *     exception if this is impossible.=0A=
     */=0A=
    function getTrusted(type, maybeTrusted) {=0A=
      if (maybeTrusted =3D=3D=3D null || isUndefined(maybeTrusted) || =
maybeTrusted =3D=3D=3D '') {=0A=
        return maybeTrusted;=0A=
      }=0A=
      var constructor =3D (byType.hasOwnProperty(type) ? byType[type] : =
null);=0A=
      // If maybeTrusted is a trusted class instance or subclass =
instance, then unwrap and return=0A=
      // as-is.=0A=
      if (constructor &amp;&amp; maybeTrusted instanceof constructor) {=0A=
        return maybeTrusted.$$unwrapTrustedValue();=0A=
      }=0A=
      // Otherwise, if we get here, then we may either make it safe, or =
throw an exception. This=0A=
      // depends on the context: some are sanitizatible (HTML), some use =
whitelists (RESOURCE_URL),=0A=
      // some are impossible to do (JS). This step isn't implemented for =
CSS and URL, as AngularJS=0A=
      // has no corresponding sinks.=0A=
      if (type =3D=3D=3D SCE_CONTEXTS.RESOURCE_URL) {=0A=
        // RESOURCE_URL uses a whitelist.=0A=
        if (isResourceUrlAllowedByPolicy(maybeTrusted)) {=0A=
          return maybeTrusted;=0A=
        } else {=0A=
          throw $sceMinErr('insecurl',=0A=
              'Blocked loading resource from url not allowed by =
$sceDelegate policy.  URL: {0}',=0A=
              maybeTrusted.toString());=0A=
        }=0A=
      } else if (type =3D=3D=3D SCE_CONTEXTS.HTML) {=0A=
        // htmlSanitizer throws its own error when no sanitizer is =
available.=0A=
        return htmlSanitizer(maybeTrusted);=0A=
      }=0A=
      // Default error when the $sce service has no way to make the =
input safe.=0A=
      throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a =
safe context.');=0A=
    }=0A=
=0A=
    return { trustAs: trustAs,=0A=
             getTrusted: getTrusted,=0A=
             valueOf: valueOf };=0A=
  }];=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $sceProvider=0A=
 * @this=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * The $sceProvider provider allows developers to configure the {@link =
ng.$sce $sce} service.=0A=
 * -   enable/disable Strict Contextual Escaping (SCE) in a module=0A=
 * -   override the default implementation with a custom delegate=0A=
 *=0A=
 * Read more about {@link ng.$sce Strict Contextual Escaping (SCE)}.=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $sce=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * `$sce` is a service that provides Strict Contextual Escaping services =
to AngularJS.=0A=
 *=0A=
 * # Strict Contextual Escaping=0A=
 *=0A=
 * Strict Contextual Escaping (SCE) is a mode in which AngularJS =
constrains bindings to only render=0A=
 * trusted values. Its goal is to assist in writing code in a way that =
(a) is secure by default, and=0A=
 * (b) makes auditing for security vulnerabilities such as XSS, =
clickjacking, etc. a lot easier.=0A=
 *=0A=
 * ## Overview=0A=
 *=0A=
 * To systematically block XSS security bugs, AngularJS treats all =
values as untrusted by default in=0A=
 * HTML or sensitive URL bindings. When binding untrusted values, =
AngularJS will automatically=0A=
 * run security checks on them (sanitizations, whitelists, depending on =
context), or throw when it=0A=
 * cannot guarantee the security of the result. That behavior depends =
strongly on contexts: HTML=0A=
 * can be sanitized, but template URLs cannot, for instance.=0A=
 *=0A=
 * To illustrate this, consider the `ng-bind-html` directive. It renders =
its value directly as HTML:=0A=
 * we call that the *context*. When given an untrusted input, AngularJS =
will attempt to sanitize it=0A=
 * before rendering if a sanitizer is available, and throw otherwise. To =
bypass sanitization and=0A=
 * render the input as-is, you will need to mark it as trusted for that =
context before attempting=0A=
 * to bind it.=0A=
 *=0A=
 * As of version 1.2, AngularJS ships with SCE enabled by default.=0A=
 *=0A=
 * ## In practice=0A=
 *=0A=
 * Here's an example of a binding in a privileged context:=0A=
 *=0A=
 * ```=0A=
 * &lt;input ng-model=3D"userHtml" aria-label=3D"User input"&gt;=0A=
 * &lt;div ng-bind-html=3D"userHtml"&gt;&lt;/div&gt;=0A=
 * ```=0A=
 *=0A=
 * Notice that `ng-bind-html` is bound to `userHtml` controlled by the =
user.  With SCE=0A=
 * disabled, this application allows the user to render arbitrary HTML =
into the DIV, which would=0A=
 * be an XSS security bug. In a more realistic example, one may be =
rendering user comments, blog=0A=
 * articles, etc. via bindings. (HTML is just one example of a context =
where rendering user=0A=
 * controlled input creates security vulnerabilities.)=0A=
 *=0A=
 * For the case of HTML, you might use a library, either on the client =
side, or on the server side,=0A=
 * to sanitize unsafe HTML before binding to the value and rendering it =
in the document.=0A=
 *=0A=
 * How would you ensure that every place that used these types of =
bindings was bound to a value that=0A=
 * was sanitized by your library (or returned as safe for rendering by =
your server?)  How can you=0A=
 * ensure that you didn't accidentally delete the line that sanitized =
the value, or renamed some=0A=
 * properties/fields and forgot to update the binding to the sanitized =
value?=0A=
 *=0A=
 * To be secure by default, AngularJS makes sure bindings go through =
that sanitization, or=0A=
 * any similar validation process, unless there's a good reason to trust =
the given value in this=0A=
 * context.  That trust is formalized with a function call. This means =
that as a developer, you=0A=
 * can assume all untrusted bindings are safe. Then, to audit your code =
for binding security issues,=0A=
 * you just need to ensure the values you mark as trusted indeed are =
safe - because they were=0A=
 * received from your server, sanitized by your library, etc. You can =
organize your codebase to=0A=
 * help with this - perhaps allowing only the files in a specific =
directory to do this.=0A=
 * Ensuring that the internal API exposed by that code doesn't markup =
arbitrary values as safe then=0A=
 * becomes a more manageable task.=0A=
 *=0A=
 * In the case of AngularJS' SCE service, one uses {@link =
ng.$sce#trustAs $sce.trustAs}=0A=
 * (and shorthand methods such as {@link ng.$sce#trustAsHtml =
$sce.trustAsHtml}, etc.) to=0A=
 * build the trusted versions of your values.=0A=
 *=0A=
 * ## How does it work?=0A=
 *=0A=
 * In privileged contexts, directives and code will bind to the result =
of {@link ng.$sce#getTrusted=0A=
 * $sce.getTrusted(context, value)} rather than to the value directly.  =
Think of this function as=0A=
 * a way to enforce the required security context in your data sink. =
Directives use {@link=0A=
 * ng.$sce#parseAs $sce.parseAs} rather than `$parse` to watch attribute =
bindings, which performs=0A=
 * the {@link ng.$sce#getTrusted $sce.getTrusted} behind the scenes on =
non-constant literals. Also,=0A=
 * when binding without directives, AngularJS will understand the =
context of your bindings=0A=
 * automatically.=0A=
 *=0A=
 * As an example, {@link ng.directive:ngBindHtml ngBindHtml} uses {@link=0A=
 * ng.$sce#parseAsHtml $sce.parseAsHtml(binding expression)}.  Here's =
the actual code (slightly=0A=
 * simplified):=0A=
 *=0A=
 * ```=0A=
 * var ngBindHtmlDirective =3D ['$sce', function($sce) {=0A=
 *   return function(scope, element, attr) {=0A=
 *     scope.$watch($sce.parseAsHtml(attr.ngBindHtml), function(value) {=0A=
 *       element.html(value || '');=0A=
 *     });=0A=
 *   };=0A=
 * }];=0A=
 * ```=0A=
 *=0A=
 * ## Impact on loading templates=0A=
 *=0A=
 * This applies both to the {@link ng.directive:ngInclude `ng-include`} =
directive as well as=0A=
 * `templateUrl`'s specified by {@link guide/directive directives}.=0A=
 *=0A=
 * By default, Angular only loads templates from the same domain and =
protocol as the application=0A=
 * document.  This is done by calling {@link =
ng.$sce#getTrustedResourceUrl=0A=
 * $sce.getTrustedResourceUrl} on the template URL.  To load templates =
from other domains and/or=0A=
 * protocols, you may either {@link =
ng.$sceDelegateProvider#resourceUrlWhitelist whitelist=0A=
 * them} or {@link ng.$sce#trustAsResourceUrl wrap it} into a trusted =
value.=0A=
 *=0A=
 * *Please note*:=0A=
 * The browser's=0A=
 * [Same Origin =
Policy](https://code.google.com/p/browsersec/wiki/Part2#Same-origin_polic=
y_for_XMLHttpRequest)=0A=
 * and [Cross-Origin Resource Sharing (CORS)](http://www.w3.org/TR/cors/)=0A=
 * policy apply in addition to this and may further restrict whether the =
template is successfully=0A=
 * loaded.  This means that without the right CORS policy, loading =
templates from a different domain=0A=
 * won't work on all browsers.  Also, loading templates from `file://` =
URL does not work on some=0A=
 * browsers.=0A=
 *=0A=
 * ## This feels like too much overhead=0A=
 *=0A=
 * It's important to remember that SCE only applies to interpolation =
expressions.=0A=
 *=0A=
 * If your expressions are constant literals, they're automatically =
trusted and you don't need to=0A=
 * call `$sce.trustAs` on them (e.g.=0A=
 * `&lt;div ng-bind-html=3D"'&lt;b&gt;implicitly =
trusted&lt;/b&gt;'"&gt;&lt;/div&gt;`) just works. The `$sceDelegate` will=0A=
 * also use the `$sanitize` service if it is available when binding =
untrusted values to=0A=
 * `$sce.HTML` context. AngularJS provides an implementation in =
`angular-sanitize.js`, and if you=0A=
 * wish to use it, you will also need to depend on the {@link ngSanitize =
`ngSanitize`} module in=0A=
 * your application.=0A=
 *=0A=
 * The included {@link ng.$sceDelegate $sceDelegate} comes with sane =
defaults to allow you to load=0A=
 * templates in `ng-include` from your application's domain without =
having to even know about SCE.=0A=
 * It blocks loading templates from other domains or loading templates =
over http from an https=0A=
 * served document.  You can change these by setting your own custom =
{@link=0A=
 * ng.$sceDelegateProvider#resourceUrlWhitelist whitelists} and {@link=0A=
 * ng.$sceDelegateProvider#resourceUrlBlacklist blacklists} for matching =
such URLs.=0A=
 *=0A=
 * This significantly reduces the overhead.  It is far easier to pay the =
small overhead and have an=0A=
 * application that's secure and can be audited to verify that with much =
more ease than bolting=0A=
 * security onto an application later.=0A=
 *=0A=
 * &lt;a name=3D"contexts"&gt;&lt;/a&gt;=0A=
 * ## What trusted context types are supported?=0A=
 *=0A=
 * | Context             | Notes          |=0A=
 * |---------------------|----------------|=0A=
 * | `$sce.HTML`         | For HTML that's safe to source into the =
application.  The {@link ng.directive:ngBindHtml ngBindHtml} directive =
uses this context for bindings. If an unsafe value is encountered, and =
the {@link ngSanitize.$sanitize $sanitize} service is available =
(implemented by the {@link ngSanitize ngSanitize} module) this will =
sanitize the value instead of throwing an error. |=0A=
 * | `$sce.CSS`          | For CSS that's safe to source into the =
application.  Currently, no bindings require this context. Feel free to =
use it in your own directives. |=0A=
 * | `$sce.URL`          | For URLs that are safe to follow as links.  =
Currently unused (`&lt;a href=3D`, `&lt;img src=3D`, and some others =
sanitize their urls and don't constitute an SCE context.) |=0A=
 * | `$sce.RESOURCE_URL` | For URLs that are not only safe to follow as =
links, but whose contents are also safe to include in your application.  =
Examples include `ng-include`, `src` / `ngSrc` bindings for tags other =
than `IMG`, `VIDEO`, `AUDIO`, `SOURCE`, and `TRACK` (e.g. `IFRAME`, =
`OBJECT`, etc.)  &lt;br&gt;&lt;br&gt;Note that `$sce.RESOURCE_URL` makes =
a stronger statement about the URL than `$sce.URL` does (it's not just =
the URL that matters, but also what is at the end of it), and therefore =
contexts requiring values trusted for `$sce.RESOURCE_URL` can be used =
anywhere that values trusted for `$sce.URL` are required. |=0A=
 * | `$sce.JS`           | For JavaScript that is safe to execute in =
your application's context.  Currently, no bindings require this =
context.  Feel free to use it in your own directives. |=0A=
 *=0A=
 *=0A=
 * Be aware that `a[href]` and `img[src]` automatically sanitize their =
URLs and do not pass them=0A=
 * through {@link ng.$sce#getTrusted $sce.getTrusted}. There's no CSS-, =
URL-, or JS-context bindings=0A=
 * in AngularJS currently, so their corresponding `$sce.trustAs` =
functions aren't useful yet. This=0A=
 * might evolve.=0A=
 *=0A=
 * ## Format of items in {@link =
ng.$sceDelegateProvider#resourceUrlWhitelist =
resourceUrlWhitelist}/{@link =
ng.$sceDelegateProvider#resourceUrlBlacklist Blacklist} &lt;a =
name=3D"resourceUrlPatternItem"&gt;&lt;/a&gt;=0A=
 *=0A=
 *  Each element in these arrays must be one of the following:=0A=
 *=0A=
 *  - **'self'**=0A=
 *    - The special **string**, `'self'`, can be used to match against =
all URLs of the **same=0A=
 *      domain** as the application document using the **same protocol**.=0A=
 *  - **String** (except the special value `'self'`)=0A=
 *    - The string is matched against the full *normalized / absolute =
URL* of the resource=0A=
 *      being tested (substring matches are not good enough.)=0A=
 *    - There are exactly **two wildcard sequences** - `*` and `**`.  =
All other characters=0A=
 *      match themselves.=0A=
 *    - `*`: matches zero or more occurrences of any character other =
than one of the following 6=0A=
 *      characters: '`:`', '`/`', '`.`', '`?`', '`&amp;`' and '`;`'.  =
It's a useful wildcard for use=0A=
 *      in a whitelist.=0A=
 *    - `**`: matches zero or more occurrences of *any* character.  As =
such, it's not=0A=
 *      appropriate for use in a scheme, domain, etc. as it would match =
too much.  (e.g.=0A=
 *      http://**.example.com/ would match =
http://evil.com/?ignore=3D.example.com/ and that might=0A=
 *      not have been the intention.)  Its usage at the very end of the =
path is ok.  (e.g.=0A=
 *      http://foo.example.com/templates/**).=0A=
 *  - **RegExp** (*see caveat below*)=0A=
 *    - *Caveat*:  While regular expressions are powerful and offer =
great flexibility,  their syntax=0A=
 *      (and all the inevitable escaping) makes them *harder to =
maintain*.  It's easy to=0A=
 *      accidentally introduce a bug when one updates a complex =
expression (imho, all regexes should=0A=
 *      have good test coverage).  For instance, the use of `.` in the =
regex is correct only in a=0A=
 *      small number of cases.  A `.` character in the regex used when =
matching the scheme or a=0A=
 *      subdomain could be matched against a `:` or literal `.` that was =
likely not intended.   It=0A=
 *      is highly recommended to use the string patterns and only fall =
back to regular expressions=0A=
 *      as a last resort.=0A=
 *    - The regular expression must be an instance of RegExp (i.e. not a =
string.)  It is=0A=
 *      matched against the **entire** *normalized / absolute URL* of =
the resource being tested=0A=
 *      (even when the RegExp did not have the `^` and `$` codes.)  In =
addition, any flags=0A=
 *      present on the RegExp (such as multiline, global, ignoreCase) =
are ignored.=0A=
 *    - If you are generating your JavaScript from some other templating =
engine (not=0A=
 *      recommended, e.g. in issue =
[#4006](https://github.com/angular/angular.js/issues/4006)),=0A=
 *      remember to escape your regular expression (and be aware that =
you might need more than=0A=
 *      one level of escaping depending on your templating engine and =
the way you interpolated=0A=
 *      the value.)  Do make use of your platform's escaping mechanism =
as it might be good=0A=
 *      enough before coding your own.  E.g. Ruby has=0A=
 *      =
[Regexp.escape(str)](http://www.ruby-doc.org/core-2.0.0/Regexp.html#metho=
d-c-escape)=0A=
 *      and Python has =
[re.escape](http://docs.python.org/library/re.html#re.escape).=0A=
 *      Javascript lacks a similar built in function for escaping.  Take =
a look at Google=0A=
 *      Closure library's [goog.string.regExpEscape(s)](=0A=
 *      =
http://docs.closure-library.googlecode.com/git/closure_goog_string_string=
.js.source.html#line962).=0A=
 *=0A=
 * Refer {@link ng.$sceDelegateProvider $sceDelegateProvider} for an =
example.=0A=
 *=0A=
 * ## Show me an example using SCE.=0A=
 *=0A=
 * &lt;example module=3D"mySceApp" deps=3D"angular-sanitize.js" =
name=3D"sce-service"&gt;=0A=
 * &lt;file name=3D"index.html"&gt;=0A=
 *   &lt;div ng-controller=3D"AppController as myCtrl"&gt;=0A=
 *     &lt;i ng-bind-html=3D"myCtrl.explicitlyTrustedHtml" =
id=3D"explicitlyTrustedHtml"&gt;&lt;/i&gt;&lt;br&gt;&lt;br&gt;=0A=
 *     &lt;b&gt;User comments&lt;/b&gt;&lt;br&gt;=0A=
 *     By default, HTML that isn't explicitly trusted (e.g. Alice's =
comment) is sanitized when=0A=
 *     $sanitize is available.  If $sanitize isn't available, this =
results in an error instead of an=0A=
 *     exploit.=0A=
 *     &lt;div class=3D"well"&gt;=0A=
 *       &lt;div ng-repeat=3D"userComment in myCtrl.userComments"&gt;=0A=
 *         &lt;b&gt;{{userComment.name}}&lt;/b&gt;:=0A=
 *         &lt;span ng-bind-html=3D"userComment.htmlComment" =
class=3D"htmlComment"&gt;&lt;/span&gt;=0A=
 *         &lt;br&gt;=0A=
 *       &lt;/div&gt;=0A=
 *     &lt;/div&gt;=0A=
 *   &lt;/div&gt;=0A=
 * &lt;/file&gt;=0A=
 *=0A=
 * &lt;file name=3D"script.js"&gt;=0A=
 *   angular.module('mySceApp', ['ngSanitize'])=0A=
 *     .controller('AppController', ['$http', '$templateCache', '$sce',=0A=
 *       function AppController($http, $templateCache, $sce) {=0A=
 *         var self =3D this;=0A=
 *         $http.get('test_data.json', {cache: =
$templateCache}).then(function(response) {=0A=
 *           self.userComments =3D response.data;=0A=
 *         });=0A=
 *         self.explicitlyTrustedHtml =3D $sce.trustAsHtml(=0A=
 *             '&lt;span =
onmouseover=3D"this.textContent=3D&amp;quot;Explicitly trusted HTML =
bypasses ' +=0A=
 *             'sanitization.&amp;quot;"&gt;Hover over this =
text.&lt;/span&gt;');=0A=
 *       }]);=0A=
 * &lt;/file&gt;=0A=
 *=0A=
 * &lt;file name=3D"test_data.json"&gt;=0A=
 * [=0A=
 *   { "name": "Alice",=0A=
 *     "htmlComment":=0A=
 *         "&lt;span onmouseover=3D'this.textContent=3D\"PWN3D!\"'&gt;Is =
&lt;i&gt;anyone&lt;/i&gt; reading this?&lt;/span&gt;"=0A=
 *   },=0A=
 *   { "name": "Bob",=0A=
 *     "htmlComment": "&lt;i&gt;Yes!&lt;/i&gt;  Am I the only other one?"=0A=
 *   }=0A=
 * ]=0A=
 * &lt;/file&gt;=0A=
 *=0A=
 * &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
 *   describe('SCE doc demo', function() {=0A=
 *     it('should sanitize untrusted values', function() {=0A=
 *       =
expect(element.all(by.css('.htmlComment')).first().getAttribute('innerHTM=
L'))=0A=
 *           .toBe('&lt;span&gt;Is &lt;i&gt;anyone&lt;/i&gt; reading =
this?&lt;/span&gt;');=0A=
 *     });=0A=
 *=0A=
 *     it('should NOT sanitize explicitly trusted values', function() {=0A=
 *       =
expect(element(by.id('explicitlyTrustedHtml')).getAttribute('innerHTML'))=
.toBe(=0A=
 *           '&lt;span =
onmouseover=3D"this.textContent=3D&amp;quot;Explicitly trusted HTML =
bypasses ' +=0A=
 *           'sanitization.&amp;quot;"&gt;Hover over this =
text.&lt;/span&gt;');=0A=
 *     });=0A=
 *   });=0A=
 * &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 *=0A=
 *=0A=
 *=0A=
 * ## Can I disable SCE completely?=0A=
 *=0A=
 * Yes, you can.  However, this is strongly discouraged.  SCE gives you =
a lot of security benefits=0A=
 * for little coding overhead.  It will be much harder to take an SCE =
disabled application and=0A=
 * either secure it on your own or enable SCE at a later stage.  It =
might make sense to disable SCE=0A=
 * for cases where you have a lot of existing code that was written =
before SCE was introduced and=0A=
 * you're migrating them a module at a time. Also do note that this is =
an app-wide setting, so if=0A=
 * you are writing a library, you will cause security bugs applications =
using it.=0A=
 *=0A=
 * That said, here's how you can completely disable SCE:=0A=
 *=0A=
 * ```=0A=
 * angular.module('myAppWithSceDisabledmyApp', =
[]).config(function($sceProvider) {=0A=
 *   // Completely disable SCE.  For demonstration purposes only!=0A=
 *   // Do not use in new projects or libraries.=0A=
 *   $sceProvider.enabled(false);=0A=
 * });=0A=
 * ```=0A=
 *=0A=
 */=0A=
=0A=
function $SceProvider() {=0A=
  var enabled =3D true;=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $sceProvider#enabled=0A=
   * @kind function=0A=
   *=0A=
   * @param {boolean=3D} value If provided, then enables/disables SCE =
application-wide.=0A=
   * @return {boolean} True if SCE is enabled, false otherwise.=0A=
   *=0A=
   * @description=0A=
   * Enables/disables SCE and returns the current value.=0A=
   */=0A=
  this.enabled =3D function(value) {=0A=
    if (arguments.length) {=0A=
      enabled =3D !!value;=0A=
    }=0A=
    return enabled;=0A=
  };=0A=
=0A=
=0A=
  /* Design notes on the default implementation for SCE.=0A=
   *=0A=
   * The API contract for the SCE delegate=0A=
   * -------------------------------------=0A=
   * The SCE delegate object must provide the following 3 methods:=0A=
   *=0A=
   * - trustAs(contextEnum, value)=0A=
   *     This method is used to tell the SCE service that the provided =
value is OK to use in the=0A=
   *     contexts specified by contextEnum.  It must return an object =
that will be accepted by=0A=
   *     getTrusted() for a compatible contextEnum and return this value.=0A=
   *=0A=
   * - valueOf(value)=0A=
   *     For values that were not produced by trustAs(), return them as =
is.  For values that were=0A=
   *     produced by trustAs(), return the corresponding input value to =
trustAs.  Basically, if=0A=
   *     trustAs is wrapping the given values into some type, this =
operation unwraps it when given=0A=
   *     such a value.=0A=
   *=0A=
   * - getTrusted(contextEnum, value)=0A=
   *     This function should return the a value that is safe to use in =
the context specified by=0A=
   *     contextEnum or throw and exception otherwise.=0A=
   *=0A=
   * NOTE: This contract deliberately does NOT state that values =
returned by trustAs() must be=0A=
   * opaque or wrapped in some holder object.  That happens to be an =
implementation detail.  For=0A=
   * instance, an implementation could maintain a registry of all =
trusted objects by context.  In=0A=
   * such a case, trustAs() would return the same object that was passed =
in.  getTrusted() would=0A=
   * return the same object passed in if it was found in the registry =
under a compatible context or=0A=
   * throw an exception otherwise.  An implementation might only wrap =
values some of the time based=0A=
   * on some criteria.  getTrusted() might return a value and not throw =
an exception for special=0A=
   * constants or objects even if not wrapped.  All such implementations =
fulfill this contract.=0A=
   *=0A=
   *=0A=
   * A note on the inheritance model for SCE contexts=0A=
   * ------------------------------------------------=0A=
   * I've used inheritance and made RESOURCE_URL wrapped types a subtype =
of URL wrapped types.  This=0A=
   * is purely an implementation details.=0A=
   *=0A=
   * The contract is simply this:=0A=
   *=0A=
   *     getTrusted($sce.RESOURCE_URL, value) succeeding implies that =
getTrusted($sce.URL, value)=0A=
   *     will also succeed.=0A=
   *=0A=
   * Inheritance happens to capture this in a natural way. In some =
future, we may not use=0A=
   * inheritance anymore. That is OK because no code outside of sce.js =
and sceSpecs.js would need to=0A=
   * be aware of this detail.=0A=
   */=0A=
=0A=
  this.$get =3D ['$parse', '$sceDelegate', function(=0A=
                $parse,   $sceDelegate) {=0A=
    // Support: IE 9-11 only=0A=
    // Prereq: Ensure that we're not running in IE&lt;11 quirks mode.  =
In that mode, IE &lt; 11 allow=0A=
    // the "expression(javascript expression)" syntax which is insecure.=0A=
    if (enabled &amp;&amp; msie &lt; 8) {=0A=
      throw $sceMinErr('iequirks',=0A=
        'Strict Contextual Escaping does not support Internet Explorer =
version &lt; 11 in quirks ' +=0A=
        'mode.  You can fix this by adding the text &lt;!doctype =
html&gt; to the top of your HTML ' +=0A=
        'document.  See http://docs.angularjs.org/api/ng.$sce for more =
information.');=0A=
    }=0A=
=0A=
    var sce =3D shallowCopy(SCE_CONTEXTS);=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#isEnabled=0A=
     * @kind function=0A=
     *=0A=
     * @return {Boolean} True if SCE is enabled, false otherwise.  If =
you want to set the value, you=0A=
     *     have to do it at module config time on {@link ng.$sceProvider =
$sceProvider}.=0A=
     *=0A=
     * @description=0A=
     * Returns a boolean indicating if SCE is enabled.=0A=
     */=0A=
    sce.isEnabled =3D function() {=0A=
      return enabled;=0A=
    };=0A=
    sce.trustAs =3D $sceDelegate.trustAs;=0A=
    sce.getTrusted =3D $sceDelegate.getTrusted;=0A=
    sce.valueOf =3D $sceDelegate.valueOf;=0A=
=0A=
    if (!enabled) {=0A=
      sce.trustAs =3D sce.getTrusted =3D function(type, value) { return =
value; };=0A=
      sce.valueOf =3D identity;=0A=
    }=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#parseAs=0A=
     *=0A=
     * @description=0A=
     * Converts Angular {@link guide/expression expression} into a =
function.  This is like {@link=0A=
     * ng.$parse $parse} and is identical when the expression is a =
literal constant.  Otherwise, it=0A=
     * wraps the expression in a call to {@link ng.$sce#getTrusted =
$sce.getTrusted(*type*,=0A=
     * *result*)}=0A=
     *=0A=
     * @param {string} type The SCE context in which this result will be =
used.=0A=
     * @param {string} expression String expression to compile.=0A=
     * @return {function(context, locals)} A function which represents =
the compiled expression:=0A=
     *=0A=
     *    * `context` =E2=80&#65533; `{object}` =E2=80&#65533; an object =
against which any expressions embedded in the=0A=
     *      strings are evaluated against (typically a scope object).=0A=
     *    * `locals` =E2=80&#65533; `{object=3D}` =E2=80&#65533; local =
variables context object, useful for overriding values=0A=
     *      in `context`.=0A=
     */=0A=
    sce.parseAs =3D function sceParseAs(type, expr) {=0A=
      var parsed =3D $parse(expr);=0A=
      if (parsed.literal &amp;&amp; parsed.constant) {=0A=
        return parsed;=0A=
      } else {=0A=
        return $parse(expr, function(value) {=0A=
          return sce.getTrusted(type, value);=0A=
        });=0A=
      }=0A=
    };=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#trustAs=0A=
     *=0A=
     * @description=0A=
     * Delegates to {@link ng.$sceDelegate#trustAs =
`$sceDelegate.trustAs`}. As such, returns a=0A=
     * wrapped object that represents your value, and the trust you have =
in its safety for the given=0A=
     * context. AngularJS can then use that value as-is in bindings of =
the specified secure context.=0A=
     * This is used in bindings for `ng-bind-html`, `ng-include`, and =
most `src` attribute=0A=
     * interpolations. See {@link ng.$sce $sce} for strict contextual =
escaping.=0A=
     *=0A=
     * @param {string} type The context in which this value is safe for =
use, e.g. `$sce.URL`,=0A=
     *     `$sce.RESOURCE_URL`, `$sce.HTML`, `$sce.JS` or `$sce.CSS`.=0A=
     *=0A=
     * @param {*} value The value that that should be considered trusted.=0A=
     * @return {*} A wrapped version of value that can be used as a =
trusted variant of your `value`=0A=
     *     in the context you specified.=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#trustAsHtml=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.trustAsHtml(value)` =E2=86&#65533;=0A=
     *     {@link ng.$sceDelegate#trustAs =
`$sceDelegate.trustAs($sce.HTML, value)`}=0A=
     *=0A=
     * @param {*} value The value to mark as trusted for `$sce.HTML` =
context.=0A=
     * @return {*} A wrapped version of value that can be used as a =
trusted variant of your `value`=0A=
     *     in `$sce.HTML` context (like `ng-bind-html`).=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#trustAsCss=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.trustAsCss(value)` =E2=86&#65533;=0A=
     *     {@link ng.$sceDelegate#trustAs =
`$sceDelegate.trustAs($sce.CSS, value)`}=0A=
     *=0A=
     * @param {*} value The value to mark as trusted for `$sce.CSS` =
context.=0A=
     * @return {*} A wrapped version of value that can be used as a =
trusted variant=0A=
     *     of your `value` in `$sce.CSS` context. This context is =
currently unused, so there are=0A=
     *     almost no reasons to use this function so far.=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#trustAsUrl=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.trustAsUrl(value)` =E2=86&#65533;=0A=
     *     {@link ng.$sceDelegate#trustAs =
`$sceDelegate.trustAs($sce.URL, value)`}=0A=
     *=0A=
     * @param {*} value The value to mark as trusted for `$sce.URL` =
context.=0A=
     * @return {*} A wrapped version of value that can be used as a =
trusted variant of your `value`=0A=
     *     in `$sce.URL` context. That context is currently unused, so =
there are almost no reasons=0A=
     *     to use this function so far.=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#trustAsResourceUrl=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.trustAsResourceUrl(value)` =E2=86&#65533;=0A=
     *     {@link ng.$sceDelegate#trustAs =
`$sceDelegate.trustAs($sce.RESOURCE_URL, value)`}=0A=
     *=0A=
     * @param {*} value The value to mark as trusted for =
`$sce.RESOURCE_URL` context.=0A=
     * @return {*} A wrapped version of value that can be used as a =
trusted variant of your `value`=0A=
     *     in `$sce.RESOURCE_URL` context (template URLs in =
`ng-include`, most `src` attribute=0A=
     *     bindings, ...)=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#trustAsJs=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.trustAsJs(value)` =E2=86&#65533;=0A=
     *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.JS, =
value)`}=0A=
     *=0A=
     * @param {*} value The value to mark as trusted for `$sce.JS` =
context.=0A=
     * @return {*} A wrapped version of value that can be used as a =
trusted variant of your `value`=0A=
     *     in `$sce.JS` context. That context is currently unused, so =
there are almost no reasons to=0A=
     *     use this function so far.=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#getTrusted=0A=
     *=0A=
     * @description=0A=
     * Delegates to {@link ng.$sceDelegate#getTrusted =
`$sceDelegate.getTrusted`}.  As such,=0A=
     * takes any input, and either returns a value that's safe to use in =
the specified context,=0A=
     * or throws an exception. This function is aware of trusted values =
created by the `trustAs`=0A=
     * function and its shorthands, and when contexts are appropriate, =
returns the unwrapped value=0A=
     * as-is. Finally, this function can also throw when there is no way =
to turn `maybeTrusted` in a=0A=
     * safe value (e.g., no sanitization is available or possible.)=0A=
     *=0A=
     * @param {string} type The context in which this value is to be =
used.=0A=
     * @param {*} maybeTrusted The result of a prior {@link =
ng.$sce#trustAs=0A=
     *     `$sce.trustAs`} call, or anything else (which will not be =
considered trusted.)=0A=
     * @return {*} A version of the value that's safe to use in the =
given context, or throws an=0A=
     *     exception if this is impossible.=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#getTrustedHtml=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.getTrustedHtml(value)` =E2=86&#65533;=0A=
     *     {@link ng.$sceDelegate#getTrusted =
`$sceDelegate.getTrusted($sce.HTML, value)`}=0A=
     *=0A=
     * @param {*} value The value to pass to `$sce.getTrusted`.=0A=
     * @return {*} The return value of `$sce.getTrusted($sce.HTML, =
value)`=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#getTrustedCss=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.getTrustedCss(value)` =E2=86&#65533;=0A=
     *     {@link ng.$sceDelegate#getTrusted =
`$sceDelegate.getTrusted($sce.CSS, value)`}=0A=
     *=0A=
     * @param {*} value The value to pass to `$sce.getTrusted`.=0A=
     * @return {*} The return value of `$sce.getTrusted($sce.CSS, value)`=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#getTrustedUrl=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.getTrustedUrl(value)` =E2=86&#65533;=0A=
     *     {@link ng.$sceDelegate#getTrusted =
`$sceDelegate.getTrusted($sce.URL, value)`}=0A=
     *=0A=
     * @param {*} value The value to pass to `$sce.getTrusted`.=0A=
     * @return {*} The return value of `$sce.getTrusted($sce.URL, value)`=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#getTrustedResourceUrl=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.getTrustedResourceUrl(value)` =
=E2=86&#65533;=0A=
     *     {@link ng.$sceDelegate#getTrusted =
`$sceDelegate.getTrusted($sce.RESOURCE_URL, value)`}=0A=
     *=0A=
     * @param {*} value The value to pass to `$sceDelegate.getTrusted`.=0A=
     * @return {*} The return value of =
`$sce.getTrusted($sce.RESOURCE_URL, value)`=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#getTrustedJs=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.getTrustedJs(value)` =E2=86&#65533;=0A=
     *     {@link ng.$sceDelegate#getTrusted =
`$sceDelegate.getTrusted($sce.JS, value)`}=0A=
     *=0A=
     * @param {*} value The value to pass to `$sce.getTrusted`.=0A=
     * @return {*} The return value of `$sce.getTrusted($sce.JS, value)`=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#parseAsHtml=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.parseAsHtml(expression string)` =
=E2=86&#65533;=0A=
     *     {@link ng.$sce#parseAs `$sce.parseAs($sce.HTML, value)`}=0A=
     *=0A=
     * @param {string} expression String expression to compile.=0A=
     * @return {function(context, locals)} A function which represents =
the compiled expression:=0A=
     *=0A=
     *    * `context` =E2=80&#65533; `{object}` =E2=80&#65533; an object =
against which any expressions embedded in the=0A=
     *      strings are evaluated against (typically a scope object).=0A=
     *    * `locals` =E2=80&#65533; `{object=3D}` =E2=80&#65533; local =
variables context object, useful for overriding values=0A=
     *      in `context`.=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#parseAsCss=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.parseAsCss(value)` =E2=86&#65533;=0A=
     *     {@link ng.$sce#parseAs `$sce.parseAs($sce.CSS, value)`}=0A=
     *=0A=
     * @param {string} expression String expression to compile.=0A=
     * @return {function(context, locals)} A function which represents =
the compiled expression:=0A=
     *=0A=
     *    * `context` =E2=80&#65533; `{object}` =E2=80&#65533; an object =
against which any expressions embedded in the=0A=
     *      strings are evaluated against (typically a scope object).=0A=
     *    * `locals` =E2=80&#65533; `{object=3D}` =E2=80&#65533; local =
variables context object, useful for overriding values=0A=
     *      in `context`.=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#parseAsUrl=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.parseAsUrl(value)` =E2=86&#65533;=0A=
     *     {@link ng.$sce#parseAs `$sce.parseAs($sce.URL, value)`}=0A=
     *=0A=
     * @param {string} expression String expression to compile.=0A=
     * @return {function(context, locals)} A function which represents =
the compiled expression:=0A=
     *=0A=
     *    * `context` =E2=80&#65533; `{object}` =E2=80&#65533; an object =
against which any expressions embedded in the=0A=
     *      strings are evaluated against (typically a scope object).=0A=
     *    * `locals` =E2=80&#65533; `{object=3D}` =E2=80&#65533; local =
variables context object, useful for overriding values=0A=
     *      in `context`.=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#parseAsResourceUrl=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.parseAsResourceUrl(value)` =E2=86&#65533;=0A=
     *     {@link ng.$sce#parseAs `$sce.parseAs($sce.RESOURCE_URL, =
value)`}=0A=
     *=0A=
     * @param {string} expression String expression to compile.=0A=
     * @return {function(context, locals)} A function which represents =
the compiled expression:=0A=
     *=0A=
     *    * `context` =E2=80&#65533; `{object}` =E2=80&#65533; an object =
against which any expressions embedded in the=0A=
     *      strings are evaluated against (typically a scope object).=0A=
     *    * `locals` =E2=80&#65533; `{object=3D}` =E2=80&#65533; local =
variables context object, useful for overriding values=0A=
     *      in `context`.=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#parseAsJs=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.parseAsJs(value)` =E2=86&#65533;=0A=
     *     {@link ng.$sce#parseAs `$sce.parseAs($sce.JS, value)`}=0A=
     *=0A=
     * @param {string} expression String expression to compile.=0A=
     * @return {function(context, locals)} A function which represents =
the compiled expression:=0A=
     *=0A=
     *    * `context` =E2=80&#65533; `{object}` =E2=80&#65533; an object =
against which any expressions embedded in the=0A=
     *      strings are evaluated against (typically a scope object).=0A=
     *    * `locals` =E2=80&#65533; `{object=3D}` =E2=80&#65533; local =
variables context object, useful for overriding values=0A=
     *      in `context`.=0A=
     */=0A=
=0A=
    // Shorthand delegations.=0A=
    var parse =3D sce.parseAs,=0A=
        getTrusted =3D sce.getTrusted,=0A=
        trustAs =3D sce.trustAs;=0A=
=0A=
    forEach(SCE_CONTEXTS, function(enumValue, name) {=0A=
      var lName =3D lowercase(name);=0A=
      sce[snakeToCamel('parse_as_' + lName)] =3D function(expr) {=0A=
        return parse(enumValue, expr);=0A=
      };=0A=
      sce[snakeToCamel('get_trusted_' + lName)] =3D function(value) {=0A=
        return getTrusted(enumValue, value);=0A=
      };=0A=
      sce[snakeToCamel('trust_as_' + lName)] =3D function(value) {=0A=
        return trustAs(enumValue, value);=0A=
      };=0A=
    });=0A=
=0A=
    return sce;=0A=
  }];=0A=
}=0A=
=0A=
/* exported $SnifferProvider */=0A=
=0A=
/**=0A=
 * !!! This is an undocumented "private" service !!!=0A=
 *=0A=
 * @name $sniffer=0A=
 * @requires $window=0A=
 * @requires $document=0A=
 * @this=0A=
 *=0A=
 * @property {boolean} history Does the browser support html5 history =
api ?=0A=
 * @property {boolean} transitions Does the browser support CSS =
transition events ?=0A=
 * @property {boolean} animations Does the browser support CSS animation =
events ?=0A=
 *=0A=
 * @description=0A=
 * This is very simple implementation of testing browser's features.=0A=
 */=0A=
function $SnifferProvider() {=0A=
  this.$get =3D ['$window', '$document', function($window, $document) {=0A=
    var eventSupport =3D {},=0A=
        // Chrome Packaged Apps are not allowed to access =
`history.pushState`.=0A=
        // If not sandboxed, they can be detected by the presence of =
`chrome.app.runtime`=0A=
        // (see https://developer.chrome.com/apps/api_index). If =
sandboxed, they can be detected by=0A=
        // the presence of an extension runtime ID and the absence of =
other Chrome runtime APIs=0A=
        // (see https://developer.chrome.com/apps/manifest/sandbox).=0A=
        // (NW.js apps have access to Chrome APIs, but do support =
`history`.)=0A=
        isNw =3D $window.nw &amp;&amp; $window.nw.process,=0A=
        isChromePackagedApp =3D=0A=
            !isNw &amp;&amp;=0A=
            $window.chrome &amp;&amp;=0A=
            ($window.chrome.app &amp;&amp; $window.chrome.app.runtime ||=0A=
                !$window.chrome.app &amp;&amp; $window.chrome.runtime =
&amp;&amp; $window.chrome.runtime.id),=0A=
        hasHistoryPushState =3D !isChromePackagedApp &amp;&amp; =
$window.history &amp;&amp; $window.history.pushState,=0A=
        android =3D=0A=
          toInt((/android (\d+)/.exec(lowercase(($window.navigator || =
{}).userAgent)) || [])[1]),=0A=
        boxee =3D /Boxee/i.test(($window.navigator || {}).userAgent),=0A=
        document =3D $document[0] || {},=0A=
        bodyStyle =3D document.body &amp;&amp; document.body.style,=0A=
        transitions =3D false,=0A=
        animations =3D false;=0A=
=0A=
    if (bodyStyle) {=0A=
      // Support: Android &lt;5, Blackberry Browser 10, default Chrome =
in Android 4.4.x=0A=
      // Mentioned browsers need a -webkit- prefix for transitions &amp; =
animations.=0A=
      transitions =3D !!('transition' in bodyStyle || 'webkitTransition' =
in bodyStyle);=0A=
      animations =3D !!('animation' in bodyStyle || 'webkitAnimation' in =
bodyStyle);=0A=
    }=0A=
=0A=
=0A=
    return {=0A=
      // Android has history.pushState, but it does not update location =
correctly=0A=
      // so let's not use the history API at all.=0A=
      // http://code.google.com/p/android/issues/detail?id=3D17471=0A=
      // https://github.com/angular/angular.js/issues/904=0A=
=0A=
      // older webkit browser (533.9) on Boxee box has exactly the same =
problem as Android has=0A=
      // so let's not use the history API also=0A=
      // We are purposefully using `!(android &lt; 4)` to cover the case =
when `android` is undefined=0A=
      history: !!(hasHistoryPushState &amp;&amp; !(android &lt; 4) =
&amp;&amp; !boxee),=0A=
      hasEvent: function(event) {=0A=
        // Support: IE 9-11 only=0A=
        // IE9 implements 'input' event it's so fubared that we rather =
pretend that it doesn't have=0A=
        // it. In particular the event is not fired when backspace or =
delete key are pressed or=0A=
        // when cut operation is performed.=0A=
        // IE10+ implements 'input' event but it erroneously fires under =
various situations,=0A=
        // e.g. when placeholder changes, or a form is focused.=0A=
        if (event =3D=3D=3D 'input' &amp;&amp; msie) return false;=0A=
=0A=
        if (isUndefined(eventSupport[event])) {=0A=
          var divElm =3D document.createElement('div');=0A=
          eventSupport[event] =3D 'on' + event in divElm;=0A=
        }=0A=
=0A=
        return eventSupport[event];=0A=
      },=0A=
      csp: csp(),=0A=
      transitions: transitions,=0A=
      animations: animations,=0A=
      android: android=0A=
    };=0A=
  }];=0A=
}=0A=
=0A=
var $templateRequestMinErr =3D minErr('$compile');=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $templateRequestProvider=0A=
 * @this=0A=
 *=0A=
 * @description=0A=
 * Used to configure the options passed to the {@link $http} service =
when making a template request.=0A=
 *=0A=
 * For example, it can be used for specifying the "Accept" header that =
is sent to the server, when=0A=
 * requesting a template.=0A=
 */=0A=
function $TemplateRequestProvider() {=0A=
=0A=
  var httpOptions;=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $templateRequestProvider#httpOptions=0A=
   * @description=0A=
   * The options to be passed to the {@link $http} service when making =
the request.=0A=
   * You can use this to override options such as the "Accept" header =
for template requests.=0A=
   *=0A=
   * The {@link $templateRequest} will set the `cache` and the =
`transformResponse` properties of the=0A=
   * options if not overridden here.=0A=
   *=0A=
   * @param {string=3D} value new value for the {@link $http} options.=0A=
   * @returns {string|self} Returns the {@link $http} options when used =
as getter and self if used as setter.=0A=
   */=0A=
  this.httpOptions =3D function(val) {=0A=
    if (val) {=0A=
      httpOptions =3D val;=0A=
      return this;=0A=
    }=0A=
    return httpOptions;=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc service=0A=
   * @name $templateRequest=0A=
   *=0A=
   * @description=0A=
   * The `$templateRequest` service runs security checks then downloads =
the provided template using=0A=
   * `$http` and, upon success, stores the contents inside of =
`$templateCache`. If the HTTP request=0A=
   * fails or the response data of the HTTP request is empty, a =
`$compile` error will be thrown (the=0A=
   * exception can be thwarted by setting the 2nd parameter of the =
function to true). Note that the=0A=
   * contents of `$templateCache` are trusted, so the call to =
`$sce.getTrustedUrl(tpl)` is omitted=0A=
   * when `tpl` is of type string and `$templateCache` has the matching =
entry.=0A=
   *=0A=
   * If you want to pass custom options to the `$http` service, such as =
setting the Accept header you=0A=
   * can configure this via {@link $templateRequestProvider#httpOptions}.=0A=
   *=0A=
   * @param {string|TrustedResourceUrl} tpl The HTTP request template URL=0A=
   * @param {boolean=3D} ignoreRequestError Whether or not to ignore the =
exception when the request fails or the template is empty=0A=
   *=0A=
   * @return {Promise} a promise for the HTTP response data of the given =
URL.=0A=
   *=0A=
   * @property {number} totalPendingRequests total amount of pending =
template requests being downloaded.=0A=
   */=0A=
  this.$get =3D ['$exceptionHandler', '$templateCache', '$http', '$q', =
'$sce',=0A=
    function($exceptionHandler, $templateCache, $http, $q, $sce) {=0A=
=0A=
      function handleRequestFn(tpl, ignoreRequestError) {=0A=
        handleRequestFn.totalPendingRequests++;=0A=
=0A=
        // We consider the template cache holds only trusted templates, =
so=0A=
        // there's no need to go through whitelisting again for keys =
that already=0A=
        // are included in there. This also makes Angular accept any =
script=0A=
        // directive, no matter its name. However, we still need to =
unwrap trusted=0A=
        // types.=0A=
        if (!isString(tpl) || isUndefined($templateCache.get(tpl))) {=0A=
          tpl =3D $sce.getTrustedResourceUrl(tpl);=0A=
        }=0A=
=0A=
        var transformResponse =3D $http.defaults &amp;&amp; =
$http.defaults.transformResponse;=0A=
=0A=
        if (isArray(transformResponse)) {=0A=
          transformResponse =3D =
transformResponse.filter(function(transformer) {=0A=
            return transformer !=3D=3D defaultHttpResponseTransform;=0A=
          });=0A=
        } else if (transformResponse =3D=3D=3D =
defaultHttpResponseTransform) {=0A=
          transformResponse =3D null;=0A=
        }=0A=
=0A=
        return $http.get(tpl, extend({=0A=
            cache: $templateCache,=0A=
            transformResponse: transformResponse=0A=
          }, httpOptions))=0A=
          .finally(function() {=0A=
            handleRequestFn.totalPendingRequests--;=0A=
          })=0A=
          .then(function(response) {=0A=
            $templateCache.put(tpl, response.data);=0A=
            return response.data;=0A=
          }, handleError);=0A=
=0A=
        function handleError(resp) {=0A=
          if (!ignoreRequestError) {=0A=
            resp =3D $templateRequestMinErr('tpload',=0A=
                'Failed to load template: {0} (HTTP status: {1} {2})',=0A=
                tpl, resp.status, resp.statusText);=0A=
=0A=
            $exceptionHandler(resp);=0A=
          }=0A=
=0A=
          return $q.reject(resp);=0A=
        }=0A=
      }=0A=
=0A=
      handleRequestFn.totalPendingRequests =3D 0;=0A=
=0A=
      return handleRequestFn;=0A=
    }=0A=
  ];=0A=
}=0A=
=0A=
/** @this */=0A=
function $$TestabilityProvider() {=0A=
  this.$get =3D ['$rootScope', '$browser', '$location',=0A=
       function($rootScope,   $browser,   $location) {=0A=
=0A=
    /**=0A=
     * @name $testability=0A=
     *=0A=
     * @description=0A=
     * The private $$testability service provides a collection of =
methods for use when debugging=0A=
     * or by automated test and debugging tools.=0A=
     */=0A=
    var testability =3D {};=0A=
=0A=
    /**=0A=
     * @name $$testability#findBindings=0A=
     *=0A=
     * @description=0A=
     * Returns an array of elements that are bound (via ng-bind or {{}})=0A=
     * to expressions matching the input.=0A=
     *=0A=
     * @param {Element} element The element root to search from.=0A=
     * @param {string} expression The binding expression to match.=0A=
     * @param {boolean} opt_exactMatch If true, only returns exact =
matches=0A=
     *     for the expression. Filters and whitespace are ignored.=0A=
     */=0A=
    testability.findBindings =3D function(element, expression, =
opt_exactMatch) {=0A=
      var bindings =3D element.getElementsByClassName('ng-binding');=0A=
      var matches =3D [];=0A=
      forEach(bindings, function(binding) {=0A=
        var dataBinding =3D angular.element(binding).data('$binding');=0A=
        if (dataBinding) {=0A=
          forEach(dataBinding, function(bindingName) {=0A=
            if (opt_exactMatch) {=0A=
              var matcher =3D new RegExp('(^|\\s)' + =
escapeForRegexp(expression) + '(\\s|\\||$)');=0A=
              if (matcher.test(bindingName)) {=0A=
                matches.push(binding);=0A=
              }=0A=
            } else {=0A=
              if (bindingName.indexOf(expression) !=3D=3D -1) {=0A=
                matches.push(binding);=0A=
              }=0A=
            }=0A=
          });=0A=
        }=0A=
      });=0A=
      return matches;=0A=
    };=0A=
=0A=
    /**=0A=
     * @name $$testability#findModels=0A=
     *=0A=
     * @description=0A=
     * Returns an array of elements that are two-way found via ng-model =
to=0A=
     * expressions matching the input.=0A=
     *=0A=
     * @param {Element} element The element root to search from.=0A=
     * @param {string} expression The model expression to match.=0A=
     * @param {boolean} opt_exactMatch If true, only returns exact =
matches=0A=
     *     for the expression.=0A=
     */=0A=
    testability.findModels =3D function(element, expression, =
opt_exactMatch) {=0A=
      var prefixes =3D ['ng-', 'data-ng-', 'ng\\:'];=0A=
      for (var p =3D 0; p &lt; prefixes.length; ++p) {=0A=
        var attributeEquals =3D opt_exactMatch ? '=3D' : '*=3D';=0A=
        var selector =3D '[' + prefixes[p] + 'model' + attributeEquals + =
'"' + expression + '"]';=0A=
        var elements =3D element.querySelectorAll(selector);=0A=
        if (elements.length) {=0A=
          return elements;=0A=
        }=0A=
      }=0A=
    };=0A=
=0A=
    /**=0A=
     * @name $$testability#getLocation=0A=
     *=0A=
     * @description=0A=
     * Shortcut for getting the location in a browser agnostic way. =
Returns=0A=
     *     the path, search, and hash. (e.g. /path?a=3Db#hash)=0A=
     */=0A=
    testability.getLocation =3D function() {=0A=
      return $location.url();=0A=
    };=0A=
=0A=
    /**=0A=
     * @name $$testability#setLocation=0A=
     *=0A=
     * @description=0A=
     * Shortcut for navigating to a location without doing a full page =
reload.=0A=
     *=0A=
     * @param {string} url The location url (path, search and hash,=0A=
     *     e.g. /path?a=3Db#hash) to go to.=0A=
     */=0A=
    testability.setLocation =3D function(url) {=0A=
      if (url !=3D=3D $location.url()) {=0A=
        $location.url(url);=0A=
        $rootScope.$digest();=0A=
      }=0A=
    };=0A=
=0A=
    /**=0A=
     * @name $$testability#whenStable=0A=
     *=0A=
     * @description=0A=
     * Calls the callback when $timeout and $http requests are completed.=0A=
     *=0A=
     * @param {function} callback=0A=
     */=0A=
    testability.whenStable =3D function(callback) {=0A=
      $browser.notifyWhenNoOutstandingRequests(callback);=0A=
    };=0A=
=0A=
    return testability;=0A=
  }];=0A=
}=0A=
=0A=
/** @this */=0A=
function $TimeoutProvider() {=0A=
  this.$get =3D ['$rootScope', '$browser', '$q', '$$q', =
'$exceptionHandler',=0A=
       function($rootScope,   $browser,   $q,   $$q,   =
$exceptionHandler) {=0A=
=0A=
    var deferreds =3D {};=0A=
=0A=
=0A=
     /**=0A=
      * @ngdoc service=0A=
      * @name $timeout=0A=
      *=0A=
      * @description=0A=
      * Angular's wrapper for `window.setTimeout`. The `fn` function is =
wrapped into a try/catch=0A=
      * block and delegates any exceptions to=0A=
      * {@link ng.$exceptionHandler $exceptionHandler} service.=0A=
      *=0A=
      * The return value of calling `$timeout` is a promise, which will =
be resolved when=0A=
      * the delay has passed and the timeout function, if provided, is =
executed.=0A=
      *=0A=
      * To cancel a timeout request, call `$timeout.cancel(promise)`.=0A=
      *=0A=
      * In tests you can use {@link ngMock.$timeout `$timeout.flush()`} =
to=0A=
      * synchronously flush the queue of deferred functions.=0A=
      *=0A=
      * If you only want a promise that will be resolved after some =
specified delay=0A=
      * then you can call `$timeout` without the `fn` function.=0A=
      *=0A=
      * @param {function()=3D} fn A function, whose execution should be =
delayed.=0A=
      * @param {number=3D} [delay=3D0] Delay in milliseconds.=0A=
      * @param {boolean=3D} [invokeApply=3Dtrue] If set to `false` skips =
model dirty checking, otherwise=0A=
      *   will invoke `fn` within the {@link ng.$rootScope.Scope#$apply =
$apply} block.=0A=
      * @param {...*=3D} Pass additional parameters to the executed =
function.=0A=
      * @returns {Promise} Promise that will be resolved when the =
timeout is reached. The promise=0A=
      *   will be resolved with the return value of the `fn` function.=0A=
      *=0A=
      */=0A=
    function timeout(fn, delay, invokeApply) {=0A=
      if (!isFunction(fn)) {=0A=
        invokeApply =3D delay;=0A=
        delay =3D fn;=0A=
        fn =3D noop;=0A=
      }=0A=
=0A=
      var args =3D sliceArgs(arguments, 3),=0A=
          skipApply =3D (isDefined(invokeApply) &amp;&amp; !invokeApply),=0A=
          deferred =3D (skipApply ? $$q : $q).defer(),=0A=
          promise =3D deferred.promise,=0A=
          timeoutId;=0A=
=0A=
      timeoutId =3D $browser.defer(function() {=0A=
        try {=0A=
          deferred.resolve(fn.apply(null, args));=0A=
        } catch (e) {=0A=
          deferred.reject(e);=0A=
          $exceptionHandler(e);=0A=
        } finally {=0A=
          delete deferreds[promise.$$timeoutId];=0A=
        }=0A=
=0A=
        if (!skipApply) $rootScope.$apply();=0A=
      }, delay);=0A=
=0A=
      promise.$$timeoutId =3D timeoutId;=0A=
      deferreds[timeoutId] =3D deferred;=0A=
=0A=
      return promise;=0A=
    }=0A=
=0A=
=0A=
     /**=0A=
      * @ngdoc method=0A=
      * @name $timeout#cancel=0A=
      *=0A=
      * @description=0A=
      * Cancels a task associated with the `promise`. As a result of =
this, the promise will be=0A=
      * resolved with a rejection.=0A=
      *=0A=
      * @param {Promise=3D} promise Promise returned by the `$timeout` =
function.=0A=
      * @returns {boolean} Returns `true` if the task hasn't executed =
yet and was successfully=0A=
      *   canceled.=0A=
      */=0A=
    timeout.cancel =3D function(promise) {=0A=
      if (promise &amp;&amp; promise.$$timeoutId in deferreds) {=0A=
        // Timeout cancels should not report an unhandled promise.=0A=
        markQExceptionHandled(deferreds[promise.$$timeoutId].promise);=0A=
        deferreds[promise.$$timeoutId].reject('canceled');=0A=
        delete deferreds[promise.$$timeoutId];=0A=
        return $browser.defer.cancel(promise.$$timeoutId);=0A=
      }=0A=
      return false;=0A=
    };=0A=
=0A=
    return timeout;=0A=
  }];=0A=
}=0A=
=0A=
// NOTE:  The usage of window and document instead of $window and =
$document here is=0A=
// deliberate.  This service depends on the specific behavior of anchor =
nodes created by the=0A=
// browser (resolving and parsing URLs) that is unlikely to be provided =
by mock objects and=0A=
// cause us to break tests.  In addition, when the browser resolves a =
URL for XHR, it=0A=
// doesn't know about mocked locations and resolves URLs to the real =
document - which is=0A=
// exactly the behavior needed here.  There is little value is mocking =
these out for this=0A=
// service.=0A=
var urlParsingNode =3D window.document.createElement('a');=0A=
var originUrl =3D urlResolve(window.location.href);=0A=
=0A=
=0A=
/**=0A=
 *=0A=
 * Implementation Notes for non-IE browsers=0A=
 * ----------------------------------------=0A=
 * Assigning a URL to the href property of an anchor DOM node, even one =
attached to the DOM,=0A=
 * results both in the normalizing and parsing of the URL.  Normalizing =
means that a relative=0A=
 * URL will be resolved into an absolute URL in the context of the =
application document.=0A=
 * Parsing means that the anchor node's host, hostname, protocol, port, =
pathname and related=0A=
 * properties are all populated to reflect the normalized URL.  This =
approach has wide=0A=
 * compatibility - Safari 1+, Mozilla 1+ etc.  See=0A=
 * http://www.aptana.com/reference/html/api/HTMLAnchorElement.html=0A=
 *=0A=
 * Implementation Notes for IE=0A=
 * ---------------------------=0A=
 * IE &lt;=3D 10 normalizes the URL when assigned to the anchor node =
similar to the other=0A=
 * browsers.  However, the parsed components will not be set if the URL =
assigned did not specify=0A=
 * them.  (e.g. if you assign a.href =3D "foo", then a.protocol, a.host, =
etc. will be empty.)  We=0A=
 * work around that by performing the parsing in a 2nd step by taking a =
previously normalized=0A=
 * URL (e.g. by assigning to a.href) and assigning it a.href again.  =
This correctly populates the=0A=
 * properties such as protocol, hostname, port, etc.=0A=
 *=0A=
 * References:=0A=
 *   http://developer.mozilla.org/en-US/docs/Web/API/HTMLAnchorElement=0A=
 *   http://www.aptana.com/reference/html/api/HTMLAnchorElement.html=0A=
 *   http://url.spec.whatwg.org/#urlutils=0A=
 *   https://github.com/angular/angular.js/pull/2902=0A=
 *   http://james.padolsey.com/javascript/parsing-urls-with-the-dom/=0A=
 *=0A=
 * @kind function=0A=
 * @param {string} url The URL to be parsed.=0A=
 * @description Normalizes and parses a URL.=0A=
 * @returns {object} Returns the normalized URL as a dictionary.=0A=
 *=0A=
 *   | member name   | Description    |=0A=
 *   |---------------|----------------|=0A=
 *   | href          | A normalized version of the provided URL if it =
was not an absolute URL |=0A=
 *   | protocol      | The protocol including the trailing colon         =
                     |=0A=
 *   | host          | The host and port (if the port is non-default) of =
the normalizedUrl    |=0A=
 *   | search        | The search params, minus the question mark        =
                     |=0A=
 *   | hash          | The hash string, minus the hash symbol=0A=
 *   | hostname      | The hostname=0A=
 *   | port          | The port, without ":"=0A=
 *   | pathname      | The pathname, beginning with "/"=0A=
 *=0A=
 */=0A=
function urlResolve(url) {=0A=
  var href =3D url;=0A=
=0A=
  // Support: IE 9-11 only=0A=
  if (msie) {=0A=
    // Normalize before parse.  Refer Implementation Notes on why this is=0A=
    // done in two steps on IE.=0A=
    urlParsingNode.setAttribute('href', href);=0A=
    href =3D urlParsingNode.href;=0A=
  }=0A=
=0A=
  urlParsingNode.setAttribute('href', href);=0A=
=0A=
  // urlParsingNode provides the UrlUtils interface - =
http://url.spec.whatwg.org/#urlutils=0A=
  return {=0A=
    href: urlParsingNode.href,=0A=
    protocol: urlParsingNode.protocol ? =
urlParsingNode.protocol.replace(/:$/, '') : '',=0A=
    host: urlParsingNode.host,=0A=
    search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, =
'') : '',=0A=
    hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : =
'',=0A=
    hostname: urlParsingNode.hostname,=0A=
    port: urlParsingNode.port,=0A=
    pathname: (urlParsingNode.pathname.charAt(0) =3D=3D=3D '/')=0A=
      ? urlParsingNode.pathname=0A=
      : '/' + urlParsingNode.pathname=0A=
  };=0A=
}=0A=
=0A=
/**=0A=
 * Parse a request URL and determine whether this is a same-origin =
request as the application document.=0A=
 *=0A=
 * @param {string|object} requestUrl The url of the request as a string =
that will be resolved=0A=
 * or a parsed URL object.=0A=
 * @returns {boolean} Whether the request is for the same origin as the =
application document.=0A=
 */=0A=
function urlIsSameOrigin(requestUrl) {=0A=
  var parsed =3D (isString(requestUrl)) ? urlResolve(requestUrl) : =
requestUrl;=0A=
  return (parsed.protocol =3D=3D=3D originUrl.protocol &amp;&amp;=0A=
          parsed.host =3D=3D=3D originUrl.host);=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $window=0A=
 * @this=0A=
 *=0A=
 * @description=0A=
 * A reference to the browser's `window` object. While `window`=0A=
 * is globally available in JavaScript, it causes testability problems, =
because=0A=
 * it is a global variable. In angular we always refer to it through the=0A=
 * `$window` service, so it may be overridden, removed or mocked for =
testing.=0A=
 *=0A=
 * Expressions, like the one defined for the `ngClick` directive in the =
example=0A=
 * below, are evaluated with respect to the current scope.  Therefore, =
there is=0A=
 * no risk of inadvertently coding in a dependency on a global value in =
such an=0A=
 * expression.=0A=
 *=0A=
 * @example=0A=
   &lt;example module=3D"windowExample" name=3D"window-service"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
       &lt;script&gt;=0A=
         angular.module('windowExample', [])=0A=
           .controller('ExampleController', ['$scope', '$window', =
function($scope, $window) {=0A=
             $scope.greeting =3D 'Hello, World!';=0A=
             $scope.doGreeting =3D function(greeting) {=0A=
               $window.alert(greeting);=0A=
             };=0A=
           }]);=0A=
       &lt;/script&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
         &lt;input type=3D"text" ng-model=3D"greeting" =
aria-label=3D"greeting" /&gt;=0A=
         &lt;button =
ng-click=3D"doGreeting(greeting)"&gt;ALERT&lt;/button&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
      it('should display the greeting in the input box', function() {=0A=
       element(by.model('greeting')).sendKeys('Hello, E2E Tests');=0A=
       // If we click the button it will block the test runner=0A=
       // element(':button').click();=0A=
      });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
function $WindowProvider() {=0A=
  this.$get =3D valueFn(window);=0A=
}=0A=
=0A=
/**=0A=
 * @name $$cookieReader=0A=
 * @requires $document=0A=
 *=0A=
 * @description=0A=
 * This is a private service for reading cookies used by $http and =
ngCookies=0A=
 *=0A=
 * @return {Object} a key/value map of the current cookies=0A=
 */=0A=
function $$CookieReader($document) {=0A=
  var rawDocument =3D $document[0] || {};=0A=
  var lastCookies =3D {};=0A=
  var lastCookieString =3D '';=0A=
=0A=
  function safeGetCookie(rawDocument) {=0A=
    try {=0A=
      return rawDocument.cookie || '';=0A=
    } catch (e) {=0A=
      return '';=0A=
    }=0A=
  }=0A=
=0A=
  function safeDecodeURIComponent(str) {=0A=
    try {=0A=
      return decodeURIComponent(str);=0A=
    } catch (e) {=0A=
      return str;=0A=
    }=0A=
  }=0A=
=0A=
  return function() {=0A=
    var cookieArray, cookie, i, index, name;=0A=
    var currentCookieString =3D safeGetCookie(rawDocument);=0A=
=0A=
    if (currentCookieString !=3D=3D lastCookieString) {=0A=
      lastCookieString =3D currentCookieString;=0A=
      cookieArray =3D lastCookieString.split('; ');=0A=
      lastCookies =3D {};=0A=
=0A=
      for (i =3D 0; i &lt; cookieArray.length; i++) {=0A=
        cookie =3D cookieArray[i];=0A=
        index =3D cookie.indexOf('=3D');=0A=
        if (index &gt; 0) { //ignore nameless cookies=0A=
          name =3D safeDecodeURIComponent(cookie.substring(0, index));=0A=
          // the first value that is seen for a cookie is the most=0A=
          // specific one.  values for the same cookie name that=0A=
          // follow are for less specific paths.=0A=
          if (isUndefined(lastCookies[name])) {=0A=
            lastCookies[name] =3D =
safeDecodeURIComponent(cookie.substring(index + 1));=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
    return lastCookies;=0A=
  };=0A=
}=0A=
=0A=
$$CookieReader.$inject =3D ['$document'];=0A=
=0A=
/** @this */=0A=
function $$CookieReaderProvider() {=0A=
  this.$get =3D $$CookieReader;=0A=
}=0A=
=0A=
/* global currencyFilter: true,=0A=
 dateFilter: true,=0A=
 filterFilter: true,=0A=
 jsonFilter: true,=0A=
 limitToFilter: true,=0A=
 lowercaseFilter: true,=0A=
 numberFilter: true,=0A=
 orderByFilter: true,=0A=
 uppercaseFilter: true,=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $filterProvider=0A=
 * @description=0A=
 *=0A=
 * Filters are just functions which transform input to an output. =
However filters need to be=0A=
 * Dependency Injected. To achieve this a filter definition consists of =
a factory function which is=0A=
 * annotated with dependencies and is responsible for creating a filter =
function.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * **Note:** Filter names must be valid angular {@link expression} =
identifiers, such as `uppercase` or `orderBy`.=0A=
 * Names with special characters, such as hyphens and dots, are not =
allowed. If you wish to namespace=0A=
 * your filters, then you can use capitalization =
(`myappSubsectionFilterx`) or underscores=0A=
 * (`myapp_subsection_filterx`).=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * ```js=0A=
 *   // Filter registration=0A=
 *   function MyModule($provide, $filterProvider) {=0A=
 *     // create a service to demonstrate injection (not always needed)=0A=
 *     $provide.value('greet', function(name){=0A=
 *       return 'Hello ' + name + '!';=0A=
 *     });=0A=
 *=0A=
 *     // register a filter factory which uses the=0A=
 *     // greet service to demonstrate DI.=0A=
 *     $filterProvider.register('greet', function(greet){=0A=
 *       // return the filter function which uses the greet service=0A=
 *       // to generate salutation=0A=
 *       return function(text) {=0A=
 *         // filters need to be forgiving so check input validity=0A=
 *         return text &amp;&amp; greet(text) || text;=0A=
 *       };=0A=
 *     });=0A=
 *   }=0A=
 * ```=0A=
 *=0A=
 * The filter function is registered with the `$injector` under the =
filter name suffix with=0A=
 * `Filter`.=0A=
 *=0A=
 * ```js=0A=
 *   it('should be the same instance', inject(=0A=
 *     function($filterProvider) {=0A=
 *       $filterProvider.register('reverse', function(){=0A=
 *         return ...;=0A=
 *       });=0A=
 *     },=0A=
 *     function($filter, reverseFilter) {=0A=
 *       expect($filter('reverse')).toBe(reverseFilter);=0A=
 *     });=0A=
 * ```=0A=
 *=0A=
 *=0A=
 * For more information about how angular filters work, and how to =
create your own filters, see=0A=
 * {@link guide/filter Filters} in the Angular Developer Guide.=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $filter=0A=
 * @kind function=0A=
 * @description=0A=
 * Filters are used for formatting data displayed to the user.=0A=
 *=0A=
 * They can be used in view templates, controllers or services.Angular =
comes=0A=
 * with a collection of [built-in filters](api/ng/filter), but it is =
easy to=0A=
 * define your own as well.=0A=
 *=0A=
 * The general syntax in templates is as follows:=0A=
 *=0A=
 * ```html=0A=
 * {{ expression [| filter_name[:parameter_value] ... ] }}=0A=
 * ```=0A=
 *=0A=
 * @param {String} name Name of the filter function to retrieve=0A=
 * @return {Function} the filter function=0A=
 * @example=0A=
   &lt;example name=3D"$filter" module=3D"filterExample"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
       &lt;div ng-controller=3D"MainCtrl"&gt;=0A=
        &lt;h3&gt;{{ originalText }}&lt;/h3&gt;=0A=
        &lt;h3&gt;{{ filteredText }}&lt;/h3&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
=0A=
     &lt;file name=3D"script.js"&gt;=0A=
      angular.module('filterExample', [])=0A=
      .controller('MainCtrl', function($scope, $filter) {=0A=
        $scope.originalText =3D 'hello';=0A=
        $scope.filteredText =3D =
$filter('uppercase')($scope.originalText);=0A=
      });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
  */=0A=
$FilterProvider.$inject =3D ['$provide'];=0A=
/** @this */=0A=
function $FilterProvider($provide) {=0A=
  var suffix =3D 'Filter';=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $filterProvider#register=0A=
   * @param {string|Object} name Name of the filter function, or an =
object map of filters where=0A=
   *    the keys are the filter names and the values are the filter =
factories.=0A=
   *=0A=
   *    &lt;div class=3D"alert alert-warning"&gt;=0A=
   *    **Note:** Filter names must be valid angular {@link expression} =
identifiers, such as `uppercase` or `orderBy`.=0A=
   *    Names with special characters, such as hyphens and dots, are not =
allowed. If you wish to namespace=0A=
   *    your filters, then you can use capitalization =
(`myappSubsectionFilterx`) or underscores=0A=
   *    (`myapp_subsection_filterx`).=0A=
   *    &lt;/div&gt;=0A=
    * @param {Function} factory If the first argument was a string, a =
factory function for the filter to be registered.=0A=
   * @returns {Object} Registered filter instance, or if a map of =
filters was provided then a map=0A=
   *    of the registered filter instances.=0A=
   */=0A=
  function register(name, factory) {=0A=
    if (isObject(name)) {=0A=
      var filters =3D {};=0A=
      forEach(name, function(filter, key) {=0A=
        filters[key] =3D register(key, filter);=0A=
      });=0A=
      return filters;=0A=
    } else {=0A=
      return $provide.factory(name + suffix, factory);=0A=
    }=0A=
  }=0A=
  this.register =3D register;=0A=
=0A=
  this.$get =3D ['$injector', function($injector) {=0A=
    return function(name) {=0A=
      return $injector.get(name + suffix);=0A=
    };=0A=
  }];=0A=
=0A=
  ////////////////////////////////////////=0A=
=0A=
  /* global=0A=
    currencyFilter: false,=0A=
    dateFilter: false,=0A=
    filterFilter: false,=0A=
    jsonFilter: false,=0A=
    limitToFilter: false,=0A=
    lowercaseFilter: false,=0A=
    numberFilter: false,=0A=
    orderByFilter: false,=0A=
    uppercaseFilter: false=0A=
  */=0A=
=0A=
  register('currency', currencyFilter);=0A=
  register('date', dateFilter);=0A=
  register('filter', filterFilter);=0A=
  register('json', jsonFilter);=0A=
  register('limitTo', limitToFilter);=0A=
  register('lowercase', lowercaseFilter);=0A=
  register('number', numberFilter);=0A=
  register('orderBy', orderByFilter);=0A=
  register('uppercase', uppercaseFilter);=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc filter=0A=
 * @name filter=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Selects a subset of items from `array` and returns it as a new array.=0A=
 *=0A=
 * @param {Array} array The source array.=0A=
 * &lt;div class=3D"alert alert-info"&gt;=0A=
 *   **Note**: If the array contains objects that reference themselves, =
filtering is not possible.=0A=
 * &lt;/div&gt;=0A=
 * @param {string|Object|function()} expression The predicate to be used =
for selecting items from=0A=
 *   `array`.=0A=
 *=0A=
 *   Can be one of:=0A=
 *=0A=
 *   - `string`: The string is used for matching against the contents of =
the `array`. All strings or=0A=
 *     objects with string properties in `array` that match this string =
will be returned. This also=0A=
 *     applies to nested object properties.=0A=
 *     The predicate can be negated by prefixing the string with `!`.=0A=
 *=0A=
 *   - `Object`: A pattern object can be used to filter specific =
properties on objects contained=0A=
 *     by `array`. For example `{name:"M", phone:"1"}` predicate will =
return an array of items=0A=
 *     which have property `name` containing "M" and property `phone` =
containing "1". A special=0A=
 *     property name (`$` by default) can be used (e.g. as in `{$: =
"text"}`) to accept a match=0A=
 *     against any property of the object or its nested object =
properties. That's equivalent to the=0A=
 *     simple substring match with a `string` as described above. The =
special property name can be=0A=
 *     overwritten, using the `anyPropertyKey` parameter.=0A=
 *     The predicate can be negated by prefixing the string with `!`.=0A=
 *     For example `{name: "!M"}` predicate will return an array of =
items which have property `name`=0A=
 *     not containing "M".=0A=
 *=0A=
 *     Note that a named property will match properties on the same =
level only, while the special=0A=
 *     `$` property will match properties on the same level or deeper. =
E.g. an array item like=0A=
 *     `{name: {first: 'John', last: 'Doe'}}` will **not** be matched by =
`{name: 'John'}`, but=0A=
 *     **will** be matched by `{$: 'John'}`.=0A=
 *=0A=
 *   - `function(value, index, array)`: A predicate function can be used =
to write arbitrary filters.=0A=
 *     The function is called for each element of the array, with the =
element, its index, and=0A=
 *     the entire array itself as arguments.=0A=
 *=0A=
 *     The final result is an array of those elements that the predicate =
returned true for.=0A=
 *=0A=
 * @param {function(actual, expected)|true|false} [comparator] =
Comparator which is used in=0A=
 *     determining if values retrieved using `expression` (when it is =
not a function) should be=0A=
 *     considered a match based on the expected value (from the filter =
expression) and actual=0A=
 *     value (from the object in the array).=0A=
 *=0A=
 *   Can be one of:=0A=
 *=0A=
 *   - `function(actual, expected)`:=0A=
 *     The function will be given the object value and the predicate =
value to compare and=0A=
 *     should return true if both values should be considered equal.=0A=
 *=0A=
 *   - `true`: A shorthand for `function(actual, expected) { return =
angular.equals(actual, expected)}`.=0A=
 *     This is essentially strict comparison of expected and actual.=0A=
 *=0A=
 *   - `false`: A short hand for a function which will look for a =
substring match in a case=0A=
 *     insensitive way. Primitive values are converted to strings. =
Objects are not compared against=0A=
 *     primitives, unless they have a custom `toString` method (e.g. =
`Date` objects).=0A=
 *=0A=
 *=0A=
 *   Defaults to `false`.=0A=
 *=0A=
 * @param {string} [anyPropertyKey] The special property name that =
matches against any property.=0A=
 *     By default `$`.=0A=
 *=0A=
 * @example=0A=
   &lt;example name=3D"filter-filter"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
       &lt;div ng-init=3D"friends =3D [{name:'John', phone:'555-1276'},=0A=
                                {name:'Mary', phone:'800-BIG-MARY'},=0A=
                                {name:'Mike', phone:'555-4321'},=0A=
                                {name:'Adam', phone:'555-5678'},=0A=
                                {name:'Julie', phone:'555-8765'},=0A=
                                {name:'Juliette', =
phone:'555-5678'}]"&gt;&lt;/div&gt;=0A=
=0A=
       &lt;label&gt;Search: &lt;input =
ng-model=3D"searchText"&gt;&lt;/label&gt;=0A=
       &lt;table id=3D"searchTextResults"&gt;=0A=
         =
&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Phone&lt;/th&gt;&lt;/tr&gt;=0A=
         &lt;tr ng-repeat=3D"friend in friends | filter:searchText"&gt;=0A=
           &lt;td&gt;{{friend.name}}&lt;/td&gt;=0A=
           &lt;td&gt;{{friend.phone}}&lt;/td&gt;=0A=
         &lt;/tr&gt;=0A=
       &lt;/table&gt;=0A=
       &lt;hr&gt;=0A=
       &lt;label&gt;Any: &lt;input =
ng-model=3D"search.$"&gt;&lt;/label&gt; &lt;br&gt;=0A=
       &lt;label&gt;Name only &lt;input =
ng-model=3D"search.name"&gt;&lt;/label&gt;&lt;br&gt;=0A=
       &lt;label&gt;Phone only &lt;input =
ng-model=3D"search.phone"&gt;&lt;/label&gt;&lt;br&gt;=0A=
       &lt;label&gt;Equality &lt;input type=3D"checkbox" =
ng-model=3D"strict"&gt;&lt;/label&gt;&lt;br&gt;=0A=
       &lt;table id=3D"searchObjResults"&gt;=0A=
         =
&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Phone&lt;/th&gt;&lt;/tr&gt;=0A=
         &lt;tr ng-repeat=3D"friendObj in friends | =
filter:search:strict"&gt;=0A=
           &lt;td&gt;{{friendObj.name}}&lt;/td&gt;=0A=
           &lt;td&gt;{{friendObj.phone}}&lt;/td&gt;=0A=
         &lt;/tr&gt;=0A=
       &lt;/table&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       var expectFriendNames =3D function(expectedNames, key) {=0A=
         element.all(by.repeater(key + ' in friends').column(key + =
'.name')).then(function(arr) {=0A=
           arr.forEach(function(wd, i) {=0A=
             expect(wd.getText()).toMatch(expectedNames[i]);=0A=
           });=0A=
         });=0A=
       };=0A=
=0A=
       it('should search across all fields when filtering with a =
string', function() {=0A=
         var searchText =3D element(by.model('searchText'));=0A=
         searchText.clear();=0A=
         searchText.sendKeys('m');=0A=
         expectFriendNames(['Mary', 'Mike', 'Adam'], 'friend');=0A=
=0A=
         searchText.clear();=0A=
         searchText.sendKeys('76');=0A=
         expectFriendNames(['John', 'Julie'], 'friend');=0A=
       });=0A=
=0A=
       it('should search in specific fields when filtering with a =
predicate object', function() {=0A=
         var searchAny =3D element(by.model('search.$'));=0A=
         searchAny.clear();=0A=
         searchAny.sendKeys('i');=0A=
         expectFriendNames(['Mary', 'Mike', 'Julie', 'Juliette'], =
'friendObj');=0A=
       });=0A=
       it('should use a equal comparison when comparator is true', =
function() {=0A=
         var searchName =3D element(by.model('search.name'));=0A=
         var strict =3D element(by.model('strict'));=0A=
         searchName.clear();=0A=
         searchName.sendKeys('Julie');=0A=
         strict.click();=0A=
         expectFriendNames(['Julie'], 'friendObj');=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
function filterFilter() {=0A=
  return function(array, expression, comparator, anyPropertyKey) {=0A=
    if (!isArrayLike(array)) {=0A=
      if (array =3D=3D null) {=0A=
        return array;=0A=
      } else {=0A=
        throw minErr('filter')('notarray', 'Expected array but received: =
{0}', array);=0A=
      }=0A=
    }=0A=
=0A=
    anyPropertyKey =3D anyPropertyKey || '$';=0A=
    var expressionType =3D getTypeForFilter(expression);=0A=
    var predicateFn;=0A=
    var matchAgainstAnyProp;=0A=
=0A=
    switch (expressionType) {=0A=
      case 'function':=0A=
        predicateFn =3D expression;=0A=
        break;=0A=
      case 'boolean':=0A=
      case 'null':=0A=
      case 'number':=0A=
      case 'string':=0A=
        matchAgainstAnyProp =3D true;=0A=
        // falls through=0A=
      case 'object':=0A=
        predicateFn =3D createPredicateFn(expression, comparator, =
anyPropertyKey, matchAgainstAnyProp);=0A=
        break;=0A=
      default:=0A=
        return array;=0A=
    }=0A=
=0A=
    return Array.prototype.filter.call(array, predicateFn);=0A=
  };=0A=
}=0A=
=0A=
// Helper functions for `filterFilter`=0A=
function createPredicateFn(expression, comparator, anyPropertyKey, =
matchAgainstAnyProp) {=0A=
  var shouldMatchPrimitives =3D isObject(expression) &amp;&amp; =
(anyPropertyKey in expression);=0A=
  var predicateFn;=0A=
=0A=
  if (comparator =3D=3D=3D true) {=0A=
    comparator =3D equals;=0A=
  } else if (!isFunction(comparator)) {=0A=
    comparator =3D function(actual, expected) {=0A=
      if (isUndefined(actual)) {=0A=
        // No substring matching against `undefined`=0A=
        return false;=0A=
      }=0A=
      if ((actual =3D=3D=3D null) || (expected =3D=3D=3D null)) {=0A=
        // No substring matching against `null`; only match against =
`null`=0A=
        return actual =3D=3D=3D expected;=0A=
      }=0A=
      if (isObject(expected) || (isObject(actual) &amp;&amp; =
!hasCustomToString(actual))) {=0A=
        // Should not compare primitives against objects, unless they =
have custom `toString` method=0A=
        return false;=0A=
      }=0A=
=0A=
      actual =3D lowercase('' + actual);=0A=
      expected =3D lowercase('' + expected);=0A=
      return actual.indexOf(expected) !=3D=3D -1;=0A=
    };=0A=
  }=0A=
=0A=
  predicateFn =3D function(item) {=0A=
    if (shouldMatchPrimitives &amp;&amp; !isObject(item)) {=0A=
      return deepCompare(item, expression[anyPropertyKey], comparator, =
anyPropertyKey, false);=0A=
    }=0A=
    return deepCompare(item, expression, comparator, anyPropertyKey, =
matchAgainstAnyProp);=0A=
  };=0A=
=0A=
  return predicateFn;=0A=
}=0A=
=0A=
function deepCompare(actual, expected, comparator, anyPropertyKey, =
matchAgainstAnyProp, dontMatchWholeObject) {=0A=
  var actualType =3D getTypeForFilter(actual);=0A=
  var expectedType =3D getTypeForFilter(expected);=0A=
=0A=
  if ((expectedType =3D=3D=3D 'string') &amp;&amp; (expected.charAt(0) =
=3D=3D=3D '!')) {=0A=
    return !deepCompare(actual, expected.substring(1), comparator, =
anyPropertyKey, matchAgainstAnyProp);=0A=
  } else if (isArray(actual)) {=0A=
    // In case `actual` is an array, consider it a match=0A=
    // if ANY of it's items matches `expected`=0A=
    return actual.some(function(item) {=0A=
      return deepCompare(item, expected, comparator, anyPropertyKey, =
matchAgainstAnyProp);=0A=
    });=0A=
  }=0A=
=0A=
  switch (actualType) {=0A=
    case 'object':=0A=
      var key;=0A=
      if (matchAgainstAnyProp) {=0A=
        for (key in actual) {=0A=
          // Under certain, rare, circumstances, key may not be a string =
and `charAt` will be undefined=0A=
          // See: https://github.com/angular/angular.js/issues/15644=0A=
          if (key.charAt &amp;&amp; (key.charAt(0) !=3D=3D '$') =
&amp;&amp;=0A=
              deepCompare(actual[key], expected, comparator, =
anyPropertyKey, true)) {=0A=
            return true;=0A=
          }=0A=
        }=0A=
        return dontMatchWholeObject ? false : deepCompare(actual, =
expected, comparator, anyPropertyKey, false);=0A=
      } else if (expectedType =3D=3D=3D 'object') {=0A=
        for (key in expected) {=0A=
          var expectedVal =3D expected[key];=0A=
          if (isFunction(expectedVal) || isUndefined(expectedVal)) {=0A=
            continue;=0A=
          }=0A=
=0A=
          var matchAnyProperty =3D key =3D=3D=3D anyPropertyKey;=0A=
          var actualVal =3D matchAnyProperty ? actual : actual[key];=0A=
          if (!deepCompare(actualVal, expectedVal, comparator, =
anyPropertyKey, matchAnyProperty, matchAnyProperty)) {=0A=
            return false;=0A=
          }=0A=
        }=0A=
        return true;=0A=
      } else {=0A=
        return comparator(actual, expected);=0A=
      }=0A=
    case 'function':=0A=
      return false;=0A=
    default:=0A=
      return comparator(actual, expected);=0A=
  }=0A=
}=0A=
=0A=
// Used for easily differentiating between `null` and actual `object`=0A=
function getTypeForFilter(val) {=0A=
  return (val =3D=3D=3D null) ? 'null' : typeof val;=0A=
}=0A=
=0A=
var MAX_DIGITS =3D 22;=0A=
var DECIMAL_SEP =3D '.';=0A=
var ZERO_CHAR =3D '0';=0A=
=0A=
/**=0A=
 * @ngdoc filter=0A=
 * @name currency=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Formats a number as a currency (ie $1,234.56). When no currency =
symbol is provided, default=0A=
 * symbol for current locale is used.=0A=
 *=0A=
 * @param {number} amount Input to filter.=0A=
 * @param {string=3D} symbol Currency symbol or identifier to be =
displayed.=0A=
 * @param {number=3D} fractionSize Number of decimal places to round the =
amount to, defaults to default max fraction size for current locale=0A=
 * @returns {string} Formatted number.=0A=
 *=0A=
 *=0A=
 * @example=0A=
   &lt;example module=3D"currencyExample" name=3D"currency-filter"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
       &lt;script&gt;=0A=
         angular.module('currencyExample', [])=0A=
           .controller('ExampleController', ['$scope', function($scope) {=0A=
             $scope.amount =3D 1234.56;=0A=
           }]);=0A=
       &lt;/script&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
         &lt;input type=3D"number" ng-model=3D"amount" =
aria-label=3D"amount"&gt; &lt;br&gt;=0A=
         default currency symbol ($): &lt;span =
id=3D"currency-default"&gt;{{amount | currency}}&lt;/span&gt;&lt;br&gt;=0A=
         custom currency identifier (USD$): &lt;span =
id=3D"currency-custom"&gt;{{amount | =
currency:"USD$"}}&lt;/span&gt;&lt;br&gt;=0A=
         no fractions (0): &lt;span =
id=3D"currency-no-fractions"&gt;{{amount | =
currency:"USD$":0}}&lt;/span&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should init with 1234.56', function() {=0A=
         =
expect(element(by.id('currency-default')).getText()).toBe('$1,234.56');=0A=
         =
expect(element(by.id('currency-custom')).getText()).toBe('USD$1,234.56');=0A=
         =
expect(element(by.id('currency-no-fractions')).getText()).toBe('USD$1,235=
');=0A=
       });=0A=
       it('should update', function() {=0A=
         if (browser.params.browser =3D=3D=3D 'safari') {=0A=
           // Safari does not understand the minus key. See=0A=
           // https://github.com/angular/protractor/issues/481=0A=
           return;=0A=
         }=0A=
         element(by.model('amount')).clear();=0A=
         element(by.model('amount')).sendKeys('-1234');=0A=
         =
expect(element(by.id('currency-default')).getText()).toBe('-$1,234.00');=0A=
         =
expect(element(by.id('currency-custom')).getText()).toBe('-USD$1,234.00')=
;=0A=
         =
expect(element(by.id('currency-no-fractions')).getText()).toBe('-USD$1,23=
4');=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
currencyFilter.$inject =3D ['$locale'];=0A=
function currencyFilter($locale) {=0A=
  var formats =3D $locale.NUMBER_FORMATS;=0A=
  return function(amount, currencySymbol, fractionSize) {=0A=
    if (isUndefined(currencySymbol)) {=0A=
      currencySymbol =3D formats.CURRENCY_SYM;=0A=
    }=0A=
=0A=
    if (isUndefined(fractionSize)) {=0A=
      fractionSize =3D formats.PATTERNS[1].maxFrac;=0A=
    }=0A=
=0A=
    // if null or undefined pass it through=0A=
    return (amount =3D=3D null)=0A=
        ? amount=0A=
        : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, =
formats.DECIMAL_SEP, fractionSize).=0A=
            replace(/\u00A4/g, currencySymbol);=0A=
  };=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc filter=0A=
 * @name number=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Formats a number as text.=0A=
 *=0A=
 * If the input is null or undefined, it will just be returned.=0A=
 * If the input is infinite (Infinity or -Infinity), the Infinity symbol =
'=E2=88&#65533;' or '-=E2=88&#65533;' is returned, respectively.=0A=
 * If the input is not a number an empty string is returned.=0A=
 *=0A=
 *=0A=
 * @param {number|string} number Number to format.=0A=
 * @param {(number|string)=3D} fractionSize Number of decimal places to =
round the number to.=0A=
 * If this is not provided then the fraction size is computed from the =
current locale's number=0A=
 * formatting pattern. In the case of the default locale, it will be 3.=0A=
 * @returns {string} Number rounded to `fractionSize` appropriately =
formatted based on the current=0A=
 *                   locale (e.g., in the en_US locale it will have "." =
as the decimal separator and=0A=
 *                   include "," group separators after each third =
digit).=0A=
 *=0A=
 * @example=0A=
   &lt;example module=3D"numberFilterExample" name=3D"number-filter"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
       &lt;script&gt;=0A=
         angular.module('numberFilterExample', [])=0A=
           .controller('ExampleController', ['$scope', function($scope) {=0A=
             $scope.val =3D 1234.56789;=0A=
           }]);=0A=
       &lt;/script&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
         &lt;label&gt;Enter number: &lt;input =
ng-model=3D'val'&gt;&lt;/label&gt;&lt;br&gt;=0A=
         Default formatting: &lt;span id=3D'number-default'&gt;{{val | =
number}}&lt;/span&gt;&lt;br&gt;=0A=
         No fractions: &lt;span&gt;{{val | =
number:0}}&lt;/span&gt;&lt;br&gt;=0A=
         Negative number: &lt;span&gt;{{-val | number:4}}&lt;/span&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should format numbers', function() {=0A=
         =
expect(element(by.id('number-default')).getText()).toBe('1,234.568');=0A=
         expect(element(by.binding('val | =
number:0')).getText()).toBe('1,235');=0A=
         expect(element(by.binding('-val | =
number:4')).getText()).toBe('-1,234.5679');=0A=
       });=0A=
=0A=
       it('should update', function() {=0A=
         element(by.model('val')).clear();=0A=
         element(by.model('val')).sendKeys('3374.333');=0A=
         =
expect(element(by.id('number-default')).getText()).toBe('3,374.333');=0A=
         expect(element(by.binding('val | =
number:0')).getText()).toBe('3,374');=0A=
         expect(element(by.binding('-val | =
number:4')).getText()).toBe('-3,374.3330');=0A=
      });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
numberFilter.$inject =3D ['$locale'];=0A=
function numberFilter($locale) {=0A=
  var formats =3D $locale.NUMBER_FORMATS;=0A=
  return function(number, fractionSize) {=0A=
=0A=
    // if null or undefined pass it through=0A=
    return (number =3D=3D null)=0A=
        ? number=0A=
        : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, =
formats.DECIMAL_SEP,=0A=
                       fractionSize);=0A=
  };=0A=
}=0A=
=0A=
/**=0A=
 * Parse a number (as a string) into three components that can be used=0A=
 * for formatting the number.=0A=
 *=0A=
 * (Significant bits of this parse algorithm came from =
https://github.com/MikeMcl/big.js/)=0A=
 *=0A=
 * @param  {string} numStr The number to parse=0A=
 * @return {object} An object describing this number, containing the =
following keys:=0A=
 *  - d : an array of digits containing leading zeros as necessary=0A=
 *  - i : the number of the digits in `d` that are to the left of the =
decimal point=0A=
 *  - e : the exponent for numbers that would need more than =
`MAX_DIGITS` digits in `d`=0A=
 *=0A=
 */=0A=
function parse(numStr) {=0A=
  var exponent =3D 0, digits, numberOfIntegerDigits;=0A=
  var i, j, zeros;=0A=
=0A=
  // Decimal point?=0A=
  if ((numberOfIntegerDigits =3D numStr.indexOf(DECIMAL_SEP)) &gt; -1) {=0A=
    numStr =3D numStr.replace(DECIMAL_SEP, '');=0A=
  }=0A=
=0A=
  // Exponential form?=0A=
  if ((i =3D numStr.search(/e/i)) &gt; 0) {=0A=
    // Work out the exponent.=0A=
    if (numberOfIntegerDigits &lt; 0) numberOfIntegerDigits =3D i;=0A=
    numberOfIntegerDigits +=3D +numStr.slice(i + 1);=0A=
    numStr =3D numStr.substring(0, i);=0A=
  } else if (numberOfIntegerDigits &lt; 0) {=0A=
    // There was no decimal point or exponent so it is an integer.=0A=
    numberOfIntegerDigits =3D numStr.length;=0A=
  }=0A=
=0A=
  // Count the number of leading zeros.=0A=
  for (i =3D 0; numStr.charAt(i) =3D=3D=3D ZERO_CHAR; i++) { /* empty */ =
}=0A=
=0A=
  if (i =3D=3D=3D (zeros =3D numStr.length)) {=0A=
    // The digits are all zero.=0A=
    digits =3D [0];=0A=
    numberOfIntegerDigits =3D 1;=0A=
  } else {=0A=
    // Count the number of trailing zeros=0A=
    zeros--;=0A=
    while (numStr.charAt(zeros) =3D=3D=3D ZERO_CHAR) zeros--;=0A=
=0A=
    // Trailing zeros are insignificant so ignore them=0A=
    numberOfIntegerDigits -=3D i;=0A=
    digits =3D [];=0A=
    // Convert string to array of digits without leading/trailing zeros.=0A=
    for (j =3D 0; i &lt;=3D zeros; i++, j++) {=0A=
      digits[j] =3D +numStr.charAt(i);=0A=
    }=0A=
  }=0A=
=0A=
  // If the number overflows the maximum allowed digits then use an =
exponent.=0A=
  if (numberOfIntegerDigits &gt; MAX_DIGITS) {=0A=
    digits =3D digits.splice(0, MAX_DIGITS - 1);=0A=
    exponent =3D numberOfIntegerDigits - 1;=0A=
    numberOfIntegerDigits =3D 1;=0A=
  }=0A=
=0A=
  return { d: digits, e: exponent, i: numberOfIntegerDigits };=0A=
}=0A=
=0A=
/**=0A=
 * Round the parsed number to the specified number of decimal places=0A=
 * This function changed the parsedNumber in-place=0A=
 */=0A=
function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {=0A=
    var digits =3D parsedNumber.d;=0A=
    var fractionLen =3D digits.length - parsedNumber.i;=0A=
=0A=
    // determine fractionSize if it is not specified; `+fractionSize` =
converts it to a number=0A=
    fractionSize =3D (isUndefined(fractionSize)) ? =
Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;=0A=
=0A=
    // The index of the digit to where rounding is to occur=0A=
    var roundAt =3D fractionSize + parsedNumber.i;=0A=
    var digit =3D digits[roundAt];=0A=
=0A=
    if (roundAt &gt; 0) {=0A=
      // Drop fractional digits beyond `roundAt`=0A=
      digits.splice(Math.max(parsedNumber.i, roundAt));=0A=
=0A=
      // Set non-fractional digits beyond `roundAt` to 0=0A=
      for (var j =3D roundAt; j &lt; digits.length; j++) {=0A=
        digits[j] =3D 0;=0A=
      }=0A=
    } else {=0A=
      // We rounded to zero so reset the parsedNumber=0A=
      fractionLen =3D Math.max(0, fractionLen);=0A=
      parsedNumber.i =3D 1;=0A=
      digits.length =3D Math.max(1, roundAt =3D fractionSize + 1);=0A=
      digits[0] =3D 0;=0A=
      for (var i =3D 1; i &lt; roundAt; i++) digits[i] =3D 0;=0A=
    }=0A=
=0A=
    if (digit &gt;=3D 5) {=0A=
      if (roundAt - 1 &lt; 0) {=0A=
        for (var k =3D 0; k &gt; roundAt; k--) {=0A=
          digits.unshift(0);=0A=
          parsedNumber.i++;=0A=
        }=0A=
        digits.unshift(1);=0A=
        parsedNumber.i++;=0A=
      } else {=0A=
        digits[roundAt - 1]++;=0A=
      }=0A=
    }=0A=
=0A=
    // Pad out with zeros to get the required fraction length=0A=
    for (; fractionLen &lt; Math.max(0, fractionSize); fractionLen++) =
digits.push(0);=0A=
=0A=
=0A=
    // Do any carrying, e.g. a digit was rounded up to 10=0A=
    var carry =3D digits.reduceRight(function(carry, d, i, digits) {=0A=
      d =3D d + carry;=0A=
      digits[i] =3D d % 10;=0A=
      return Math.floor(d / 10);=0A=
    }, 0);=0A=
    if (carry) {=0A=
      digits.unshift(carry);=0A=
      parsedNumber.i++;=0A=
    }=0A=
}=0A=
=0A=
/**=0A=
 * Format a number into a string=0A=
 * @param  {number} number       The number to format=0A=
 * @param  {{=0A=
 *           minFrac, // the minimum number of digits required in the =
fraction part of the number=0A=
 *           maxFrac, // the maximum number of digits required in the =
fraction part of the number=0A=
 *           gSize,   // number of digits in each group of separated =
digits=0A=
 *           lgSize,  // number of digits in the last group of digits =
before the decimal separator=0A=
 *           negPre,  // the string to go in front of a negative number =
(e.g. `-` or `(`))=0A=
 *           posPre,  // the string to go in front of a positive number=0A=
 *           negSuf,  // the string to go after a negative number (e.g. =
`)`)=0A=
 *           posSuf   // the string to go after a positive number=0A=
 *         }} pattern=0A=
 * @param  {string} groupSep     The string to separate groups of number =
(e.g. `,`)=0A=
 * @param  {string} decimalSep   The string to act as the decimal =
separator (e.g. `.`)=0A=
 * @param  {[type]} fractionSize The size of the fractional part of the =
number=0A=
 * @return {string}              The number formatted as a string=0A=
 */=0A=
function formatNumber(number, pattern, groupSep, decimalSep, =
fractionSize) {=0A=
=0A=
  if (!(isString(number) || isNumber(number)) || isNaN(number)) return =
'';=0A=
=0A=
  var isInfinity =3D !isFinite(number);=0A=
  var isZero =3D false;=0A=
  var numStr =3D Math.abs(number) + '',=0A=
      formattedText =3D '',=0A=
      parsedNumber;=0A=
=0A=
  if (isInfinity) {=0A=
    formattedText =3D '\u221e';=0A=
  } else {=0A=
    parsedNumber =3D parse(numStr);=0A=
=0A=
    roundNumber(parsedNumber, fractionSize, pattern.minFrac, =
pattern.maxFrac);=0A=
=0A=
    var digits =3D parsedNumber.d;=0A=
    var integerLen =3D parsedNumber.i;=0A=
    var exponent =3D parsedNumber.e;=0A=
    var decimals =3D [];=0A=
    isZero =3D digits.reduce(function(isZero, d) { return isZero =
&amp;&amp; !d; }, true);=0A=
=0A=
    // pad zeros for small numbers=0A=
    while (integerLen &lt; 0) {=0A=
      digits.unshift(0);=0A=
      integerLen++;=0A=
    }=0A=
=0A=
    // extract decimals digits=0A=
    if (integerLen &gt; 0) {=0A=
      decimals =3D digits.splice(integerLen, digits.length);=0A=
    } else {=0A=
      decimals =3D digits;=0A=
      digits =3D [0];=0A=
    }=0A=
=0A=
    // format the integer digits with grouping separators=0A=
    var groups =3D [];=0A=
    if (digits.length &gt;=3D pattern.lgSize) {=0A=
      groups.unshift(digits.splice(-pattern.lgSize, =
digits.length).join(''));=0A=
    }=0A=
    while (digits.length &gt; pattern.gSize) {=0A=
      groups.unshift(digits.splice(-pattern.gSize, =
digits.length).join(''));=0A=
    }=0A=
    if (digits.length) {=0A=
      groups.unshift(digits.join(''));=0A=
    }=0A=
    formattedText =3D groups.join(groupSep);=0A=
=0A=
    // append the decimal digits=0A=
    if (decimals.length) {=0A=
      formattedText +=3D decimalSep + decimals.join('');=0A=
    }=0A=
=0A=
    if (exponent) {=0A=
      formattedText +=3D 'e+' + exponent;=0A=
    }=0A=
  }=0A=
  if (number &lt; 0 &amp;&amp; !isZero) {=0A=
    return pattern.negPre + formattedText + pattern.negSuf;=0A=
  } else {=0A=
    return pattern.posPre + formattedText + pattern.posSuf;=0A=
  }=0A=
}=0A=
=0A=
function padNumber(num, digits, trim, negWrap) {=0A=
  var neg =3D '';=0A=
  if (num &lt; 0 || (negWrap &amp;&amp; num &lt;=3D 0)) {=0A=
    if (negWrap) {=0A=
      num =3D -num + 1;=0A=
    } else {=0A=
      num =3D -num;=0A=
      neg =3D '-';=0A=
    }=0A=
  }=0A=
  num =3D '' + num;=0A=
  while (num.length &lt; digits) num =3D ZERO_CHAR + num;=0A=
  if (trim) {=0A=
    num =3D num.substr(num.length - digits);=0A=
  }=0A=
  return neg + num;=0A=
}=0A=
=0A=
=0A=
function dateGetter(name, size, offset, trim, negWrap) {=0A=
  offset =3D offset || 0;=0A=
  return function(date) {=0A=
    var value =3D date['get' + name]();=0A=
    if (offset &gt; 0 || value &gt; -offset) {=0A=
      value +=3D offset;=0A=
    }=0A=
    if (value =3D=3D=3D 0 &amp;&amp; offset =3D=3D=3D -12) value =3D 12;=0A=
    return padNumber(value, size, trim, negWrap);=0A=
  };=0A=
}=0A=
=0A=
function dateStrGetter(name, shortForm, standAlone) {=0A=
  return function(date, formats) {=0A=
    var value =3D date['get' + name]();=0A=
    var propPrefix =3D (standAlone ? 'STANDALONE' : '') + (shortForm ? =
'SHORT' : '');=0A=
    var get =3D uppercase(propPrefix + name);=0A=
=0A=
    return formats[get][value];=0A=
  };=0A=
}=0A=
=0A=
function timeZoneGetter(date, formats, offset) {=0A=
  var zone =3D -1 * offset;=0A=
  var paddedZone =3D (zone &gt;=3D 0) ? '+' : '';=0A=
=0A=
  paddedZone +=3D padNumber(Math[zone &gt; 0 ? 'floor' : 'ceil'](zone / =
60), 2) +=0A=
                padNumber(Math.abs(zone % 60), 2);=0A=
=0A=
  return paddedZone;=0A=
}=0A=
=0A=
function getFirstThursdayOfYear(year) {=0A=
    // 0 =3D index of January=0A=
    var dayOfWeekOnFirst =3D (new Date(year, 0, 1)).getDay();=0A=
    // 4 =3D index of Thursday (+1 to account for 1st =3D 5)=0A=
    // 11 =3D index of *next* Thursday (+1 account for 1st =3D 12)=0A=
    return new Date(year, 0, ((dayOfWeekOnFirst &lt;=3D 4) ? 5 : 12) - =
dayOfWeekOnFirst);=0A=
}=0A=
=0A=
function getThursdayThisWeek(datetime) {=0A=
    return new Date(datetime.getFullYear(), datetime.getMonth(),=0A=
      // 4 =3D index of Thursday=0A=
      datetime.getDate() + (4 - datetime.getDay()));=0A=
}=0A=
=0A=
function weekGetter(size) {=0A=
   return function(date) {=0A=
      var firstThurs =3D getFirstThursdayOfYear(date.getFullYear()),=0A=
         thisThurs =3D getThursdayThisWeek(date);=0A=
=0A=
      var diff =3D +thisThurs - +firstThurs,=0A=
         result =3D 1 + Math.round(diff / 6.048e8); // 6.048e8 ms per =
week=0A=
=0A=
      return padNumber(result, size);=0A=
   };=0A=
}=0A=
=0A=
function ampmGetter(date, formats) {=0A=
  return date.getHours() &lt; 12 ? formats.AMPMS[0] : formats.AMPMS[1];=0A=
}=0A=
=0A=
function eraGetter(date, formats) {=0A=
  return date.getFullYear() &lt;=3D 0 ? formats.ERAS[0] : =
formats.ERAS[1];=0A=
}=0A=
=0A=
function longEraGetter(date, formats) {=0A=
  return date.getFullYear() &lt;=3D 0 ? formats.ERANAMES[0] : =
formats.ERANAMES[1];=0A=
}=0A=
=0A=
var DATE_FORMATS =3D {=0A=
  yyyy: dateGetter('FullYear', 4, 0, false, true),=0A=
    yy: dateGetter('FullYear', 2, 0, true, true),=0A=
     y: dateGetter('FullYear', 1, 0, false, true),=0A=
  MMMM: dateStrGetter('Month'),=0A=
   MMM: dateStrGetter('Month', true),=0A=
    MM: dateGetter('Month', 2, 1),=0A=
     M: dateGetter('Month', 1, 1),=0A=
  LLLL: dateStrGetter('Month', false, true),=0A=
    dd: dateGetter('Date', 2),=0A=
     d: dateGetter('Date', 1),=0A=
    HH: dateGetter('Hours', 2),=0A=
     H: dateGetter('Hours', 1),=0A=
    hh: dateGetter('Hours', 2, -12),=0A=
     h: dateGetter('Hours', 1, -12),=0A=
    mm: dateGetter('Minutes', 2),=0A=
     m: dateGetter('Minutes', 1),=0A=
    ss: dateGetter('Seconds', 2),=0A=
     s: dateGetter('Seconds', 1),=0A=
     // while ISO 8601 requires fractions to be prefixed with `.` or `,`=0A=
     // we can be just safely rely on using `sss` since we currently =
don't support single or two digit fractions=0A=
   sss: dateGetter('Milliseconds', 3),=0A=
  EEEE: dateStrGetter('Day'),=0A=
   EEE: dateStrGetter('Day', true),=0A=
     a: ampmGetter,=0A=
     Z: timeZoneGetter,=0A=
    ww: weekGetter(2),=0A=
     w: weekGetter(1),=0A=
     G: eraGetter,=0A=
     GG: eraGetter,=0A=
     GGG: eraGetter,=0A=
     GGGG: longEraGetter=0A=
};=0A=
=0A=
var DATE_FORMATS_SPLIT =3D =
/((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+=
|a|Z|G+|w+))([\s\S]*)/,=0A=
    NUMBER_STRING =3D /^-?\d+$/;=0A=
=0A=
/**=0A=
 * @ngdoc filter=0A=
 * @name date=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 *   Formats `date` to a string based on the requested `format`.=0A=
 *=0A=
 *   `format` string can be composed of the following elements:=0A=
 *=0A=
 *   * `'yyyy'`: 4 digit representation of year (e.g. AD 1 =3D&gt; 0001, =
AD 2010 =3D&gt; 2010)=0A=
 *   * `'yy'`: 2 digit representation of year, padded (00-99). (e.g. AD =
2001 =3D&gt; 01, AD 2010 =3D&gt; 10)=0A=
 *   * `'y'`: 1 digit representation of year, e.g. (AD 1 =3D&gt; 1, AD =
199 =3D&gt; 199)=0A=
 *   * `'MMMM'`: Month in year (January-December)=0A=
 *   * `'MMM'`: Month in year (Jan-Dec)=0A=
 *   * `'MM'`: Month in year, padded (01-12)=0A=
 *   * `'M'`: Month in year (1-12)=0A=
 *   * `'LLLL'`: Stand-alone month in year (January-December)=0A=
 *   * `'dd'`: Day in month, padded (01-31)=0A=
 *   * `'d'`: Day in month (1-31)=0A=
 *   * `'EEEE'`: Day in Week,(Sunday-Saturday)=0A=
 *   * `'EEE'`: Day in Week, (Sun-Sat)=0A=
 *   * `'HH'`: Hour in day, padded (00-23)=0A=
 *   * `'H'`: Hour in day (0-23)=0A=
 *   * `'hh'`: Hour in AM/PM, padded (01-12)=0A=
 *   * `'h'`: Hour in AM/PM, (1-12)=0A=
 *   * `'mm'`: Minute in hour, padded (00-59)=0A=
 *   * `'m'`: Minute in hour (0-59)=0A=
 *   * `'ss'`: Second in minute, padded (00-59)=0A=
 *   * `'s'`: Second in minute (0-59)=0A=
 *   * `'sss'`: Millisecond in second, padded (000-999)=0A=
 *   * `'a'`: AM/PM marker=0A=
 *   * `'Z'`: 4 digit (+sign) representation of the timezone offset =
(-1200-+1200)=0A=
 *   * `'ww'`: Week of year, padded (00-53). Week 01 is the week with =
the first Thursday of the year=0A=
 *   * `'w'`: Week of year (0-53). Week 1 is the week with the first =
Thursday of the year=0A=
 *   * `'G'`, `'GG'`, `'GGG'`: The abbreviated form of the era string =
(e.g. 'AD')=0A=
 *   * `'GGGG'`: The long form of the era string (e.g. 'Anno Domini')=0A=
 *=0A=
 *   `format` string can also be one of the following predefined=0A=
 *   {@link guide/i18n localizable formats}:=0A=
 *=0A=
 *   * `'medium'`: equivalent to `'MMM d, y h:mm:ss a'` for en_US locale=0A=
 *     (e.g. Sep 3, 2010 12:05:08 PM)=0A=
 *   * `'short'`: equivalent to `'M/d/yy h:mm a'` for en_US  locale =
(e.g. 9/3/10 12:05 PM)=0A=
 *   * `'fullDate'`: equivalent to `'EEEE, MMMM d, y'` for en_US  locale=0A=
 *     (e.g. Friday, September 3, 2010)=0A=
 *   * `'longDate'`: equivalent to `'MMMM d, y'` for en_US  locale (e.g. =
September 3, 2010)=0A=
 *   * `'mediumDate'`: equivalent to `'MMM d, y'` for en_US  locale =
(e.g. Sep 3, 2010)=0A=
 *   * `'shortDate'`: equivalent to `'M/d/yy'` for en_US locale (e.g. =
9/3/10)=0A=
 *   * `'mediumTime'`: equivalent to `'h:mm:ss a'` for en_US locale =
(e.g. 12:05:08 PM)=0A=
 *   * `'shortTime'`: equivalent to `'h:mm a'` for en_US locale (e.g. =
12:05 PM)=0A=
 *=0A=
 *   `format` string can contain literal values. These need to be =
escaped by surrounding with single quotes (e.g.=0A=
 *   `"h 'in the morning'"`). In order to output a single quote, escape =
it - i.e., two single quotes in a sequence=0A=
 *   (e.g. `"h 'o''clock'"`).=0A=
 *=0A=
 *   Any other characters in the `format` string will be output as-is.=0A=
 *=0A=
 * @param {(Date|number|string)} date Date to format either as Date =
object, milliseconds (string or=0A=
 *    number) or various ISO 8601 datetime string formats (e.g. =
yyyy-MM-ddTHH:mm:ss.sssZ and its=0A=
 *    shorter versions like yyyy-MM-ddTHH:mmZ, yyyy-MM-dd or =
yyyyMMddTHHmmssZ). If no timezone is=0A=
 *    specified in the string input, the time is considered to be in the =
local timezone.=0A=
 * @param {string=3D} format Formatting rules (see Description). If not =
specified,=0A=
 *    `mediumDate` is used.=0A=
 * @param {string=3D} timezone Timezone to be used for formatting. It =
understands UTC/GMT and the=0A=
 *    continental US time zone abbreviations, but for general use, use a =
time zone offset, for=0A=
 *    example, `'+0430'` (4 hours, 30 minutes east of the Greenwich =
meridian)=0A=
 *    If not specified, the timezone of the browser will be used.=0A=
 * @returns {string} Formatted string or the input if input is not =
recognized as date/millis.=0A=
 *=0A=
 * @example=0A=
   &lt;example name=3D"filter-date"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
       &lt;span ng-non-bindable&gt;{{1288323623006 | =
date:'medium'}}&lt;/span&gt;:=0A=
           &lt;span&gt;{{1288323623006 | =
date:'medium'}}&lt;/span&gt;&lt;br&gt;=0A=
       &lt;span ng-non-bindable&gt;{{1288323623006 | date:'yyyy-MM-dd =
HH:mm:ss Z'}}&lt;/span&gt;:=0A=
          &lt;span&gt;{{1288323623006 | date:'yyyy-MM-dd HH:mm:ss =
Z'}}&lt;/span&gt;&lt;br&gt;=0A=
       &lt;span ng-non-bindable&gt;{{1288323623006 | date:'MM/dd/yyyy @ =
h:mma'}}&lt;/span&gt;:=0A=
          &lt;span&gt;{{'1288323623006' | date:'MM/dd/yyyy @ =
h:mma'}}&lt;/span&gt;&lt;br&gt;=0A=
       &lt;span ng-non-bindable&gt;{{1288323623006 | date:"MM/dd/yyyy =
'at' h:mma"}}&lt;/span&gt;:=0A=
          &lt;span&gt;{{'1288323623006' | date:"MM/dd/yyyy 'at' =
h:mma"}}&lt;/span&gt;&lt;br&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should format date', function() {=0A=
         expect(element(by.binding("1288323623006 | =
date:'medium'")).getText()).=0A=
            toMatch(/Oct 2\d, 2010 \d{1,2}:\d{2}:\d{2} (AM|PM)/);=0A=
         expect(element(by.binding("1288323623006 | date:'yyyy-MM-dd =
HH:mm:ss Z'")).getText()).=0A=
            toMatch(/2010-10-2\d \d{2}:\d{2}:\d{2} (-|\+)?\d{4}/);=0A=
         expect(element(by.binding("'1288323623006' | date:'MM/dd/yyyy @ =
h:mma'")).getText()).=0A=
            toMatch(/10\/2\d\/2010 @ \d{1,2}:\d{2}(AM|PM)/);=0A=
         expect(element(by.binding("'1288323623006' | date:\"MM/dd/yyyy =
'at' h:mma\"")).getText()).=0A=
            toMatch(/10\/2\d\/2010 at \d{1,2}:\d{2}(AM|PM)/);=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
dateFilter.$inject =3D ['$locale'];=0A=
function dateFilter($locale) {=0A=
=0A=
=0A=
  var R_ISO8601_STR =3D =
/^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?=
(Z|([+-])(\d\d):?(\d\d))?)?$/;=0A=
                     // 1        2       3         4          5          =
6          7          8  9     10      11=0A=
  function jsonStringToDate(string) {=0A=
    var match;=0A=
    if ((match =3D string.match(R_ISO8601_STR))) {=0A=
      var date =3D new Date(0),=0A=
          tzHour =3D 0,=0A=
          tzMin  =3D 0,=0A=
          dateSetter =3D match[8] ? date.setUTCFullYear : =
date.setFullYear,=0A=
          timeSetter =3D match[8] ? date.setUTCHours : date.setHours;=0A=
=0A=
      if (match[9]) {=0A=
        tzHour =3D toInt(match[9] + match[10]);=0A=
        tzMin =3D toInt(match[9] + match[11]);=0A=
      }=0A=
      dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, =
toInt(match[3]));=0A=
      var h =3D toInt(match[4] || 0) - tzHour;=0A=
      var m =3D toInt(match[5] || 0) - tzMin;=0A=
      var s =3D toInt(match[6] || 0);=0A=
      var ms =3D Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);=0A=
      timeSetter.call(date, h, m, s, ms);=0A=
      return date;=0A=
    }=0A=
    return string;=0A=
  }=0A=
=0A=
=0A=
  return function(date, format, timezone) {=0A=
    var text =3D '',=0A=
        parts =3D [],=0A=
        fn, match;=0A=
=0A=
    format =3D format || 'mediumDate';=0A=
    format =3D $locale.DATETIME_FORMATS[format] || format;=0A=
    if (isString(date)) {=0A=
      date =3D NUMBER_STRING.test(date) ? toInt(date) : =
jsonStringToDate(date);=0A=
    }=0A=
=0A=
    if (isNumber(date)) {=0A=
      date =3D new Date(date);=0A=
    }=0A=
=0A=
    if (!isDate(date) || !isFinite(date.getTime())) {=0A=
      return date;=0A=
    }=0A=
=0A=
    while (format) {=0A=
      match =3D DATE_FORMATS_SPLIT.exec(format);=0A=
      if (match) {=0A=
        parts =3D concat(parts, match, 1);=0A=
        format =3D parts.pop();=0A=
      } else {=0A=
        parts.push(format);=0A=
        format =3D null;=0A=
      }=0A=
    }=0A=
=0A=
    var dateTimezoneOffset =3D date.getTimezoneOffset();=0A=
    if (timezone) {=0A=
      dateTimezoneOffset =3D timezoneToOffset(timezone, =
dateTimezoneOffset);=0A=
      date =3D convertTimezoneToLocal(date, timezone, true);=0A=
    }=0A=
    forEach(parts, function(value) {=0A=
      fn =3D DATE_FORMATS[value];=0A=
      text +=3D fn ? fn(date, $locale.DATETIME_FORMATS, =
dateTimezoneOffset)=0A=
                 : value =3D=3D=3D '\'\'' ? '\'' : =
value.replace(/(^'|'$)/g, '').replace(/''/g, '\'');=0A=
    });=0A=
=0A=
    return text;=0A=
  };=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc filter=0A=
 * @name json=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 *   Allows you to convert a JavaScript object into JSON string.=0A=
 *=0A=
 *   This filter is mostly useful for debugging. When using the double =
curly {{value}} notation=0A=
 *   the binding is automatically converted to JSON.=0A=
 *=0A=
 * @param {*} object Any JavaScript object (including arrays and =
primitive types) to filter.=0A=
 * @param {number=3D} spacing The number of spaces to use per =
indentation, defaults to 2.=0A=
 * @returns {string} JSON string.=0A=
 *=0A=
 *=0A=
 * @example=0A=
   &lt;example name=3D"filter-json"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
       &lt;pre id=3D"default-spacing"&gt;{{ {'name':'value'} | json =
}}&lt;/pre&gt;=0A=
       &lt;pre id=3D"custom-spacing"&gt;{{ {'name':'value'} | json:4 =
}}&lt;/pre&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should jsonify filtered objects', function() {=0A=
         =
expect(element(by.id('default-spacing')).getText()).toMatch(/\{\n =
{2}"name": ?"value"\n}/);=0A=
         =
expect(element(by.id('custom-spacing')).getText()).toMatch(/\{\n =
{4}"name": ?"value"\n}/);=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 *=0A=
 */=0A=
function jsonFilter() {=0A=
  return function(object, spacing) {=0A=
    if (isUndefined(spacing)) {=0A=
        spacing =3D 2;=0A=
    }=0A=
    return toJson(object, spacing);=0A=
  };=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc filter=0A=
 * @name lowercase=0A=
 * @kind function=0A=
 * @description=0A=
 * Converts string to lowercase.=0A=
 *=0A=
 * See the {@link ng.uppercase uppercase filter documentation} for a =
functionally identical example.=0A=
 *=0A=
 * @see angular.lowercase=0A=
 */=0A=
var lowercaseFilter =3D valueFn(lowercase);=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc filter=0A=
 * @name uppercase=0A=
 * @kind function=0A=
 * @description=0A=
 * Converts string to uppercase.=0A=
 * @example=0A=
   &lt;example module=3D"uppercaseFilterExample" =
name=3D"filter-uppercase"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
       &lt;script&gt;=0A=
         angular.module('uppercaseFilterExample', [])=0A=
           .controller('ExampleController', ['$scope', function($scope) {=0A=
             $scope.title =3D 'This is a title';=0A=
           }]);=0A=
       &lt;/script&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
         &lt;!-- This title should be formatted normally --&gt;=0A=
         &lt;h1&gt;{{title}}&lt;/h1&gt;=0A=
         &lt;!-- This title should be capitalized --&gt;=0A=
         &lt;h1&gt;{{title | uppercase}}&lt;/h1&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
var uppercaseFilter =3D valueFn(uppercase);=0A=
=0A=
/**=0A=
 * @ngdoc filter=0A=
 * @name limitTo=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Creates a new array or string containing only a specified number of =
elements. The elements are=0A=
 * taken from either the beginning or the end of the source array, =
string or number, as specified by=0A=
 * the value and sign (positive or negative) of `limit`. Other =
array-like objects are also supported=0A=
 * (e.g. array subclasses, NodeLists, jqLite/jQuery collections etc). If =
a number is used as input,=0A=
 * it is converted to a string.=0A=
 *=0A=
 * @param {Array|ArrayLike|string|number} input - Array/array-like, =
string or number to be limited.=0A=
 * @param {string|number} limit - The length of the returned array or =
string. If the `limit` number=0A=
 *     is positive, `limit` number of items from the beginning of the =
source array/string are copied.=0A=
 *     If the number is negative, `limit` number  of items from the end =
of the source array/string=0A=
 *     are copied. The `limit` will be trimmed if it exceeds =
`array.length`. If `limit` is undefined,=0A=
 *     the input will be returned unchanged.=0A=
 * @param {(string|number)=3D} begin - Index at which to begin =
limitation. As a negative index,=0A=
 *     `begin` indicates an offset from the end of `input`. Defaults to =
`0`.=0A=
 * @returns {Array|string} A new sub-array or substring of length =
`limit` or less if the input had=0A=
 *     less than `limit` elements.=0A=
 *=0A=
 * @example=0A=
   &lt;example module=3D"limitToExample" name=3D"limit-to-filter"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
       &lt;script&gt;=0A=
         angular.module('limitToExample', [])=0A=
           .controller('ExampleController', ['$scope', function($scope) {=0A=
             $scope.numbers =3D [1,2,3,4,5,6,7,8,9];=0A=
             $scope.letters =3D "abcdefghi";=0A=
             $scope.longNumber =3D 2345432342;=0A=
             $scope.numLimit =3D 3;=0A=
             $scope.letterLimit =3D 3;=0A=
             $scope.longNumberLimit =3D 3;=0A=
           }]);=0A=
       &lt;/script&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
         &lt;label&gt;=0A=
            Limit {{numbers}} to:=0A=
            &lt;input type=3D"number" step=3D"1" =
ng-model=3D"numLimit"&gt;=0A=
         &lt;/label&gt;=0A=
         &lt;p&gt;Output numbers: {{ numbers | limitTo:numLimit =
}}&lt;/p&gt;=0A=
         &lt;label&gt;=0A=
            Limit {{letters}} to:=0A=
            &lt;input type=3D"number" step=3D"1" =
ng-model=3D"letterLimit"&gt;=0A=
         &lt;/label&gt;=0A=
         &lt;p&gt;Output letters: {{ letters | limitTo:letterLimit =
}}&lt;/p&gt;=0A=
         &lt;label&gt;=0A=
            Limit {{longNumber}} to:=0A=
            &lt;input type=3D"number" step=3D"1" =
ng-model=3D"longNumberLimit"&gt;=0A=
         &lt;/label&gt;=0A=
         &lt;p&gt;Output long number: {{ longNumber | =
limitTo:longNumberLimit }}&lt;/p&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       var numLimitInput =3D element(by.model('numLimit'));=0A=
       var letterLimitInput =3D element(by.model('letterLimit'));=0A=
       var longNumberLimitInput =3D element(by.model('longNumberLimit'));=0A=
       var limitedNumbers =3D element(by.binding('numbers | =
limitTo:numLimit'));=0A=
       var limitedLetters =3D element(by.binding('letters | =
limitTo:letterLimit'));=0A=
       var limitedLongNumber =3D element(by.binding('longNumber | =
limitTo:longNumberLimit'));=0A=
=0A=
       it('should limit the number array to first three items', =
function() {=0A=
         expect(numLimitInput.getAttribute('value')).toBe('3');=0A=
         expect(letterLimitInput.getAttribute('value')).toBe('3');=0A=
         expect(longNumberLimitInput.getAttribute('value')).toBe('3');=0A=
         expect(limitedNumbers.getText()).toEqual('Output numbers: =
[1,2,3]');=0A=
         expect(limitedLetters.getText()).toEqual('Output letters: abc');=0A=
         expect(limitedLongNumber.getText()).toEqual('Output long =
number: 234');=0A=
       });=0A=
=0A=
       // There is a bug in safari and protractor that doesn't like the =
minus key=0A=
       // it('should update the output when -3 is entered', function() {=0A=
       //   numLimitInput.clear();=0A=
       //   numLimitInput.sendKeys('-3');=0A=
       //   letterLimitInput.clear();=0A=
       //   letterLimitInput.sendKeys('-3');=0A=
       //   longNumberLimitInput.clear();=0A=
       //   longNumberLimitInput.sendKeys('-3');=0A=
       //   expect(limitedNumbers.getText()).toEqual('Output numbers: =
[7,8,9]');=0A=
       //   expect(limitedLetters.getText()).toEqual('Output letters: =
ghi');=0A=
       //   expect(limitedLongNumber.getText()).toEqual('Output long =
number: 342');=0A=
       // });=0A=
=0A=
       it('should not exceed the maximum size of input array', =
function() {=0A=
         numLimitInput.clear();=0A=
         numLimitInput.sendKeys('100');=0A=
         letterLimitInput.clear();=0A=
         letterLimitInput.sendKeys('100');=0A=
         longNumberLimitInput.clear();=0A=
         longNumberLimitInput.sendKeys('100');=0A=
         expect(limitedNumbers.getText()).toEqual('Output numbers: =
[1,2,3,4,5,6,7,8,9]');=0A=
         expect(limitedLetters.getText()).toEqual('Output letters: =
abcdefghi');=0A=
         expect(limitedLongNumber.getText()).toEqual('Output long =
number: 2345432342');=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
*/=0A=
function limitToFilter() {=0A=
  return function(input, limit, begin) {=0A=
    if (Math.abs(Number(limit)) =3D=3D=3D Infinity) {=0A=
      limit =3D Number(limit);=0A=
    } else {=0A=
      limit =3D toInt(limit);=0A=
    }=0A=
    if (isNumberNaN(limit)) return input;=0A=
=0A=
    if (isNumber(input)) input =3D input.toString();=0A=
    if (!isArrayLike(input)) return input;=0A=
=0A=
    begin =3D (!begin || isNaN(begin)) ? 0 : toInt(begin);=0A=
    begin =3D (begin &lt; 0) ? Math.max(0, input.length + begin) : begin;=0A=
=0A=
    if (limit &gt;=3D 0) {=0A=
      return sliceFn(input, begin, begin + limit);=0A=
    } else {=0A=
      if (begin =3D=3D=3D 0) {=0A=
        return sliceFn(input, limit, input.length);=0A=
      } else {=0A=
        return sliceFn(input, Math.max(0, begin + limit), begin);=0A=
      }=0A=
    }=0A=
  };=0A=
}=0A=
=0A=
function sliceFn(input, begin, end) {=0A=
  if (isString(input)) return input.slice(begin, end);=0A=
=0A=
  return slice.call(input, begin, end);=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc filter=0A=
 * @name orderBy=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Returns an array containing the items from the specified =
`collection`, ordered by a `comparator`=0A=
 * function based on the values computed using the `expression` =
predicate.=0A=
 *=0A=
 * For example, `[{id: 'foo'}, {id: 'bar'}] | orderBy:'id'` would result =
in=0A=
 * `[{id: 'bar'}, {id: 'foo'}]`.=0A=
 *=0A=
 * The `collection` can be an Array or array-like object (e.g. NodeList, =
jQuery object, TypedArray,=0A=
 * String, etc).=0A=
 *=0A=
 * The `expression` can be a single predicate, or a list of predicates =
each serving as a tie-breaker=0A=
 * for the preceding one. The `expression` is evaluated against each =
item and the output is used=0A=
 * for comparing with other items.=0A=
 *=0A=
 * You can change the sorting order by setting `reverse` to `true`. By =
default, items are sorted in=0A=
 * ascending order.=0A=
 *=0A=
 * The comparison is done using the `comparator` function. If none is =
specified, a default, built-in=0A=
 * comparator is used (see below for details - in a nutshell, it =
compares numbers numerically and=0A=
 * strings alphabetically).=0A=
 *=0A=
 * ### Under the hood=0A=
 *=0A=
 * Ordering the specified `collection` happens in two phases:=0A=
 *=0A=
 * 1. All items are passed through the predicate (or predicates), and =
the returned values are saved=0A=
 *    along with their type (`string`, `number` etc). For example, an =
item `{label: 'foo'}`, passed=0A=
 *    through a predicate that extracts the value of the `label` =
property, would be transformed to:=0A=
 *    ```=0A=
 *    {=0A=
 *      value: 'foo',=0A=
 *      type: 'string',=0A=
 *      index: ...=0A=
 *    }=0A=
 *    ```=0A=
 * 2. The comparator function is used to sort the items, based on the =
derived values, types and=0A=
 *    indices.=0A=
 *=0A=
 * If you use a custom comparator, it will be called with pairs of =
objects of the form=0A=
 * `{value: ..., type: '...', index: ...}` and is expected to return `0` =
if the objects are equal=0A=
 * (as far as the comparator is concerned), `-1` if the 1st one should =
be ranked higher than the=0A=
 * second, or `1` otherwise.=0A=
 *=0A=
 * In order to ensure that the sorting will be deterministic across =
platforms, if none of the=0A=
 * specified predicates can distinguish between two items, `orderBy` =
will automatically introduce a=0A=
 * dummy predicate that returns the item's index as `value`.=0A=
 * (If you are using a custom comparator, make sure it can handle this =
predicate as well.)=0A=
 *=0A=
 * If a custom comparator still can't distinguish between two items, =
then they will be sorted based=0A=
 * on their index using the built-in comparator.=0A=
 *=0A=
 * Finally, in an attempt to simplify things, if a predicate returns an =
object as the extracted=0A=
 * value for an item, `orderBy` will try to convert that object to a =
primitive value, before passing=0A=
 * it to the comparator. The following rules govern the conversion:=0A=
 *=0A=
 * 1. If the object has a `valueOf()` method that returns a primitive, =
its return value will be=0A=
 *    used instead.&lt;br /&gt;=0A=
 *    (If the object has a `valueOf()` method that returns another =
object, then the returned object=0A=
 *    will be used in subsequent steps.)=0A=
 * 2. If the object has a custom `toString()` method (i.e. not the one =
inherited from `Object`) that=0A=
 *    returns a primitive, its return value will be used instead.&lt;br =
/&gt;=0A=
 *    (If the object has a `toString()` method that returns another =
object, then the returned object=0A=
 *    will be used in subsequent steps.)=0A=
 * 3. No conversion; the object itself is used.=0A=
 *=0A=
 * ### The default comparator=0A=
 *=0A=
 * The default, built-in comparator should be sufficient for most =
usecases. In short, it compares=0A=
 * numbers numerically, strings alphabetically (and case-insensitively), =
for objects falls back to=0A=
 * using their index in the original collection, and sorts values of =
different types by type.=0A=
 *=0A=
 * More specifically, it follows these steps to determine the relative =
order of items:=0A=
 *=0A=
 * 1. If the compared values are of different types, compare the types =
themselves alphabetically.=0A=
 * 2. If both values are of type `string`, compare them alphabetically =
in a case- and=0A=
 *    locale-insensitive way.=0A=
 * 3. If both values are objects, compare their indices instead.=0A=
 * 4. Otherwise, return:=0A=
 *    -  `0`, if the values are equal (by strict equality comparison, =
i.e. using `=3D=3D=3D`).=0A=
 *    - `-1`, if the 1st value is "less than" the 2nd value (compared =
using the `&lt;` operator).=0A=
 *    -  `1`, otherwise.=0A=
 *=0A=
 * **Note:** If you notice numbers not being sorted as expected, make =
sure they are actually being=0A=
 *           saved as numbers and not strings.=0A=
 * **Note:** For the purpose of sorting, `null` values are treated as =
the string `'null'` (i.e.=0A=
 *           `type: 'string'`, `value: 'null'`). This may cause =
unexpected sort order relative to=0A=
 *           other values.=0A=
 *=0A=
 * @param {Array|ArrayLike} collection - The collection (array or =
array-like object) to sort.=0A=
 * @param {(Function|string|Array.&lt;Function|string&gt;)=3D} =
expression - A predicate (or list of=0A=
 *    predicates) to be used by the comparator to determine the order of =
elements.=0A=
 *=0A=
 *    Can be one of:=0A=
 *=0A=
 *    - `Function`: A getter function. This function will be called with =
each item as argument and=0A=
 *      the return value will be used for sorting.=0A=
 *    - `string`: An Angular expression. This expression will be =
evaluated against each item and the=0A=
 *      result will be used for sorting. For example, use `'label'` to =
sort by a property called=0A=
 *      `label` or `'label.substring(0, 3)'` to sort by the first 3 =
characters of the `label`=0A=
 *      property.&lt;br /&gt;=0A=
 *      (The result of a constant expression is interpreted as a =
property name to be used for=0A=
 *      comparison. For example, use `'"special name"'` (note the extra =
pair of quotes) to sort by a=0A=
 *      property called `special name`.)&lt;br /&gt;=0A=
 *      An expression can be optionally prefixed with `+` or `-` to =
control the sorting direction,=0A=
 *      ascending or descending. For example, `'+label'` or `'-label'`. =
If no property is provided,=0A=
 *      (e.g. `'+'` or `'-'`), the collection element itself is used in =
comparisons.=0A=
 *    - `Array`: An array of function and/or string predicates. If a =
predicate cannot determine the=0A=
 *      relative order of two items, the next predicate is used as a =
tie-breaker.=0A=
 *=0A=
 * **Note:** If the predicate is missing or empty then it defaults to =
`'+'`.=0A=
 *=0A=
 * @param {boolean=3D} reverse - If `true`, reverse the sorting order.=0A=
 * @param {(Function)=3D} comparator - The comparator function used to =
determine the relative order of=0A=
 *    value pairs. If omitted, the built-in comparator will be used.=0A=
 *=0A=
 * @returns {Array} - The sorted array.=0A=
 *=0A=
 *=0A=
 * @example=0A=
 * ### Ordering a table with `ngRepeat`=0A=
 *=0A=
 * The example below demonstrates a simple {@link ngRepeat ngRepeat}, =
where the data is sorted by=0A=
 * age in descending order (expression is set to `'-age'`). The =
`comparator` is not set, which means=0A=
 * it defaults to the built-in comparator.=0A=
 *=0A=
   &lt;example name=3D"orderBy-static" module=3D"orderByExample1"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
         &lt;table class=3D"friends"&gt;=0A=
           &lt;tr&gt;=0A=
             &lt;th&gt;Name&lt;/th&gt;=0A=
             &lt;th&gt;Phone Number&lt;/th&gt;=0A=
             &lt;th&gt;Age&lt;/th&gt;=0A=
           &lt;/tr&gt;=0A=
           &lt;tr ng-repeat=3D"friend in friends | orderBy:'-age'"&gt;=0A=
             &lt;td&gt;{{friend.name}}&lt;/td&gt;=0A=
             &lt;td&gt;{{friend.phone}}&lt;/td&gt;=0A=
             &lt;td&gt;{{friend.age}}&lt;/td&gt;=0A=
           &lt;/tr&gt;=0A=
         &lt;/table&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"script.js"&gt;=0A=
       angular.module('orderByExample1', [])=0A=
         .controller('ExampleController', ['$scope', function($scope) {=0A=
           $scope.friends =3D [=0A=
             {name: 'John',   phone: '555-1212',  age: 10},=0A=
             {name: 'Mary',   phone: '555-9876',  age: 19},=0A=
             {name: 'Mike',   phone: '555-4321',  age: 21},=0A=
             {name: 'Adam',   phone: '555-5678',  age: 35},=0A=
             {name: 'Julie',  phone: '555-8765',  age: 29}=0A=
           ];=0A=
         }]);=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"style.css"&gt;=0A=
       .friends {=0A=
         border-collapse: collapse;=0A=
       }=0A=
=0A=
       .friends th {=0A=
         border-bottom: 1px solid;=0A=
       }=0A=
       .friends td, .friends th {=0A=
         border-left: 1px solid;=0A=
         padding: 5px 10px;=0A=
       }=0A=
       .friends td:first-child, .friends th:first-child {=0A=
         border-left: none;=0A=
       }=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       // Element locators=0A=
       var names =3D =
element.all(by.repeater('friends').column('friend.name'));=0A=
=0A=
       it('should sort friends by age in reverse order', function() {=0A=
         expect(names.get(0).getText()).toBe('Adam');=0A=
         expect(names.get(1).getText()).toBe('Julie');=0A=
         expect(names.get(2).getText()).toBe('Mike');=0A=
         expect(names.get(3).getText()).toBe('Mary');=0A=
         expect(names.get(4).getText()).toBe('John');=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 * &lt;hr /&gt;=0A=
 *=0A=
 * @example=0A=
 * ### Changing parameters dynamically=0A=
 *=0A=
 * All parameters can be changed dynamically. The next example shows how =
you can make the columns of=0A=
 * a table sortable, by binding the `expression` and `reverse` =
parameters to scope properties.=0A=
 *=0A=
   &lt;example name=3D"orderBy-dynamic" module=3D"orderByExample2"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
         &lt;pre&gt;Sort by =3D {{propertyName}}; reverse =3D =
{{reverse}}&lt;/pre&gt;=0A=
         &lt;hr/&gt;=0A=
         &lt;button ng-click=3D"propertyName =3D null; reverse =3D =
false"&gt;Set to unsorted&lt;/button&gt;=0A=
         &lt;hr/&gt;=0A=
         &lt;table class=3D"friends"&gt;=0A=
           &lt;tr&gt;=0A=
             &lt;th&gt;=0A=
               &lt;button =
ng-click=3D"sortBy('name')"&gt;Name&lt;/button&gt;=0A=
               &lt;span class=3D"sortorder" ng-show=3D"propertyName =
=3D=3D=3D 'name'" ng-class=3D"{reverse: reverse}"&gt;&lt;/span&gt;=0A=
             &lt;/th&gt;=0A=
             &lt;th&gt;=0A=
               &lt;button ng-click=3D"sortBy('phone')"&gt;Phone =
Number&lt;/button&gt;=0A=
               &lt;span class=3D"sortorder" ng-show=3D"propertyName =
=3D=3D=3D 'phone'" ng-class=3D"{reverse: reverse}"&gt;&lt;/span&gt;=0A=
             &lt;/th&gt;=0A=
             &lt;th&gt;=0A=
               &lt;button =
ng-click=3D"sortBy('age')"&gt;Age&lt;/button&gt;=0A=
               &lt;span class=3D"sortorder" ng-show=3D"propertyName =
=3D=3D=3D 'age'" ng-class=3D"{reverse: reverse}"&gt;&lt;/span&gt;=0A=
             &lt;/th&gt;=0A=
           &lt;/tr&gt;=0A=
           &lt;tr ng-repeat=3D"friend in friends | =
orderBy:propertyName:reverse"&gt;=0A=
             &lt;td&gt;{{friend.name}}&lt;/td&gt;=0A=
             &lt;td&gt;{{friend.phone}}&lt;/td&gt;=0A=
             &lt;td&gt;{{friend.age}}&lt;/td&gt;=0A=
           &lt;/tr&gt;=0A=
         &lt;/table&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"script.js"&gt;=0A=
       angular.module('orderByExample2', [])=0A=
         .controller('ExampleController', ['$scope', function($scope) {=0A=
           var friends =3D [=0A=
             {name: 'John',   phone: '555-1212',  age: 10},=0A=
             {name: 'Mary',   phone: '555-9876',  age: 19},=0A=
             {name: 'Mike',   phone: '555-4321',  age: 21},=0A=
             {name: 'Adam',   phone: '555-5678',  age: 35},=0A=
             {name: 'Julie',  phone: '555-8765',  age: 29}=0A=
           ];=0A=
=0A=
           $scope.propertyName =3D 'age';=0A=
           $scope.reverse =3D true;=0A=
           $scope.friends =3D friends;=0A=
=0A=
           $scope.sortBy =3D function(propertyName) {=0A=
             $scope.reverse =3D ($scope.propertyName =3D=3D=3D =
propertyName) ? !$scope.reverse : false;=0A=
             $scope.propertyName =3D propertyName;=0A=
           };=0A=
         }]);=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"style.css"&gt;=0A=
       .friends {=0A=
         border-collapse: collapse;=0A=
       }=0A=
=0A=
       .friends th {=0A=
         border-bottom: 1px solid;=0A=
       }=0A=
       .friends td, .friends th {=0A=
         border-left: 1px solid;=0A=
         padding: 5px 10px;=0A=
       }=0A=
       .friends td:first-child, .friends th:first-child {=0A=
         border-left: none;=0A=
       }=0A=
=0A=
       .sortorder:after {=0A=
         content: '\25b2';   // BLACK UP-POINTING TRIANGLE=0A=
       }=0A=
       .sortorder.reverse:after {=0A=
         content: '\25bc';   // BLACK DOWN-POINTING TRIANGLE=0A=
       }=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       // Element locators=0A=
       var unsortButton =3D element(by.partialButtonText('unsorted'));=0A=
       var nameHeader =3D element(by.partialButtonText('Name'));=0A=
       var phoneHeader =3D element(by.partialButtonText('Phone'));=0A=
       var ageHeader =3D element(by.partialButtonText('Age'));=0A=
       var firstName =3D =
element(by.repeater('friends').column('friend.name').row(0));=0A=
       var lastName =3D =
element(by.repeater('friends').column('friend.name').row(4));=0A=
=0A=
       it('should sort friends by some property, when clicking on the =
column header', function() {=0A=
         expect(firstName.getText()).toBe('Adam');=0A=
         expect(lastName.getText()).toBe('John');=0A=
=0A=
         phoneHeader.click();=0A=
         expect(firstName.getText()).toBe('John');=0A=
         expect(lastName.getText()).toBe('Mary');=0A=
=0A=
         nameHeader.click();=0A=
         expect(firstName.getText()).toBe('Adam');=0A=
         expect(lastName.getText()).toBe('Mike');=0A=
=0A=
         ageHeader.click();=0A=
         expect(firstName.getText()).toBe('John');=0A=
         expect(lastName.getText()).toBe('Adam');=0A=
       });=0A=
=0A=
       it('should sort friends in reverse order, when clicking on the =
same column', function() {=0A=
         expect(firstName.getText()).toBe('Adam');=0A=
         expect(lastName.getText()).toBe('John');=0A=
=0A=
         ageHeader.click();=0A=
         expect(firstName.getText()).toBe('John');=0A=
         expect(lastName.getText()).toBe('Adam');=0A=
=0A=
         ageHeader.click();=0A=
         expect(firstName.getText()).toBe('Adam');=0A=
         expect(lastName.getText()).toBe('John');=0A=
       });=0A=
=0A=
       it('should restore the original order, when clicking "Set to =
unsorted"', function() {=0A=
         expect(firstName.getText()).toBe('Adam');=0A=
         expect(lastName.getText()).toBe('John');=0A=
=0A=
         unsortButton.click();=0A=
         expect(firstName.getText()).toBe('John');=0A=
         expect(lastName.getText()).toBe('Julie');=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 * &lt;hr /&gt;=0A=
 *=0A=
 * @example=0A=
 * ### Using `orderBy` inside a controller=0A=
 *=0A=
 * It is also possible to call the `orderBy` filter manually, by =
injecting `orderByFilter`, and=0A=
 * calling it with the desired parameters. (Alternatively, you could =
inject the `$filter` factory=0A=
 * and retrieve the `orderBy` filter with `$filter('orderBy')`.)=0A=
 *=0A=
   &lt;example name=3D"orderBy-call-manually" =
module=3D"orderByExample3"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
         &lt;pre&gt;Sort by =3D {{propertyName}}; reverse =3D =
{{reverse}}&lt;/pre&gt;=0A=
         &lt;hr/&gt;=0A=
         &lt;button ng-click=3D"sortBy(null)"&gt;Set to =
unsorted&lt;/button&gt;=0A=
         &lt;hr/&gt;=0A=
         &lt;table class=3D"friends"&gt;=0A=
           &lt;tr&gt;=0A=
             &lt;th&gt;=0A=
               &lt;button =
ng-click=3D"sortBy('name')"&gt;Name&lt;/button&gt;=0A=
               &lt;span class=3D"sortorder" ng-show=3D"propertyName =
=3D=3D=3D 'name'" ng-class=3D"{reverse: reverse}"&gt;&lt;/span&gt;=0A=
             &lt;/th&gt;=0A=
             &lt;th&gt;=0A=
               &lt;button ng-click=3D"sortBy('phone')"&gt;Phone =
Number&lt;/button&gt;=0A=
               &lt;span class=3D"sortorder" ng-show=3D"propertyName =
=3D=3D=3D 'phone'" ng-class=3D"{reverse: reverse}"&gt;&lt;/span&gt;=0A=
             &lt;/th&gt;=0A=
             &lt;th&gt;=0A=
               &lt;button =
ng-click=3D"sortBy('age')"&gt;Age&lt;/button&gt;=0A=
               &lt;span class=3D"sortorder" ng-show=3D"propertyName =
=3D=3D=3D 'age'" ng-class=3D"{reverse: reverse}"&gt;&lt;/span&gt;=0A=
             &lt;/th&gt;=0A=
           &lt;/tr&gt;=0A=
           &lt;tr ng-repeat=3D"friend in friends"&gt;=0A=
             &lt;td&gt;{{friend.name}}&lt;/td&gt;=0A=
             &lt;td&gt;{{friend.phone}}&lt;/td&gt;=0A=
             &lt;td&gt;{{friend.age}}&lt;/td&gt;=0A=
           &lt;/tr&gt;=0A=
         &lt;/table&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"script.js"&gt;=0A=
       angular.module('orderByExample3', [])=0A=
         .controller('ExampleController', ['$scope', 'orderByFilter', =
function($scope, orderBy) {=0A=
           var friends =3D [=0A=
             {name: 'John',   phone: '555-1212',  age: 10},=0A=
             {name: 'Mary',   phone: '555-9876',  age: 19},=0A=
             {name: 'Mike',   phone: '555-4321',  age: 21},=0A=
             {name: 'Adam',   phone: '555-5678',  age: 35},=0A=
             {name: 'Julie',  phone: '555-8765',  age: 29}=0A=
           ];=0A=
=0A=
           $scope.propertyName =3D 'age';=0A=
           $scope.reverse =3D true;=0A=
           $scope.friends =3D orderBy(friends, $scope.propertyName, =
$scope.reverse);=0A=
=0A=
           $scope.sortBy =3D function(propertyName) {=0A=
             $scope.reverse =3D (propertyName !=3D=3D null &amp;&amp; =
$scope.propertyName =3D=3D=3D propertyName)=0A=
                 ? !$scope.reverse : false;=0A=
             $scope.propertyName =3D propertyName;=0A=
             $scope.friends =3D orderBy(friends, $scope.propertyName, =
$scope.reverse);=0A=
           };=0A=
         }]);=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"style.css"&gt;=0A=
       .friends {=0A=
         border-collapse: collapse;=0A=
       }=0A=
=0A=
       .friends th {=0A=
         border-bottom: 1px solid;=0A=
       }=0A=
       .friends td, .friends th {=0A=
         border-left: 1px solid;=0A=
         padding: 5px 10px;=0A=
       }=0A=
       .friends td:first-child, .friends th:first-child {=0A=
         border-left: none;=0A=
       }=0A=
=0A=
       .sortorder:after {=0A=
         content: '\25b2';   // BLACK UP-POINTING TRIANGLE=0A=
       }=0A=
       .sortorder.reverse:after {=0A=
         content: '\25bc';   // BLACK DOWN-POINTING TRIANGLE=0A=
       }=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       // Element locators=0A=
       var unsortButton =3D element(by.partialButtonText('unsorted'));=0A=
       var nameHeader =3D element(by.partialButtonText('Name'));=0A=
       var phoneHeader =3D element(by.partialButtonText('Phone'));=0A=
       var ageHeader =3D element(by.partialButtonText('Age'));=0A=
       var firstName =3D =
element(by.repeater('friends').column('friend.name').row(0));=0A=
       var lastName =3D =
element(by.repeater('friends').column('friend.name').row(4));=0A=
=0A=
       it('should sort friends by some property, when clicking on the =
column header', function() {=0A=
         expect(firstName.getText()).toBe('Adam');=0A=
         expect(lastName.getText()).toBe('John');=0A=
=0A=
         phoneHeader.click();=0A=
         expect(firstName.getText()).toBe('John');=0A=
         expect(lastName.getText()).toBe('Mary');=0A=
=0A=
         nameHeader.click();=0A=
         expect(firstName.getText()).toBe('Adam');=0A=
         expect(lastName.getText()).toBe('Mike');=0A=
=0A=
         ageHeader.click();=0A=
         expect(firstName.getText()).toBe('John');=0A=
         expect(lastName.getText()).toBe('Adam');=0A=
       });=0A=
=0A=
       it('should sort friends in reverse order, when clicking on the =
same column', function() {=0A=
         expect(firstName.getText()).toBe('Adam');=0A=
         expect(lastName.getText()).toBe('John');=0A=
=0A=
         ageHeader.click();=0A=
         expect(firstName.getText()).toBe('John');=0A=
         expect(lastName.getText()).toBe('Adam');=0A=
=0A=
         ageHeader.click();=0A=
         expect(firstName.getText()).toBe('Adam');=0A=
         expect(lastName.getText()).toBe('John');=0A=
       });=0A=
=0A=
       it('should restore the original order, when clicking "Set to =
unsorted"', function() {=0A=
         expect(firstName.getText()).toBe('Adam');=0A=
         expect(lastName.getText()).toBe('John');=0A=
=0A=
         unsortButton.click();=0A=
         expect(firstName.getText()).toBe('John');=0A=
         expect(lastName.getText()).toBe('Julie');=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 * &lt;hr /&gt;=0A=
 *=0A=
 * @example=0A=
 * ### Using a custom comparator=0A=
 *=0A=
 * If you have very specific requirements about the way items are =
sorted, you can pass your own=0A=
 * comparator function. For example, you might need to compare some =
strings in a locale-sensitive=0A=
 * way. (When specifying a custom comparator, you also need to pass a =
value for the `reverse`=0A=
 * argument - passing `false` retains the default sorting order, i.e. =
ascending.)=0A=
 *=0A=
   &lt;example name=3D"orderBy-custom-comparator" =
module=3D"orderByExample4"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
         &lt;div class=3D"friends-container custom-comparator"&gt;=0A=
           &lt;h3&gt;Locale-sensitive Comparator&lt;/h3&gt;=0A=
           &lt;table class=3D"friends"&gt;=0A=
             &lt;tr&gt;=0A=
               &lt;th&gt;Name&lt;/th&gt;=0A=
               &lt;th&gt;Favorite Letter&lt;/th&gt;=0A=
             &lt;/tr&gt;=0A=
             &lt;tr ng-repeat=3D"friend in friends | =
orderBy:'favoriteLetter':false:localeSensitiveComparator"&gt;=0A=
               &lt;td&gt;{{friend.name}}&lt;/td&gt;=0A=
               &lt;td&gt;{{friend.favoriteLetter}}&lt;/td&gt;=0A=
             &lt;/tr&gt;=0A=
           &lt;/table&gt;=0A=
         &lt;/div&gt;=0A=
         &lt;div class=3D"friends-container default-comparator"&gt;=0A=
           &lt;h3&gt;Default Comparator&lt;/h3&gt;=0A=
           &lt;table class=3D"friends"&gt;=0A=
             &lt;tr&gt;=0A=
               &lt;th&gt;Name&lt;/th&gt;=0A=
               &lt;th&gt;Favorite Letter&lt;/th&gt;=0A=
             &lt;/tr&gt;=0A=
             &lt;tr ng-repeat=3D"friend in friends | =
orderBy:'favoriteLetter'"&gt;=0A=
               &lt;td&gt;{{friend.name}}&lt;/td&gt;=0A=
               &lt;td&gt;{{friend.favoriteLetter}}&lt;/td&gt;=0A=
             &lt;/tr&gt;=0A=
           &lt;/table&gt;=0A=
         &lt;/div&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"script.js"&gt;=0A=
       angular.module('orderByExample4', [])=0A=
         .controller('ExampleController', ['$scope', function($scope) {=0A=
           $scope.friends =3D [=0A=
             {name: 'John',   favoriteLetter: '=C3=84'},=0A=
             {name: 'Mary',   favoriteLetter: '=C3=9C'},=0A=
             {name: 'Mike',   favoriteLetter: '=C3=96'},=0A=
             {name: 'Adam',   favoriteLetter: 'H'},=0A=
             {name: 'Julie',  favoriteLetter: 'Z'}=0A=
           ];=0A=
=0A=
           $scope.localeSensitiveComparator =3D function(v1, v2) {=0A=
             // If we don't get strings, just compare by index=0A=
             if (v1.type !=3D=3D 'string' || v2.type !=3D=3D 'string') {=0A=
               return (v1.index &lt; v2.index) ? -1 : 1;=0A=
             }=0A=
=0A=
             // Compare strings alphabetically, taking locale into =
account=0A=
             return v1.value.localeCompare(v2.value);=0A=
           };=0A=
         }]);=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"style.css"&gt;=0A=
       .friends-container {=0A=
         display: inline-block;=0A=
         margin: 0 30px;=0A=
       }=0A=
=0A=
       .friends {=0A=
         border-collapse: collapse;=0A=
       }=0A=
=0A=
       .friends th {=0A=
         border-bottom: 1px solid;=0A=
       }=0A=
       .friends td, .friends th {=0A=
         border-left: 1px solid;=0A=
         padding: 5px 10px;=0A=
       }=0A=
       .friends td:first-child, .friends th:first-child {=0A=
         border-left: none;=0A=
       }=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       // Element locators=0A=
       var container =3D element(by.css('.custom-comparator'));=0A=
       var names =3D =
container.all(by.repeater('friends').column('friend.name'));=0A=
=0A=
       it('should sort friends by favorite letter (in correct =
alphabetical order)', function() {=0A=
         expect(names.get(0).getText()).toBe('John');=0A=
         expect(names.get(1).getText()).toBe('Adam');=0A=
         expect(names.get(2).getText()).toBe('Mike');=0A=
         expect(names.get(3).getText()).toBe('Mary');=0A=
         expect(names.get(4).getText()).toBe('Julie');=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 *=0A=
 */=0A=
orderByFilter.$inject =3D ['$parse'];=0A=
function orderByFilter($parse) {=0A=
  return function(array, sortPredicate, reverseOrder, compareFn) {=0A=
=0A=
    if (array =3D=3D null) return array;=0A=
    if (!isArrayLike(array)) {=0A=
      throw minErr('orderBy')('notarray', 'Expected array but received: =
{0}', array);=0A=
    }=0A=
=0A=
    if (!isArray(sortPredicate)) { sortPredicate =3D [sortPredicate]; }=0A=
    if (sortPredicate.length =3D=3D=3D 0) { sortPredicate =3D ['+']; }=0A=
=0A=
    var predicates =3D processPredicates(sortPredicate);=0A=
=0A=
    var descending =3D reverseOrder ? -1 : 1;=0A=
=0A=
    // Define the `compare()` function. Use a default comparator if none =
is specified.=0A=
    var compare =3D isFunction(compareFn) ? compareFn : defaultCompare;=0A=
=0A=
    // The next three lines are a version of a Swartzian Transform idiom =
from Perl=0A=
    // (sometimes called the Decorate-Sort-Undecorate idiom)=0A=
    // See https://en.wikipedia.org/wiki/Schwartzian_transform=0A=
    var compareValues =3D Array.prototype.map.call(array, =
getComparisonObject);=0A=
    compareValues.sort(doComparison);=0A=
    array =3D compareValues.map(function(item) { return item.value; });=0A=
=0A=
    return array;=0A=
=0A=
    function getComparisonObject(value, index) {=0A=
      // NOTE: We are adding an extra `tieBreaker` value based on the =
element's index.=0A=
      // This will be used to keep the sort stable when none of the =
input predicates can=0A=
      // distinguish between two elements.=0A=
      return {=0A=
        value: value,=0A=
        tieBreaker: {value: index, type: 'number', index: index},=0A=
        predicateValues: predicates.map(function(predicate) {=0A=
          return getPredicateValue(predicate.get(value), index);=0A=
        })=0A=
      };=0A=
    }=0A=
=0A=
    function doComparison(v1, v2) {=0A=
      for (var i =3D 0, ii =3D predicates.length; i &lt; ii; i++) {=0A=
        var result =3D compare(v1.predicateValues[i], =
v2.predicateValues[i]);=0A=
        if (result) {=0A=
          return result * predicates[i].descending * descending;=0A=
        }=0A=
      }=0A=
=0A=
      return (compare(v1.tieBreaker, v2.tieBreaker) || =
defaultCompare(v1.tieBreaker, v2.tieBreaker)) * descending;=0A=
    }=0A=
  };=0A=
=0A=
  function processPredicates(sortPredicates) {=0A=
    return sortPredicates.map(function(predicate) {=0A=
      var descending =3D 1, get =3D identity;=0A=
=0A=
      if (isFunction(predicate)) {=0A=
        get =3D predicate;=0A=
      } else if (isString(predicate)) {=0A=
        if ((predicate.charAt(0) =3D=3D=3D '+' || predicate.charAt(0) =
=3D=3D=3D '-')) {=0A=
          descending =3D predicate.charAt(0) =3D=3D=3D '-' ? -1 : 1;=0A=
          predicate =3D predicate.substring(1);=0A=
        }=0A=
        if (predicate !=3D=3D '') {=0A=
          get =3D $parse(predicate);=0A=
          if (get.constant) {=0A=
            var key =3D get();=0A=
            get =3D function(value) { return value[key]; };=0A=
          }=0A=
        }=0A=
      }=0A=
      return {get: get, descending: descending};=0A=
    });=0A=
  }=0A=
=0A=
  function isPrimitive(value) {=0A=
    switch (typeof value) {=0A=
      case 'number': /* falls through */=0A=
      case 'boolean': /* falls through */=0A=
      case 'string':=0A=
        return true;=0A=
      default:=0A=
        return false;=0A=
    }=0A=
  }=0A=
=0A=
  function objectValue(value) {=0A=
    // If `valueOf` is a valid function use that=0A=
    if (isFunction(value.valueOf)) {=0A=
      value =3D value.valueOf();=0A=
      if (isPrimitive(value)) return value;=0A=
    }=0A=
    // If `toString` is a valid function and not the one from =
`Object.prototype` use that=0A=
    if (hasCustomToString(value)) {=0A=
      value =3D value.toString();=0A=
      if (isPrimitive(value)) return value;=0A=
    }=0A=
=0A=
    return value;=0A=
  }=0A=
=0A=
  function getPredicateValue(value, index) {=0A=
    var type =3D typeof value;=0A=
    if (value =3D=3D=3D null) {=0A=
      type =3D 'string';=0A=
      value =3D 'null';=0A=
    } else if (type =3D=3D=3D 'object') {=0A=
      value =3D objectValue(value);=0A=
    }=0A=
    return {value: value, type: type, index: index};=0A=
  }=0A=
=0A=
  function defaultCompare(v1, v2) {=0A=
    var result =3D 0;=0A=
    var type1 =3D v1.type;=0A=
    var type2 =3D v2.type;=0A=
=0A=
    if (type1 =3D=3D=3D type2) {=0A=
      var value1 =3D v1.value;=0A=
      var value2 =3D v2.value;=0A=
=0A=
      if (type1 =3D=3D=3D 'string') {=0A=
        // Compare strings case-insensitively=0A=
        value1 =3D value1.toLowerCase();=0A=
        value2 =3D value2.toLowerCase();=0A=
      } else if (type1 =3D=3D=3D 'object') {=0A=
        // For basic objects, use the position of the object=0A=
        // in the collection instead of the value=0A=
        if (isObject(value1)) value1 =3D v1.index;=0A=
        if (isObject(value2)) value2 =3D v2.index;=0A=
      }=0A=
=0A=
      if (value1 !=3D=3D value2) {=0A=
        result =3D value1 &lt; value2 ? -1 : 1;=0A=
      }=0A=
    } else {=0A=
      result =3D type1 &lt; type2 ? -1 : 1;=0A=
    }=0A=
=0A=
    return result;=0A=
  }=0A=
}=0A=
=0A=
function ngDirective(directive) {=0A=
  if (isFunction(directive)) {=0A=
    directive =3D {=0A=
      link: directive=0A=
    };=0A=
  }=0A=
  directive.restrict =3D directive.restrict || 'AC';=0A=
  return valueFn(directive);=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name a=0A=
 * @restrict E=0A=
 *=0A=
 * @description=0A=
 * Modifies the default behavior of the html a tag so that the default =
action is prevented when=0A=
 * the href attribute is empty.=0A=
 *=0A=
 * For dynamically creating `href` attributes for a tags, see the {@link =
ng.ngHref `ngHref`} directive.=0A=
 */=0A=
var htmlAnchorDirective =3D valueFn({=0A=
  restrict: 'E',=0A=
  compile: function(element, attr) {=0A=
    if (!attr.href &amp;&amp; !attr.xlinkHref) {=0A=
      return function(scope, element) {=0A=
        // If the linked element is not an anchor tag anymore, do nothing=0A=
        if (element[0].nodeName.toLowerCase() !=3D=3D 'a') return;=0A=
=0A=
        // SVGAElement does not use the href attribute, but rather the =
'xlinkHref' attribute.=0A=
        var href =3D toString.call(element.prop('href')) =3D=3D=3D =
'[object SVGAnimatedString]' ?=0A=
                   'xlink:href' : 'href';=0A=
        element.on('click', function(event) {=0A=
          // if we have no href url, then don't navigate anywhere.=0A=
          if (!element.attr(href)) {=0A=
            event.preventDefault();=0A=
          }=0A=
        });=0A=
      };=0A=
    }=0A=
  }=0A=
});=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngHref=0A=
 * @restrict A=0A=
 * @priority 99=0A=
 *=0A=
 * @description=0A=
 * Using Angular markup like `{{hash}}` in an href attribute will=0A=
 * make the link go to the wrong URL if the user clicks it before=0A=
 * Angular has a chance to replace the `{{hash}}` markup with its=0A=
 * value. Until Angular replaces the markup the link will be broken=0A=
 * and will most likely return a 404 error. The `ngHref` directive=0A=
 * solves this problem.=0A=
 *=0A=
 * The wrong way to write it:=0A=
 * ```html=0A=
 * &lt;a =
href=3D"http://www.gravatar.com/avatar/{{hash}}"&gt;link1&lt;/a&gt;=0A=
 * ```=0A=
 *=0A=
 * The correct way to write it:=0A=
 * ```html=0A=
 * &lt;a =
ng-href=3D"http://www.gravatar.com/avatar/{{hash}}"&gt;link1&lt;/a&gt;=0A=
 * ```=0A=
 *=0A=
 * @element A=0A=
 * @param {template} ngHref any string which can contain `{{}}` markup.=0A=
 *=0A=
 * @example=0A=
 * This example shows various combinations of `href`, `ng-href` and =
`ng-click` attributes=0A=
 * in links and their different behaviors:=0A=
    &lt;example name=3D"ng-href"&gt;=0A=
      &lt;file name=3D"index.html"&gt;=0A=
        &lt;input ng-model=3D"value" /&gt;&lt;br /&gt;=0A=
        &lt;a id=3D"link-1" href ng-click=3D"value =3D 1"&gt;link =
1&lt;/a&gt; (link, don't reload)&lt;br /&gt;=0A=
        &lt;a id=3D"link-2" href=3D"" ng-click=3D"value =3D 2"&gt;link =
2&lt;/a&gt; (link, don't reload)&lt;br /&gt;=0A=
        &lt;a id=3D"link-3" ng-href=3D"/{{'123'}}"&gt;link 3&lt;/a&gt; =
(link, reload!)&lt;br /&gt;=0A=
        &lt;a id=3D"link-4" href=3D"" name=3D"xx" ng-click=3D"value =3D =
4"&gt;anchor&lt;/a&gt; (link, don't reload)&lt;br /&gt;=0A=
        &lt;a id=3D"link-5" name=3D"xxx" ng-click=3D"value =3D =
5"&gt;anchor&lt;/a&gt; (no link)&lt;br /&gt;=0A=
        &lt;a id=3D"link-6" ng-href=3D"{{value}}"&gt;link&lt;/a&gt; =
(link, change location)=0A=
      &lt;/file&gt;=0A=
      &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
        it('should execute ng-click but not reload when href without =
value', function() {=0A=
          element(by.id('link-1')).click();=0A=
          =
expect(element(by.model('value')).getAttribute('value')).toEqual('1');=0A=
          expect(element(by.id('link-1')).getAttribute('href')).toBe('');=0A=
        });=0A=
=0A=
        it('should execute ng-click but not reload when href empty =
string', function() {=0A=
          element(by.id('link-2')).click();=0A=
          =
expect(element(by.model('value')).getAttribute('value')).toEqual('2');=0A=
          expect(element(by.id('link-2')).getAttribute('href')).toBe('');=0A=
        });=0A=
=0A=
        it('should execute ng-click and change url when ng-href =
specified', function() {=0A=
          =
expect(element(by.id('link-3')).getAttribute('href')).toMatch(/\/123$/);=0A=
=0A=
          element(by.id('link-3')).click();=0A=
=0A=
          // At this point, we navigate away from an Angular page, so we =
need=0A=
          // to use browser.driver to get the base webdriver.=0A=
=0A=
          browser.wait(function() {=0A=
            return browser.driver.getCurrentUrl().then(function(url) {=0A=
              return url.match(/\/123$/);=0A=
            });=0A=
          }, 5000, 'page should navigate to /123');=0A=
        });=0A=
=0A=
        it('should execute ng-click but not reload when href empty =
string and name specified', function() {=0A=
          element(by.id('link-4')).click();=0A=
          =
expect(element(by.model('value')).getAttribute('value')).toEqual('4');=0A=
          expect(element(by.id('link-4')).getAttribute('href')).toBe('');=0A=
        });=0A=
=0A=
        it('should execute ng-click but not reload when no href but name =
specified', function() {=0A=
          element(by.id('link-5')).click();=0A=
          =
expect(element(by.model('value')).getAttribute('value')).toEqual('5');=0A=
          =
expect(element(by.id('link-5')).getAttribute('href')).toBe(null);=0A=
        });=0A=
=0A=
        it('should only change url when only ng-href', function() {=0A=
          element(by.model('value')).clear();=0A=
          element(by.model('value')).sendKeys('6');=0A=
          =
expect(element(by.id('link-6')).getAttribute('href')).toMatch(/\/6$/);=0A=
=0A=
          element(by.id('link-6')).click();=0A=
=0A=
          // At this point, we navigate away from an Angular page, so we =
need=0A=
          // to use browser.driver to get the base webdriver.=0A=
          browser.wait(function() {=0A=
            return browser.driver.getCurrentUrl().then(function(url) {=0A=
              return url.match(/\/6$/);=0A=
            });=0A=
          }, 5000, 'page should navigate to /6');=0A=
        });=0A=
      &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngSrc=0A=
 * @restrict A=0A=
 * @priority 99=0A=
 *=0A=
 * @description=0A=
 * Using Angular markup like `{{hash}}` in a `src` attribute doesn't=0A=
 * work right: The browser will fetch from the URL with the literal=0A=
 * text `{{hash}}` until Angular replaces the expression inside=0A=
 * `{{hash}}`. The `ngSrc` directive solves this problem.=0A=
 *=0A=
 * The buggy way to write it:=0A=
 * ```html=0A=
 * &lt;img src=3D"http://www.gravatar.com/avatar/{{hash}}" =
alt=3D"Description"/&gt;=0A=
 * ```=0A=
 *=0A=
 * The correct way to write it:=0A=
 * ```html=0A=
 * &lt;img ng-src=3D"http://www.gravatar.com/avatar/{{hash}}" =
alt=3D"Description" /&gt;=0A=
 * ```=0A=
 *=0A=
 * @element IMG=0A=
 * @param {template} ngSrc any string which can contain `{{}}` markup.=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngSrcset=0A=
 * @restrict A=0A=
 * @priority 99=0A=
 *=0A=
 * @description=0A=
 * Using Angular markup like `{{hash}}` in a `srcset` attribute doesn't=0A=
 * work right: The browser will fetch from the URL with the literal=0A=
 * text `{{hash}}` until Angular replaces the expression inside=0A=
 * `{{hash}}`. The `ngSrcset` directive solves this problem.=0A=
 *=0A=
 * The buggy way to write it:=0A=
 * ```html=0A=
 * &lt;img srcset=3D"http://www.gravatar.com/avatar/{{hash}} 2x" =
alt=3D"Description"/&gt;=0A=
 * ```=0A=
 *=0A=
 * The correct way to write it:=0A=
 * ```html=0A=
 * &lt;img ng-srcset=3D"http://www.gravatar.com/avatar/{{hash}} 2x" =
alt=3D"Description" /&gt;=0A=
 * ```=0A=
 *=0A=
 * @element IMG=0A=
 * @param {template} ngSrcset any string which can contain `{{}}` markup.=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngDisabled=0A=
 * @restrict A=0A=
 * @priority 100=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * This directive sets the `disabled` attribute on the element =
(typically a form control,=0A=
 * e.g. `input`, `button`, `select` etc.) if the=0A=
 * {@link guide/expression expression} inside `ngDisabled` evaluates to =
truthy.=0A=
 *=0A=
 * A special directive is necessary because we cannot use interpolation =
inside the `disabled`=0A=
 * attribute. See the {@link guide/interpolation interpolation guide} =
for more info.=0A=
 *=0A=
 * @example=0A=
    &lt;example name=3D"ng-disabled"&gt;=0A=
      &lt;file name=3D"index.html"&gt;=0A=
        &lt;label&gt;Click me to toggle: &lt;input type=3D"checkbox" =
ng-model=3D"checked"&gt;&lt;/label&gt;&lt;br/&gt;=0A=
        &lt;button ng-model=3D"button" =
ng-disabled=3D"checked"&gt;Button&lt;/button&gt;=0A=
      &lt;/file&gt;=0A=
      &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
        it('should toggle button', function() {=0A=
          =
expect(element(by.css('button')).getAttribute('disabled')).toBeFalsy();=0A=
          element(by.model('checked')).click();=0A=
          =
expect(element(by.css('button')).getAttribute('disabled')).toBeTruthy();=0A=
        });=0A=
      &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
 *=0A=
 * @element INPUT=0A=
 * @param {expression} ngDisabled If the {@link guide/expression =
expression} is truthy,=0A=
 *     then the `disabled` attribute will be set on the element=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngChecked=0A=
 * @restrict A=0A=
 * @priority 100=0A=
 *=0A=
 * @description=0A=
 * Sets the `checked` attribute on the element, if the expression inside =
`ngChecked` is truthy.=0A=
 *=0A=
 * Note that this directive should not be used together with {@link =
ngModel `ngModel`},=0A=
 * as this can lead to unexpected behavior.=0A=
 *=0A=
 * A special directive is necessary because we cannot use interpolation =
inside the `checked`=0A=
 * attribute. See the {@link guide/interpolation interpolation guide} =
for more info.=0A=
 *=0A=
 * @example=0A=
    &lt;example name=3D"ng-checked"&gt;=0A=
      &lt;file name=3D"index.html"&gt;=0A=
        &lt;label&gt;Check me to check both: &lt;input type=3D"checkbox" =
ng-model=3D"master"&gt;&lt;/label&gt;&lt;br/&gt;=0A=
        &lt;input id=3D"checkSlave" type=3D"checkbox" =
ng-checked=3D"master" aria-label=3D"Slave input"&gt;=0A=
      &lt;/file&gt;=0A=
      &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
        it('should check both checkBoxes', function() {=0A=
          =
expect(element(by.id('checkSlave')).getAttribute('checked')).toBeFalsy();=0A=
          element(by.model('master')).click();=0A=
          =
expect(element(by.id('checkSlave')).getAttribute('checked')).toBeTruthy()=
;=0A=
        });=0A=
      &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
 *=0A=
 * @element INPUT=0A=
 * @param {expression} ngChecked If the {@link guide/expression =
expression} is truthy,=0A=
 *     then the `checked` attribute will be set on the element=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngReadonly=0A=
 * @restrict A=0A=
 * @priority 100=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * Sets the `readonly` attribute on the element, if the expression =
inside `ngReadonly` is truthy.=0A=
 * Note that `readonly` applies only to `input` elements with specific =
types. [See the input docs on=0A=
 * =
MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr=
-readonly) for more information.=0A=
 *=0A=
 * A special directive is necessary because we cannot use interpolation =
inside the `readonly`=0A=
 * attribute. See the {@link guide/interpolation interpolation guide} =
for more info.=0A=
 *=0A=
 * @example=0A=
    &lt;example name=3D"ng-readonly"&gt;=0A=
      &lt;file name=3D"index.html"&gt;=0A=
        &lt;label&gt;Check me to make text readonly: &lt;input =
type=3D"checkbox" ng-model=3D"checked"&gt;&lt;/label&gt;&lt;br/&gt;=0A=
        &lt;input type=3D"text" ng-readonly=3D"checked" value=3D"I'm =
Angular" aria-label=3D"Readonly field" /&gt;=0A=
      &lt;/file&gt;=0A=
      &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
        it('should toggle readonly attr', function() {=0A=
          =
expect(element(by.css('[type=3D"text"]')).getAttribute('readonly')).toBeF=
alsy();=0A=
          element(by.model('checked')).click();=0A=
          =
expect(element(by.css('[type=3D"text"]')).getAttribute('readonly')).toBeT=
ruthy();=0A=
        });=0A=
      &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
 *=0A=
 * @element INPUT=0A=
 * @param {expression} ngReadonly If the {@link guide/expression =
expression} is truthy,=0A=
 *     then special attribute "readonly" will be set on the element=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngSelected=0A=
 * @restrict A=0A=
 * @priority 100=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * Sets the `selected` attribute on the element, if the expression =
inside `ngSelected` is truthy.=0A=
 *=0A=
 * A special directive is necessary because we cannot use interpolation =
inside the `selected`=0A=
 * attribute. See the {@link guide/interpolation interpolation guide} =
for more info.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 *   **Note:** `ngSelected` does not interact with the `select` and =
`ngModel` directives, it only=0A=
 *   sets the `selected` attribute on the element. If you are using =
`ngModel` on the select, you=0A=
 *   should not use `ngSelected` on the options, as `ngModel` will set =
the select value and=0A=
 *   selected options.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * @example=0A=
    &lt;example name=3D"ng-selected"&gt;=0A=
      &lt;file name=3D"index.html"&gt;=0A=
        &lt;label&gt;Check me to select: &lt;input type=3D"checkbox" =
ng-model=3D"selected"&gt;&lt;/label&gt;&lt;br/&gt;=0A=
        &lt;select aria-label=3D"ngSelected demo"&gt;=0A=
          &lt;option&gt;Hello!&lt;/option&gt;=0A=
          &lt;option id=3D"greet" =
ng-selected=3D"selected"&gt;Greetings!&lt;/option&gt;=0A=
        &lt;/select&gt;=0A=
      &lt;/file&gt;=0A=
      &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
        it('should select Greetings!', function() {=0A=
          =
expect(element(by.id('greet')).getAttribute('selected')).toBeFalsy();=0A=
          element(by.model('selected')).click();=0A=
          =
expect(element(by.id('greet')).getAttribute('selected')).toBeTruthy();=0A=
        });=0A=
      &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
 *=0A=
 * @element OPTION=0A=
 * @param {expression} ngSelected If the {@link guide/expression =
expression} is truthy,=0A=
 *     then special attribute "selected" will be set on the element=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngOpen=0A=
 * @restrict A=0A=
 * @priority 100=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * Sets the `open` attribute on the element, if the expression inside =
`ngOpen` is truthy.=0A=
 *=0A=
 * A special directive is necessary because we cannot use interpolation =
inside the `open`=0A=
 * attribute. See the {@link guide/interpolation interpolation guide} =
for more info.=0A=
 *=0A=
 * ## A note about browser compatibility=0A=
 *=0A=
 * Edge, Firefox, and Internet Explorer do not support the `details` =
element, it is=0A=
 * recommended to use {@link ng.ngShow} and {@link ng.ngHide} instead.=0A=
 *=0A=
 * @example=0A=
     &lt;example name=3D"ng-open"&gt;=0A=
       &lt;file name=3D"index.html"&gt;=0A=
         &lt;label&gt;Check me check multiple: &lt;input =
type=3D"checkbox" ng-model=3D"open"&gt;&lt;/label&gt;&lt;br/&gt;=0A=
         &lt;details id=3D"details" ng-open=3D"open"&gt;=0A=
            &lt;summary&gt;Show/Hide me&lt;/summary&gt;=0A=
         &lt;/details&gt;=0A=
       &lt;/file&gt;=0A=
       &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
         it('should toggle open', function() {=0A=
           =
expect(element(by.id('details')).getAttribute('open')).toBeFalsy();=0A=
           element(by.model('open')).click();=0A=
           =
expect(element(by.id('details')).getAttribute('open')).toBeTruthy();=0A=
         });=0A=
       &lt;/file&gt;=0A=
     &lt;/example&gt;=0A=
 *=0A=
 * @element DETAILS=0A=
 * @param {expression} ngOpen If the {@link guide/expression expression} =
is truthy,=0A=
 *     then special attribute "open" will be set on the element=0A=
 */=0A=
=0A=
var ngAttributeAliasDirectives =3D {};=0A=
=0A=
// boolean attrs are evaluated=0A=
forEach(BOOLEAN_ATTR, function(propName, attrName) {=0A=
  // binding to multiple is not supported=0A=
  if (propName =3D=3D=3D 'multiple') return;=0A=
=0A=
  function defaultLinkFn(scope, element, attr) {=0A=
    scope.$watch(attr[normalized], function =
ngBooleanAttrWatchAction(value) {=0A=
      attr.$set(attrName, !!value);=0A=
    });=0A=
  }=0A=
=0A=
  var normalized =3D directiveNormalize('ng-' + attrName);=0A=
  var linkFn =3D defaultLinkFn;=0A=
=0A=
  if (propName =3D=3D=3D 'checked') {=0A=
    linkFn =3D function(scope, element, attr) {=0A=
      // ensuring ngChecked doesn't interfere with ngModel when both are =
set on the same input=0A=
      if (attr.ngModel !=3D=3D attr[normalized]) {=0A=
        defaultLinkFn(scope, element, attr);=0A=
      }=0A=
    };=0A=
  }=0A=
=0A=
  ngAttributeAliasDirectives[normalized] =3D function() {=0A=
    return {=0A=
      restrict: 'A',=0A=
      priority: 100,=0A=
      link: linkFn=0A=
    };=0A=
  };=0A=
});=0A=
=0A=
// aliased input attrs are evaluated=0A=
forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {=0A=
  ngAttributeAliasDirectives[ngAttr] =3D function() {=0A=
    return {=0A=
      priority: 100,=0A=
      link: function(scope, element, attr) {=0A=
        //special case ngPattern when a literal regular expression value=0A=
        //is used as the expression (this way we don't have to watch =
anything).=0A=
        if (ngAttr =3D=3D=3D 'ngPattern' &amp;&amp; =
attr.ngPattern.charAt(0) =3D=3D=3D '/') {=0A=
          var match =3D attr.ngPattern.match(REGEX_STRING_REGEXP);=0A=
          if (match) {=0A=
            attr.$set('ngPattern', new RegExp(match[1], match[2]));=0A=
            return;=0A=
          }=0A=
        }=0A=
=0A=
        scope.$watch(attr[ngAttr], function =
ngAttrAliasWatchAction(value) {=0A=
          attr.$set(ngAttr, value);=0A=
        });=0A=
      }=0A=
    };=0A=
  };=0A=
});=0A=
=0A=
// ng-src, ng-srcset, ng-href are interpolated=0A=
forEach(['src', 'srcset', 'href'], function(attrName) {=0A=
  var normalized =3D directiveNormalize('ng-' + attrName);=0A=
  ngAttributeAliasDirectives[normalized] =3D function() {=0A=
    return {=0A=
      priority: 99, // it needs to run after the attributes are =
interpolated=0A=
      link: function(scope, element, attr) {=0A=
        var propName =3D attrName,=0A=
            name =3D attrName;=0A=
=0A=
        if (attrName =3D=3D=3D 'href' &amp;&amp;=0A=
            toString.call(element.prop('href')) =3D=3D=3D '[object =
SVGAnimatedString]') {=0A=
          name =3D 'xlinkHref';=0A=
          attr.$attr[name] =3D 'xlink:href';=0A=
          propName =3D null;=0A=
        }=0A=
=0A=
        attr.$observe(normalized, function(value) {=0A=
          if (!value) {=0A=
            if (attrName =3D=3D=3D 'href') {=0A=
              attr.$set(name, null);=0A=
            }=0A=
            return;=0A=
          }=0A=
=0A=
          attr.$set(name, value);=0A=
=0A=
          // Support: IE 9-11 only=0A=
          // On IE, if "ng:src" directive declaration is used and "src" =
attribute doesn't exist=0A=
          // then calling element.setAttribute('src', 'foo') doesn't do =
anything, so we need=0A=
          // to set the property as well to achieve the desired effect.=0A=
          // We use attr[attrName] value since $set can sanitize the url.=0A=
          if (msie &amp;&amp; propName) element.prop(propName, =
attr[name]);=0A=
        });=0A=
      }=0A=
    };=0A=
  };=0A=
});=0A=
=0A=
/* global -nullFormCtrl, -PENDING_CLASS, -SUBMITTED_CLASS=0A=
 */=0A=
var nullFormCtrl =3D {=0A=
  $addControl: noop,=0A=
  $$renameControl: nullFormRenameControl,=0A=
  $removeControl: noop,=0A=
  $setValidity: noop,=0A=
  $setDirty: noop,=0A=
  $setPristine: noop,=0A=
  $setSubmitted: noop=0A=
},=0A=
PENDING_CLASS =3D 'ng-pending',=0A=
SUBMITTED_CLASS =3D 'ng-submitted';=0A=
=0A=
function nullFormRenameControl(control, name) {=0A=
  control.$name =3D name;=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc type=0A=
 * @name form.FormController=0A=
 *=0A=
 * @property {boolean} $pristine True if user has not interacted with =
the form yet.=0A=
 * @property {boolean} $dirty True if user has already interacted with =
the form.=0A=
 * @property {boolean} $valid True if all of the containing forms and =
controls are valid.=0A=
 * @property {boolean} $invalid True if at least one containing control =
or form is invalid.=0A=
 * @property {boolean} $submitted True if user has submitted the form =
even if its invalid.=0A=
 *=0A=
 * @property {Object} $pending An object hash, containing references to =
controls or forms with=0A=
 *  pending validators, where:=0A=
 *=0A=
 *  - keys are validations tokens (error names).=0A=
 *  - values are arrays of controls or forms that have a pending =
validator for the given error name.=0A=
 *=0A=
 * See {@link form.FormController#$error $error} for a list of built-in =
validation tokens.=0A=
 *=0A=
 * @property {Object} $error An object hash, containing references to =
controls or forms with failing=0A=
 *  validators, where:=0A=
 *=0A=
 *  - keys are validation tokens (error names),=0A=
 *  - values are arrays of controls or forms that have a failing =
validator for the given error name.=0A=
 *=0A=
 *  Built-in validation tokens:=0A=
 *  - `email`=0A=
 *  - `max`=0A=
 *  - `maxlength`=0A=
 *  - `min`=0A=
 *  - `minlength`=0A=
 *  - `number`=0A=
 *  - `pattern`=0A=
 *  - `required`=0A=
 *  - `url`=0A=
 *  - `date`=0A=
 *  - `datetimelocal`=0A=
 *  - `time`=0A=
 *  - `week`=0A=
 *  - `month`=0A=
 *=0A=
 * @description=0A=
 * `FormController` keeps track of all its controls and nested forms as =
well as the state of them,=0A=
 * such as being valid/invalid or dirty/pristine.=0A=
 *=0A=
 * Each {@link ng.directive:form form} directive creates an instance=0A=
 * of `FormController`.=0A=
 *=0A=
 */=0A=
//asks for $scope to fool the BC controller module=0A=
FormController.$inject =3D ['$element', '$attrs', '$scope', '$animate', =
'$interpolate'];=0A=
function FormController($element, $attrs, $scope, $animate, =
$interpolate) {=0A=
  this.$$controls =3D [];=0A=
=0A=
  // init state=0A=
  this.$error =3D {};=0A=
  this.$$success =3D {};=0A=
  this.$pending =3D undefined;=0A=
  this.$name =3D $interpolate($attrs.name || $attrs.ngForm || =
'')($scope);=0A=
  this.$dirty =3D false;=0A=
  this.$pristine =3D true;=0A=
  this.$valid =3D true;=0A=
  this.$invalid =3D false;=0A=
  this.$submitted =3D false;=0A=
  this.$$parentForm =3D nullFormCtrl;=0A=
=0A=
  this.$$element =3D $element;=0A=
  this.$$animate =3D $animate;=0A=
=0A=
  setupValidity(this);=0A=
}=0A=
=0A=
FormController.prototype =3D {=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name form.FormController#$rollbackViewValue=0A=
   *=0A=
   * @description=0A=
   * Rollback all form controls pending updates to the `$modelValue`.=0A=
   *=0A=
   * Updates may be pending by a debounced event or because the input is =
waiting for a some future=0A=
   * event defined in `ng-model-options`. This method is typically =
needed by the reset button of=0A=
   * a form that uses `ng-model-options` to pend updates.=0A=
   */=0A=
  $rollbackViewValue: function() {=0A=
    forEach(this.$$controls, function(control) {=0A=
      control.$rollbackViewValue();=0A=
    });=0A=
  },=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name form.FormController#$commitViewValue=0A=
   *=0A=
   * @description=0A=
   * Commit all form controls pending updates to the `$modelValue`.=0A=
   *=0A=
   * Updates may be pending by a debounced event or because the input is =
waiting for a some future=0A=
   * event defined in `ng-model-options`. This method is rarely needed =
as `NgModelController`=0A=
   * usually handles calling this in response to input events.=0A=
   */=0A=
  $commitViewValue: function() {=0A=
    forEach(this.$$controls, function(control) {=0A=
      control.$commitViewValue();=0A=
    });=0A=
  },=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name form.FormController#$addControl=0A=
   * @param {object} control control object, either a {@link =
form.FormController} or an=0A=
   * {@link ngModel.NgModelController}=0A=
   *=0A=
   * @description=0A=
   * Register a control with the form. Input elements using =
ngModelController do this automatically=0A=
   * when they are linked.=0A=
   *=0A=
   * Note that the current state of the control will not be reflected on =
the new parent form. This=0A=
   * is not an issue with normal use, as freshly compiled and linked =
controls are in a `$pristine`=0A=
   * state.=0A=
   *=0A=
   * However, if the method is used programmatically, for example by =
adding dynamically created controls,=0A=
   * or controls that have been previously removed without destroying =
their corresponding DOM element,=0A=
   * it's the developers responsibility to make sure the current state =
propagates to the parent form.=0A=
   *=0A=
   * For example, if an input control is added that is already `$dirty` =
and has `$error` properties,=0A=
   * calling `$setDirty()` and `$validate()` afterwards will propagate =
the state to the parent form.=0A=
   */=0A=
  $addControl: function(control) {=0A=
    // Breaking change - before, inputs whose name was "hasOwnProperty" =
were quietly ignored=0A=
    // and not added to the scope.  Now we throw an error.=0A=
    assertNotHasOwnProperty(control.$name, 'input');=0A=
    this.$$controls.push(control);=0A=
=0A=
    if (control.$name) {=0A=
      this[control.$name] =3D control;=0A=
    }=0A=
=0A=
    control.$$parentForm =3D this;=0A=
  },=0A=
=0A=
  // Private API: rename a form control=0A=
  $$renameControl: function(control, newName) {=0A=
    var oldName =3D control.$name;=0A=
=0A=
    if (this[oldName] =3D=3D=3D control) {=0A=
      delete this[oldName];=0A=
    }=0A=
    this[newName] =3D control;=0A=
    control.$name =3D newName;=0A=
  },=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name form.FormController#$removeControl=0A=
   * @param {object} control control object, either a {@link =
form.FormController} or an=0A=
   * {@link ngModel.NgModelController}=0A=
   *=0A=
   * @description=0A=
   * Deregister a control from the form.=0A=
   *=0A=
   * Input elements using ngModelController do this automatically when =
they are destroyed.=0A=
   *=0A=
   * Note that only the removed control's validation state =
(`$errors`etc.) will be removed from the=0A=
   * form. `$dirty`, `$submitted` states will not be changed, because =
the expected behavior can be=0A=
   * different from case to case. For example, removing the only =
`$dirty` control from a form may or=0A=
   * may not mean that the form is still `$dirty`.=0A=
   */=0A=
  $removeControl: function(control) {=0A=
    if (control.$name &amp;&amp; this[control.$name] =3D=3D=3D control) {=0A=
      delete this[control.$name];=0A=
    }=0A=
    forEach(this.$pending, function(value, name) {=0A=
      // eslint-disable-next-line no-invalid-this=0A=
      this.$setValidity(name, null, control);=0A=
    }, this);=0A=
    forEach(this.$error, function(value, name) {=0A=
      // eslint-disable-next-line no-invalid-this=0A=
      this.$setValidity(name, null, control);=0A=
    }, this);=0A=
    forEach(this.$$success, function(value, name) {=0A=
      // eslint-disable-next-line no-invalid-this=0A=
      this.$setValidity(name, null, control);=0A=
    }, this);=0A=
=0A=
    arrayRemove(this.$$controls, control);=0A=
    control.$$parentForm =3D nullFormCtrl;=0A=
  },=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name form.FormController#$setDirty=0A=
   *=0A=
   * @description=0A=
   * Sets the form to a dirty state.=0A=
   *=0A=
   * This method can be called to add the 'ng-dirty' class and set the =
form to a dirty=0A=
   * state (ng-dirty class). This method will also propagate to parent =
forms.=0A=
   */=0A=
  $setDirty: function() {=0A=
    this.$$animate.removeClass(this.$$element, PRISTINE_CLASS);=0A=
    this.$$animate.addClass(this.$$element, DIRTY_CLASS);=0A=
    this.$dirty =3D true;=0A=
    this.$pristine =3D false;=0A=
    this.$$parentForm.$setDirty();=0A=
  },=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name form.FormController#$setPristine=0A=
   *=0A=
   * @description=0A=
   * Sets the form to its pristine state.=0A=
   *=0A=
   * This method sets the form's `$pristine` state to true, the `$dirty` =
state to false, removes=0A=
   * the `ng-dirty` class and adds the `ng-pristine` class. =
Additionally, it sets the `$submitted`=0A=
   * state to false.=0A=
   *=0A=
   * This method will also propagate to all the controls contained in =
this form.=0A=
   *=0A=
   * Setting a form back to a pristine state is often useful when we =
want to 'reuse' a form after=0A=
   * saving or resetting it.=0A=
   */=0A=
  $setPristine: function() {=0A=
    this.$$animate.setClass(this.$$element, PRISTINE_CLASS, DIRTY_CLASS =
+ ' ' + SUBMITTED_CLASS);=0A=
    this.$dirty =3D false;=0A=
    this.$pristine =3D true;=0A=
    this.$submitted =3D false;=0A=
    forEach(this.$$controls, function(control) {=0A=
      control.$setPristine();=0A=
    });=0A=
  },=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name form.FormController#$setUntouched=0A=
   *=0A=
   * @description=0A=
   * Sets the form to its untouched state.=0A=
   *=0A=
   * This method can be called to remove the 'ng-touched' class and set =
the form controls to their=0A=
   * untouched state (ng-untouched class).=0A=
   *=0A=
   * Setting a form controls back to their untouched state is often =
useful when setting the form=0A=
   * back to its pristine state.=0A=
   */=0A=
  $setUntouched: function() {=0A=
    forEach(this.$$controls, function(control) {=0A=
      control.$setUntouched();=0A=
    });=0A=
  },=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name form.FormController#$setSubmitted=0A=
   *=0A=
   * @description=0A=
   * Sets the form to its submitted state.=0A=
   */=0A=
  $setSubmitted: function() {=0A=
    this.$$animate.addClass(this.$$element, SUBMITTED_CLASS);=0A=
    this.$submitted =3D true;=0A=
    this.$$parentForm.$setSubmitted();=0A=
  }=0A=
};=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name form.FormController#$setValidity=0A=
 *=0A=
 * @description=0A=
 * Change the validity state of the form, and notify the parent form (if =
any).=0A=
 *=0A=
 * Application developers will rarely need to call this method directly. =
It is used internally, by=0A=
 * {@link ngModel.NgModelController#$setValidity =
NgModelController.$setValidity()}, to propagate a=0A=
 * control's validity state to the parent `FormController`.=0A=
 *=0A=
 * @param {string} validationErrorKey Name of the validator. The =
`validationErrorKey` will be=0A=
 *        assigned to either `$error[validationErrorKey]` or =
`$pending[validationErrorKey]` (for=0A=
 *        unfulfilled `$asyncValidators`), so that it is available for =
data-binding. The=0A=
 *        `validationErrorKey` should be in camelCase and will get =
converted into dash-case for=0A=
 *        class name. Example: `myError` will result in =
`ng-valid-my-error` and=0A=
 *        `ng-invalid-my-error` classes and can be bound to as `{{ =
someForm.$error.myError }}`.=0A=
 * @param {boolean} isValid Whether the current state is valid (true), =
invalid (false), pending=0A=
 *        (undefined),  or skipped (null). Pending is used for =
unfulfilled `$asyncValidators`.=0A=
 *        Skipped is used by AngularJS when validators do not run =
because of parse errors and when=0A=
 *        `$asyncValidators` do not run because any of the `$validators` =
failed.=0A=
 * @param {NgModelController | FormController} controller - The =
controller whose validity state is=0A=
 *        triggering the change.=0A=
 */=0A=
addSetValidityMethod({=0A=
  clazz: FormController,=0A=
  set: function(object, property, controller) {=0A=
    var list =3D object[property];=0A=
    if (!list) {=0A=
      object[property] =3D [controller];=0A=
    } else {=0A=
      var index =3D list.indexOf(controller);=0A=
      if (index =3D=3D=3D -1) {=0A=
        list.push(controller);=0A=
      }=0A=
    }=0A=
  },=0A=
  unset: function(object, property, controller) {=0A=
    var list =3D object[property];=0A=
    if (!list) {=0A=
      return;=0A=
    }=0A=
    arrayRemove(list, controller);=0A=
    if (list.length =3D=3D=3D 0) {=0A=
      delete object[property];=0A=
    }=0A=
  }=0A=
});=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngForm=0A=
 * @restrict EAC=0A=
 *=0A=
 * @description=0A=
 * Nestable alias of {@link ng.directive:form `form`} directive. HTML=0A=
 * does not allow nesting of form elements. It is useful to nest forms, =
for example if the validity of a=0A=
 * sub-group of controls needs to be determined.=0A=
 *=0A=
 * Note: the purpose of `ngForm` is to group controls,=0A=
 * but not to be a replacement for the `&lt;form&gt;` tag with all of =
its capabilities=0A=
 * (e.g. posting to the server, ...).=0A=
 *=0A=
 * @param {string=3D} ngForm|name Name of the form. If specified, the =
form controller will be published into=0A=
 *                       related scope, under this name.=0A=
 *=0A=
 */=0A=
=0A=
 /**=0A=
 * @ngdoc directive=0A=
 * @name form=0A=
 * @restrict E=0A=
 *=0A=
 * @description=0A=
 * Directive that instantiates=0A=
 * {@link form.FormController FormController}.=0A=
 *=0A=
 * If the `name` attribute is specified, the form controller is =
published onto the current scope under=0A=
 * this name.=0A=
 *=0A=
 * # Alias: {@link ng.directive:ngForm `ngForm`}=0A=
 *=0A=
 * In Angular, forms can be nested. This means that the outer form is =
valid when all of the child=0A=
 * forms are valid as well. However, browsers do not allow nesting of =
`&lt;form&gt;` elements, so=0A=
 * Angular provides the {@link ng.directive:ngForm `ngForm`} directive, =
which behaves identically to=0A=
 * `form` but can be nested. Nested forms can be useful, for example, if =
the validity of a sub-group=0A=
 * of controls needs to be determined.=0A=
 *=0A=
 * # CSS classes=0A=
 *  - `ng-valid` is set if the form is valid.=0A=
 *  - `ng-invalid` is set if the form is invalid.=0A=
 *  - `ng-pending` is set if the form is pending.=0A=
 *  - `ng-pristine` is set if the form is pristine.=0A=
 *  - `ng-dirty` is set if the form is dirty.=0A=
 *  - `ng-submitted` is set if the form was submitted.=0A=
 *=0A=
 * Keep in mind that ngAnimate can detect each of these classes when =
added and removed.=0A=
 *=0A=
 *=0A=
 * # Submitting a form and preventing the default action=0A=
 *=0A=
 * Since the role of forms in client-side Angular applications is =
different than in classical=0A=
 * roundtrip apps, it is desirable for the browser not to translate the =
form submission into a full=0A=
 * page reload that sends the data to the server. Instead some =
javascript logic should be triggered=0A=
 * to handle the form submission in an application-specific way.=0A=
 *=0A=
 * For this reason, Angular prevents the default action (form submission =
to the server) unless the=0A=
 * `&lt;form&gt;` element has an `action` attribute specified.=0A=
 *=0A=
 * You can use one of the following two ways to specify what javascript =
method should be called when=0A=
 * a form is submitted:=0A=
 *=0A=
 * - {@link ng.directive:ngSubmit ngSubmit} directive on the form element=0A=
 * - {@link ng.directive:ngClick ngClick} directive on the first=0A=
  *  button or input field of type submit (input[type=3Dsubmit])=0A=
 *=0A=
 * To prevent double execution of the handler, use only one of the =
{@link ng.directive:ngSubmit ngSubmit}=0A=
 * or {@link ng.directive:ngClick ngClick} directives.=0A=
 * This is because of the following form submission rules in the HTML =
specification:=0A=
 *=0A=
 * - If a form has only one input field then hitting enter in this field =
triggers form submit=0A=
 * (`ngSubmit`)=0A=
 * - if a form has 2+ input fields and no buttons or =
input[type=3Dsubmit] then hitting enter=0A=
 * doesn't trigger submit=0A=
 * - if a form has one or more input fields and one or more buttons or =
input[type=3Dsubmit] then=0A=
 * hitting enter in any of the input fields will trigger the click =
handler on the *first* button or=0A=
 * input[type=3Dsubmit] (`ngClick`) *and* a submit handler on the =
enclosing form (`ngSubmit`)=0A=
 *=0A=
 * Any pending `ngModelOptions` changes will take place immediately when =
an enclosing form is=0A=
 * submitted. Note that `ngClick` events will occur before the model is =
updated. Use `ngSubmit`=0A=
 * to have access to the updated model.=0A=
 *=0A=
 * ## Animation Hooks=0A=
 *=0A=
 * Animations in ngForm are triggered when any of the associated CSS =
classes are added and removed.=0A=
 * These classes are: `.ng-pristine`, `.ng-dirty`, `.ng-invalid` and =
`.ng-valid` as well as any=0A=
 * other validations that are performed within the form. Animations in =
ngForm are similar to how=0A=
 * they work in ngClass and animations can be hooked into using CSS =
transitions, keyframes as well=0A=
 * as JS animations.=0A=
 *=0A=
 * The following example shows a simple way to utilize CSS transitions =
to style a form element=0A=
 * that has been rendered as invalid after it has been validated:=0A=
 *=0A=
 * &lt;pre&gt;=0A=
 * //be sure to include ngAnimate as a module to hook into more=0A=
 * //advanced animations=0A=
 * .my-form {=0A=
 *   transition:0.5s linear all;=0A=
 *   background: white;=0A=
 * }=0A=
 * .my-form.ng-invalid {=0A=
 *   background: red;=0A=
 *   color:white;=0A=
 * }=0A=
 * &lt;/pre&gt;=0A=
 *=0A=
 * @example=0A=
    &lt;example name=3D"ng-form" deps=3D"angular-animate.js" =
animations=3D"true" fixBase=3D"true" module=3D"formExample"&gt;=0A=
      &lt;file name=3D"index.html"&gt;=0A=
       &lt;script&gt;=0A=
         angular.module('formExample', [])=0A=
           .controller('FormController', ['$scope', function($scope) {=0A=
             $scope.userType =3D 'guest';=0A=
           }]);=0A=
       &lt;/script&gt;=0A=
       &lt;style&gt;=0A=
        .my-form {=0A=
          transition:all linear 0.5s;=0A=
          background: transparent;=0A=
        }=0A=
        .my-form.ng-invalid {=0A=
          background: red;=0A=
        }=0A=
       &lt;/style&gt;=0A=
       &lt;form name=3D"myForm" ng-controller=3D"FormController" =
class=3D"my-form"&gt;=0A=
         userType: &lt;input name=3D"input" ng-model=3D"userType" =
required&gt;=0A=
         &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.required"&gt;Required!&lt;/span&gt;&lt;br&=
gt;=0A=
         &lt;code&gt;userType =3D {{userType}}&lt;/code&gt;&lt;br&gt;=0A=
         &lt;code&gt;myForm.input.$valid =3D =
{{myForm.input.$valid}}&lt;/code&gt;&lt;br&gt;=0A=
         &lt;code&gt;myForm.input.$error =3D =
{{myForm.input.$error}}&lt;/code&gt;&lt;br&gt;=0A=
         &lt;code&gt;myForm.$valid =3D =
{{myForm.$valid}}&lt;/code&gt;&lt;br&gt;=0A=
         &lt;code&gt;myForm.$error.required =3D =
{{!!myForm.$error.required}}&lt;/code&gt;&lt;br&gt;=0A=
        &lt;/form&gt;=0A=
      &lt;/file&gt;=0A=
      &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
        it('should initialize to model', function() {=0A=
          var userType =3D element(by.binding('userType'));=0A=
          var valid =3D element(by.binding('myForm.input.$valid'));=0A=
=0A=
          expect(userType.getText()).toContain('guest');=0A=
          expect(valid.getText()).toContain('true');=0A=
        });=0A=
=0A=
        it('should be invalid if empty', function() {=0A=
          var userType =3D element(by.binding('userType'));=0A=
          var valid =3D element(by.binding('myForm.input.$valid'));=0A=
          var userInput =3D element(by.model('userType'));=0A=
=0A=
          userInput.clear();=0A=
          userInput.sendKeys('');=0A=
=0A=
          expect(userType.getText()).toEqual('userType =3D');=0A=
          expect(valid.getText()).toContain('false');=0A=
        });=0A=
      &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
 *=0A=
 * @param {string=3D} name Name of the form. If specified, the form =
controller will be published into=0A=
 *                       related scope, under this name.=0A=
 */=0A=
var formDirectiveFactory =3D function(isNgForm) {=0A=
  return ['$timeout', '$parse', function($timeout, $parse) {=0A=
    var formDirective =3D {=0A=
      name: 'form',=0A=
      restrict: isNgForm ? 'EAC' : 'E',=0A=
      require: ['form', '^^?form'], //first is the form's own ctrl, =
second is an optional parent form=0A=
      controller: FormController,=0A=
      compile: function ngFormCompile(formElement, attr) {=0A=
        // Setup initial state of the control=0A=
        formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);=0A=
=0A=
        var nameAttr =3D attr.name ? 'name' : (isNgForm &amp;&amp; =
attr.ngForm ? 'ngForm' : false);=0A=
=0A=
        return {=0A=
          pre: function ngFormPreLink(scope, formElement, attr, ctrls) {=0A=
            var controller =3D ctrls[0];=0A=
=0A=
            // if `action` attr is not present on the form, prevent the =
default action (submission)=0A=
            if (!('action' in attr)) {=0A=
              // we can't use jq events because if a form is destroyed =
during submission the default=0A=
              // action is not prevented. see #1238=0A=
              //=0A=
              // IE 9 is not affected because it doesn't fire a submit =
event and try to do a full=0A=
              // page reload if the form was destroyed by submission of =
the form via a click handler=0A=
              // on a button in the form. Looks like an IE9 specific bug.=0A=
              var handleFormSubmission =3D function(event) {=0A=
                scope.$apply(function() {=0A=
                  controller.$commitViewValue();=0A=
                  controller.$setSubmitted();=0A=
                });=0A=
=0A=
                event.preventDefault();=0A=
              };=0A=
=0A=
              formElement[0].addEventListener('submit', =
handleFormSubmission);=0A=
=0A=
              // unregister the preventDefault listener so that we don't =
not leak memory but in a=0A=
              // way that will achieve the prevention of the default =
action.=0A=
              formElement.on('$destroy', function() {=0A=
                $timeout(function() {=0A=
                  formElement[0].removeEventListener('submit', =
handleFormSubmission);=0A=
                }, 0, false);=0A=
              });=0A=
            }=0A=
=0A=
            var parentFormCtrl =3D ctrls[1] || controller.$$parentForm;=0A=
            parentFormCtrl.$addControl(controller);=0A=
=0A=
            var setter =3D nameAttr ? getSetter(controller.$name) : noop;=0A=
=0A=
            if (nameAttr) {=0A=
              setter(scope, controller);=0A=
              attr.$observe(nameAttr, function(newValue) {=0A=
                if (controller.$name =3D=3D=3D newValue) return;=0A=
                setter(scope, undefined);=0A=
                controller.$$parentForm.$$renameControl(controller, =
newValue);=0A=
                setter =3D getSetter(controller.$name);=0A=
                setter(scope, controller);=0A=
              });=0A=
            }=0A=
            formElement.on('$destroy', function() {=0A=
              controller.$$parentForm.$removeControl(controller);=0A=
              setter(scope, undefined);=0A=
              extend(controller, nullFormCtrl); //stop propagating child =
destruction handlers upwards=0A=
            });=0A=
          }=0A=
        };=0A=
      }=0A=
    };=0A=
=0A=
    return formDirective;=0A=
=0A=
    function getSetter(expression) {=0A=
      if (expression =3D=3D=3D '') {=0A=
        //create an assignable expression, so forms with an empty name =
can be renamed later=0A=
        return $parse('this[""]').assign;=0A=
      }=0A=
      return $parse(expression).assign || noop;=0A=
    }=0A=
  }];=0A=
};=0A=
=0A=
var formDirective =3D formDirectiveFactory();=0A=
var ngFormDirective =3D formDirectiveFactory(true);=0A=
=0A=
=0A=
=0A=
// helper methods=0A=
function setupValidity(instance) {=0A=
  instance.$$classCache =3D {};=0A=
  instance.$$classCache[INVALID_CLASS] =3D =
!(instance.$$classCache[VALID_CLASS] =3D =
instance.$$element.hasClass(VALID_CLASS));=0A=
}=0A=
function addSetValidityMethod(context) {=0A=
  var clazz =3D context.clazz,=0A=
      set =3D context.set,=0A=
      unset =3D context.unset;=0A=
=0A=
  clazz.prototype.$setValidity =3D function(validationErrorKey, state, =
controller) {=0A=
    if (isUndefined(state)) {=0A=
      createAndSet(this, '$pending', validationErrorKey, controller);=0A=
    } else {=0A=
      unsetAndCleanup(this, '$pending', validationErrorKey, controller);=0A=
    }=0A=
    if (!isBoolean(state)) {=0A=
      unset(this.$error, validationErrorKey, controller);=0A=
      unset(this.$$success, validationErrorKey, controller);=0A=
    } else {=0A=
      if (state) {=0A=
        unset(this.$error, validationErrorKey, controller);=0A=
        set(this.$$success, validationErrorKey, controller);=0A=
      } else {=0A=
        set(this.$error, validationErrorKey, controller);=0A=
        unset(this.$$success, validationErrorKey, controller);=0A=
      }=0A=
    }=0A=
    if (this.$pending) {=0A=
      cachedToggleClass(this, PENDING_CLASS, true);=0A=
      this.$valid =3D this.$invalid =3D undefined;=0A=
      toggleValidationCss(this, '', null);=0A=
    } else {=0A=
      cachedToggleClass(this, PENDING_CLASS, false);=0A=
      this.$valid =3D isObjectEmpty(this.$error);=0A=
      this.$invalid =3D !this.$valid;=0A=
      toggleValidationCss(this, '', this.$valid);=0A=
    }=0A=
=0A=
    // re-read the state as the set/unset methods could have=0A=
    // combined state in this.$error[validationError] (used for forms),=0A=
    // where setting/unsetting only increments/decrements the value,=0A=
    // and does not replace it.=0A=
    var combinedState;=0A=
    if (this.$pending &amp;&amp; this.$pending[validationErrorKey]) {=0A=
      combinedState =3D undefined;=0A=
    } else if (this.$error[validationErrorKey]) {=0A=
      combinedState =3D false;=0A=
    } else if (this.$$success[validationErrorKey]) {=0A=
      combinedState =3D true;=0A=
    } else {=0A=
      combinedState =3D null;=0A=
    }=0A=
=0A=
    toggleValidationCss(this, validationErrorKey, combinedState);=0A=
    this.$$parentForm.$setValidity(validationErrorKey, combinedState, =
this);=0A=
  };=0A=
=0A=
  function createAndSet(ctrl, name, value, controller) {=0A=
    if (!ctrl[name]) {=0A=
      ctrl[name] =3D {};=0A=
    }=0A=
    set(ctrl[name], value, controller);=0A=
  }=0A=
=0A=
  function unsetAndCleanup(ctrl, name, value, controller) {=0A=
    if (ctrl[name]) {=0A=
      unset(ctrl[name], value, controller);=0A=
    }=0A=
    if (isObjectEmpty(ctrl[name])) {=0A=
      ctrl[name] =3D undefined;=0A=
    }=0A=
  }=0A=
=0A=
  function cachedToggleClass(ctrl, className, switchValue) {=0A=
    if (switchValue &amp;&amp; !ctrl.$$classCache[className]) {=0A=
      ctrl.$$animate.addClass(ctrl.$$element, className);=0A=
      ctrl.$$classCache[className] =3D true;=0A=
    } else if (!switchValue &amp;&amp; ctrl.$$classCache[className]) {=0A=
      ctrl.$$animate.removeClass(ctrl.$$element, className);=0A=
      ctrl.$$classCache[className] =3D false;=0A=
    }=0A=
  }=0A=
=0A=
  function toggleValidationCss(ctrl, validationErrorKey, isValid) {=0A=
    validationErrorKey =3D validationErrorKey ? '-' + =
snake_case(validationErrorKey, '-') : '';=0A=
=0A=
    cachedToggleClass(ctrl, VALID_CLASS + validationErrorKey, isValid =
=3D=3D=3D true);=0A=
    cachedToggleClass(ctrl, INVALID_CLASS + validationErrorKey, isValid =
=3D=3D=3D false);=0A=
  }=0A=
}=0A=
=0A=
function isObjectEmpty(obj) {=0A=
  if (obj) {=0A=
    for (var prop in obj) {=0A=
      if (obj.hasOwnProperty(prop)) {=0A=
        return false;=0A=
      }=0A=
    }=0A=
  }=0A=
  return true;=0A=
}=0A=
=0A=
/* global=0A=
  VALID_CLASS: false,=0A=
  INVALID_CLASS: false,=0A=
  PRISTINE_CLASS: false,=0A=
  DIRTY_CLASS: false,=0A=
  ngModelMinErr: false=0A=
*/=0A=
=0A=
// Regex code was initially obtained from SO prior to modification: =
https://stackoverflow.com/questions/3143070/javascript-regex-iso-datetime=
#answer-3143231=0A=
var ISO_DATE_REGEXP =3D =
/^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\=
d|Z)$/;=0A=
// See valid URLs in RFC3987 (http://tools.ietf.org/html/rfc3987)=0A=
// Note: We are being more lenient, because browsers are too.=0A=
//   1. Scheme=0A=
//   2. Slashes=0A=
//   3. Username=0A=
//   4. Password=0A=
//   5. Hostname=0A=
//   6. Port=0A=
//   7. Path=0A=
//   8. Query=0A=
//   9. Fragment=0A=
//                 1111111111111111 222   333333    44444        =
55555555555555555555555     666     77777777     8888888     999=0A=
var URL_REGEXP =3D =
/^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+])(=
?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;=0A=
// eslint-disable-next-line max-len=0A=
var EMAIL_REGEXP =3D =
/^(?=3D.{1,254}$)(?=3D.{1,64}@)[-!#$%&amp;'*+/0-9=3D?A-Z^_`a-z{|}~]+(\.[-=
!#$%&amp;'*+/0-9=3D?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za=
-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;=0A=
var NUMBER_REGEXP =3D /^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;=0A=
var DATE_REGEXP =3D /^(\d{4,})-(\d{2})-(\d{2})$/;=0A=
var DATETIMELOCAL_REGEXP =3D =
/^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;=0A=
var WEEK_REGEXP =3D /^(\d{4,})-W(\d\d)$/;=0A=
var MONTH_REGEXP =3D /^(\d{4,})-(\d\d)$/;=0A=
var TIME_REGEXP =3D /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;=0A=
=0A=
var PARTIAL_VALIDATION_EVENTS =3D 'keydown wheel mousedown';=0A=
var PARTIAL_VALIDATION_TYPES =3D createMap();=0A=
forEach('date,datetime-local,month,time,week'.split(','), function(type) =
{=0A=
  PARTIAL_VALIDATION_TYPES[type] =3D true;=0A=
});=0A=
=0A=
var inputType =3D {=0A=
=0A=
  /**=0A=
   * @ngdoc input=0A=
   * @name input[text]=0A=
   *=0A=
   * @description=0A=
   * Standard HTML text input with angular data binding, inherited by =
most of the `input` elements.=0A=
   *=0A=
   *=0A=
   * @param {string} ngModel Assignable angular expression to data-bind =
to.=0A=
   * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
   * @param {string=3D} required Adds `required` validation error key if =
the value is not entered.=0A=
   * @param {string=3D} ngRequired Adds `required` attribute and =
`required` validation constraint to=0A=
   *    the element when the ngRequired expression evaluates to true. =
Use `ngRequired` instead of=0A=
   *    `required` when you want to data-bind to the `required` =
attribute.=0A=
   * @param {number=3D} ngMinlength Sets `minlength` validation error =
key if the value is shorter than=0A=
   *    minlength.=0A=
   * @param {number=3D} ngMaxlength Sets `maxlength` validation error =
key if the value is longer than=0A=
   *    maxlength. Setting the attribute to a negative or non-numeric =
value, allows view values of=0A=
   *    any length.=0A=
   * @param {string=3D} pattern Similar to `ngPattern` except that the =
attribute value is the actual string=0A=
   *    that contains the regular expression body that will be converted =
to a regular expression=0A=
   *    as in the ngPattern directive.=0A=
   * @param {string=3D} ngPattern Sets `pattern` validation error key if =
the ngModel {@link ngModel.NgModelController#$viewValue $viewValue}=0A=
   *    does not match a RegExp found by evaluating the Angular =
expression given in the attribute value.=0A=
   *    If the expression evaluates to a RegExp object, then this is =
used directly.=0A=
   *    If the expression evaluates to a string, then it will be =
converted to a RegExp=0A=
   *    after wrapping it in `^` and `$` characters. For instance, =
`"abc"` will be converted to=0A=
   *    `new RegExp('^abc$')`.&lt;br /&gt;=0A=
   *    **Note:** Avoid using the `g` flag on the RegExp, as it will =
cause each successive search to=0A=
   *    start at the index of the last search's match, thus not taking =
the whole input value into=0A=
   *    account.=0A=
   * @param {string=3D} ngChange Angular expression to be executed when =
input changes due to user=0A=
   *    interaction with the input element.=0A=
   * @param {boolean=3D} [ngTrim=3Dtrue] If set to false Angular will =
not automatically trim the input.=0A=
   *    This parameter is ignored for input[type=3Dpassword] controls, =
which will never trim the=0A=
   *    input.=0A=
   *=0A=
   * @example=0A=
      &lt;example name=3D"text-input-directive" =
module=3D"textInputExample"&gt;=0A=
        &lt;file name=3D"index.html"&gt;=0A=
         &lt;script&gt;=0A=
           angular.module('textInputExample', [])=0A=
             .controller('ExampleController', ['$scope', =
function($scope) {=0A=
               $scope.example =3D {=0A=
                 text: 'guest',=0A=
                 word: /^\s*\w*\s*$/=0A=
               };=0A=
             }]);=0A=
         &lt;/script&gt;=0A=
         &lt;form name=3D"myForm" ng-controller=3D"ExampleController"&gt;=0A=
           &lt;label&gt;Single word:=0A=
             &lt;input type=3D"text" name=3D"input" =
ng-model=3D"example.text"=0A=
                    ng-pattern=3D"example.word" required =
ng-trim=3D"false"&gt;=0A=
           &lt;/label&gt;=0A=
           &lt;div role=3D"alert"&gt;=0A=
             &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.required"&gt;=0A=
               Required!&lt;/span&gt;=0A=
             &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.pattern"&gt;=0A=
               Single word only!&lt;/span&gt;=0A=
           &lt;/div&gt;=0A=
           &lt;code&gt;text =3D {{example.text}}&lt;/code&gt;&lt;br/&gt;=0A=
           &lt;code&gt;myForm.input.$valid =3D =
{{myForm.input.$valid}}&lt;/code&gt;&lt;br/&gt;=0A=
           &lt;code&gt;myForm.input.$error =3D =
{{myForm.input.$error}}&lt;/code&gt;&lt;br/&gt;=0A=
           &lt;code&gt;myForm.$valid =3D =
{{myForm.$valid}}&lt;/code&gt;&lt;br/&gt;=0A=
           &lt;code&gt;myForm.$error.required =3D =
{{!!myForm.$error.required}}&lt;/code&gt;&lt;br/&gt;=0A=
          &lt;/form&gt;=0A=
        &lt;/file&gt;=0A=
        &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
          var text =3D element(by.binding('example.text'));=0A=
          var valid =3D element(by.binding('myForm.input.$valid'));=0A=
          var input =3D element(by.model('example.text'));=0A=
=0A=
          it('should initialize to model', function() {=0A=
            expect(text.getText()).toContain('guest');=0A=
            expect(valid.getText()).toContain('true');=0A=
          });=0A=
=0A=
          it('should be invalid if empty', function() {=0A=
            input.clear();=0A=
            input.sendKeys('');=0A=
=0A=
            expect(text.getText()).toEqual('text =3D');=0A=
            expect(valid.getText()).toContain('false');=0A=
          });=0A=
=0A=
          it('should be invalid if multi word', function() {=0A=
            input.clear();=0A=
            input.sendKeys('hello world');=0A=
=0A=
            expect(valid.getText()).toContain('false');=0A=
          });=0A=
        &lt;/file&gt;=0A=
      &lt;/example&gt;=0A=
   */=0A=
  'text': textInputType,=0A=
=0A=
    /**=0A=
     * @ngdoc input=0A=
     * @name input[date]=0A=
     *=0A=
     * @description=0A=
     * Input with date validation and transformation. In browsers that =
do not yet support=0A=
     * the HTML5 date input, a text element will be used. In that case, =
text must be entered in a valid ISO-8601=0A=
     * date format (yyyy-MM-dd), for example: `2009-01-06`. Since many=0A=
     * modern browsers do not yet support this input type, it is =
important to provide cues to users on the=0A=
     * expected input format via a placeholder or label.=0A=
     *=0A=
     * The model must always be a Date object, otherwise Angular will =
throw an error.=0A=
     * Invalid `Date` objects (dates whose `getTime()` is `NaN`) will be =
rendered as an empty string.=0A=
     *=0A=
     * The timezone to be used to read/write the `Date` instance in the =
model can be defined using=0A=
     * {@link ng.directive:ngModelOptions ngModelOptions}. By default, =
this is the timezone of the browser.=0A=
     *=0A=
     * @param {string} ngModel Assignable angular expression to =
data-bind to.=0A=
     * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
     * @param {string=3D} min Sets the `min` validation error key if the =
value entered is less than `min`. This must be a=0A=
     *   valid ISO date string (yyyy-MM-dd). You can also use =
interpolation inside this attribute=0A=
     *   (e.g. `min=3D"{{minDate | date:'yyyy-MM-dd'}}"`). Note that =
`min` will also add native HTML5=0A=
     *   constraint validation.=0A=
     * @param {string=3D} max Sets the `max` validation error key if the =
value entered is greater than `max`. This must be=0A=
     *   a valid ISO date string (yyyy-MM-dd). You can also use =
interpolation inside this attribute=0A=
     *   (e.g. `max=3D"{{maxDate | date:'yyyy-MM-dd'}}"`). Note that =
`max` will also add native HTML5=0A=
     *   constraint validation.=0A=
     * @param {(date|string)=3D} ngMin Sets the `min` validation =
constraint to the Date / ISO date string=0A=
     *   the `ngMin` expression evaluates to. Note that it does not set =
the `min` attribute.=0A=
     * @param {(date|string)=3D} ngMax Sets the `max` validation =
constraint to the Date / ISO date string=0A=
     *   the `ngMax` expression evaluates to. Note that it does not set =
the `max` attribute.=0A=
     * @param {string=3D} required Sets `required` validation error key =
if the value is not entered.=0A=
     * @param {string=3D} ngRequired Adds `required` attribute and =
`required` validation constraint to=0A=
     *    the element when the ngRequired expression evaluates to true. =
Use `ngRequired` instead of=0A=
     *    `required` when you want to data-bind to the `required` =
attribute.=0A=
     * @param {string=3D} ngChange Angular expression to be executed =
when input changes due to user=0A=
     *    interaction with the input element.=0A=
     *=0A=
     * @example=0A=
     &lt;example name=3D"date-input-directive" =
module=3D"dateInputExample"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
       &lt;script&gt;=0A=
          angular.module('dateInputExample', [])=0A=
            .controller('DateController', ['$scope', function($scope) {=0A=
              $scope.example =3D {=0A=
                value: new Date(2013, 9, 22)=0A=
              };=0A=
            }]);=0A=
       &lt;/script&gt;=0A=
       &lt;form name=3D"myForm" ng-controller=3D"DateController as =
dateCtrl"&gt;=0A=
          &lt;label for=3D"exampleInput"&gt;Pick a date in =
2013:&lt;/label&gt;=0A=
          &lt;input type=3D"date" id=3D"exampleInput" name=3D"input" =
ng-model=3D"example.value"=0A=
              placeholder=3D"yyyy-MM-dd" min=3D"2013-01-01" =
max=3D"2013-12-31" required /&gt;=0A=
          &lt;div role=3D"alert"&gt;=0A=
            &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.required"&gt;=0A=
                Required!&lt;/span&gt;=0A=
            &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.date"&gt;=0A=
                Not a valid date!&lt;/span&gt;=0A=
           &lt;/div&gt;=0A=
           &lt;tt&gt;value =3D {{example.value | date: =
"yyyy-MM-dd"}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.input.$valid =3D =
{{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.input.$error =3D =
{{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.$valid =3D =
{{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.$error.required =3D =
{{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;=0A=
       &lt;/form&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
        var value =3D element(by.binding('example.value | date: =
"yyyy-MM-dd"'));=0A=
        var valid =3D element(by.binding('myForm.input.$valid'));=0A=
=0A=
        // currently protractor/webdriver does not support=0A=
        // sending keys to all known HTML5 input controls=0A=
        // for various browsers (see =
https://github.com/angular/protractor/issues/562).=0A=
        function setInput(val) {=0A=
          // set the value of the element and force validation.=0A=
          var scr =3D "var ipt =3D =
document.getElementById('exampleInput'); " +=0A=
          "ipt.value =3D '" + val + "';" +=0A=
          "angular.element(ipt).scope().$apply(function(s) { =
s.myForm[ipt.name].$setViewValue('" + val + "'); });";=0A=
          browser.executeScript(scr);=0A=
        }=0A=
=0A=
        it('should initialize to model', function() {=0A=
          expect(value.getText()).toContain('2013-10-22');=0A=
          expect(valid.getText()).toContain('myForm.input.$valid =3D =
true');=0A=
        });=0A=
=0A=
        it('should be invalid if empty', function() {=0A=
          setInput('');=0A=
          expect(value.getText()).toEqual('value =3D');=0A=
          expect(valid.getText()).toContain('myForm.input.$valid =3D =
false');=0A=
        });=0A=
=0A=
        it('should be invalid if over max', function() {=0A=
          setInput('2015-01-01');=0A=
          expect(value.getText()).toContain('');=0A=
          expect(valid.getText()).toContain('myForm.input.$valid =3D =
false');=0A=
        });=0A=
     &lt;/file&gt;=0A=
     &lt;/example&gt;=0A=
     */=0A=
  'date': createDateInputType('date', DATE_REGEXP,=0A=
         createDateParser(DATE_REGEXP, ['yyyy', 'MM', 'dd']),=0A=
         'yyyy-MM-dd'),=0A=
=0A=
   /**=0A=
    * @ngdoc input=0A=
    * @name input[datetime-local]=0A=
    *=0A=
    * @description=0A=
    * Input with datetime validation and transformation. In browsers =
that do not yet support=0A=
    * the HTML5 date input, a text element will be used. In that case, =
the text must be entered in a valid ISO-8601=0A=
    * local datetime format (yyyy-MM-ddTHH:mm:ss), for example: =
`2010-12-28T14:57:00`.=0A=
    *=0A=
    * The model must always be a Date object, otherwise Angular will =
throw an error.=0A=
    * Invalid `Date` objects (dates whose `getTime()` is `NaN`) will be =
rendered as an empty string.=0A=
    *=0A=
    * The timezone to be used to read/write the `Date` instance in the =
model can be defined using=0A=
    * {@link ng.directive:ngModelOptions ngModelOptions}. By default, =
this is the timezone of the browser.=0A=
    *=0A=
    * @param {string} ngModel Assignable angular expression to data-bind =
to.=0A=
    * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
    * @param {string=3D} min Sets the `min` validation error key if the =
value entered is less than `min`.=0A=
    *   This must be a valid ISO datetime format (yyyy-MM-ddTHH:mm:ss). =
You can also use interpolation=0A=
    *   inside this attribute (e.g. `min=3D"{{minDatetimeLocal | =
date:'yyyy-MM-ddTHH:mm:ss'}}"`).=0A=
    *   Note that `min` will also add native HTML5 constraint validation.=0A=
    * @param {string=3D} max Sets the `max` validation error key if the =
value entered is greater than `max`.=0A=
    *   This must be a valid ISO datetime format (yyyy-MM-ddTHH:mm:ss). =
You can also use interpolation=0A=
    *   inside this attribute (e.g. `max=3D"{{maxDatetimeLocal | =
date:'yyyy-MM-ddTHH:mm:ss'}}"`).=0A=
    *   Note that `max` will also add native HTML5 constraint validation.=0A=
    * @param {(date|string)=3D} ngMin Sets the `min` validation error =
key to the Date / ISO datetime string=0A=
    *   the `ngMin` expression evaluates to. Note that it does not set =
the `min` attribute.=0A=
    * @param {(date|string)=3D} ngMax Sets the `max` validation error =
key to the Date / ISO datetime string=0A=
    *   the `ngMax` expression evaluates to. Note that it does not set =
the `max` attribute.=0A=
    * @param {string=3D} required Sets `required` validation error key =
if the value is not entered.=0A=
    * @param {string=3D} ngRequired Adds `required` attribute and =
`required` validation constraint to=0A=
    *    the element when the ngRequired expression evaluates to true. =
Use `ngRequired` instead of=0A=
    *    `required` when you want to data-bind to the `required` =
attribute.=0A=
    * @param {string=3D} ngChange Angular expression to be executed when =
input changes due to user=0A=
    *    interaction with the input element.=0A=
    *=0A=
    * @example=0A=
    &lt;example name=3D"datetimelocal-input-directive" =
module=3D"dateExample"&gt;=0A=
    &lt;file name=3D"index.html"&gt;=0A=
      &lt;script&gt;=0A=
        angular.module('dateExample', [])=0A=
          .controller('DateController', ['$scope', function($scope) {=0A=
            $scope.example =3D {=0A=
              value: new Date(2010, 11, 28, 14, 57)=0A=
            };=0A=
          }]);=0A=
      &lt;/script&gt;=0A=
      &lt;form name=3D"myForm" ng-controller=3D"DateController as =
dateCtrl"&gt;=0A=
        &lt;label for=3D"exampleInput"&gt;Pick a date between in =
2013:&lt;/label&gt;=0A=
        &lt;input type=3D"datetime-local" id=3D"exampleInput" =
name=3D"input" ng-model=3D"example.value"=0A=
            placeholder=3D"yyyy-MM-ddTHH:mm:ss" =
min=3D"2001-01-01T00:00:00" max=3D"2013-12-31T00:00:00" required /&gt;=0A=
        &lt;div role=3D"alert"&gt;=0A=
          &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.required"&gt;=0A=
              Required!&lt;/span&gt;=0A=
          &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.datetimelocal"&gt;=0A=
              Not a valid date!&lt;/span&gt;=0A=
        &lt;/div&gt;=0A=
        &lt;tt&gt;value =3D {{example.value | date: =
"yyyy-MM-ddTHH:mm:ss"}}&lt;/tt&gt;&lt;br/&gt;=0A=
        &lt;tt&gt;myForm.input.$valid =3D =
{{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
        &lt;tt&gt;myForm.input.$error =3D =
{{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;=0A=
        &lt;tt&gt;myForm.$valid =3D =
{{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
        &lt;tt&gt;myForm.$error.required =3D =
{{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;=0A=
      &lt;/form&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
      var value =3D element(by.binding('example.value | date: =
"yyyy-MM-ddTHH:mm:ss"'));=0A=
      var valid =3D element(by.binding('myForm.input.$valid'));=0A=
=0A=
      // currently protractor/webdriver does not support=0A=
      // sending keys to all known HTML5 input controls=0A=
      // for various browsers =
(https://github.com/angular/protractor/issues/562).=0A=
      function setInput(val) {=0A=
        // set the value of the element and force validation.=0A=
        var scr =3D "var ipt =3D =
document.getElementById('exampleInput'); " +=0A=
        "ipt.value =3D '" + val + "';" +=0A=
        "angular.element(ipt).scope().$apply(function(s) { =
s.myForm[ipt.name].$setViewValue('" + val + "'); });";=0A=
        browser.executeScript(scr);=0A=
      }=0A=
=0A=
      it('should initialize to model', function() {=0A=
        expect(value.getText()).toContain('2010-12-28T14:57:00');=0A=
        expect(valid.getText()).toContain('myForm.input.$valid =3D =
true');=0A=
      });=0A=
=0A=
      it('should be invalid if empty', function() {=0A=
        setInput('');=0A=
        expect(value.getText()).toEqual('value =3D');=0A=
        expect(valid.getText()).toContain('myForm.input.$valid =3D =
false');=0A=
      });=0A=
=0A=
      it('should be invalid if over max', function() {=0A=
        setInput('2015-01-01T23:59:00');=0A=
        expect(value.getText()).toContain('');=0A=
        expect(valid.getText()).toContain('myForm.input.$valid =3D =
false');=0A=
      });=0A=
    &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
    */=0A=
  'datetime-local': createDateInputType('datetimelocal', =
DATETIMELOCAL_REGEXP,=0A=
      createDateParser(DATETIMELOCAL_REGEXP, ['yyyy', 'MM', 'dd', 'HH', =
'mm', 'ss', 'sss']),=0A=
      'yyyy-MM-ddTHH:mm:ss.sss'),=0A=
=0A=
  /**=0A=
   * @ngdoc input=0A=
   * @name input[time]=0A=
   *=0A=
   * @description=0A=
   * Input with time validation and transformation. In browsers that do =
not yet support=0A=
   * the HTML5 time input, a text element will be used. In that case, =
the text must be entered in a valid ISO-8601=0A=
   * local time format (HH:mm:ss), for example: `14:57:00`. Model must =
be a Date object. This binding will always output a=0A=
   * Date object to the model of January 1, 1970, or local date `new =
Date(1970, 0, 1, HH, mm, ss)`.=0A=
   *=0A=
   * The model must always be a Date object, otherwise Angular will =
throw an error.=0A=
   * Invalid `Date` objects (dates whose `getTime()` is `NaN`) will be =
rendered as an empty string.=0A=
   *=0A=
   * The timezone to be used to read/write the `Date` instance in the =
model can be defined using=0A=
   * {@link ng.directive:ngModelOptions ngModelOptions}. By default, =
this is the timezone of the browser.=0A=
   *=0A=
   * @param {string} ngModel Assignable angular expression to data-bind =
to.=0A=
   * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
   * @param {string=3D} min Sets the `min` validation error key if the =
value entered is less than `min`.=0A=
   *   This must be a valid ISO time format (HH:mm:ss). You can also use =
interpolation inside this=0A=
   *   attribute (e.g. `min=3D"{{minTime | date:'HH:mm:ss'}}"`). Note =
that `min` will also add=0A=
   *   native HTML5 constraint validation.=0A=
   * @param {string=3D} max Sets the `max` validation error key if the =
value entered is greater than `max`.=0A=
   *   This must be a valid ISO time format (HH:mm:ss). You can also use =
interpolation inside this=0A=
   *   attribute (e.g. `max=3D"{{maxTime | date:'HH:mm:ss'}}"`). Note =
that `max` will also add=0A=
   *   native HTML5 constraint validation.=0A=
   * @param {(date|string)=3D} ngMin Sets the `min` validation =
constraint to the Date / ISO time string the=0A=
   *   `ngMin` expression evaluates to. Note that it does not set the =
`min` attribute.=0A=
   * @param {(date|string)=3D} ngMax Sets the `max` validation =
constraint to the Date / ISO time string the=0A=
   *   `ngMax` expression evaluates to. Note that it does not set the =
`max` attribute.=0A=
   * @param {string=3D} required Sets `required` validation error key if =
the value is not entered.=0A=
   * @param {string=3D} ngRequired Adds `required` attribute and =
`required` validation constraint to=0A=
   *    the element when the ngRequired expression evaluates to true. =
Use `ngRequired` instead of=0A=
   *    `required` when you want to data-bind to the `required` =
attribute.=0A=
   * @param {string=3D} ngChange Angular expression to be executed when =
input changes due to user=0A=
   *    interaction with the input element.=0A=
   *=0A=
   * @example=0A=
   &lt;example name=3D"time-input-directive" module=3D"timeExample"&gt;=0A=
   &lt;file name=3D"index.html"&gt;=0A=
     &lt;script&gt;=0A=
      angular.module('timeExample', [])=0A=
        .controller('DateController', ['$scope', function($scope) {=0A=
          $scope.example =3D {=0A=
            value: new Date(1970, 0, 1, 14, 57, 0)=0A=
          };=0A=
        }]);=0A=
     &lt;/script&gt;=0A=
     &lt;form name=3D"myForm" ng-controller=3D"DateController as =
dateCtrl"&gt;=0A=
        &lt;label for=3D"exampleInput"&gt;Pick a time between 8am and =
5pm:&lt;/label&gt;=0A=
        &lt;input type=3D"time" id=3D"exampleInput" name=3D"input" =
ng-model=3D"example.value"=0A=
            placeholder=3D"HH:mm:ss" min=3D"08:00:00" max=3D"17:00:00" =
required /&gt;=0A=
        &lt;div role=3D"alert"&gt;=0A=
          &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.required"&gt;=0A=
              Required!&lt;/span&gt;=0A=
          &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.time"&gt;=0A=
              Not a valid date!&lt;/span&gt;=0A=
        &lt;/div&gt;=0A=
        &lt;tt&gt;value =3D {{example.value | date: =
"HH:mm:ss"}}&lt;/tt&gt;&lt;br/&gt;=0A=
        &lt;tt&gt;myForm.input.$valid =3D =
{{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
        &lt;tt&gt;myForm.input.$error =3D =
{{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;=0A=
        &lt;tt&gt;myForm.$valid =3D =
{{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
        &lt;tt&gt;myForm.$error.required =3D =
{{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;=0A=
     &lt;/form&gt;=0A=
   &lt;/file&gt;=0A=
   &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
      var value =3D element(by.binding('example.value | date: =
"HH:mm:ss"'));=0A=
      var valid =3D element(by.binding('myForm.input.$valid'));=0A=
=0A=
      // currently protractor/webdriver does not support=0A=
      // sending keys to all known HTML5 input controls=0A=
      // for various browsers =
(https://github.com/angular/protractor/issues/562).=0A=
      function setInput(val) {=0A=
        // set the value of the element and force validation.=0A=
        var scr =3D "var ipt =3D =
document.getElementById('exampleInput'); " +=0A=
        "ipt.value =3D '" + val + "';" +=0A=
        "angular.element(ipt).scope().$apply(function(s) { =
s.myForm[ipt.name].$setViewValue('" + val + "'); });";=0A=
        browser.executeScript(scr);=0A=
      }=0A=
=0A=
      it('should initialize to model', function() {=0A=
        expect(value.getText()).toContain('14:57:00');=0A=
        expect(valid.getText()).toContain('myForm.input.$valid =3D =
true');=0A=
      });=0A=
=0A=
      it('should be invalid if empty', function() {=0A=
        setInput('');=0A=
        expect(value.getText()).toEqual('value =3D');=0A=
        expect(valid.getText()).toContain('myForm.input.$valid =3D =
false');=0A=
      });=0A=
=0A=
      it('should be invalid if over max', function() {=0A=
        setInput('23:59:00');=0A=
        expect(value.getText()).toContain('');=0A=
        expect(valid.getText()).toContain('myForm.input.$valid =3D =
false');=0A=
      });=0A=
   &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
   */=0A=
  'time': createDateInputType('time', TIME_REGEXP,=0A=
      createDateParser(TIME_REGEXP, ['HH', 'mm', 'ss', 'sss']),=0A=
     'HH:mm:ss.sss'),=0A=
=0A=
   /**=0A=
    * @ngdoc input=0A=
    * @name input[week]=0A=
    *=0A=
    * @description=0A=
    * Input with week-of-the-year validation and transformation to Date. =
In browsers that do not yet support=0A=
    * the HTML5 week input, a text element will be used. In that case, =
the text must be entered in a valid ISO-8601=0A=
    * week format (yyyy-W##), for example: `2013-W02`.=0A=
    *=0A=
    * The model must always be a Date object, otherwise Angular will =
throw an error.=0A=
    * Invalid `Date` objects (dates whose `getTime()` is `NaN`) will be =
rendered as an empty string.=0A=
    *=0A=
    * The timezone to be used to read/write the `Date` instance in the =
model can be defined using=0A=
    * {@link ng.directive:ngModelOptions ngModelOptions}. By default, =
this is the timezone of the browser.=0A=
    *=0A=
    * @param {string} ngModel Assignable angular expression to data-bind =
to.=0A=
    * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
    * @param {string=3D} min Sets the `min` validation error key if the =
value entered is less than `min`.=0A=
    *   This must be a valid ISO week format (yyyy-W##). You can also =
use interpolation inside this=0A=
    *   attribute (e.g. `min=3D"{{minWeek | date:'yyyy-Www'}}"`). Note =
that `min` will also add=0A=
    *   native HTML5 constraint validation.=0A=
    * @param {string=3D} max Sets the `max` validation error key if the =
value entered is greater than `max`.=0A=
    *   This must be a valid ISO week format (yyyy-W##). You can also =
use interpolation inside this=0A=
    *   attribute (e.g. `max=3D"{{maxWeek | date:'yyyy-Www'}}"`). Note =
that `max` will also add=0A=
    *   native HTML5 constraint validation.=0A=
    * @param {(date|string)=3D} ngMin Sets the `min` validation =
constraint to the Date / ISO week string=0A=
    *   the `ngMin` expression evaluates to. Note that it does not set =
the `min` attribute.=0A=
    * @param {(date|string)=3D} ngMax Sets the `max` validation =
constraint to the Date / ISO week string=0A=
    *   the `ngMax` expression evaluates to. Note that it does not set =
the `max` attribute.=0A=
    * @param {string=3D} required Sets `required` validation error key =
if the value is not entered.=0A=
    * @param {string=3D} ngRequired Adds `required` attribute and =
`required` validation constraint to=0A=
    *    the element when the ngRequired expression evaluates to true. =
Use `ngRequired` instead of=0A=
    *    `required` when you want to data-bind to the `required` =
attribute.=0A=
    * @param {string=3D} ngChange Angular expression to be executed when =
input changes due to user=0A=
    *    interaction with the input element.=0A=
    *=0A=
    * @example=0A=
    &lt;example name=3D"week-input-directive" module=3D"weekExample"&gt;=0A=
    &lt;file name=3D"index.html"&gt;=0A=
      &lt;script&gt;=0A=
      angular.module('weekExample', [])=0A=
        .controller('DateController', ['$scope', function($scope) {=0A=
          $scope.example =3D {=0A=
            value: new Date(2013, 0, 3)=0A=
          };=0A=
        }]);=0A=
      &lt;/script&gt;=0A=
      &lt;form name=3D"myForm" ng-controller=3D"DateController as =
dateCtrl"&gt;=0A=
        &lt;label&gt;Pick a date between in 2013:=0A=
          &lt;input id=3D"exampleInput" type=3D"week" name=3D"input" =
ng-model=3D"example.value"=0A=
                 placeholder=3D"YYYY-W##" min=3D"2012-W32"=0A=
                 max=3D"2013-W52" required /&gt;=0A=
        &lt;/label&gt;=0A=
        &lt;div role=3D"alert"&gt;=0A=
          &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.required"&gt;=0A=
              Required!&lt;/span&gt;=0A=
          &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.week"&gt;=0A=
              Not a valid date!&lt;/span&gt;=0A=
        &lt;/div&gt;=0A=
        &lt;tt&gt;value =3D {{example.value | date: =
"yyyy-Www"}}&lt;/tt&gt;&lt;br/&gt;=0A=
        &lt;tt&gt;myForm.input.$valid =3D =
{{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
        &lt;tt&gt;myForm.input.$error =3D =
{{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;=0A=
        &lt;tt&gt;myForm.$valid =3D =
{{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
        &lt;tt&gt;myForm.$error.required =3D =
{{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;=0A=
      &lt;/form&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
      var value =3D element(by.binding('example.value | date: =
"yyyy-Www"'));=0A=
      var valid =3D element(by.binding('myForm.input.$valid'));=0A=
=0A=
      // currently protractor/webdriver does not support=0A=
      // sending keys to all known HTML5 input controls=0A=
      // for various browsers =
(https://github.com/angular/protractor/issues/562).=0A=
      function setInput(val) {=0A=
        // set the value of the element and force validation.=0A=
        var scr =3D "var ipt =3D =
document.getElementById('exampleInput'); " +=0A=
        "ipt.value =3D '" + val + "';" +=0A=
        "angular.element(ipt).scope().$apply(function(s) { =
s.myForm[ipt.name].$setViewValue('" + val + "'); });";=0A=
        browser.executeScript(scr);=0A=
      }=0A=
=0A=
      it('should initialize to model', function() {=0A=
        expect(value.getText()).toContain('2013-W01');=0A=
        expect(valid.getText()).toContain('myForm.input.$valid =3D =
true');=0A=
      });=0A=
=0A=
      it('should be invalid if empty', function() {=0A=
        setInput('');=0A=
        expect(value.getText()).toEqual('value =3D');=0A=
        expect(valid.getText()).toContain('myForm.input.$valid =3D =
false');=0A=
      });=0A=
=0A=
      it('should be invalid if over max', function() {=0A=
        setInput('2015-W01');=0A=
        expect(value.getText()).toContain('');=0A=
        expect(valid.getText()).toContain('myForm.input.$valid =3D =
false');=0A=
      });=0A=
    &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
    */=0A=
  'week': createDateInputType('week', WEEK_REGEXP, weekParser, =
'yyyy-Www'),=0A=
=0A=
  /**=0A=
   * @ngdoc input=0A=
   * @name input[month]=0A=
   *=0A=
   * @description=0A=
   * Input with month validation and transformation. In browsers that do =
not yet support=0A=
   * the HTML5 month input, a text element will be used. In that case, =
the text must be entered in a valid ISO-8601=0A=
   * month format (yyyy-MM), for example: `2009-01`.=0A=
   *=0A=
   * The model must always be a Date object, otherwise Angular will =
throw an error.=0A=
   * Invalid `Date` objects (dates whose `getTime()` is `NaN`) will be =
rendered as an empty string.=0A=
   * If the model is not set to the first of the month, the next view to =
model update will set it=0A=
   * to the first of the month.=0A=
   *=0A=
   * The timezone to be used to read/write the `Date` instance in the =
model can be defined using=0A=
   * {@link ng.directive:ngModelOptions ngModelOptions}. By default, =
this is the timezone of the browser.=0A=
   *=0A=
   * @param {string} ngModel Assignable angular expression to data-bind =
to.=0A=
   * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
   * @param {string=3D} min Sets the `min` validation error key if the =
value entered is less than `min`.=0A=
   *   This must be a valid ISO month format (yyyy-MM). You can also use =
interpolation inside this=0A=
   *   attribute (e.g. `min=3D"{{minMonth | date:'yyyy-MM'}}"`). Note =
that `min` will also add=0A=
   *   native HTML5 constraint validation.=0A=
   * @param {string=3D} max Sets the `max` validation error key if the =
value entered is greater than `max`.=0A=
   *   This must be a valid ISO month format (yyyy-MM). You can also use =
interpolation inside this=0A=
   *   attribute (e.g. `max=3D"{{maxMonth | date:'yyyy-MM'}}"`). Note =
that `max` will also add=0A=
   *   native HTML5 constraint validation.=0A=
   * @param {(date|string)=3D} ngMin Sets the `min` validation =
constraint to the Date / ISO week string=0A=
   *   the `ngMin` expression evaluates to. Note that it does not set =
the `min` attribute.=0A=
   * @param {(date|string)=3D} ngMax Sets the `max` validation =
constraint to the Date / ISO week string=0A=
   *   the `ngMax` expression evaluates to. Note that it does not set =
the `max` attribute.=0A=
=0A=
   * @param {string=3D} required Sets `required` validation error key if =
the value is not entered.=0A=
   * @param {string=3D} ngRequired Adds `required` attribute and =
`required` validation constraint to=0A=
   *    the element when the ngRequired expression evaluates to true. =
Use `ngRequired` instead of=0A=
   *    `required` when you want to data-bind to the `required` =
attribute.=0A=
   * @param {string=3D} ngChange Angular expression to be executed when =
input changes due to user=0A=
   *    interaction with the input element.=0A=
   *=0A=
   * @example=0A=
   &lt;example name=3D"month-input-directive" module=3D"monthExample"&gt;=0A=
   &lt;file name=3D"index.html"&gt;=0A=
     &lt;script&gt;=0A=
      angular.module('monthExample', [])=0A=
        .controller('DateController', ['$scope', function($scope) {=0A=
          $scope.example =3D {=0A=
            value: new Date(2013, 9, 1)=0A=
          };=0A=
        }]);=0A=
     &lt;/script&gt;=0A=
     &lt;form name=3D"myForm" ng-controller=3D"DateController as =
dateCtrl"&gt;=0A=
       &lt;label for=3D"exampleInput"&gt;Pick a month in =
2013:&lt;/label&gt;=0A=
       &lt;input id=3D"exampleInput" type=3D"month" name=3D"input" =
ng-model=3D"example.value"=0A=
          placeholder=3D"yyyy-MM" min=3D"2013-01" max=3D"2013-12" =
required /&gt;=0A=
       &lt;div role=3D"alert"&gt;=0A=
         &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.required"&gt;=0A=
            Required!&lt;/span&gt;=0A=
         &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.month"&gt;=0A=
            Not a valid month!&lt;/span&gt;=0A=
       &lt;/div&gt;=0A=
       &lt;tt&gt;value =3D {{example.value | date: =
"yyyy-MM"}}&lt;/tt&gt;&lt;br/&gt;=0A=
       &lt;tt&gt;myForm.input.$valid =3D =
{{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
       &lt;tt&gt;myForm.input.$error =3D =
{{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;=0A=
       &lt;tt&gt;myForm.$valid =3D =
{{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
       &lt;tt&gt;myForm.$error.required =3D =
{{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;=0A=
     &lt;/form&gt;=0A=
   &lt;/file&gt;=0A=
   &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
      var value =3D element(by.binding('example.value | date: =
"yyyy-MM"'));=0A=
      var valid =3D element(by.binding('myForm.input.$valid'));=0A=
=0A=
      // currently protractor/webdriver does not support=0A=
      // sending keys to all known HTML5 input controls=0A=
      // for various browsers =
(https://github.com/angular/protractor/issues/562).=0A=
      function setInput(val) {=0A=
        // set the value of the element and force validation.=0A=
        var scr =3D "var ipt =3D =
document.getElementById('exampleInput'); " +=0A=
        "ipt.value =3D '" + val + "';" +=0A=
        "angular.element(ipt).scope().$apply(function(s) { =
s.myForm[ipt.name].$setViewValue('" + val + "'); });";=0A=
        browser.executeScript(scr);=0A=
      }=0A=
=0A=
      it('should initialize to model', function() {=0A=
        expect(value.getText()).toContain('2013-10');=0A=
        expect(valid.getText()).toContain('myForm.input.$valid =3D =
true');=0A=
      });=0A=
=0A=
      it('should be invalid if empty', function() {=0A=
        setInput('');=0A=
        expect(value.getText()).toEqual('value =3D');=0A=
        expect(valid.getText()).toContain('myForm.input.$valid =3D =
false');=0A=
      });=0A=
=0A=
      it('should be invalid if over max', function() {=0A=
        setInput('2015-01');=0A=
        expect(value.getText()).toContain('');=0A=
        expect(valid.getText()).toContain('myForm.input.$valid =3D =
false');=0A=
      });=0A=
   &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
   */=0A=
  'month': createDateInputType('month', MONTH_REGEXP,=0A=
     createDateParser(MONTH_REGEXP, ['yyyy', 'MM']),=0A=
     'yyyy-MM'),=0A=
=0A=
  /**=0A=
   * @ngdoc input=0A=
   * @name input[number]=0A=
   *=0A=
   * @description=0A=
   * Text input with number validation and transformation. Sets the =
`number` validation=0A=
   * error if not a valid number.=0A=
   *=0A=
   * &lt;div class=3D"alert alert-warning"&gt;=0A=
   * The model must always be of type `number` otherwise Angular will =
throw an error.=0A=
   * Be aware that a string containing a number is not enough. See the =
{@link ngModel:numfmt}=0A=
   * error docs for more information and an example of how to convert =
your model if necessary.=0A=
   * &lt;/div&gt;=0A=
   *=0A=
   * ## Issues with HTML5 constraint validation=0A=
   *=0A=
   * In browsers that follow the=0A=
   * [HTML5 =
specification](https://html.spec.whatwg.org/multipage/forms.html#number-s=
tate-%28type=3Dnumber%29),=0A=
   * `input[number]` does not work as expected with {@link =
ngModelOptions `ngModelOptions.allowInvalid`}.=0A=
   * If a non-number is entered in the input, the browser will report =
the value as an empty string,=0A=
   * which means the view / model values in `ngModel` and subsequently =
the scope value=0A=
   * will also be an empty string.=0A=
   *=0A=
   *=0A=
   * @param {string} ngModel Assignable angular expression to data-bind =
to.=0A=
   * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
   * @param {string=3D} min Sets the `min` validation error key if the =
value entered is less than `min`.=0A=
   *    Can be interpolated.=0A=
   * @param {string=3D} max Sets the `max` validation error key if the =
value entered is greater than `max`.=0A=
   *    Can be interpolated.=0A=
   * @param {string=3D} ngMin Like `min`, sets the `min` validation =
error key if the value entered is less than `ngMin`,=0A=
   *    but does not trigger HTML5 native validation. Takes an =
expression.=0A=
   * @param {string=3D} ngMax Like `max`, sets the `max` validation =
error key if the value entered is greater than `ngMax`,=0A=
   *    but does not trigger HTML5 native validation. Takes an =
expression.=0A=
   * @param {string=3D} step Sets the `step` validation error key if the =
value entered does not fit the `step` constraint.=0A=
   *    Can be interpolated.=0A=
   * @param {string=3D} ngStep Like `step`, sets the `step` validation =
error key if the value entered does not fit the `ngStep` constraint,=0A=
   *    but does not trigger HTML5 native validation. Takes an =
expression.=0A=
   * @param {string=3D} required Sets `required` validation error key if =
the value is not entered.=0A=
   * @param {string=3D} ngRequired Adds `required` attribute and =
`required` validation constraint to=0A=
   *    the element when the ngRequired expression evaluates to true. =
Use `ngRequired` instead of=0A=
   *    `required` when you want to data-bind to the `required` =
attribute.=0A=
   * @param {number=3D} ngMinlength Sets `minlength` validation error =
key if the value is shorter than=0A=
   *    minlength.=0A=
   * @param {number=3D} ngMaxlength Sets `maxlength` validation error =
key if the value is longer than=0A=
   *    maxlength. Setting the attribute to a negative or non-numeric =
value, allows view values of=0A=
   *    any length.=0A=
   * @param {string=3D} pattern Similar to `ngPattern` except that the =
attribute value is the actual string=0A=
   *    that contains the regular expression body that will be converted =
to a regular expression=0A=
   *    as in the ngPattern directive.=0A=
   * @param {string=3D} ngPattern Sets `pattern` validation error key if =
the ngModel {@link ngModel.NgModelController#$viewValue $viewValue}=0A=
   *    does not match a RegExp found by evaluating the Angular =
expression given in the attribute value.=0A=
   *    If the expression evaluates to a RegExp object, then this is =
used directly.=0A=
   *    If the expression evaluates to a string, then it will be =
converted to a RegExp=0A=
   *    after wrapping it in `^` and `$` characters. For instance, =
`"abc"` will be converted to=0A=
   *    `new RegExp('^abc$')`.&lt;br /&gt;=0A=
   *    **Note:** Avoid using the `g` flag on the RegExp, as it will =
cause each successive search to=0A=
   *    start at the index of the last search's match, thus not taking =
the whole input value into=0A=
   *    account.=0A=
   * @param {string=3D} ngChange Angular expression to be executed when =
input changes due to user=0A=
   *    interaction with the input element.=0A=
   *=0A=
   * @example=0A=
      &lt;example name=3D"number-input-directive" =
module=3D"numberExample"&gt;=0A=
        &lt;file name=3D"index.html"&gt;=0A=
         &lt;script&gt;=0A=
           angular.module('numberExample', [])=0A=
             .controller('ExampleController', ['$scope', =
function($scope) {=0A=
               $scope.example =3D {=0A=
                 value: 12=0A=
               };=0A=
             }]);=0A=
         &lt;/script&gt;=0A=
         &lt;form name=3D"myForm" ng-controller=3D"ExampleController"&gt;=0A=
           &lt;label&gt;Number:=0A=
             &lt;input type=3D"number" name=3D"input" =
ng-model=3D"example.value"=0A=
                    min=3D"0" max=3D"99" required&gt;=0A=
          &lt;/label&gt;=0A=
           &lt;div role=3D"alert"&gt;=0A=
             &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.required"&gt;=0A=
               Required!&lt;/span&gt;=0A=
             &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.number"&gt;=0A=
               Not valid number!&lt;/span&gt;=0A=
           &lt;/div&gt;=0A=
           &lt;tt&gt;value =3D {{example.value}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.input.$valid =3D =
{{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.input.$error =3D =
{{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.$valid =3D =
{{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.$error.required =3D =
{{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;=0A=
          &lt;/form&gt;=0A=
        &lt;/file&gt;=0A=
        &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
          var value =3D element(by.binding('example.value'));=0A=
          var valid =3D element(by.binding('myForm.input.$valid'));=0A=
          var input =3D element(by.model('example.value'));=0A=
=0A=
          it('should initialize to model', function() {=0A=
            expect(value.getText()).toContain('12');=0A=
            expect(valid.getText()).toContain('true');=0A=
          });=0A=
=0A=
          it('should be invalid if empty', function() {=0A=
            input.clear();=0A=
            input.sendKeys('');=0A=
            expect(value.getText()).toEqual('value =3D');=0A=
            expect(valid.getText()).toContain('false');=0A=
          });=0A=
=0A=
          it('should be invalid if over max', function() {=0A=
            input.clear();=0A=
            input.sendKeys('123');=0A=
            expect(value.getText()).toEqual('value =3D');=0A=
            expect(valid.getText()).toContain('false');=0A=
          });=0A=
        &lt;/file&gt;=0A=
      &lt;/example&gt;=0A=
   */=0A=
  'number': numberInputType,=0A=
=0A=
=0A=
  /**=0A=
   * @ngdoc input=0A=
   * @name input[url]=0A=
   *=0A=
   * @description=0A=
   * Text input with URL validation. Sets the `url` validation error key =
if the content is not a=0A=
   * valid URL.=0A=
   *=0A=
   * &lt;div class=3D"alert alert-warning"&gt;=0A=
   * **Note:** `input[url]` uses a regex to validate urls that is =
derived from the regex=0A=
   * used in Chromium. If you need stricter validation, you can use =
`ng-pattern` or modify=0A=
   * the built-in validators (see the {@link guide/forms Forms guide})=0A=
   * &lt;/div&gt;=0A=
   *=0A=
   * @param {string} ngModel Assignable angular expression to data-bind =
to.=0A=
   * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
   * @param {string=3D} required Sets `required` validation error key if =
the value is not entered.=0A=
   * @param {string=3D} ngRequired Adds `required` attribute and =
`required` validation constraint to=0A=
   *    the element when the ngRequired expression evaluates to true. =
Use `ngRequired` instead of=0A=
   *    `required` when you want to data-bind to the `required` =
attribute.=0A=
   * @param {number=3D} ngMinlength Sets `minlength` validation error =
key if the value is shorter than=0A=
   *    minlength.=0A=
   * @param {number=3D} ngMaxlength Sets `maxlength` validation error =
key if the value is longer than=0A=
   *    maxlength. Setting the attribute to a negative or non-numeric =
value, allows view values of=0A=
   *    any length.=0A=
   * @param {string=3D} pattern Similar to `ngPattern` except that the =
attribute value is the actual string=0A=
   *    that contains the regular expression body that will be converted =
to a regular expression=0A=
   *    as in the ngPattern directive.=0A=
   * @param {string=3D} ngPattern Sets `pattern` validation error key if =
the ngModel {@link ngModel.NgModelController#$viewValue $viewValue}=0A=
   *    does not match a RegExp found by evaluating the Angular =
expression given in the attribute value.=0A=
   *    If the expression evaluates to a RegExp object, then this is =
used directly.=0A=
   *    If the expression evaluates to a string, then it will be =
converted to a RegExp=0A=
   *    after wrapping it in `^` and `$` characters. For instance, =
`"abc"` will be converted to=0A=
   *    `new RegExp('^abc$')`.&lt;br /&gt;=0A=
   *    **Note:** Avoid using the `g` flag on the RegExp, as it will =
cause each successive search to=0A=
   *    start at the index of the last search's match, thus not taking =
the whole input value into=0A=
   *    account.=0A=
   * @param {string=3D} ngChange Angular expression to be executed when =
input changes due to user=0A=
   *    interaction with the input element.=0A=
   *=0A=
   * @example=0A=
      &lt;example name=3D"url-input-directive" module=3D"urlExample"&gt;=0A=
        &lt;file name=3D"index.html"&gt;=0A=
         &lt;script&gt;=0A=
           angular.module('urlExample', [])=0A=
             .controller('ExampleController', ['$scope', =
function($scope) {=0A=
               $scope.url =3D {=0A=
                 text: 'http://google.com'=0A=
               };=0A=
             }]);=0A=
         &lt;/script&gt;=0A=
         &lt;form name=3D"myForm" ng-controller=3D"ExampleController"&gt;=0A=
           &lt;label&gt;URL:=0A=
             &lt;input type=3D"url" name=3D"input" ng-model=3D"url.text" =
required&gt;=0A=
           &lt;label&gt;=0A=
           &lt;div role=3D"alert"&gt;=0A=
             &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.required"&gt;=0A=
               Required!&lt;/span&gt;=0A=
             &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.url"&gt;=0A=
               Not valid url!&lt;/span&gt;=0A=
           &lt;/div&gt;=0A=
           &lt;tt&gt;text =3D {{url.text}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.input.$valid =3D =
{{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.input.$error =3D =
{{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.$valid =3D =
{{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.$error.required =3D =
{{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.$error.url =3D =
{{!!myForm.$error.url}}&lt;/tt&gt;&lt;br/&gt;=0A=
          &lt;/form&gt;=0A=
        &lt;/file&gt;=0A=
        &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
          var text =3D element(by.binding('url.text'));=0A=
          var valid =3D element(by.binding('myForm.input.$valid'));=0A=
          var input =3D element(by.model('url.text'));=0A=
=0A=
          it('should initialize to model', function() {=0A=
            expect(text.getText()).toContain('http://google.com');=0A=
            expect(valid.getText()).toContain('true');=0A=
          });=0A=
=0A=
          it('should be invalid if empty', function() {=0A=
            input.clear();=0A=
            input.sendKeys('');=0A=
=0A=
            expect(text.getText()).toEqual('text =3D');=0A=
            expect(valid.getText()).toContain('false');=0A=
          });=0A=
=0A=
          it('should be invalid if not url', function() {=0A=
            input.clear();=0A=
            input.sendKeys('box');=0A=
=0A=
            expect(valid.getText()).toContain('false');=0A=
          });=0A=
        &lt;/file&gt;=0A=
      &lt;/example&gt;=0A=
   */=0A=
  'url': urlInputType,=0A=
=0A=
=0A=
  /**=0A=
   * @ngdoc input=0A=
   * @name input[email]=0A=
   *=0A=
   * @description=0A=
   * Text input with email validation. Sets the `email` validation error =
key if not a valid email=0A=
   * address.=0A=
   *=0A=
   * &lt;div class=3D"alert alert-warning"&gt;=0A=
   * **Note:** `input[email]` uses a regex to validate email addresses =
that is derived from the regex=0A=
   * used in Chromium. If you need stricter validation (e.g. requiring a =
top-level domain), you can=0A=
   * use `ng-pattern` or modify the built-in validators (see the {@link =
guide/forms Forms guide})=0A=
   * &lt;/div&gt;=0A=
   *=0A=
   * @param {string} ngModel Assignable angular expression to data-bind =
to.=0A=
   * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
   * @param {string=3D} required Sets `required` validation error key if =
the value is not entered.=0A=
   * @param {string=3D} ngRequired Adds `required` attribute and =
`required` validation constraint to=0A=
   *    the element when the ngRequired expression evaluates to true. =
Use `ngRequired` instead of=0A=
   *    `required` when you want to data-bind to the `required` =
attribute.=0A=
   * @param {number=3D} ngMinlength Sets `minlength` validation error =
key if the value is shorter than=0A=
   *    minlength.=0A=
   * @param {number=3D} ngMaxlength Sets `maxlength` validation error =
key if the value is longer than=0A=
   *    maxlength. Setting the attribute to a negative or non-numeric =
value, allows view values of=0A=
   *    any length.=0A=
   * @param {string=3D} pattern Similar to `ngPattern` except that the =
attribute value is the actual string=0A=
   *    that contains the regular expression body that will be converted =
to a regular expression=0A=
   *    as in the ngPattern directive.=0A=
   * @param {string=3D} ngPattern Sets `pattern` validation error key if =
the ngModel {@link ngModel.NgModelController#$viewValue $viewValue}=0A=
   *    does not match a RegExp found by evaluating the Angular =
expression given in the attribute value.=0A=
   *    If the expression evaluates to a RegExp object, then this is =
used directly.=0A=
   *    If the expression evaluates to a string, then it will be =
converted to a RegExp=0A=
   *    after wrapping it in `^` and `$` characters. For instance, =
`"abc"` will be converted to=0A=
   *    `new RegExp('^abc$')`.&lt;br /&gt;=0A=
   *    **Note:** Avoid using the `g` flag on the RegExp, as it will =
cause each successive search to=0A=
   *    start at the index of the last search's match, thus not taking =
the whole input value into=0A=
   *    account.=0A=
   * @param {string=3D} ngChange Angular expression to be executed when =
input changes due to user=0A=
   *    interaction with the input element.=0A=
   *=0A=
   * @example=0A=
      &lt;example name=3D"email-input-directive" =
module=3D"emailExample"&gt;=0A=
        &lt;file name=3D"index.html"&gt;=0A=
         &lt;script&gt;=0A=
           angular.module('emailExample', [])=0A=
             .controller('ExampleController', ['$scope', =
function($scope) {=0A=
               $scope.email =3D {=0A=
                 text: 'me@example.com'=0A=
               };=0A=
             }]);=0A=
         &lt;/script&gt;=0A=
           &lt;form name=3D"myForm" =
ng-controller=3D"ExampleController"&gt;=0A=
             &lt;label&gt;Email:=0A=
               &lt;input type=3D"email" name=3D"input" =
ng-model=3D"email.text" required&gt;=0A=
             &lt;/label&gt;=0A=
             &lt;div role=3D"alert"&gt;=0A=
               &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.required"&gt;=0A=
                 Required!&lt;/span&gt;=0A=
               &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.email"&gt;=0A=
                 Not valid email!&lt;/span&gt;=0A=
             &lt;/div&gt;=0A=
             &lt;tt&gt;text =3D {{email.text}}&lt;/tt&gt;&lt;br/&gt;=0A=
             &lt;tt&gt;myForm.input.$valid =3D =
{{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
             &lt;tt&gt;myForm.input.$error =3D =
{{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;=0A=
             &lt;tt&gt;myForm.$valid =3D =
{{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
             &lt;tt&gt;myForm.$error.required =3D =
{{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;=0A=
             &lt;tt&gt;myForm.$error.email =3D =
{{!!myForm.$error.email}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;/form&gt;=0A=
         &lt;/file&gt;=0A=
        &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
          var text =3D element(by.binding('email.text'));=0A=
          var valid =3D element(by.binding('myForm.input.$valid'));=0A=
          var input =3D element(by.model('email.text'));=0A=
=0A=
          it('should initialize to model', function() {=0A=
            expect(text.getText()).toContain('me@example.com');=0A=
            expect(valid.getText()).toContain('true');=0A=
          });=0A=
=0A=
          it('should be invalid if empty', function() {=0A=
            input.clear();=0A=
            input.sendKeys('');=0A=
            expect(text.getText()).toEqual('text =3D');=0A=
            expect(valid.getText()).toContain('false');=0A=
          });=0A=
=0A=
          it('should be invalid if not email', function() {=0A=
            input.clear();=0A=
            input.sendKeys('xxx');=0A=
=0A=
            expect(valid.getText()).toContain('false');=0A=
          });=0A=
        &lt;/file&gt;=0A=
      &lt;/example&gt;=0A=
   */=0A=
  'email': emailInputType,=0A=
=0A=
=0A=
  /**=0A=
   * @ngdoc input=0A=
   * @name input[radio]=0A=
   *=0A=
   * @description=0A=
   * HTML radio button.=0A=
   *=0A=
   * @param {string} ngModel Assignable angular expression to data-bind =
to.=0A=
   * @param {string} value The value to which the `ngModel` expression =
should be set when selected.=0A=
   *    Note that `value` only supports `string` values, i.e. the scope =
model needs to be a string,=0A=
   *    too. Use `ngValue` if you need complex models (`number`, =
`object`, ...).=0A=
   * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
   * @param {string=3D} ngChange Angular expression to be executed when =
input changes due to user=0A=
   *    interaction with the input element.=0A=
   * @param {string} ngValue Angular expression to which `ngModel` will =
be be set when the radio=0A=
   *    is selected. Should be used instead of the `value` attribute if =
you need=0A=
   *    a non-string `ngModel` (`boolean`, `array`, ...).=0A=
   *=0A=
   * @example=0A=
      &lt;example name=3D"radio-input-directive" =
module=3D"radioExample"&gt;=0A=
        &lt;file name=3D"index.html"&gt;=0A=
         &lt;script&gt;=0A=
           angular.module('radioExample', [])=0A=
             .controller('ExampleController', ['$scope', =
function($scope) {=0A=
               $scope.color =3D {=0A=
                 name: 'blue'=0A=
               };=0A=
               $scope.specialValue =3D {=0A=
                 "id": "12345",=0A=
                 "value": "green"=0A=
               };=0A=
             }]);=0A=
         &lt;/script&gt;=0A=
         &lt;form name=3D"myForm" ng-controller=3D"ExampleController"&gt;=0A=
           &lt;label&gt;=0A=
             &lt;input type=3D"radio" ng-model=3D"color.name" =
value=3D"red"&gt;=0A=
             Red=0A=
           &lt;/label&gt;&lt;br/&gt;=0A=
           &lt;label&gt;=0A=
             &lt;input type=3D"radio" ng-model=3D"color.name" =
ng-value=3D"specialValue"&gt;=0A=
             Green=0A=
           &lt;/label&gt;&lt;br/&gt;=0A=
           &lt;label&gt;=0A=
             &lt;input type=3D"radio" ng-model=3D"color.name" =
value=3D"blue"&gt;=0A=
             Blue=0A=
           &lt;/label&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;color =3D {{color.name | =
json}}&lt;/tt&gt;&lt;br/&gt;=0A=
          &lt;/form&gt;=0A=
          Note that `ng-value=3D"specialValue"` sets radio item's value =
to be the value of `$scope.specialValue`.=0A=
        &lt;/file&gt;=0A=
        &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
          it('should change state', function() {=0A=
            var inputs =3D element.all(by.model('color.name'));=0A=
            var color =3D element(by.binding('color.name'));=0A=
=0A=
            expect(color.getText()).toContain('blue');=0A=
=0A=
            inputs.get(0).click();=0A=
            expect(color.getText()).toContain('red');=0A=
=0A=
            inputs.get(1).click();=0A=
            expect(color.getText()).toContain('green');=0A=
          });=0A=
        &lt;/file&gt;=0A=
      &lt;/example&gt;=0A=
   */=0A=
  'radio': radioInputType,=0A=
=0A=
  /**=0A=
   * @ngdoc input=0A=
   * @name input[range]=0A=
   *=0A=
   * @description=0A=
   * Native range input with validation and transformation.=0A=
   *=0A=
   * The model for the range input must always be a `Number`.=0A=
   *=0A=
   * IE9 and other browsers that do not support the `range` type fall =
back=0A=
   * to a text input without any default values for `min`, `max` and =
`step`. Model binding,=0A=
   * validation and number parsing are nevertheless supported.=0A=
   *=0A=
   * Browsers that support range (latest Chrome, Safari, Firefox, Edge) =
treat `input[range]`=0A=
   * in a way that never allows the input to hold an invalid value. That =
means:=0A=
   * - any non-numerical value is set to `(max + min) / 2`.=0A=
   * - any numerical value that is less than the current min val, or =
greater than the current max val=0A=
   * is set to the min / max val respectively.=0A=
   * - additionally, the current `step` is respected, so the nearest =
value that satisfies a step=0A=
   * is used.=0A=
   *=0A=
   * See the [HTML Spec on =
input[type=3Drange]](https://www.w3.org/TR/html5/forms.html#range-state-(=
type=3Drange))=0A=
   * for more info.=0A=
   *=0A=
   * This has the following consequences for Angular:=0A=
   *=0A=
   * Since the element value should always reflect the current model =
value, a range input=0A=
   * will set the bound ngModel expression to the value that the browser =
has set for the=0A=
   * input element. For example, in the following input `&lt;input =
type=3D"range" ng-model=3D"model.value"&gt;`,=0A=
   * if the application sets `model.value =3D null`, the browser will =
set the input to `'50'`.=0A=
   * Angular will then set the model to `50`, to prevent input and model =
value being out of sync.=0A=
   *=0A=
   * That means the model for range will immediately be set to `50` =
after `ngModel` has been=0A=
   * initialized. It also means a range input can never have the =
required error.=0A=
   *=0A=
   * This does not only affect changes to the model value, but also to =
the values of the `min`,=0A=
   * `max`, and `step` attributes. When these change in a way that will =
cause the browser to modify=0A=
   * the input value, Angular will also update the model value.=0A=
   *=0A=
   * Automatic value adjustment also means that a range input element =
can never have the `required`,=0A=
   * `min`, or `max` errors.=0A=
   *=0A=
   * However, `step` is currently only fully implemented by Firefox. =
Other browsers have problems=0A=
   * when the step value changes dynamically - they do not adjust the =
element value correctly, but=0A=
   * instead may set the `stepMismatch` error. If that's the case, the =
Angular will set the `step`=0A=
   * error on the input, and set the model to `undefined`.=0A=
   *=0A=
   * Note that `input[range]` is not compatible with`ngMax`, `ngMin`, =
and `ngStep`, because they do=0A=
   * not set the `min` and `max` attributes, which means that the =
browser won't automatically adjust=0A=
   * the input value based on their values, and will always assume min =
=3D 0, max =3D 100, and step =3D 1.=0A=
   *=0A=
   * @param {string}  ngModel Assignable angular expression to data-bind =
to.=0A=
   * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
   * @param {string=3D} min Sets the `min` validation to ensure that the =
value entered is greater=0A=
   *                  than `min`. Can be interpolated.=0A=
   * @param {string=3D} max Sets the `max` validation to ensure that the =
value entered is less than `max`.=0A=
   *                  Can be interpolated.=0A=
   * @param {string=3D} step Sets the `step` validation to ensure that =
the value entered matches the `step`=0A=
   *                  Can be interpolated.=0A=
   * @param {string=3D} ngChange Angular expression to be executed when =
the ngModel value changes due=0A=
   *                  to user interaction with the input element.=0A=
   * @param {expression=3D} ngChecked If the expression is truthy, then =
the `checked` attribute will be set on the=0A=
   *                      element. **Note** : `ngChecked` should not be =
used alongside `ngModel`.=0A=
   *                      Checkout {@link ng.directive:ngChecked =
ngChecked} for usage.=0A=
   *=0A=
   * @example=0A=
      &lt;example name=3D"range-input-directive" =
module=3D"rangeExample"&gt;=0A=
        &lt;file name=3D"index.html"&gt;=0A=
          &lt;script&gt;=0A=
            angular.module('rangeExample', [])=0A=
              .controller('ExampleController', ['$scope', =
function($scope) {=0A=
                $scope.value =3D 75;=0A=
                $scope.min =3D 10;=0A=
                $scope.max =3D 90;=0A=
              }]);=0A=
          &lt;/script&gt;=0A=
          &lt;form name=3D"myForm" =
ng-controller=3D"ExampleController"&gt;=0A=
=0A=
            Model as range: &lt;input type=3D"range" name=3D"range" =
ng-model=3D"value" min=3D"{{min}}"  max=3D"{{max}}"&gt;=0A=
            &lt;hr&gt;=0A=
            Model as number: &lt;input type=3D"number" =
ng-model=3D"value"&gt;&lt;br&gt;=0A=
            Min: &lt;input type=3D"number" ng-model=3D"min"&gt;&lt;br&gt;=0A=
            Max: &lt;input type=3D"number" ng-model=3D"max"&gt;&lt;br&gt;=0A=
            value =3D &lt;code&gt;{{value}}&lt;/code&gt;&lt;br/&gt;=0A=
            myForm.range.$valid =3D =
&lt;code&gt;{{myForm.range.$valid}}&lt;/code&gt;&lt;br/&gt;=0A=
            myForm.range.$error =3D =
&lt;code&gt;{{myForm.range.$error}}&lt;/code&gt;=0A=
          &lt;/form&gt;=0A=
        &lt;/file&gt;=0A=
      &lt;/example&gt;=0A=
=0A=
   * ## Range Input with ngMin &amp; ngMax attributes=0A=
=0A=
   * @example=0A=
      &lt;example name=3D"range-input-directive-ng" =
module=3D"rangeExample"&gt;=0A=
        &lt;file name=3D"index.html"&gt;=0A=
          &lt;script&gt;=0A=
            angular.module('rangeExample', [])=0A=
              .controller('ExampleController', ['$scope', =
function($scope) {=0A=
                $scope.value =3D 75;=0A=
                $scope.min =3D 10;=0A=
                $scope.max =3D 90;=0A=
              }]);=0A=
          &lt;/script&gt;=0A=
          &lt;form name=3D"myForm" =
ng-controller=3D"ExampleController"&gt;=0A=
            Model as range: &lt;input type=3D"range" name=3D"range" =
ng-model=3D"value" ng-min=3D"min" ng-max=3D"max"&gt;=0A=
            &lt;hr&gt;=0A=
            Model as number: &lt;input type=3D"number" =
ng-model=3D"value"&gt;&lt;br&gt;=0A=
            Min: &lt;input type=3D"number" ng-model=3D"min"&gt;&lt;br&gt;=0A=
            Max: &lt;input type=3D"number" ng-model=3D"max"&gt;&lt;br&gt;=0A=
            value =3D &lt;code&gt;{{value}}&lt;/code&gt;&lt;br/&gt;=0A=
            myForm.range.$valid =3D =
&lt;code&gt;{{myForm.range.$valid}}&lt;/code&gt;&lt;br/&gt;=0A=
            myForm.range.$error =3D =
&lt;code&gt;{{myForm.range.$error}}&lt;/code&gt;=0A=
          &lt;/form&gt;=0A=
        &lt;/file&gt;=0A=
      &lt;/example&gt;=0A=
=0A=
   */=0A=
  'range': rangeInputType,=0A=
=0A=
  /**=0A=
   * @ngdoc input=0A=
   * @name input[checkbox]=0A=
   *=0A=
   * @description=0A=
   * HTML checkbox.=0A=
   *=0A=
   * @param {string} ngModel Assignable angular expression to data-bind =
to.=0A=
   * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
   * @param {expression=3D} ngTrueValue The value to which the =
expression should be set when selected.=0A=
   * @param {expression=3D} ngFalseValue The value to which the =
expression should be set when not selected.=0A=
   * @param {string=3D} ngChange Angular expression to be executed when =
input changes due to user=0A=
   *    interaction with the input element.=0A=
   *=0A=
   * @example=0A=
      &lt;example name=3D"checkbox-input-directive" =
module=3D"checkboxExample"&gt;=0A=
        &lt;file name=3D"index.html"&gt;=0A=
         &lt;script&gt;=0A=
           angular.module('checkboxExample', [])=0A=
             .controller('ExampleController', ['$scope', =
function($scope) {=0A=
               $scope.checkboxModel =3D {=0A=
                value1 : true,=0A=
                value2 : 'YES'=0A=
              };=0A=
             }]);=0A=
         &lt;/script&gt;=0A=
         &lt;form name=3D"myForm" ng-controller=3D"ExampleController"&gt;=0A=
           &lt;label&gt;Value1:=0A=
             &lt;input type=3D"checkbox" =
ng-model=3D"checkboxModel.value1"&gt;=0A=
           &lt;/label&gt;&lt;br/&gt;=0A=
           &lt;label&gt;Value2:=0A=
             &lt;input type=3D"checkbox" =
ng-model=3D"checkboxModel.value2"=0A=
                    ng-true-value=3D"'YES'" ng-false-value=3D"'NO'"&gt;=0A=
            &lt;/label&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;value1 =3D =
{{checkboxModel.value1}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;value2 =3D =
{{checkboxModel.value2}}&lt;/tt&gt;&lt;br/&gt;=0A=
          &lt;/form&gt;=0A=
        &lt;/file&gt;=0A=
        &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
          it('should change state', function() {=0A=
            var value1 =3D element(by.binding('checkboxModel.value1'));=0A=
            var value2 =3D element(by.binding('checkboxModel.value2'));=0A=
=0A=
            expect(value1.getText()).toContain('true');=0A=
            expect(value2.getText()).toContain('YES');=0A=
=0A=
            element(by.model('checkboxModel.value1')).click();=0A=
            element(by.model('checkboxModel.value2')).click();=0A=
=0A=
            expect(value1.getText()).toContain('false');=0A=
            expect(value2.getText()).toContain('NO');=0A=
          });=0A=
        &lt;/file&gt;=0A=
      &lt;/example&gt;=0A=
   */=0A=
  'checkbox': checkboxInputType,=0A=
=0A=
  'hidden': noop,=0A=
  'button': noop,=0A=
  'submit': noop,=0A=
  'reset': noop,=0A=
  'file': noop=0A=
};=0A=
=0A=
function stringBasedInputType(ctrl) {=0A=
  ctrl.$formatters.push(function(value) {=0A=
    return ctrl.$isEmpty(value) ? value : value.toString();=0A=
  });=0A=
}=0A=
=0A=
function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {=0A=
  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);=0A=
  stringBasedInputType(ctrl);=0A=
}=0A=
=0A=
function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {=0A=
  var type =3D lowercase(element[0].type);=0A=
=0A=
  // In composition mode, users are still inputting intermediate text =
buffer,=0A=
  // hold the listener until composition is done.=0A=
  // More about composition events: =
https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent=0A=
  if (!$sniffer.android) {=0A=
    var composing =3D false;=0A=
=0A=
    element.on('compositionstart', function() {=0A=
      composing =3D true;=0A=
    });=0A=
=0A=
    element.on('compositionend', function() {=0A=
      composing =3D false;=0A=
      listener();=0A=
    });=0A=
  }=0A=
=0A=
  var timeout;=0A=
=0A=
  var listener =3D function(ev) {=0A=
    if (timeout) {=0A=
      $browser.defer.cancel(timeout);=0A=
      timeout =3D null;=0A=
    }=0A=
    if (composing) return;=0A=
    var value =3D element.val(),=0A=
        event =3D ev &amp;&amp; ev.type;=0A=
=0A=
    // By default we will trim the value=0A=
    // If the attribute ng-trim exists we will avoid trimming=0A=
    // If input type is 'password', the value is never trimmed=0A=
    if (type !=3D=3D 'password' &amp;&amp; (!attr.ngTrim || attr.ngTrim =
!=3D=3D 'false')) {=0A=
      value =3D trim(value);=0A=
    }=0A=
=0A=
    // If a control is suffering from bad input (due to native =
validators), browsers discard its=0A=
    // value, so it may be necessary to revalidate (by calling =
$setViewValue again) even if the=0A=
    // control's value is the same empty value twice in a row.=0A=
    if (ctrl.$viewValue !=3D=3D value || (value =3D=3D=3D '' &amp;&amp; =
ctrl.$$hasNativeValidators)) {=0A=
      ctrl.$setViewValue(value, event);=0A=
    }=0A=
  };=0A=
=0A=
  // if the browser does support "input" event, we are fine - except on =
IE9 which doesn't fire the=0A=
  // input event on backspace, delete or cut=0A=
  if ($sniffer.hasEvent('input')) {=0A=
    element.on('input', listener);=0A=
  } else {=0A=
    var deferListener =3D function(ev, input, origValue) {=0A=
      if (!timeout) {=0A=
        timeout =3D $browser.defer(function() {=0A=
          timeout =3D null;=0A=
          if (!input || input.value !=3D=3D origValue) {=0A=
            listener(ev);=0A=
          }=0A=
        });=0A=
      }=0A=
    };=0A=
=0A=
    element.on('keydown', /** @this */ function(event) {=0A=
      var key =3D event.keyCode;=0A=
=0A=
      // ignore=0A=
      //    command            modifiers                   arrows=0A=
      if (key =3D=3D=3D 91 || (15 &lt; key &amp;&amp; key &lt; 19) || =
(37 &lt;=3D key &amp;&amp; key &lt;=3D 40)) return;=0A=
=0A=
      deferListener(event, this, this.value);=0A=
    });=0A=
=0A=
    // if user modifies input value using context menu in IE, we need =
"paste" and "cut" events to catch it=0A=
    if ($sniffer.hasEvent('paste')) {=0A=
      element.on('paste cut', deferListener);=0A=
    }=0A=
  }=0A=
=0A=
  // if user paste into input using mouse on older browser=0A=
  // or form autocomplete on newer browser, we need "change" event to =
catch it=0A=
  element.on('change', listener);=0A=
=0A=
  // Some native input types (date-family) have the ability to change =
validity without=0A=
  // firing any input/change events.=0A=
  // For these event types, when native validators are present and the =
browser supports the type,=0A=
  // check for validity changes on various DOM events.=0A=
  if (PARTIAL_VALIDATION_TYPES[type] &amp;&amp; =
ctrl.$$hasNativeValidators &amp;&amp; type =3D=3D=3D attr.type) {=0A=
    element.on(PARTIAL_VALIDATION_EVENTS, /** @this */ function(ev) {=0A=
      if (!timeout) {=0A=
        var validity =3D this[VALIDITY_STATE_PROPERTY];=0A=
        var origBadInput =3D validity.badInput;=0A=
        var origTypeMismatch =3D validity.typeMismatch;=0A=
        timeout =3D $browser.defer(function() {=0A=
          timeout =3D null;=0A=
          if (validity.badInput !=3D=3D origBadInput || =
validity.typeMismatch !=3D=3D origTypeMismatch) {=0A=
            listener(ev);=0A=
          }=0A=
        });=0A=
      }=0A=
    });=0A=
  }=0A=
=0A=
  ctrl.$render =3D function() {=0A=
    // Workaround for Firefox validation #12102.=0A=
    var value =3D ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue;=0A=
    if (element.val() !=3D=3D value) {=0A=
      element.val(value);=0A=
    }=0A=
  };=0A=
}=0A=
=0A=
function weekParser(isoWeek, existingDate) {=0A=
  if (isDate(isoWeek)) {=0A=
    return isoWeek;=0A=
  }=0A=
=0A=
  if (isString(isoWeek)) {=0A=
    WEEK_REGEXP.lastIndex =3D 0;=0A=
    var parts =3D WEEK_REGEXP.exec(isoWeek);=0A=
    if (parts) {=0A=
      var year =3D +parts[1],=0A=
          week =3D +parts[2],=0A=
          hours =3D 0,=0A=
          minutes =3D 0,=0A=
          seconds =3D 0,=0A=
          milliseconds =3D 0,=0A=
          firstThurs =3D getFirstThursdayOfYear(year),=0A=
          addDays =3D (week - 1) * 7;=0A=
=0A=
      if (existingDate) {=0A=
        hours =3D existingDate.getHours();=0A=
        minutes =3D existingDate.getMinutes();=0A=
        seconds =3D existingDate.getSeconds();=0A=
        milliseconds =3D existingDate.getMilliseconds();=0A=
      }=0A=
=0A=
      return new Date(year, 0, firstThurs.getDate() + addDays, hours, =
minutes, seconds, milliseconds);=0A=
    }=0A=
  }=0A=
=0A=
  return NaN;=0A=
}=0A=
=0A=
function createDateParser(regexp, mapping) {=0A=
  return function(iso, date) {=0A=
    var parts, map;=0A=
=0A=
    if (isDate(iso)) {=0A=
      return iso;=0A=
    }=0A=
=0A=
    if (isString(iso)) {=0A=
      // When a date is JSON'ified to wraps itself inside of an extra=0A=
      // set of double quotes. This makes the date parsing code unable=0A=
      // to match the date string and parse it as a date.=0A=
      if (iso.charAt(0) =3D=3D=3D '"' &amp;&amp; iso.charAt(iso.length - =
1) =3D=3D=3D '"') {=0A=
        iso =3D iso.substring(1, iso.length - 1);=0A=
      }=0A=
      if (ISO_DATE_REGEXP.test(iso)) {=0A=
        return new Date(iso);=0A=
      }=0A=
      regexp.lastIndex =3D 0;=0A=
      parts =3D regexp.exec(iso);=0A=
=0A=
      if (parts) {=0A=
        parts.shift();=0A=
        if (date) {=0A=
          map =3D {=0A=
            yyyy: date.getFullYear(),=0A=
            MM: date.getMonth() + 1,=0A=
            dd: date.getDate(),=0A=
            HH: date.getHours(),=0A=
            mm: date.getMinutes(),=0A=
            ss: date.getSeconds(),=0A=
            sss: date.getMilliseconds() / 1000=0A=
          };=0A=
        } else {=0A=
          map =3D { yyyy: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: =
0 };=0A=
        }=0A=
=0A=
        forEach(parts, function(part, index) {=0A=
          if (index &lt; mapping.length) {=0A=
            map[mapping[index]] =3D +part;=0A=
          }=0A=
        });=0A=
        return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, =
map.ss || 0, map.sss * 1000 || 0);=0A=
      }=0A=
    }=0A=
=0A=
    return NaN;=0A=
  };=0A=
}=0A=
=0A=
function createDateInputType(type, regexp, parseDate, format) {=0A=
  return function dynamicDateInputType(scope, element, attr, ctrl, =
$sniffer, $browser, $filter) {=0A=
    badInputChecker(scope, element, attr, ctrl);=0A=
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);=0A=
    var timezone =3D ctrl &amp;&amp; ctrl.$options.getOption('timezone');=0A=
    var previousDate;=0A=
=0A=
    ctrl.$$parserName =3D type;=0A=
    ctrl.$parsers.push(function(value) {=0A=
      if (ctrl.$isEmpty(value)) return null;=0A=
      if (regexp.test(value)) {=0A=
        // Note: We cannot read ctrl.$modelValue, as there might be a =
different=0A=
        // parser/formatter in the processing chain so that the model=0A=
        // contains some different data format!=0A=
        var parsedDate =3D parseDate(value, previousDate);=0A=
        if (timezone) {=0A=
          parsedDate =3D convertTimezoneToLocal(parsedDate, timezone);=0A=
        }=0A=
        return parsedDate;=0A=
      }=0A=
      return undefined;=0A=
    });=0A=
=0A=
    ctrl.$formatters.push(function(value) {=0A=
      if (value &amp;&amp; !isDate(value)) {=0A=
        throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', =
value);=0A=
      }=0A=
      if (isValidDate(value)) {=0A=
        previousDate =3D value;=0A=
        if (previousDate &amp;&amp; timezone) {=0A=
          previousDate =3D convertTimezoneToLocal(previousDate, =
timezone, true);=0A=
        }=0A=
        return $filter('date')(value, format, timezone);=0A=
      } else {=0A=
        previousDate =3D null;=0A=
        return '';=0A=
      }=0A=
    });=0A=
=0A=
    if (isDefined(attr.min) || attr.ngMin) {=0A=
      var minVal;=0A=
      ctrl.$validators.min =3D function(value) {=0A=
        return !isValidDate(value) || isUndefined(minVal) || =
parseDate(value) &gt;=3D minVal;=0A=
      };=0A=
      attr.$observe('min', function(val) {=0A=
        minVal =3D parseObservedDateValue(val);=0A=
        ctrl.$validate();=0A=
      });=0A=
    }=0A=
=0A=
    if (isDefined(attr.max) || attr.ngMax) {=0A=
      var maxVal;=0A=
      ctrl.$validators.max =3D function(value) {=0A=
        return !isValidDate(value) || isUndefined(maxVal) || =
parseDate(value) &lt;=3D maxVal;=0A=
      };=0A=
      attr.$observe('max', function(val) {=0A=
        maxVal =3D parseObservedDateValue(val);=0A=
        ctrl.$validate();=0A=
      });=0A=
    }=0A=
=0A=
    function isValidDate(value) {=0A=
      // Invalid Date: getTime() returns NaN=0A=
      return value &amp;&amp; !(value.getTime &amp;&amp; value.getTime() =
!=3D=3D value.getTime());=0A=
    }=0A=
=0A=
    function parseObservedDateValue(val) {=0A=
      return isDefined(val) &amp;&amp; !isDate(val) ? parseDate(val) || =
undefined : val;=0A=
    }=0A=
  };=0A=
}=0A=
=0A=
function badInputChecker(scope, element, attr, ctrl) {=0A=
  var node =3D element[0];=0A=
  var nativeValidation =3D ctrl.$$hasNativeValidators =3D =
isObject(node.validity);=0A=
  if (nativeValidation) {=0A=
    ctrl.$parsers.push(function(value) {=0A=
      var validity =3D element.prop(VALIDITY_STATE_PROPERTY) || {};=0A=
      return validity.badInput || validity.typeMismatch ? undefined : =
value;=0A=
    });=0A=
  }=0A=
}=0A=
=0A=
function numberFormatterParser(ctrl) {=0A=
  ctrl.$$parserName =3D 'number';=0A=
  ctrl.$parsers.push(function(value) {=0A=
    if (ctrl.$isEmpty(value))      return null;=0A=
    if (NUMBER_REGEXP.test(value)) return parseFloat(value);=0A=
    return undefined;=0A=
  });=0A=
=0A=
  ctrl.$formatters.push(function(value) {=0A=
    if (!ctrl.$isEmpty(value)) {=0A=
      if (!isNumber(value)) {=0A=
        throw ngModelMinErr('numfmt', 'Expected `{0}` to be a number', =
value);=0A=
      }=0A=
      value =3D value.toString();=0A=
    }=0A=
    return value;=0A=
  });=0A=
}=0A=
=0A=
function parseNumberAttrVal(val) {=0A=
  if (isDefined(val) &amp;&amp; !isNumber(val)) {=0A=
    val =3D parseFloat(val);=0A=
  }=0A=
  return !isNumberNaN(val) ? val : undefined;=0A=
}=0A=
=0A=
function isNumberInteger(num) {=0A=
  // See =
http://stackoverflow.com/questions/14636536/how-to-check-if-a-variable-is=
-an-integer-in-javascript#14794066=0A=
  // (minus the assumption that `num` is a number)=0A=
=0A=
  // eslint-disable-next-line no-bitwise=0A=
  return (num | 0) =3D=3D=3D num;=0A=
}=0A=
=0A=
function countDecimals(num) {=0A=
  var numString =3D num.toString();=0A=
  var decimalSymbolIndex =3D numString.indexOf('.');=0A=
=0A=
  if (decimalSymbolIndex =3D=3D=3D -1) {=0A=
    if (-1 &lt; num &amp;&amp; num &lt; 1) {=0A=
      // It may be in the exponential notation format (`1e-X`)=0A=
      var match =3D /e-(\d+)$/.exec(numString);=0A=
=0A=
      if (match) {=0A=
        return Number(match[1]);=0A=
      }=0A=
    }=0A=
=0A=
    return 0;=0A=
  }=0A=
=0A=
  return numString.length - decimalSymbolIndex - 1;=0A=
}=0A=
=0A=
function isValidForStep(viewValue, stepBase, step) {=0A=
  // At this point `stepBase` and `step` are expected to be non-NaN =
values=0A=
  // and `viewValue` is expected to be a valid stringified number.=0A=
  var value =3D Number(viewValue);=0A=
=0A=
  var isNonIntegerValue =3D !isNumberInteger(value);=0A=
  var isNonIntegerStepBase =3D !isNumberInteger(stepBase);=0A=
  var isNonIntegerStep =3D !isNumberInteger(step);=0A=
=0A=
  // Due to limitations in Floating Point Arithmetic (e.g. `0.3 - 0.2 =
!=3D=3D 0.1` or=0A=
  // `0.5 % 0.1 !=3D=3D 0`), we need to convert all numbers to integers.=0A=
  if (isNonIntegerValue || isNonIntegerStepBase || isNonIntegerStep) {=0A=
    var valueDecimals =3D isNonIntegerValue ? countDecimals(value) : 0;=0A=
    var stepBaseDecimals =3D isNonIntegerStepBase ? =
countDecimals(stepBase) : 0;=0A=
    var stepDecimals =3D isNonIntegerStep ? countDecimals(step) : 0;=0A=
=0A=
    var decimalCount =3D Math.max(valueDecimals, stepBaseDecimals, =
stepDecimals);=0A=
    var multiplier =3D Math.pow(10, decimalCount);=0A=
=0A=
    value =3D value * multiplier;=0A=
    stepBase =3D stepBase * multiplier;=0A=
    step =3D step * multiplier;=0A=
=0A=
    if (isNonIntegerValue) value =3D Math.round(value);=0A=
    if (isNonIntegerStepBase) stepBase =3D Math.round(stepBase);=0A=
    if (isNonIntegerStep) step =3D Math.round(step);=0A=
  }=0A=
=0A=
  return (value - stepBase) % step =3D=3D=3D 0;=0A=
}=0A=
=0A=
function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) =
{=0A=
  badInputChecker(scope, element, attr, ctrl);=0A=
  numberFormatterParser(ctrl);=0A=
  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);=0A=
=0A=
  var minVal;=0A=
  var maxVal;=0A=
=0A=
  if (isDefined(attr.min) || attr.ngMin) {=0A=
    ctrl.$validators.min =3D function(value) {=0A=
      return ctrl.$isEmpty(value) || isUndefined(minVal) || value =
&gt;=3D minVal;=0A=
    };=0A=
=0A=
    attr.$observe('min', function(val) {=0A=
      minVal =3D parseNumberAttrVal(val);=0A=
      // TODO(matsko): implement validateLater to reduce number of =
validations=0A=
      ctrl.$validate();=0A=
    });=0A=
  }=0A=
=0A=
  if (isDefined(attr.max) || attr.ngMax) {=0A=
    ctrl.$validators.max =3D function(value) {=0A=
      return ctrl.$isEmpty(value) || isUndefined(maxVal) || value =
&lt;=3D maxVal;=0A=
    };=0A=
=0A=
    attr.$observe('max', function(val) {=0A=
      maxVal =3D parseNumberAttrVal(val);=0A=
      // TODO(matsko): implement validateLater to reduce number of =
validations=0A=
      ctrl.$validate();=0A=
    });=0A=
  }=0A=
=0A=
  if (isDefined(attr.step) || attr.ngStep) {=0A=
    var stepVal;=0A=
    ctrl.$validators.step =3D function(modelValue, viewValue) {=0A=
      return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) ||=0A=
             isValidForStep(viewValue, minVal || 0, stepVal);=0A=
    };=0A=
=0A=
    attr.$observe('step', function(val) {=0A=
      stepVal =3D parseNumberAttrVal(val);=0A=
      // TODO(matsko): implement validateLater to reduce number of =
validations=0A=
      ctrl.$validate();=0A=
    });=0A=
  }=0A=
}=0A=
=0A=
function rangeInputType(scope, element, attr, ctrl, $sniffer, $browser) {=0A=
  badInputChecker(scope, element, attr, ctrl);=0A=
  numberFormatterParser(ctrl);=0A=
  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);=0A=
=0A=
  var supportsRange =3D ctrl.$$hasNativeValidators &amp;&amp; =
element[0].type =3D=3D=3D 'range',=0A=
      minVal =3D supportsRange ? 0 : undefined,=0A=
      maxVal =3D supportsRange ? 100 : undefined,=0A=
      stepVal =3D supportsRange ? 1 : undefined,=0A=
      validity =3D element[0].validity,=0A=
      hasMinAttr =3D isDefined(attr.min),=0A=
      hasMaxAttr =3D isDefined(attr.max),=0A=
      hasStepAttr =3D isDefined(attr.step);=0A=
=0A=
  var originalRender =3D ctrl.$render;=0A=
=0A=
  ctrl.$render =3D supportsRange &amp;&amp; =
isDefined(validity.rangeUnderflow) &amp;&amp; =
isDefined(validity.rangeOverflow) ?=0A=
    //Browsers that implement range will set these values automatically, =
but reading the adjusted values after=0A=
    //$render would cause the min / max validators to be applied with =
the wrong value=0A=
    function rangeRender() {=0A=
      originalRender();=0A=
      ctrl.$setViewValue(element.val());=0A=
    } :=0A=
    originalRender;=0A=
=0A=
  if (hasMinAttr) {=0A=
    ctrl.$validators.min =3D supportsRange ?=0A=
      // Since all browsers set the input to a valid value, we don't =
need to check validity=0A=
      function noopMinValidator() { return true; } :=0A=
      // non-support browsers validate the min val=0A=
      function minValidator(modelValue, viewValue) {=0A=
        return ctrl.$isEmpty(viewValue) || isUndefined(minVal) || =
viewValue &gt;=3D minVal;=0A=
      };=0A=
=0A=
    setInitialValueAndObserver('min', minChange);=0A=
  }=0A=
=0A=
  if (hasMaxAttr) {=0A=
    ctrl.$validators.max =3D supportsRange ?=0A=
      // Since all browsers set the input to a valid value, we don't =
need to check validity=0A=
      function noopMaxValidator() { return true; } :=0A=
      // non-support browsers validate the max val=0A=
      function maxValidator(modelValue, viewValue) {=0A=
        return ctrl.$isEmpty(viewValue) || isUndefined(maxVal) || =
viewValue &lt;=3D maxVal;=0A=
      };=0A=
=0A=
    setInitialValueAndObserver('max', maxChange);=0A=
  }=0A=
=0A=
  if (hasStepAttr) {=0A=
    ctrl.$validators.step =3D supportsRange ?=0A=
      function nativeStepValidator() {=0A=
        // Currently, only FF implements the spec on step change =
correctly (i.e. adjusting the=0A=
        // input element value to a valid value). It's possible that =
other browsers set the stepMismatch=0A=
        // validity error instead, so we can at least report an error in =
that case.=0A=
        return !validity.stepMismatch;=0A=
      } :=0A=
      // ngStep doesn't set the setp attr, so the browser doesn't adjust =
the input value as setting step would=0A=
      function stepValidator(modelValue, viewValue) {=0A=
        return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) ||=0A=
               isValidForStep(viewValue, minVal || 0, stepVal);=0A=
      };=0A=
=0A=
    setInitialValueAndObserver('step', stepChange);=0A=
  }=0A=
=0A=
  function setInitialValueAndObserver(htmlAttrName, changeFn) {=0A=
    // interpolated attributes set the attribute value only after a =
digest, but we need the=0A=
    // attribute value when the input is first rendered, so that the =
browser can adjust the=0A=
    // input value based on the min/max value=0A=
    element.attr(htmlAttrName, attr[htmlAttrName]);=0A=
    attr.$observe(htmlAttrName, changeFn);=0A=
  }=0A=
=0A=
  function minChange(val) {=0A=
    minVal =3D parseNumberAttrVal(val);=0A=
    // ignore changes before model is initialized=0A=
    if (isNumberNaN(ctrl.$modelValue)) {=0A=
      return;=0A=
    }=0A=
=0A=
    if (supportsRange) {=0A=
      var elVal =3D element.val();=0A=
      // IE11 doesn't set the el val correctly if the minVal is greater =
than the element value=0A=
      if (minVal &gt; elVal) {=0A=
        elVal =3D minVal;=0A=
        element.val(elVal);=0A=
      }=0A=
      ctrl.$setViewValue(elVal);=0A=
    } else {=0A=
      // TODO(matsko): implement validateLater to reduce number of =
validations=0A=
      ctrl.$validate();=0A=
    }=0A=
  }=0A=
=0A=
  function maxChange(val) {=0A=
    maxVal =3D parseNumberAttrVal(val);=0A=
    // ignore changes before model is initialized=0A=
    if (isNumberNaN(ctrl.$modelValue)) {=0A=
      return;=0A=
    }=0A=
=0A=
    if (supportsRange) {=0A=
      var elVal =3D element.val();=0A=
      // IE11 doesn't set the el val correctly if the maxVal is less =
than the element value=0A=
      if (maxVal &lt; elVal) {=0A=
        element.val(maxVal);=0A=
        // IE11 and Chrome don't set the value to the minVal when max =
&lt; min=0A=
        elVal =3D maxVal &lt; minVal ? minVal : maxVal;=0A=
      }=0A=
      ctrl.$setViewValue(elVal);=0A=
    } else {=0A=
      // TODO(matsko): implement validateLater to reduce number of =
validations=0A=
      ctrl.$validate();=0A=
    }=0A=
  }=0A=
=0A=
  function stepChange(val) {=0A=
    stepVal =3D parseNumberAttrVal(val);=0A=
    // ignore changes before model is initialized=0A=
    if (isNumberNaN(ctrl.$modelValue)) {=0A=
      return;=0A=
    }=0A=
=0A=
    // Some browsers don't adjust the input value correctly, but set the =
stepMismatch error=0A=
    if (supportsRange &amp;&amp; ctrl.$viewValue !=3D=3D element.val()) {=0A=
      ctrl.$setViewValue(element.val());=0A=
    } else {=0A=
      // TODO(matsko): implement validateLater to reduce number of =
validations=0A=
      ctrl.$validate();=0A=
    }=0A=
  }=0A=
}=0A=
=0A=
function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {=0A=
  // Note: no badInputChecker here by purpose as `url` is only a =
validation=0A=
  // in browsers, i.e. we can always read out input.value even if it is =
not valid!=0A=
  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);=0A=
  stringBasedInputType(ctrl);=0A=
=0A=
  ctrl.$$parserName =3D 'url';=0A=
  ctrl.$validators.url =3D function(modelValue, viewValue) {=0A=
    var value =3D modelValue || viewValue;=0A=
    return ctrl.$isEmpty(value) || URL_REGEXP.test(value);=0A=
  };=0A=
}=0A=
=0A=
function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {=0A=
  // Note: no badInputChecker here by purpose as `url` is only a =
validation=0A=
  // in browsers, i.e. we can always read out input.value even if it is =
not valid!=0A=
  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);=0A=
  stringBasedInputType(ctrl);=0A=
=0A=
  ctrl.$$parserName =3D 'email';=0A=
  ctrl.$validators.email =3D function(modelValue, viewValue) {=0A=
    var value =3D modelValue || viewValue;=0A=
    return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);=0A=
  };=0A=
}=0A=
=0A=
function radioInputType(scope, element, attr, ctrl) {=0A=
  var doTrim =3D !attr.ngTrim || trim(attr.ngTrim) !=3D=3D 'false';=0A=
  // make the name unique, if not defined=0A=
  if (isUndefined(attr.name)) {=0A=
    element.attr('name', nextUid());=0A=
  }=0A=
=0A=
  var listener =3D function(ev) {=0A=
    var value;=0A=
    if (element[0].checked) {=0A=
      value =3D attr.value;=0A=
      if (doTrim) {=0A=
        value =3D trim(value);=0A=
      }=0A=
      ctrl.$setViewValue(value, ev &amp;&amp; ev.type);=0A=
    }=0A=
  };=0A=
=0A=
  element.on('click', listener);=0A=
=0A=
  ctrl.$render =3D function() {=0A=
    var value =3D attr.value;=0A=
    if (doTrim) {=0A=
      value =3D trim(value);=0A=
    }=0A=
    element[0].checked =3D (value =3D=3D=3D ctrl.$viewValue);=0A=
  };=0A=
=0A=
  attr.$observe('value', ctrl.$render);=0A=
}=0A=
=0A=
function parseConstantExpr($parse, context, name, expression, fallback) {=0A=
  var parseFn;=0A=
  if (isDefined(expression)) {=0A=
    parseFn =3D $parse(expression);=0A=
    if (!parseFn.constant) {=0A=
      throw ngModelMinErr('constexpr', 'Expected constant expression for =
`{0}`, but saw ' +=0A=
                                   '`{1}`.', name, expression);=0A=
    }=0A=
    return parseFn(context);=0A=
  }=0A=
  return fallback;=0A=
}=0A=
=0A=
function checkboxInputType(scope, element, attr, ctrl, $sniffer, =
$browser, $filter, $parse) {=0A=
  var trueValue =3D parseConstantExpr($parse, scope, 'ngTrueValue', =
attr.ngTrueValue, true);=0A=
  var falseValue =3D parseConstantExpr($parse, scope, 'ngFalseValue', =
attr.ngFalseValue, false);=0A=
=0A=
  var listener =3D function(ev) {=0A=
    ctrl.$setViewValue(element[0].checked, ev &amp;&amp; ev.type);=0A=
  };=0A=
=0A=
  element.on('click', listener);=0A=
=0A=
  ctrl.$render =3D function() {=0A=
    element[0].checked =3D ctrl.$viewValue;=0A=
  };=0A=
=0A=
  // Override the standard `$isEmpty` because the $viewValue of an empty =
checkbox is always set to `false`=0A=
  // This is because of the parser below, which compares the =
`$modelValue` with `trueValue` to convert=0A=
  // it to a boolean.=0A=
  ctrl.$isEmpty =3D function(value) {=0A=
    return value =3D=3D=3D false;=0A=
  };=0A=
=0A=
  ctrl.$formatters.push(function(value) {=0A=
    return equals(value, trueValue);=0A=
  });=0A=
=0A=
  ctrl.$parsers.push(function(value) {=0A=
    return value ? trueValue : falseValue;=0A=
  });=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name textarea=0A=
 * @restrict E=0A=
 *=0A=
 * @description=0A=
 * HTML textarea element control with angular data-binding. The =
data-binding and validation=0A=
 * properties of this element are exactly the same as those of the=0A=
 * {@link ng.directive:input input element}.=0A=
 *=0A=
 * @param {string} ngModel Assignable angular expression to data-bind to.=0A=
 * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
 * @param {string=3D} required Sets `required` validation error key if =
the value is not entered.=0A=
 * @param {string=3D} ngRequired Adds `required` attribute and =
`required` validation constraint to=0A=
 *    the element when the ngRequired expression evaluates to true. Use =
`ngRequired` instead of=0A=
 *    `required` when you want to data-bind to the `required` attribute.=0A=
 * @param {number=3D} ngMinlength Sets `minlength` validation error key =
if the value is shorter than=0A=
 *    minlength.=0A=
 * @param {number=3D} ngMaxlength Sets `maxlength` validation error key =
if the value is longer than=0A=
 *    maxlength. Setting the attribute to a negative or non-numeric =
value, allows view values of any=0A=
 *    length.=0A=
 * @param {string=3D} ngPattern Sets `pattern` validation error key if =
the ngModel {@link ngModel.NgModelController#$viewValue $viewValue}=0A=
 *    does not match a RegExp found by evaluating the Angular expression =
given in the attribute value.=0A=
 *    If the expression evaluates to a RegExp object, then this is used =
directly.=0A=
 *    If the expression evaluates to a string, then it will be converted =
to a RegExp=0A=
 *    after wrapping it in `^` and `$` characters. For instance, `"abc"` =
will be converted to=0A=
 *    `new RegExp('^abc$')`.&lt;br /&gt;=0A=
 *    **Note:** Avoid using the `g` flag on the RegExp, as it will cause =
each successive search to=0A=
 *    start at the index of the last search's match, thus not taking the =
whole input value into=0A=
 *    account.=0A=
 * @param {string=3D} ngChange Angular expression to be executed when =
input changes due to user=0A=
 *    interaction with the input element.=0A=
 * @param {boolean=3D} [ngTrim=3Dtrue] If set to false Angular will not =
automatically trim the input.=0A=
 *=0A=
 * @knownIssue=0A=
 *=0A=
 * When specifying the `placeholder` attribute of `&lt;textarea&gt;`, =
Internet Explorer will temporarily=0A=
 * insert the placeholder value as the textarea's content. If the =
placeholder value contains=0A=
 * interpolation (`{{ ... }}`), an error will be logged in the console =
when Angular tries to update=0A=
 * the value of the by-then-removed text node. This doesn't affect the =
functionality of the=0A=
 * textarea, but can be undesirable.=0A=
 *=0A=
 * You can work around this Internet Explorer issue by using =
`ng-attr-placeholder` instead of=0A=
 * `placeholder` on textareas, whenever you need interpolation in the =
placeholder value. You can=0A=
 * find more details on `ngAttr` in the=0A=
 * =
[Interpolation](guide/interpolation#-ngattr-for-binding-to-arbitrary-attr=
ibutes) section of the=0A=
 * Developer Guide.=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name input=0A=
 * @restrict E=0A=
 *=0A=
 * @description=0A=
 * HTML input element control. When used together with {@link ngModel =
`ngModel`}, it provides data-binding,=0A=
 * input state control, and validation.=0A=
 * Input control follows HTML5 input types and polyfills the HTML5 =
validation behavior for older browsers.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * **Note:** Not every feature offered is available for all input types.=0A=
 * Specifically, data binding and event handling via `ng-model` is =
unsupported for `input[file]`.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * @param {string} ngModel Assignable angular expression to data-bind to.=0A=
 * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
 * @param {string=3D} required Sets `required` validation error key if =
the value is not entered.=0A=
 * @param {boolean=3D} ngRequired Sets `required` attribute if set to =
true=0A=
 * @param {number=3D} ngMinlength Sets `minlength` validation error key =
if the value is shorter than=0A=
 *    minlength.=0A=
 * @param {number=3D} ngMaxlength Sets `maxlength` validation error key =
if the value is longer than=0A=
 *    maxlength. Setting the attribute to a negative or non-numeric =
value, allows view values of any=0A=
 *    length.=0A=
 * @param {string=3D} ngPattern Sets `pattern` validation error key if =
the ngModel {@link ngModel.NgModelController#$viewValue $viewValue}=0A=
 *    value does not match a RegExp found by evaluating the Angular =
expression given in the attribute value.=0A=
 *    If the expression evaluates to a RegExp object, then this is used =
directly.=0A=
 *    If the expression evaluates to a string, then it will be converted =
to a RegExp=0A=
 *    after wrapping it in `^` and `$` characters. For instance, `"abc"` =
will be converted to=0A=
 *    `new RegExp('^abc$')`.&lt;br /&gt;=0A=
 *    **Note:** Avoid using the `g` flag on the RegExp, as it will cause =
each successive search to=0A=
 *    start at the index of the last search's match, thus not taking the =
whole input value into=0A=
 *    account.=0A=
 * @param {string=3D} ngChange Angular expression to be executed when =
input changes due to user=0A=
 *    interaction with the input element.=0A=
 * @param {boolean=3D} [ngTrim=3Dtrue] If set to false Angular will not =
automatically trim the input.=0A=
 *    This parameter is ignored for input[type=3Dpassword] controls, =
which will never trim the=0A=
 *    input.=0A=
 *=0A=
 * @example=0A=
    &lt;example name=3D"input-directive" module=3D"inputExample"&gt;=0A=
      &lt;file name=3D"index.html"&gt;=0A=
       &lt;script&gt;=0A=
          angular.module('inputExample', [])=0A=
            .controller('ExampleController', ['$scope', function($scope) =
{=0A=
              $scope.user =3D {name: 'guest', last: 'visitor'};=0A=
            }]);=0A=
       &lt;/script&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
         &lt;form name=3D"myForm"&gt;=0A=
           &lt;label&gt;=0A=
              User name:=0A=
              &lt;input type=3D"text" name=3D"userName" =
ng-model=3D"user.name" required&gt;=0A=
           &lt;/label&gt;=0A=
           &lt;div role=3D"alert"&gt;=0A=
             &lt;span class=3D"error" =
ng-show=3D"myForm.userName.$error.required"&gt;=0A=
              Required!&lt;/span&gt;=0A=
           &lt;/div&gt;=0A=
           &lt;label&gt;=0A=
              Last name:=0A=
              &lt;input type=3D"text" name=3D"lastName" =
ng-model=3D"user.last"=0A=
              ng-minlength=3D"3" ng-maxlength=3D"10"&gt;=0A=
           &lt;/label&gt;=0A=
           &lt;div role=3D"alert"&gt;=0A=
             &lt;span class=3D"error" =
ng-show=3D"myForm.lastName.$error.minlength"&gt;=0A=
               Too short!&lt;/span&gt;=0A=
             &lt;span class=3D"error" =
ng-show=3D"myForm.lastName.$error.maxlength"&gt;=0A=
               Too long!&lt;/span&gt;=0A=
           &lt;/div&gt;=0A=
         &lt;/form&gt;=0A=
         &lt;hr&gt;=0A=
         &lt;tt&gt;user =3D {{user}}&lt;/tt&gt;&lt;br/&gt;=0A=
         &lt;tt&gt;myForm.userName.$valid =3D =
{{myForm.userName.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
         &lt;tt&gt;myForm.userName.$error =3D =
{{myForm.userName.$error}}&lt;/tt&gt;&lt;br/&gt;=0A=
         &lt;tt&gt;myForm.lastName.$valid =3D =
{{myForm.lastName.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
         &lt;tt&gt;myForm.lastName.$error =3D =
{{myForm.lastName.$error}}&lt;/tt&gt;&lt;br/&gt;=0A=
         &lt;tt&gt;myForm.$valid =3D =
{{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
         &lt;tt&gt;myForm.$error.required =3D =
{{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;=0A=
         &lt;tt&gt;myForm.$error.minlength =3D =
{{!!myForm.$error.minlength}}&lt;/tt&gt;&lt;br/&gt;=0A=
         &lt;tt&gt;myForm.$error.maxlength =3D =
{{!!myForm.$error.maxlength}}&lt;/tt&gt;&lt;br/&gt;=0A=
       &lt;/div&gt;=0A=
      &lt;/file&gt;=0A=
      &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
        var user =3D element(by.exactBinding('user'));=0A=
        var userNameValid =3D =
element(by.binding('myForm.userName.$valid'));=0A=
        var lastNameValid =3D =
element(by.binding('myForm.lastName.$valid'));=0A=
        var lastNameError =3D =
element(by.binding('myForm.lastName.$error'));=0A=
        var formValid =3D element(by.binding('myForm.$valid'));=0A=
        var userNameInput =3D element(by.model('user.name'));=0A=
        var userLastInput =3D element(by.model('user.last'));=0A=
=0A=
        it('should initialize to model', function() {=0A=
          =
expect(user.getText()).toContain('{"name":"guest","last":"visitor"}');=0A=
          expect(userNameValid.getText()).toContain('true');=0A=
          expect(formValid.getText()).toContain('true');=0A=
        });=0A=
=0A=
        it('should be invalid if empty when required', function() {=0A=
          userNameInput.clear();=0A=
          userNameInput.sendKeys('');=0A=
=0A=
          expect(user.getText()).toContain('{"last":"visitor"}');=0A=
          expect(userNameValid.getText()).toContain('false');=0A=
          expect(formValid.getText()).toContain('false');=0A=
        });=0A=
=0A=
        it('should be valid if empty when min length is set', function() =
{=0A=
          userLastInput.clear();=0A=
          userLastInput.sendKeys('');=0A=
=0A=
          expect(user.getText()).toContain('{"name":"guest","last":""}');=0A=
          expect(lastNameValid.getText()).toContain('true');=0A=
          expect(formValid.getText()).toContain('true');=0A=
        });=0A=
=0A=
        it('should be invalid if less than required min length', =
function() {=0A=
          userLastInput.clear();=0A=
          userLastInput.sendKeys('xx');=0A=
=0A=
          expect(user.getText()).toContain('{"name":"guest"}');=0A=
          expect(lastNameValid.getText()).toContain('false');=0A=
          expect(lastNameError.getText()).toContain('minlength');=0A=
          expect(formValid.getText()).toContain('false');=0A=
        });=0A=
=0A=
        it('should be invalid if longer than max length', function() {=0A=
          userLastInput.clear();=0A=
          userLastInput.sendKeys('some ridiculously long name');=0A=
=0A=
          expect(user.getText()).toContain('{"name":"guest"}');=0A=
          expect(lastNameValid.getText()).toContain('false');=0A=
          expect(lastNameError.getText()).toContain('maxlength');=0A=
          expect(formValid.getText()).toContain('false');=0A=
        });=0A=
      &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
 */=0A=
var inputDirective =3D ['$browser', '$sniffer', '$filter', '$parse',=0A=
    function($browser, $sniffer, $filter, $parse) {=0A=
  return {=0A=
    restrict: 'E',=0A=
    require: ['?ngModel'],=0A=
    link: {=0A=
      pre: function(scope, element, attr, ctrls) {=0A=
        if (ctrls[0]) {=0A=
          (inputType[lowercase(attr.type)] || inputType.text)(scope, =
element, attr, ctrls[0], $sniffer,=0A=
                                                              $browser, =
$filter, $parse);=0A=
        }=0A=
      }=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
=0A=
=0A=
var CONSTANT_VALUE_REGEXP =3D /^(true|false|\d+)$/;=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngValue=0A=
 *=0A=
 * @description=0A=
 * Binds the given expression to the value of the element.=0A=
 *=0A=
 * It is mainly used on {@link input[radio] `input[radio]`} and option =
elements,=0A=
 * so that when the element is selected, the {@link ngModel `ngModel`} =
of that element (or its=0A=
 * {@link select `select`} parent element) is set to the bound value. It =
is especially useful=0A=
 * for dynamically generated lists using {@link ngRepeat `ngRepeat`}, as =
shown below.=0A=
 *=0A=
 * It can also be used to achieve one-way binding of a given expression =
to an input element=0A=
 * such as an `input[text]` or a `textarea`, when that element does not =
use ngModel.=0A=
 *=0A=
 * @element input=0A=
 * @param {string=3D} ngValue angular expression, whose value will be =
bound to the `value` attribute=0A=
 * and `value` property of the element.=0A=
 *=0A=
 * @example=0A=
    &lt;example name=3D"ngValue-directive" module=3D"valueExample"&gt;=0A=
      &lt;file name=3D"index.html"&gt;=0A=
       &lt;script&gt;=0A=
          angular.module('valueExample', [])=0A=
            .controller('ExampleController', ['$scope', function($scope) =
{=0A=
              $scope.names =3D ['pizza', 'unicorns', 'robots'];=0A=
              $scope.my =3D { favorite: 'unicorns' };=0A=
            }]);=0A=
       &lt;/script&gt;=0A=
        &lt;form ng-controller=3D"ExampleController"&gt;=0A=
          &lt;h2&gt;Which is your favorite?&lt;/h2&gt;=0A=
            &lt;label ng-repeat=3D"name in names" for=3D"{{name}}"&gt;=0A=
              {{name}}=0A=
              &lt;input type=3D"radio"=0A=
                     ng-model=3D"my.favorite"=0A=
                     ng-value=3D"name"=0A=
                     id=3D"{{name}}"=0A=
                     name=3D"favorite"&gt;=0A=
            &lt;/label&gt;=0A=
          &lt;div&gt;You chose {{my.favorite}}&lt;/div&gt;=0A=
        &lt;/form&gt;=0A=
      &lt;/file&gt;=0A=
      &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
        var favorite =3D element(by.binding('my.favorite'));=0A=
=0A=
        it('should initialize to model', function() {=0A=
          expect(favorite.getText()).toContain('unicorns');=0A=
        });=0A=
        it('should bind the values to the inputs', function() {=0A=
          element.all(by.model('my.favorite')).get(0).click();=0A=
          expect(favorite.getText()).toContain('pizza');=0A=
        });=0A=
      &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
 */=0A=
var ngValueDirective =3D function() {=0A=
  /**=0A=
   *  inputs use the value attribute as their default value if the value =
property is not set.=0A=
   *  Once the value property has been set (by adding input), it will =
not react to changes to=0A=
   *  the value attribute anymore. Setting both attribute and property =
fixes this behavior, and=0A=
   *  makes it possible to use ngValue as a sort of one-way bind.=0A=
   */=0A=
  function updateElementValue(element, attr, value) {=0A=
    // Support: IE9 only=0A=
    // In IE9 values are converted to string (e.g. `input.value =3D =
null` results in `input.value =3D=3D=3D 'null'`).=0A=
    var propValue =3D isDefined(value) ? value : (msie =3D=3D=3D 9) ? '' =
: null;=0A=
    element.prop('value', propValue);=0A=
    attr.$set('value', value);=0A=
  }=0A=
=0A=
  return {=0A=
    restrict: 'A',=0A=
    priority: 100,=0A=
    compile: function(tpl, tplAttr) {=0A=
      if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {=0A=
        return function ngValueConstantLink(scope, elm, attr) {=0A=
          var value =3D scope.$eval(attr.ngValue);=0A=
          updateElementValue(elm, attr, value);=0A=
        };=0A=
      } else {=0A=
        return function ngValueLink(scope, elm, attr) {=0A=
          scope.$watch(attr.ngValue, function valueWatchAction(value) {=0A=
            updateElementValue(elm, attr, value);=0A=
          });=0A=
        };=0A=
      }=0A=
    }=0A=
  };=0A=
};=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngBind=0A=
 * @restrict AC=0A=
 *=0A=
 * @description=0A=
 * The `ngBind` attribute tells Angular to replace the text content of =
the specified HTML element=0A=
 * with the value of a given expression, and to update the text content =
when the value of that=0A=
 * expression changes.=0A=
 *=0A=
 * Typically, you don't use `ngBind` directly, but instead you use the =
double curly markup like=0A=
 * `{{ expression }}` which is similar but less verbose.=0A=
 *=0A=
 * It is preferable to use `ngBind` instead of `{{ expression }}` if a =
template is momentarily=0A=
 * displayed by the browser in its raw state before Angular compiles it. =
Since `ngBind` is an=0A=
 * element attribute, it makes the bindings invisible to the user while =
the page is loading.=0A=
 *=0A=
 * An alternative solution to this problem would be using the=0A=
 * {@link ng.directive:ngCloak ngCloak} directive.=0A=
 *=0A=
 *=0A=
 * @element ANY=0A=
 * @param {expression} ngBind {@link guide/expression Expression} to =
evaluate.=0A=
 *=0A=
 * @example=0A=
 * Enter a name in the Live Preview text box; the greeting below the =
text box changes instantly.=0A=
   &lt;example module=3D"bindExample" name=3D"ng-bind"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
       &lt;script&gt;=0A=
         angular.module('bindExample', [])=0A=
           .controller('ExampleController', ['$scope', function($scope) {=0A=
             $scope.name =3D 'Whirled';=0A=
           }]);=0A=
       &lt;/script&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
         &lt;label&gt;Enter name: &lt;input type=3D"text" =
ng-model=3D"name"&gt;&lt;/label&gt;&lt;br&gt;=0A=
         Hello &lt;span ng-bind=3D"name"&gt;&lt;/span&gt;!=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should check ng-bind', function() {=0A=
         var nameInput =3D element(by.model('name'));=0A=
=0A=
         expect(element(by.binding('name')).getText()).toBe('Whirled');=0A=
         nameInput.clear();=0A=
         nameInput.sendKeys('world');=0A=
         expect(element(by.binding('name')).getText()).toBe('world');=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
var ngBindDirective =3D ['$compile', function($compile) {=0A=
  return {=0A=
    restrict: 'AC',=0A=
    compile: function ngBindCompile(templateElement) {=0A=
      $compile.$$addBindingClass(templateElement);=0A=
      return function ngBindLink(scope, element, attr) {=0A=
        $compile.$$addBindingInfo(element, attr.ngBind);=0A=
        element =3D element[0];=0A=
        scope.$watch(attr.ngBind, function ngBindWatchAction(value) {=0A=
          element.textContent =3D stringify(value);=0A=
        });=0A=
      };=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngBindTemplate=0A=
 *=0A=
 * @description=0A=
 * The `ngBindTemplate` directive specifies that the element=0A=
 * text content should be replaced with the interpolation of the template=0A=
 * in the `ngBindTemplate` attribute.=0A=
 * Unlike `ngBind`, the `ngBindTemplate` can contain multiple `{{` `}}`=0A=
 * expressions. This directive is needed since some HTML elements=0A=
 * (such as TITLE and OPTION) cannot contain SPAN elements.=0A=
 *=0A=
 * @element ANY=0A=
 * @param {string} ngBindTemplate template of form=0A=
 *   &lt;tt&gt;{{&lt;/tt&gt; &lt;tt&gt;expression&lt;/tt&gt; =
&lt;tt&gt;}}&lt;/tt&gt; to eval.=0A=
 *=0A=
 * @example=0A=
 * Try it here: enter text in text box and watch the greeting change.=0A=
   &lt;example module=3D"bindExample" name=3D"ng-bind-template"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
       &lt;script&gt;=0A=
         angular.module('bindExample', [])=0A=
           .controller('ExampleController', ['$scope', function($scope) {=0A=
             $scope.salutation =3D 'Hello';=0A=
             $scope.name =3D 'World';=0A=
           }]);=0A=
       &lt;/script&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
        &lt;label&gt;Salutation: &lt;input type=3D"text" =
ng-model=3D"salutation"&gt;&lt;/label&gt;&lt;br&gt;=0A=
        &lt;label&gt;Name: &lt;input type=3D"text" =
ng-model=3D"name"&gt;&lt;/label&gt;&lt;br&gt;=0A=
        &lt;pre ng-bind-template=3D"{{salutation}} =
{{name}}!"&gt;&lt;/pre&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should check ng-bind', function() {=0A=
         var salutationElem =3D element(by.binding('salutation'));=0A=
         var salutationInput =3D element(by.model('salutation'));=0A=
         var nameInput =3D element(by.model('name'));=0A=
=0A=
         expect(salutationElem.getText()).toBe('Hello World!');=0A=
=0A=
         salutationInput.clear();=0A=
         salutationInput.sendKeys('Greetings');=0A=
         nameInput.clear();=0A=
         nameInput.sendKeys('user');=0A=
=0A=
         expect(salutationElem.getText()).toBe('Greetings user!');=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
var ngBindTemplateDirective =3D ['$interpolate', '$compile', =
function($interpolate, $compile) {=0A=
  return {=0A=
    compile: function ngBindTemplateCompile(templateElement) {=0A=
      $compile.$$addBindingClass(templateElement);=0A=
      return function ngBindTemplateLink(scope, element, attr) {=0A=
        var interpolateFn =3D =
$interpolate(element.attr(attr.$attr.ngBindTemplate));=0A=
        $compile.$$addBindingInfo(element, interpolateFn.expressions);=0A=
        element =3D element[0];=0A=
        attr.$observe('ngBindTemplate', function(value) {=0A=
          element.textContent =3D isUndefined(value) ? '' : value;=0A=
        });=0A=
      };=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngBindHtml=0A=
 *=0A=
 * @description=0A=
 * Evaluates the expression and inserts the resulting HTML into the =
element in a secure way. By default,=0A=
 * the resulting HTML content will be sanitized using the {@link =
ngSanitize.$sanitize $sanitize} service.=0A=
 * To utilize this functionality, ensure that `$sanitize` is available, =
for example, by including {@link=0A=
 * ngSanitize} in your module's dependencies (not in core Angular). In =
order to use {@link ngSanitize}=0A=
 * in your module's dependencies, you need to include =
"angular-sanitize.js" in your application.=0A=
 *=0A=
 * You may also bypass sanitization for values you know are safe. To do =
so, bind to=0A=
 * an explicitly trusted value via {@link ng.$sce#trustAsHtml =
$sce.trustAsHtml}.  See the example=0A=
 * under {@link ng.$sce#show-me-an-example-using-sce- Strict Contextual =
Escaping (SCE)}.=0A=
 *=0A=
 * Note: If a `$sanitize` service is unavailable and the bound value =
isn't explicitly trusted, you=0A=
 * will have an exception (instead of an exploit.)=0A=
 *=0A=
 * @element ANY=0A=
 * @param {expression} ngBindHtml {@link guide/expression Expression} to =
evaluate.=0A=
 *=0A=
 * @example=0A=
=0A=
   &lt;example module=3D"bindHtmlExample" deps=3D"angular-sanitize.js" =
name=3D"ng-bind-html"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
        &lt;p ng-bind-html=3D"myHTML"&gt;&lt;/p&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
=0A=
     &lt;file name=3D"script.js"&gt;=0A=
       angular.module('bindHtmlExample', ['ngSanitize'])=0A=
         .controller('ExampleController', ['$scope', function($scope) {=0A=
           $scope.myHTML =3D=0A=
              'I am an &lt;code&gt;HTML&lt;/code&gt;string with ' +=0A=
              '&lt;a href=3D"#"&gt;links!&lt;/a&gt; and other =
&lt;em&gt;stuff&lt;/em&gt;';=0A=
         }]);=0A=
     &lt;/file&gt;=0A=
=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should check ng-bind-html', function() {=0A=
         expect(element(by.binding('myHTML')).getText()).toBe(=0A=
             'I am an HTMLstring with links! and other stuff');=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
var ngBindHtmlDirective =3D ['$sce', '$parse', '$compile', =
function($sce, $parse, $compile) {=0A=
  return {=0A=
    restrict: 'A',=0A=
    compile: function ngBindHtmlCompile(tElement, tAttrs) {=0A=
      var ngBindHtmlGetter =3D $parse(tAttrs.ngBindHtml);=0A=
      var ngBindHtmlWatch =3D $parse(tAttrs.ngBindHtml, function =
sceValueOf(val) {=0A=
        // Unwrap the value to compare the actual inner safe value, not =
the wrapper object.=0A=
        return $sce.valueOf(val);=0A=
      });=0A=
      $compile.$$addBindingClass(tElement);=0A=
=0A=
      return function ngBindHtmlLink(scope, element, attr) {=0A=
        $compile.$$addBindingInfo(element, attr.ngBindHtml);=0A=
=0A=
        scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {=0A=
          // The watched value is the unwrapped value. To avoid =
re-escaping, use the direct getter.=0A=
          var value =3D ngBindHtmlGetter(scope);=0A=
          element.html($sce.getTrustedHtml(value) || '');=0A=
        });=0A=
      };=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngChange=0A=
 *=0A=
 * @description=0A=
 * Evaluate the given expression when the user changes the input.=0A=
 * The expression is evaluated immediately, unlike the JavaScript =
onchange event=0A=
 * which only triggers at the end of a change (usually, when the user =
leaves the=0A=
 * form element or presses the return key).=0A=
 *=0A=
 * The `ngChange` expression is only evaluated when a change in the =
input value causes=0A=
 * a new value to be committed to the model.=0A=
 *=0A=
 * It will not be evaluated:=0A=
 * * if the value returned from the `$parsers` transformation pipeline =
has not changed=0A=
 * * if the input has continued to be invalid since the model will stay =
`null`=0A=
 * * if the model is changed programmatically and not by a change to the =
input value=0A=
 *=0A=
 *=0A=
 * Note, this directive requires `ngModel` to be present.=0A=
 *=0A=
 * @element input=0A=
 * @param {expression} ngChange {@link guide/expression Expression} to =
evaluate upon change=0A=
 * in input value.=0A=
 *=0A=
 * @example=0A=
 * &lt;example name=3D"ngChange-directive" module=3D"changeExample"&gt;=0A=
 *   &lt;file name=3D"index.html"&gt;=0A=
 *     &lt;script&gt;=0A=
 *       angular.module('changeExample', [])=0A=
 *         .controller('ExampleController', ['$scope', function($scope) {=0A=
 *           $scope.counter =3D 0;=0A=
 *           $scope.change =3D function() {=0A=
 *             $scope.counter++;=0A=
 *           };=0A=
 *         }]);=0A=
 *     &lt;/script&gt;=0A=
 *     &lt;div ng-controller=3D"ExampleController"&gt;=0A=
 *       &lt;input type=3D"checkbox" ng-model=3D"confirmed" =
ng-change=3D"change()" id=3D"ng-change-example1" /&gt;=0A=
 *       &lt;input type=3D"checkbox" ng-model=3D"confirmed" =
id=3D"ng-change-example2" /&gt;=0A=
 *       &lt;label =
for=3D"ng-change-example2"&gt;Confirmed&lt;/label&gt;&lt;br /&gt;=0A=
 *       &lt;tt&gt;debug =3D {{confirmed}}&lt;/tt&gt;&lt;br/&gt;=0A=
 *       &lt;tt&gt;counter =3D {{counter}}&lt;/tt&gt;&lt;br/&gt;=0A=
 *     &lt;/div&gt;=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
 *     var counter =3D element(by.binding('counter'));=0A=
 *     var debug =3D element(by.binding('confirmed'));=0A=
 *=0A=
 *     it('should evaluate the expression if changing from view', =
function() {=0A=
 *       expect(counter.getText()).toContain('0');=0A=
 *=0A=
 *       element(by.id('ng-change-example1')).click();=0A=
 *=0A=
 *       expect(counter.getText()).toContain('1');=0A=
 *       expect(debug.getText()).toContain('true');=0A=
 *     });=0A=
 *=0A=
 *     it('should not evaluate the expression if changing from model', =
function() {=0A=
 *       element(by.id('ng-change-example2')).click();=0A=
=0A=
 *       expect(counter.getText()).toContain('0');=0A=
 *       expect(debug.getText()).toContain('true');=0A=
 *     });=0A=
 *   &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 */=0A=
var ngChangeDirective =3D valueFn({=0A=
  restrict: 'A',=0A=
  require: 'ngModel',=0A=
  link: function(scope, element, attr, ctrl) {=0A=
    ctrl.$viewChangeListeners.push(function() {=0A=
      scope.$eval(attr.ngChange);=0A=
    });=0A=
  }=0A=
});=0A=
=0A=
/* exported=0A=
  ngClassDirective,=0A=
  ngClassEvenDirective,=0A=
  ngClassOddDirective=0A=
*/=0A=
=0A=
function classDirective(name, selector) {=0A=
  name =3D 'ngClass' + name;=0A=
  var indexWatchExpression;=0A=
=0A=
  return ['$parse', function($parse) {=0A=
    return {=0A=
      restrict: 'AC',=0A=
      link: function(scope, element, attr) {=0A=
        var expression =3D attr[name].trim();=0A=
        var isOneTime =3D (expression.charAt(0) =3D=3D=3D ':') =
&amp;&amp; (expression.charAt(1) =3D=3D=3D ':');=0A=
=0A=
        var watchInterceptor =3D isOneTime ? toFlatValue : toClassString;=0A=
        var watchExpression =3D $parse(expression, watchInterceptor);=0A=
        var watchAction =3D isOneTime ? ngClassOneTimeWatchAction : =
ngClassWatchAction;=0A=
=0A=
        var classCounts =3D element.data('$classCounts');=0A=
        var oldModulo =3D true;=0A=
        var oldClassString;=0A=
=0A=
        if (!classCounts) {=0A=
          // Use createMap() to prevent class assumptions involving =
property=0A=
          // names in Object.prototype=0A=
          classCounts =3D createMap();=0A=
          element.data('$classCounts', classCounts);=0A=
        }=0A=
=0A=
        if (name !=3D=3D 'ngClass') {=0A=
          if (!indexWatchExpression) {=0A=
            indexWatchExpression =3D $parse('$index', function =
moduloTwo($index) {=0A=
              // eslint-disable-next-line no-bitwise=0A=
              return $index &amp; 1;=0A=
            });=0A=
          }=0A=
=0A=
          scope.$watch(indexWatchExpression, ngClassIndexWatchAction);=0A=
        }=0A=
=0A=
        scope.$watch(watchExpression, watchAction, isOneTime);=0A=
=0A=
        function addClasses(classString) {=0A=
          classString =3D digestClassCounts(split(classString), 1);=0A=
          attr.$addClass(classString);=0A=
        }=0A=
=0A=
        function removeClasses(classString) {=0A=
          classString =3D digestClassCounts(split(classString), -1);=0A=
          attr.$removeClass(classString);=0A=
        }=0A=
=0A=
        function updateClasses(oldClassString, newClassString) {=0A=
          var oldClassArray =3D split(oldClassString);=0A=
          var newClassArray =3D split(newClassString);=0A=
=0A=
          var toRemoveArray =3D arrayDifference(oldClassArray, =
newClassArray);=0A=
          var toAddArray =3D arrayDifference(newClassArray, =
oldClassArray);=0A=
=0A=
          var toRemoveString =3D digestClassCounts(toRemoveArray, -1);=0A=
          var toAddString =3D digestClassCounts(toAddArray, 1);=0A=
=0A=
          attr.$addClass(toAddString);=0A=
          attr.$removeClass(toRemoveString);=0A=
        }=0A=
=0A=
        function digestClassCounts(classArray, count) {=0A=
          var classesToUpdate =3D [];=0A=
=0A=
          forEach(classArray, function(className) {=0A=
            if (count &gt; 0 || classCounts[className]) {=0A=
              classCounts[className] =3D (classCounts[className] || 0) + =
count;=0A=
              if (classCounts[className] =3D=3D=3D +(count &gt; 0)) {=0A=
                classesToUpdate.push(className);=0A=
              }=0A=
            }=0A=
          });=0A=
=0A=
          return classesToUpdate.join(' ');=0A=
        }=0A=
=0A=
        function ngClassIndexWatchAction(newModulo) {=0A=
          // This watch-action should run before the =
`ngClass[OneTime]WatchAction()`, thus it=0A=
          // adds/removes `oldClassString`. If the `ngClass` expression =
has changed as well, the=0A=
          // `ngClass[OneTime]WatchAction()` will update the classes.=0A=
          if (newModulo =3D=3D=3D selector) {=0A=
            addClasses(oldClassString);=0A=
          } else {=0A=
            removeClasses(oldClassString);=0A=
          }=0A=
=0A=
          oldModulo =3D newModulo;=0A=
        }=0A=
=0A=
        function ngClassOneTimeWatchAction(newClassValue) {=0A=
          var newClassString =3D toClassString(newClassValue);=0A=
=0A=
          if (newClassString !=3D=3D oldClassString) {=0A=
            ngClassWatchAction(newClassString);=0A=
          }=0A=
        }=0A=
=0A=
        function ngClassWatchAction(newClassString) {=0A=
          if (oldModulo =3D=3D=3D selector) {=0A=
            updateClasses(oldClassString, newClassString);=0A=
          }=0A=
=0A=
          oldClassString =3D newClassString;=0A=
        }=0A=
      }=0A=
    };=0A=
  }];=0A=
=0A=
  // Helpers=0A=
  function arrayDifference(tokens1, tokens2) {=0A=
    if (!tokens1 || !tokens1.length) return [];=0A=
    if (!tokens2 || !tokens2.length) return tokens1;=0A=
=0A=
    var values =3D [];=0A=
=0A=
    outer:=0A=
    for (var i =3D 0; i &lt; tokens1.length; i++) {=0A=
      var token =3D tokens1[i];=0A=
      for (var j =3D 0; j &lt; tokens2.length; j++) {=0A=
        if (token =3D=3D=3D tokens2[j]) continue outer;=0A=
      }=0A=
      values.push(token);=0A=
    }=0A=
=0A=
    return values;=0A=
  }=0A=
=0A=
  function split(classString) {=0A=
    return classString &amp;&amp; classString.split(' ');=0A=
  }=0A=
=0A=
  function toClassString(classValue) {=0A=
    var classString =3D classValue;=0A=
=0A=
    if (isArray(classValue)) {=0A=
      classString =3D classValue.map(toClassString).join(' ');=0A=
    } else if (isObject(classValue)) {=0A=
      classString =3D Object.keys(classValue).=0A=
        filter(function(key) { return classValue[key]; }).=0A=
        join(' ');=0A=
    }=0A=
=0A=
    return classString;=0A=
  }=0A=
=0A=
  function toFlatValue(classValue) {=0A=
    var flatValue =3D classValue;=0A=
=0A=
    if (isArray(classValue)) {=0A=
      flatValue =3D classValue.map(toFlatValue);=0A=
    } else if (isObject(classValue)) {=0A=
      var hasUndefined =3D false;=0A=
=0A=
      flatValue =3D Object.keys(classValue).filter(function(key) {=0A=
        var value =3D classValue[key];=0A=
=0A=
        if (!hasUndefined &amp;&amp; isUndefined(value)) {=0A=
          hasUndefined =3D true;=0A=
        }=0A=
=0A=
        return value;=0A=
      });=0A=
=0A=
      if (hasUndefined) {=0A=
        // Prevent the `oneTimeLiteralWatchInterceptor` from =
unregistering=0A=
        // the watcher, by including at least one `undefined` value.=0A=
        flatValue.push(undefined);=0A=
      }=0A=
    }=0A=
=0A=
    return flatValue;=0A=
  }=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngClass=0A=
 * @restrict AC=0A=
 *=0A=
 * @description=0A=
 * The `ngClass` directive allows you to dynamically set CSS classes on =
an HTML element by databinding=0A=
 * an expression that represents all classes to be added.=0A=
 *=0A=
 * The directive operates in three different ways, depending on which of =
three types the expression=0A=
 * evaluates to:=0A=
 *=0A=
 * 1. If the expression evaluates to a string, the string should be one =
or more space-delimited class=0A=
 * names.=0A=
 *=0A=
 * 2. If the expression evaluates to an object, then for each key-value =
pair of the=0A=
 * object with a truthy value the corresponding key is used as a class =
name.=0A=
 *=0A=
 * 3. If the expression evaluates to an array, each element of the array =
should either be a string as in=0A=
 * type 1 or an object as in type 2. This means that you can mix strings =
and objects together in an array=0A=
 * to give you more control over what CSS classes appear. See the code =
below for an example of this.=0A=
 *=0A=
 *=0A=
 * The directive won't add duplicate classes if a particular class was =
already set.=0A=
 *=0A=
 * When the expression changes, the previously added classes are removed =
and only then are the=0A=
 * new classes added.=0A=
 *=0A=
 * @knownIssue=0A=
 * You should not use {@link guide/interpolation interpolation} in the =
value of the `class`=0A=
 * attribute, when using the `ngClass` directive on the same element.=0A=
 * See {@link guide/interpolation#known-issues here} for more info.=0A=
 *=0A=
 * @animations=0A=
 * | Animation                        | Occurs                           =
   |=0A=
 * =
|----------------------------------|-------------------------------------=
|=0A=
 * | {@link ng.$animate#addClass addClass}       | just before the class =
is applied to the element   |=0A=
 * | {@link ng.$animate#removeClass removeClass} | just before the class =
is removed from the element |=0A=
 *=0A=
 * @element ANY=0A=
 * @param {expression} ngClass {@link guide/expression Expression} to =
eval. The result=0A=
 *   of the evaluation can be a string representing space delimited class=0A=
 *   names, an array, or a map of class names to boolean values. In the =
case of a map, the=0A=
 *   names of the properties whose values are truthy will be added as =
css classes to the=0A=
 *   element.=0A=
 *=0A=
 * @example Example that demonstrates basic bindings via ngClass =
directive.=0A=
   &lt;example name=3D"ng-class"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
       &lt;p ng-class=3D"{strike: deleted, bold: important, 'has-error': =
error}"&gt;Map Syntax Example&lt;/p&gt;=0A=
       &lt;label&gt;=0A=
          &lt;input type=3D"checkbox" ng-model=3D"deleted"&gt;=0A=
          deleted (apply "strike" class)=0A=
       &lt;/label&gt;&lt;br&gt;=0A=
       &lt;label&gt;=0A=
          &lt;input type=3D"checkbox" ng-model=3D"important"&gt;=0A=
          important (apply "bold" class)=0A=
       &lt;/label&gt;&lt;br&gt;=0A=
       &lt;label&gt;=0A=
          &lt;input type=3D"checkbox" ng-model=3D"error"&gt;=0A=
          error (apply "has-error" class)=0A=
       &lt;/label&gt;=0A=
       &lt;hr&gt;=0A=
       &lt;p ng-class=3D"style"&gt;Using String Syntax&lt;/p&gt;=0A=
       &lt;input type=3D"text" ng-model=3D"style"=0A=
              placeholder=3D"Type: bold strike red" aria-label=3D"Type: =
bold strike red"&gt;=0A=
       &lt;hr&gt;=0A=
       &lt;p ng-class=3D"[style1, style2, style3]"&gt;Using Array =
Syntax&lt;/p&gt;=0A=
       &lt;input ng-model=3D"style1"=0A=
              placeholder=3D"Type: bold, strike or red" =
aria-label=3D"Type: bold, strike or red"&gt;&lt;br&gt;=0A=
       &lt;input ng-model=3D"style2"=0A=
              placeholder=3D"Type: bold, strike or red" =
aria-label=3D"Type: bold, strike or red 2"&gt;&lt;br&gt;=0A=
       &lt;input ng-model=3D"style3"=0A=
              placeholder=3D"Type: bold, strike or red" =
aria-label=3D"Type: bold, strike or red 3"&gt;&lt;br&gt;=0A=
       &lt;hr&gt;=0A=
       &lt;p ng-class=3D"[style4, {orange: warning}]"&gt;Using Array and =
Map Syntax&lt;/p&gt;=0A=
       &lt;input ng-model=3D"style4" placeholder=3D"Type: bold, strike" =
aria-label=3D"Type: bold, strike"&gt;&lt;br&gt;=0A=
       &lt;label&gt;&lt;input type=3D"checkbox" ng-model=3D"warning"&gt; =
warning (apply "orange" class)&lt;/label&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"style.css"&gt;=0A=
       .strike {=0A=
           text-decoration: line-through;=0A=
       }=0A=
       .bold {=0A=
           font-weight: bold;=0A=
       }=0A=
       .red {=0A=
           color: red;=0A=
       }=0A=
       .has-error {=0A=
           color: red;=0A=
           background-color: yellow;=0A=
       }=0A=
       .orange {=0A=
           color: orange;=0A=
       }=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       var ps =3D element.all(by.css('p'));=0A=
=0A=
       it('should let you toggle the class', function() {=0A=
=0A=
         expect(ps.first().getAttribute('class')).not.toMatch(/bold/);=0A=
         =
expect(ps.first().getAttribute('class')).not.toMatch(/has-error/);=0A=
=0A=
         element(by.model('important')).click();=0A=
         expect(ps.first().getAttribute('class')).toMatch(/bold/);=0A=
=0A=
         element(by.model('error')).click();=0A=
         expect(ps.first().getAttribute('class')).toMatch(/has-error/);=0A=
       });=0A=
=0A=
       it('should let you toggle string example', function() {=0A=
         expect(ps.get(1).getAttribute('class')).toBe('');=0A=
         element(by.model('style')).clear();=0A=
         element(by.model('style')).sendKeys('red');=0A=
         expect(ps.get(1).getAttribute('class')).toBe('red');=0A=
       });=0A=
=0A=
       it('array example should have 3 classes', function() {=0A=
         expect(ps.get(2).getAttribute('class')).toBe('');=0A=
         element(by.model('style1')).sendKeys('bold');=0A=
         element(by.model('style2')).sendKeys('strike');=0A=
         element(by.model('style3')).sendKeys('red');=0A=
         expect(ps.get(2).getAttribute('class')).toBe('bold strike red');=0A=
       });=0A=
=0A=
       it('array with map example should have 2 classes', function() {=0A=
         expect(ps.last().getAttribute('class')).toBe('');=0A=
         element(by.model('style4')).sendKeys('bold');=0A=
         element(by.model('warning')).click();=0A=
         expect(ps.last().getAttribute('class')).toBe('bold orange');=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
=0A=
   ## Animations=0A=
=0A=
   The example below demonstrates how to perform animations using =
ngClass.=0A=
=0A=
   &lt;example module=3D"ngAnimate" deps=3D"angular-animate.js" =
animations=3D"true" name=3D"ng-class"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
      &lt;input id=3D"setbtn" type=3D"button" value=3D"set" =
ng-click=3D"myVar=3D'my-class'"&gt;=0A=
      &lt;input id=3D"clearbtn" type=3D"button" value=3D"clear" =
ng-click=3D"myVar=3D''"&gt;=0A=
      &lt;br&gt;=0A=
      &lt;span class=3D"base-class" ng-class=3D"myVar"&gt;Sample =
Text&lt;/span&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"style.css"&gt;=0A=
       .base-class {=0A=
         transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;=0A=
       }=0A=
=0A=
       .base-class.my-class {=0A=
         color: red;=0A=
         font-size:3em;=0A=
       }=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should check ng-class', function() {=0A=
         =
expect(element(by.css('.base-class')).getAttribute('class')).not.=0A=
           toMatch(/my-class/);=0A=
=0A=
         element(by.id('setbtn')).click();=0A=
=0A=
         expect(element(by.css('.base-class')).getAttribute('class')).=0A=
           toMatch(/my-class/);=0A=
=0A=
         element(by.id('clearbtn')).click();=0A=
=0A=
         =
expect(element(by.css('.base-class')).getAttribute('class')).not.=0A=
           toMatch(/my-class/);=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
=0A=
=0A=
   ## ngClass and pre-existing CSS3 Transitions/Animations=0A=
   The ngClass directive still supports CSS3 Transitions/Animations even =
if they do not follow the ngAnimate CSS naming structure.=0A=
   Upon animation ngAnimate will apply supplementary CSS classes to =
track the start and end of an animation, but this will not hinder=0A=
   any pre-existing CSS transitions already on the element. To get an =
idea of what happens during a class-based animation, be sure=0A=
   to view the step by step details of {@link $animate#addClass =
$animate.addClass} and=0A=
   {@link $animate#removeClass $animate.removeClass}.=0A=
 */=0A=
var ngClassDirective =3D classDirective('', true);=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngClassOdd=0A=
 * @restrict AC=0A=
 *=0A=
 * @description=0A=
 * The `ngClassOdd` and `ngClassEven` directives work exactly as=0A=
 * {@link ng.directive:ngClass ngClass}, except they work in=0A=
 * conjunction with `ngRepeat` and take effect only on odd (even) rows.=0A=
 *=0A=
 * This directive can be applied only within the scope of an=0A=
 * {@link ng.directive:ngRepeat ngRepeat}.=0A=
 *=0A=
 * @element ANY=0A=
 * @param {expression} ngClassOdd {@link guide/expression Expression} to =
eval. The result=0A=
 *   of the evaluation can be a string representing space delimited =
class names or an array.=0A=
 *=0A=
 * @example=0A=
   &lt;example name=3D"ng-class-odd"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
        &lt;ol ng-init=3D"names=3D['John', 'Mary', 'Cate', 'Suz']"&gt;=0A=
          &lt;li ng-repeat=3D"name in names"&gt;=0A=
           &lt;span ng-class-odd=3D"'odd'" ng-class-even=3D"'even'"&gt;=0A=
             {{name}}=0A=
           &lt;/span&gt;=0A=
          &lt;/li&gt;=0A=
        &lt;/ol&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"style.css"&gt;=0A=
       .odd {=0A=
         color: red;=0A=
       }=0A=
       .even {=0A=
         color: blue;=0A=
       }=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should check ng-class-odd and ng-class-even', function() {=0A=
         expect(element(by.repeater('name in =
names').row(0).column('name')).getAttribute('class')).=0A=
           toMatch(/odd/);=0A=
         expect(element(by.repeater('name in =
names').row(1).column('name')).getAttribute('class')).=0A=
           toMatch(/even/);=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
var ngClassOddDirective =3D classDirective('Odd', 0);=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngClassEven=0A=
 * @restrict AC=0A=
 *=0A=
 * @description=0A=
 * The `ngClassOdd` and `ngClassEven` directives work exactly as=0A=
 * {@link ng.directive:ngClass ngClass}, except they work in=0A=
 * conjunction with `ngRepeat` and take effect only on odd (even) rows.=0A=
 *=0A=
 * This directive can be applied only within the scope of an=0A=
 * {@link ng.directive:ngRepeat ngRepeat}.=0A=
 *=0A=
 * @element ANY=0A=
 * @param {expression} ngClassEven {@link guide/expression Expression} =
to eval. The=0A=
 *   result of the evaluation can be a string representing space =
delimited class names or an array.=0A=
 *=0A=
 * @example=0A=
   &lt;example name=3D"ng-class-even"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
        &lt;ol ng-init=3D"names=3D['John', 'Mary', 'Cate', 'Suz']"&gt;=0A=
          &lt;li ng-repeat=3D"name in names"&gt;=0A=
           &lt;span ng-class-odd=3D"'odd'" ng-class-even=3D"'even'"&gt;=0A=
             {{name}} &amp;nbsp; &amp;nbsp; &amp;nbsp;=0A=
           &lt;/span&gt;=0A=
          &lt;/li&gt;=0A=
        &lt;/ol&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"style.css"&gt;=0A=
       .odd {=0A=
         color: red;=0A=
       }=0A=
       .even {=0A=
         color: blue;=0A=
       }=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should check ng-class-odd and ng-class-even', function() {=0A=
         expect(element(by.repeater('name in =
names').row(0).column('name')).getAttribute('class')).=0A=
           toMatch(/odd/);=0A=
         expect(element(by.repeater('name in =
names').row(1).column('name')).getAttribute('class')).=0A=
           toMatch(/even/);=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
var ngClassEvenDirective =3D classDirective('Even', 1);=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngCloak=0A=
 * @restrict AC=0A=
 *=0A=
 * @description=0A=
 * The `ngCloak` directive is used to prevent the Angular html template =
from being briefly=0A=
 * displayed by the browser in its raw (uncompiled) form while your =
application is loading. Use this=0A=
 * directive to avoid the undesirable flicker effect caused by the html =
template display.=0A=
 *=0A=
 * The directive can be applied to the `&lt;body&gt;` element, but the =
preferred usage is to apply=0A=
 * multiple `ngCloak` directives to small portions of the page to permit =
progressive rendering=0A=
 * of the browser view.=0A=
 *=0A=
 * `ngCloak` works in cooperation with the following css rule embedded =
within `angular.js` and=0A=
 * `angular.min.js`.=0A=
 * For CSP mode please add `angular-csp.css` to your html file (see =
{@link ng.directive:ngCsp ngCsp}).=0A=
 *=0A=
 * ```css=0A=
 * [ng\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, =
.x-ng-cloak {=0A=
 *   display: none !important;=0A=
 * }=0A=
 * ```=0A=
 *=0A=
 * When this css rule is loaded by the browser, all html elements =
(including their children) that=0A=
 * are tagged with the `ngCloak` directive are hidden. When Angular =
encounters this directive=0A=
 * during the compilation of the template it deletes the `ngCloak` =
element attribute, making=0A=
 * the compiled element visible.=0A=
 *=0A=
 * For the best result, the `angular.js` script must be loaded in the =
head section of the html=0A=
 * document; alternatively, the css rule above must be included in the =
external stylesheet of the=0A=
 * application.=0A=
 *=0A=
 * @element ANY=0A=
 *=0A=
 * @example=0A=
   &lt;example name=3D"ng-cloak"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
        &lt;div id=3D"template1" ng-cloak&gt;{{ 'hello' }}&lt;/div&gt;=0A=
        &lt;div id=3D"template2" class=3D"ng-cloak"&gt;{{ 'world' =
}}&lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should remove the template directive and css class', =
function() {=0A=
         expect($('#template1').getAttribute('ng-cloak')).=0A=
           toBeNull();=0A=
         expect($('#template2').getAttribute('ng-cloak')).=0A=
           toBeNull();=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 *=0A=
 */=0A=
var ngCloakDirective =3D ngDirective({=0A=
  compile: function(element, attr) {=0A=
    attr.$set('ngCloak', undefined);=0A=
    element.removeClass('ng-cloak');=0A=
  }=0A=
});=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngController=0A=
 *=0A=
 * @description=0A=
 * The `ngController` directive attaches a controller class to the view. =
This is a key aspect of how angular=0A=
 * supports the principles behind the Model-View-Controller design =
pattern.=0A=
 *=0A=
 * MVC components in angular:=0A=
 *=0A=
 * * Model =E2=80&#65533; Models are the properties of a scope; scopes =
are attached to the DOM where scope properties=0A=
 *   are accessed through bindings.=0A=
 * * View =E2=80&#65533; The template (HTML with data bindings) that is =
rendered into the View.=0A=
 * * Controller =E2=80&#65533; The `ngController` directive specifies a =
Controller class; the class contains business=0A=
 *   logic behind the application to decorate the scope with functions =
and values=0A=
 *=0A=
 * Note that you can also attach controllers to the DOM by declaring it =
in a route definition=0A=
 * via the {@link ngRoute.$route $route} service. A common mistake is to =
declare the controller=0A=
 * again using `ng-controller` in the template itself.  This will cause =
the controller to be attached=0A=
 * and executed twice.=0A=
 *=0A=
 * @element ANY=0A=
 * @scope=0A=
 * @priority 500=0A=
 * @param {expression} ngController Name of a constructor function =
registered with the current=0A=
 * {@link ng.$controllerProvider $controllerProvider} or an {@link =
guide/expression expression}=0A=
 * that on the current scope evaluates to a constructor function.=0A=
 *=0A=
 * The controller instance can be published into a scope property by =
specifying=0A=
 * `ng-controller=3D"as propertyName"`.=0A=
 *=0A=
 * If the current `$controllerProvider` is configured to use globals (via=0A=
 * {@link ng.$controllerProvider#allowGlobals =
`$controllerProvider.allowGlobals()` }), this may=0A=
 * also be the name of a globally accessible constructor function =
(deprecated, not recommended).=0A=
 *=0A=
 * @example=0A=
 * Here is a simple form for editing user contact information. Adding, =
removing, clearing, and=0A=
 * greeting are methods declared on the controller (see source tab). =
These methods can=0A=
 * easily be called from the angular markup. Any changes to the data are =
automatically reflected=0A=
 * in the View without the need for a manual update.=0A=
 *=0A=
 * Two different declaration styles are included below:=0A=
 *=0A=
 * * one binds methods and properties directly onto the controller using =
`this`:=0A=
 * `ng-controller=3D"SettingsController1 as settings"`=0A=
 * * one injects `$scope` into the controller:=0A=
 * `ng-controller=3D"SettingsController2"`=0A=
 *=0A=
 * The second option is more common in the Angular community, and is =
generally used in boilerplates=0A=
 * and in this guide. However, there are advantages to binding =
properties directly to the controller=0A=
 * and avoiding scope.=0A=
 *=0A=
 * * Using `controller as` makes it obvious which controller you are =
accessing in the template when=0A=
 * multiple controllers apply to an element.=0A=
 * * If you are writing your controllers as classes you have easier =
access to the properties and=0A=
 * methods, which will appear on the scope, from inside the controller =
code.=0A=
 * * Since there is always a `.` in the bindings, you don't have to =
worry about prototypal=0A=
 * inheritance masking primitives.=0A=
 *=0A=
 * This example demonstrates the `controller as` syntax.=0A=
 *=0A=
 * &lt;example name=3D"ngControllerAs" module=3D"controllerAsExample"&gt;=0A=
 *   &lt;file name=3D"index.html"&gt;=0A=
 *    &lt;div id=3D"ctrl-as-exmpl" ng-controller=3D"SettingsController1 =
as settings"&gt;=0A=
 *      &lt;label&gt;Name: &lt;input type=3D"text" =
ng-model=3D"settings.name"/&gt;&lt;/label&gt;=0A=
 *      &lt;button =
ng-click=3D"settings.greet()"&gt;greet&lt;/button&gt;&lt;br/&gt;=0A=
 *      Contact:=0A=
 *      &lt;ul&gt;=0A=
 *        &lt;li ng-repeat=3D"contact in settings.contacts"&gt;=0A=
 *          &lt;select ng-model=3D"contact.type" aria-label=3D"Contact =
method" id=3D"select_{{$index}}"&gt;=0A=
 *             &lt;option&gt;phone&lt;/option&gt;=0A=
 *             &lt;option&gt;email&lt;/option&gt;=0A=
 *          &lt;/select&gt;=0A=
 *          &lt;input type=3D"text" ng-model=3D"contact.value" =
aria-labelledby=3D"select_{{$index}}" /&gt;=0A=
 *          &lt;button =
ng-click=3D"settings.clearContact(contact)"&gt;clear&lt;/button&gt;=0A=
 *          &lt;button ng-click=3D"settings.removeContact(contact)" =
aria-label=3D"Remove"&gt;X&lt;/button&gt;=0A=
 *        &lt;/li&gt;=0A=
 *        &lt;li&gt;&lt;button =
ng-click=3D"settings.addContact()"&gt;add&lt;/button&gt;&lt;/li&gt;=0A=
 *     &lt;/ul&gt;=0A=
 *    &lt;/div&gt;=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"app.js"&gt;=0A=
 *    angular.module('controllerAsExample', [])=0A=
 *      .controller('SettingsController1', SettingsController1);=0A=
 *=0A=
 *    function SettingsController1() {=0A=
 *      this.name =3D 'John Smith';=0A=
 *      this.contacts =3D [=0A=
 *        {type: 'phone', value: '408 555 1212'},=0A=
 *        {type: 'email', value: 'john.smith@example.org'}=0A=
 *      ];=0A=
 *    }=0A=
 *=0A=
 *    SettingsController1.prototype.greet =3D function() {=0A=
 *      alert(this.name);=0A=
 *    };=0A=
 *=0A=
 *    SettingsController1.prototype.addContact =3D function() {=0A=
 *      this.contacts.push({type: 'email', value: =
'yourname@example.org'});=0A=
 *    };=0A=
 *=0A=
 *    SettingsController1.prototype.removeContact =3D =
function(contactToRemove) {=0A=
 *     var index =3D this.contacts.indexOf(contactToRemove);=0A=
 *      this.contacts.splice(index, 1);=0A=
 *    };=0A=
 *=0A=
 *    SettingsController1.prototype.clearContact =3D function(contact) {=0A=
 *      contact.type =3D 'phone';=0A=
 *      contact.value =3D '';=0A=
 *    };=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
 *     it('should check controller as', function() {=0A=
 *       var container =3D element(by.id('ctrl-as-exmpl'));=0A=
 *         expect(container.element(by.model('settings.name'))=0A=
 *           .getAttribute('value')).toBe('John Smith');=0A=
 *=0A=
 *       var firstRepeat =3D=0A=
 *           container.element(by.repeater('contact in =
settings.contacts').row(0));=0A=
 *       var secondRepeat =3D=0A=
 *           container.element(by.repeater('contact in =
settings.contacts').row(1));=0A=
 *=0A=
 *       =
expect(firstRepeat.element(by.model('contact.value')).getAttribute('value=
'))=0A=
 *           .toBe('408 555 1212');=0A=
 *=0A=
 *       =
expect(secondRepeat.element(by.model('contact.value')).getAttribute('valu=
e'))=0A=
 *           .toBe('john.smith@example.org');=0A=
 *=0A=
 *       firstRepeat.element(by.buttonText('clear')).click();=0A=
 *=0A=
 *       =
expect(firstRepeat.element(by.model('contact.value')).getAttribute('value=
'))=0A=
 *           .toBe('');=0A=
 *=0A=
 *       container.element(by.buttonText('add')).click();=0A=
 *=0A=
 *       expect(container.element(by.repeater('contact in =
settings.contacts').row(2))=0A=
 *           .element(by.model('contact.value'))=0A=
 *           .getAttribute('value'))=0A=
 *           .toBe('yourname@example.org');=0A=
 *     });=0A=
 *   &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 *=0A=
 * This example demonstrates the "attach to `$scope`" style of =
controller.=0A=
 *=0A=
 * &lt;example name=3D"ngController" module=3D"controllerExample"&gt;=0A=
 *  &lt;file name=3D"index.html"&gt;=0A=
 *   &lt;div id=3D"ctrl-exmpl" ng-controller=3D"SettingsController2"&gt;=0A=
 *     &lt;label&gt;Name: &lt;input type=3D"text" =
ng-model=3D"name"/&gt;&lt;/label&gt;=0A=
 *     &lt;button ng-click=3D"greet()"&gt;greet&lt;/button&gt;&lt;br/&gt;=0A=
 *     Contact:=0A=
 *     &lt;ul&gt;=0A=
 *       &lt;li ng-repeat=3D"contact in contacts"&gt;=0A=
 *         &lt;select ng-model=3D"contact.type" =
id=3D"select_{{$index}}"&gt;=0A=
 *            &lt;option&gt;phone&lt;/option&gt;=0A=
 *            &lt;option&gt;email&lt;/option&gt;=0A=
 *         &lt;/select&gt;=0A=
 *         &lt;input type=3D"text" ng-model=3D"contact.value" =
aria-labelledby=3D"select_{{$index}}" /&gt;=0A=
 *         &lt;button =
ng-click=3D"clearContact(contact)"&gt;clear&lt;/button&gt;=0A=
 *         &lt;button =
ng-click=3D"removeContact(contact)"&gt;X&lt;/button&gt;=0A=
 *       &lt;/li&gt;=0A=
 *       &lt;li&gt;[ &lt;button =
ng-click=3D"addContact()"&gt;add&lt;/button&gt; ]&lt;/li&gt;=0A=
 *    &lt;/ul&gt;=0A=
 *   &lt;/div&gt;=0A=
 *  &lt;/file&gt;=0A=
 *  &lt;file name=3D"app.js"&gt;=0A=
 *   angular.module('controllerExample', [])=0A=
 *     .controller('SettingsController2', ['$scope', =
SettingsController2]);=0A=
 *=0A=
 *   function SettingsController2($scope) {=0A=
 *     $scope.name =3D 'John Smith';=0A=
 *     $scope.contacts =3D [=0A=
 *       {type:'phone', value:'408 555 1212'},=0A=
 *       {type:'email', value:'john.smith@example.org'}=0A=
 *     ];=0A=
 *=0A=
 *     $scope.greet =3D function() {=0A=
 *       alert($scope.name);=0A=
 *     };=0A=
 *=0A=
 *     $scope.addContact =3D function() {=0A=
 *       $scope.contacts.push({type:'email', =
value:'yourname@example.org'});=0A=
 *     };=0A=
 *=0A=
 *     $scope.removeContact =3D function(contactToRemove) {=0A=
 *       var index =3D $scope.contacts.indexOf(contactToRemove);=0A=
 *       $scope.contacts.splice(index, 1);=0A=
 *     };=0A=
 *=0A=
 *     $scope.clearContact =3D function(contact) {=0A=
 *       contact.type =3D 'phone';=0A=
 *       contact.value =3D '';=0A=
 *     };=0A=
 *   }=0A=
 *  &lt;/file&gt;=0A=
 *  &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
 *    it('should check controller', function() {=0A=
 *      var container =3D element(by.id('ctrl-exmpl'));=0A=
 *=0A=
 *      expect(container.element(by.model('name'))=0A=
 *          .getAttribute('value')).toBe('John Smith');=0A=
 *=0A=
 *      var firstRepeat =3D=0A=
 *          container.element(by.repeater('contact in contacts').row(0));=0A=
 *      var secondRepeat =3D=0A=
 *          container.element(by.repeater('contact in contacts').row(1));=0A=
 *=0A=
 *      =
expect(firstRepeat.element(by.model('contact.value')).getAttribute('value=
'))=0A=
 *          .toBe('408 555 1212');=0A=
 *      =
expect(secondRepeat.element(by.model('contact.value')).getAttribute('valu=
e'))=0A=
 *          .toBe('john.smith@example.org');=0A=
 *=0A=
 *      firstRepeat.element(by.buttonText('clear')).click();=0A=
 *=0A=
 *      =
expect(firstRepeat.element(by.model('contact.value')).getAttribute('value=
'))=0A=
 *          .toBe('');=0A=
 *=0A=
 *      container.element(by.buttonText('add')).click();=0A=
 *=0A=
 *      expect(container.element(by.repeater('contact in =
contacts').row(2))=0A=
 *          .element(by.model('contact.value'))=0A=
 *          .getAttribute('value'))=0A=
 *          .toBe('yourname@example.org');=0A=
 *    });=0A=
 *  &lt;/file&gt;=0A=
 *&lt;/example&gt;=0A=
=0A=
 */=0A=
var ngControllerDirective =3D [function() {=0A=
  return {=0A=
    restrict: 'A',=0A=
    scope: true,=0A=
    controller: '@',=0A=
    priority: 500=0A=
  };=0A=
}];=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngCsp=0A=
 *=0A=
 * @restrict A=0A=
 * @element ANY=0A=
 * @description=0A=
 *=0A=
 * Angular has some features that can conflict with certain restrictions =
that are applied when using=0A=
 * [CSP (Content Security =
Policy)](https://developer.mozilla.org/en/Security/CSP) rules.=0A=
 *=0A=
 * If you intend to implement CSP with these rules then you must tell =
Angular not to use these=0A=
 * features.=0A=
 *=0A=
 * This is necessary when developing things like Google Chrome =
Extensions or Universal Windows Apps.=0A=
 *=0A=
 *=0A=
 * The following default rules in CSP affect Angular:=0A=
 *=0A=
 * * The use of `eval()`, `Function(string)` and similar functions to =
dynamically create and execute=0A=
 * code from strings is forbidden. Angular makes use of this in the =
{@link $parse} service to=0A=
 * provide a 30% increase in the speed of evaluating Angular =
expressions. (This CSP rule can be=0A=
 * disabled with the CSP keyword `unsafe-eval`, but it is generally not =
recommended as it would=0A=
 * weaken the protections offered by CSP.)=0A=
 *=0A=
 * * The use of inline resources, such as inline `&lt;script&gt;` and =
`&lt;style&gt;` elements, are forbidden.=0A=
 * This prevents apps from injecting custom styles directly into the =
document. Angular makes use of=0A=
 * this to include some CSS rules (e.g. {@link ngCloak} and {@link =
ngHide}). To make these=0A=
 * directives work when a CSP rule is blocking inline styles, you must =
link to the `angular-csp.css`=0A=
 * in your HTML manually. (This CSP rule can be disabled with the CSP =
keyword `unsafe-inline`, but=0A=
 * it is generally not recommended as it would weaken the protections =
offered by CSP.)=0A=
 *=0A=
 * If you do not provide `ngCsp` then Angular tries to autodetect if CSP =
is blocking dynamic code=0A=
 * creation from strings (e.g., `unsafe-eval` not specified in CSP =
header) and automatically=0A=
 * deactivates this feature in the {@link $parse} service. This =
autodetection, however, triggers a=0A=
 * CSP error to be logged in the console:=0A=
 *=0A=
 * ```=0A=
 * Refused to evaluate a string as JavaScript because 'unsafe-eval' is =
not an allowed source of=0A=
 * script in the following Content Security Policy directive: =
"default-src 'self'". Note that=0A=
 * 'script-src' was not explicitly set, so 'default-src' is used as a =
fallback.=0A=
 * ```=0A=
 *=0A=
 * This error is harmless but annoying. To prevent the error from =
showing up, put the `ngCsp`=0A=
 * directive on an element of the HTML document that appears before the =
`&lt;script&gt;` tag that loads=0A=
 * the `angular.js` file.=0A=
 *=0A=
 * *Note: This directive is only available in the `ng-csp` and =
`data-ng-csp` attribute form.*=0A=
 *=0A=
 * You can specify which of the CSP related Angular features should be =
deactivated by providing=0A=
 * a value for the `ng-csp` attribute. The options are as follows:=0A=
 *=0A=
 * * no-inline-style: this stops Angular from injecting CSS styles into =
the DOM=0A=
 *=0A=
 * * no-unsafe-eval: this stops Angular from optimizing $parse with =
unsafe eval of strings=0A=
 *=0A=
 * You can use these values in the following combinations:=0A=
 *=0A=
 *=0A=
 * * No declaration means that Angular will assume that you can do =
inline styles, but it will do=0A=
 * a runtime check for unsafe-eval. E.g. `&lt;body&gt;`. This is =
backwardly compatible with previous=0A=
 * versions of Angular.=0A=
 *=0A=
 * * A simple `ng-csp` (or `data-ng-csp`) attribute will tell Angular to =
deactivate both inline=0A=
 * styles and unsafe eval. E.g. `&lt;body ng-csp&gt;`. This is =
backwardly compatible with previous=0A=
 * versions of Angular.=0A=
 *=0A=
 * * Specifying only `no-unsafe-eval` tells Angular that we must not use =
eval, but that we can=0A=
 * inject inline styles. E.g. `&lt;body ng-csp=3D"no-unsafe-eval"&gt;`.=0A=
 *=0A=
 * * Specifying only `no-inline-style` tells Angular that we must not =
inject styles, but that we can=0A=
 * run eval - no automatic check for unsafe eval will occur. E.g. =
`&lt;body ng-csp=3D"no-inline-style"&gt;`=0A=
 *=0A=
 * * Specifying both `no-unsafe-eval` and `no-inline-style` tells =
Angular that we must not inject=0A=
 * styles nor use eval, which is the same as an empty: ng-csp.=0A=
 * E.g.`&lt;body ng-csp=3D"no-inline-style;no-unsafe-eval"&gt;`=0A=
 *=0A=
 * @example=0A=
 * This example shows how to apply the `ngCsp` directive to the `html` =
tag.=0A=
   ```html=0A=
     &lt;!doctype html&gt;=0A=
     &lt;html ng-app ng-csp&gt;=0A=
     ...=0A=
     ...=0A=
     &lt;/html&gt;=0A=
   ```=0A=
  * @example=0A=
      &lt;!-- Note: the `.csp` suffix in the example name triggers CSP =
mode in our http server! --&gt;=0A=
      &lt;example name=3D"example.csp" module=3D"cspExample" =
ng-csp=3D"true"&gt;=0A=
        &lt;file name=3D"index.html"&gt;=0A=
          &lt;div ng-controller=3D"MainController as ctrl"&gt;=0A=
            &lt;div&gt;=0A=
              &lt;button ng-click=3D"ctrl.inc()" =
id=3D"inc"&gt;Increment&lt;/button&gt;=0A=
              &lt;span id=3D"counter"&gt;=0A=
                {{ctrl.counter}}=0A=
              &lt;/span&gt;=0A=
            &lt;/div&gt;=0A=
=0A=
            &lt;div&gt;=0A=
              &lt;button ng-click=3D"ctrl.evil()" =
id=3D"evil"&gt;Evil&lt;/button&gt;=0A=
              &lt;span id=3D"evilError"&gt;=0A=
                {{ctrl.evilError}}=0A=
              &lt;/span&gt;=0A=
            &lt;/div&gt;=0A=
          &lt;/div&gt;=0A=
        &lt;/file&gt;=0A=
        &lt;file name=3D"script.js"&gt;=0A=
           angular.module('cspExample', [])=0A=
             .controller('MainController', function MainController() {=0A=
                this.counter =3D 0;=0A=
                this.inc =3D function() {=0A=
                  this.counter++;=0A=
                };=0A=
                this.evil =3D function() {=0A=
                  try {=0A=
                    eval('1+2'); // eslint-disable-line no-eval=0A=
                  } catch (e) {=0A=
                    this.evilError =3D e.message;=0A=
                  }=0A=
                };=0A=
              });=0A=
        &lt;/file&gt;=0A=
        &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
          var util, webdriver;=0A=
=0A=
          var incBtn =3D element(by.id('inc'));=0A=
          var counter =3D element(by.id('counter'));=0A=
          var evilBtn =3D element(by.id('evil'));=0A=
          var evilError =3D element(by.id('evilError'));=0A=
=0A=
          function getAndClearSevereErrors() {=0A=
            return =
browser.manage().logs().get('browser').then(function(browserLog) {=0A=
              return browserLog.filter(function(logEntry) {=0A=
                return logEntry.level.value &gt; =
webdriver.logging.Level.WARNING.value;=0A=
              });=0A=
            });=0A=
          }=0A=
=0A=
          function clearErrors() {=0A=
            getAndClearSevereErrors();=0A=
          }=0A=
=0A=
          function expectNoErrors() {=0A=
            getAndClearSevereErrors().then(function(filteredLog) {=0A=
              expect(filteredLog.length).toEqual(0);=0A=
              if (filteredLog.length) {=0A=
                console.log('browser console errors: ' + =
util.inspect(filteredLog));=0A=
              }=0A=
            });=0A=
          }=0A=
=0A=
          function expectError(regex) {=0A=
            getAndClearSevereErrors().then(function(filteredLog) {=0A=
              var found =3D false;=0A=
              filteredLog.forEach(function(log) {=0A=
                if (log.message.match(regex)) {=0A=
                  found =3D true;=0A=
                }=0A=
              });=0A=
              if (!found) {=0A=
                throw new Error('expected an error that matches ' + =
regex);=0A=
              }=0A=
            });=0A=
          }=0A=
=0A=
          beforeEach(function() {=0A=
            util =3D require('util');=0A=
            webdriver =3D require('selenium-webdriver');=0A=
          });=0A=
=0A=
          // For now, we only test on Chrome,=0A=
          // as Safari does not load the page with Protractor's injected =
scripts,=0A=
          // and Firefox webdriver always disables content security =
policy (#6358)=0A=
          if (browser.params.browser !=3D=3D 'chrome') {=0A=
            return;=0A=
          }=0A=
=0A=
          it('should not report errors when the page is loaded', =
function() {=0A=
            // clear errors so we are not dependent on previous tests=0A=
            clearErrors();=0A=
            // Need to reload the page as the page is already loaded when=0A=
            // we come here=0A=
            browser.driver.getCurrentUrl().then(function(url) {=0A=
              browser.get(url);=0A=
            });=0A=
            expectNoErrors();=0A=
          });=0A=
=0A=
          it('should evaluate expressions', function() {=0A=
            expect(counter.getText()).toEqual('0');=0A=
            incBtn.click();=0A=
            expect(counter.getText()).toEqual('1');=0A=
            expectNoErrors();=0A=
          });=0A=
=0A=
          it('should throw and report an error when using "eval"', =
function() {=0A=
            evilBtn.click();=0A=
            expect(evilError.getText()).toMatch(/Content Security =
Policy/);=0A=
            expectError(/Content Security Policy/);=0A=
          });=0A=
        &lt;/file&gt;=0A=
      &lt;/example&gt;=0A=
  */=0A=
=0A=
// `ngCsp` is not implemented as a proper directive any more, because we =
need it be processed while=0A=
// we bootstrap the app (before `$parse` is instantiated). For this =
reason, we just have the `csp()`=0A=
// fn that looks for the `ng-csp` attribute anywhere in the current doc.=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngClick=0A=
 *=0A=
 * @description=0A=
 * The ngClick directive allows you to specify custom behavior when=0A=
 * an element is clicked.=0A=
 *=0A=
 * @element ANY=0A=
 * @priority 0=0A=
 * @param {expression} ngClick {@link guide/expression Expression} to =
evaluate upon=0A=
 * click. ({@link guide/expression#-event- Event object is available as =
`$event`})=0A=
 *=0A=
 * @example=0A=
   &lt;example name=3D"ng-click"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
      &lt;button ng-click=3D"count =3D count + 1" =
ng-init=3D"count=3D0"&gt;=0A=
        Increment=0A=
      &lt;/button&gt;=0A=
      &lt;span&gt;=0A=
        count: {{count}}=0A=
      &lt;/span&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should check ng-click', function() {=0A=
         expect(element(by.binding('count')).getText()).toMatch('0');=0A=
         element(by.css('button')).click();=0A=
         expect(element(by.binding('count')).getText()).toMatch('1');=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
/*=0A=
 * A collection of directives that allows creation of custom event =
handlers that are defined as=0A=
 * angular expressions and are compiled and executed within the current =
scope.=0A=
 */=0A=
var ngEventDirectives =3D {};=0A=
=0A=
// For events that might fire synchronously during DOM manipulation=0A=
// we need to execute their event handlers asynchronously using =
$evalAsync,=0A=
// so that they are not executed in an inconsistent state.=0A=
var forceAsyncEvents =3D {=0A=
  'blur': true,=0A=
  'focus': true=0A=
};=0A=
forEach(=0A=
  'click dblclick mousedown mouseup mouseover mouseout mousemove =
mouseenter mouseleave keydown keyup keypress submit focus blur copy cut =
paste'.split(' '),=0A=
  function(eventName) {=0A=
    var directiveName =3D directiveNormalize('ng-' + eventName);=0A=
    ngEventDirectives[directiveName] =3D ['$parse', '$rootScope', =
function($parse, $rootScope) {=0A=
      return {=0A=
        restrict: 'A',=0A=
        compile: function($element, attr) {=0A=
          // NOTE:=0A=
          // We expose the powerful `$event` object on the scope that =
provides access to the Window,=0A=
          // etc. This is OK, because expressions are not sandboxed any =
more (and the expression=0A=
          // sandbox was never meant to be a security feature anyway).=0A=
          var fn =3D $parse(attr[directiveName]);=0A=
          return function ngEventHandler(scope, element) {=0A=
            element.on(eventName, function(event) {=0A=
              var callback =3D function() {=0A=
                fn(scope, {$event: event});=0A=
              };=0A=
              if (forceAsyncEvents[eventName] &amp;&amp; =
$rootScope.$$phase) {=0A=
                scope.$evalAsync(callback);=0A=
              } else {=0A=
                scope.$apply(callback);=0A=
              }=0A=
            });=0A=
          };=0A=
        }=0A=
      };=0A=
    }];=0A=
  }=0A=
);=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngDblclick=0A=
 *=0A=
 * @description=0A=
 * The `ngDblclick` directive allows you to specify custom behavior on a =
dblclick event.=0A=
 *=0A=
 * @element ANY=0A=
 * @priority 0=0A=
 * @param {expression} ngDblclick {@link guide/expression Expression} to =
evaluate upon=0A=
 * a dblclick. (The Event object is available as `$event`)=0A=
 *=0A=
 * @example=0A=
   &lt;example name=3D"ng-dblclick"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
      &lt;button ng-dblclick=3D"count =3D count + 1" =
ng-init=3D"count=3D0"&gt;=0A=
        Increment (on double click)=0A=
      &lt;/button&gt;=0A=
      count: {{count}}=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngMousedown=0A=
 *=0A=
 * @description=0A=
 * The ngMousedown directive allows you to specify custom behavior on =
mousedown event.=0A=
 *=0A=
 * @element ANY=0A=
 * @priority 0=0A=
 * @param {expression} ngMousedown {@link guide/expression Expression} =
to evaluate upon=0A=
 * mousedown. ({@link guide/expression#-event- Event object is available =
as `$event`})=0A=
 *=0A=
 * @example=0A=
   &lt;example name=3D"ng-mousedown"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
      &lt;button ng-mousedown=3D"count =3D count + 1" =
ng-init=3D"count=3D0"&gt;=0A=
        Increment (on mouse down)=0A=
      &lt;/button&gt;=0A=
      count: {{count}}=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngMouseup=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on mouseup event.=0A=
 *=0A=
 * @element ANY=0A=
 * @priority 0=0A=
 * @param {expression} ngMouseup {@link guide/expression Expression} to =
evaluate upon=0A=
 * mouseup. ({@link guide/expression#-event- Event object is available =
as `$event`})=0A=
 *=0A=
 * @example=0A=
   &lt;example name=3D"ng-mouseup"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
      &lt;button ng-mouseup=3D"count =3D count + 1" =
ng-init=3D"count=3D0"&gt;=0A=
        Increment (on mouse up)=0A=
      &lt;/button&gt;=0A=
      count: {{count}}=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngMouseover=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on mouseover event.=0A=
 *=0A=
 * @element ANY=0A=
 * @priority 0=0A=
 * @param {expression} ngMouseover {@link guide/expression Expression} =
to evaluate upon=0A=
 * mouseover. ({@link guide/expression#-event- Event object is available =
as `$event`})=0A=
 *=0A=
 * @example=0A=
   &lt;example name=3D"ng-mouseover"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
      &lt;button ng-mouseover=3D"count =3D count + 1" =
ng-init=3D"count=3D0"&gt;=0A=
        Increment (when mouse is over)=0A=
      &lt;/button&gt;=0A=
      count: {{count}}=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngMouseenter=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on mouseenter event.=0A=
 *=0A=
 * @element ANY=0A=
 * @priority 0=0A=
 * @param {expression} ngMouseenter {@link guide/expression Expression} =
to evaluate upon=0A=
 * mouseenter. ({@link guide/expression#-event- Event object is =
available as `$event`})=0A=
 *=0A=
 * @example=0A=
   &lt;example name=3D"ng-mouseenter"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
      &lt;button ng-mouseenter=3D"count =3D count + 1" =
ng-init=3D"count=3D0"&gt;=0A=
        Increment (when mouse enters)=0A=
      &lt;/button&gt;=0A=
      count: {{count}}=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngMouseleave=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on mouseleave event.=0A=
 *=0A=
 * @element ANY=0A=
 * @priority 0=0A=
 * @param {expression} ngMouseleave {@link guide/expression Expression} =
to evaluate upon=0A=
 * mouseleave. ({@link guide/expression#-event- Event object is =
available as `$event`})=0A=
 *=0A=
 * @example=0A=
   &lt;example name=3D"ng-mouseleave"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
      &lt;button ng-mouseleave=3D"count =3D count + 1" =
ng-init=3D"count=3D0"&gt;=0A=
        Increment (when mouse leaves)=0A=
      &lt;/button&gt;=0A=
      count: {{count}}=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngMousemove=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on mousemove event.=0A=
 *=0A=
 * @element ANY=0A=
 * @priority 0=0A=
 * @param {expression} ngMousemove {@link guide/expression Expression} =
to evaluate upon=0A=
 * mousemove. ({@link guide/expression#-event- Event object is available =
as `$event`})=0A=
 *=0A=
 * @example=0A=
   &lt;example name=3D"ng-mousemove"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
      &lt;button ng-mousemove=3D"count =3D count + 1" =
ng-init=3D"count=3D0"&gt;=0A=
        Increment (when mouse moves)=0A=
      &lt;/button&gt;=0A=
      count: {{count}}=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngKeydown=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on keydown event.=0A=
 *=0A=
 * @element ANY=0A=
 * @priority 0=0A=
 * @param {expression} ngKeydown {@link guide/expression Expression} to =
evaluate upon=0A=
 * keydown. (Event object is available as `$event` and can be =
interrogated for keyCode, altKey, etc.)=0A=
 *=0A=
 * @example=0A=
   &lt;example name=3D"ng-keydown"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
      &lt;input ng-keydown=3D"count =3D count + 1" =
ng-init=3D"count=3D0"&gt;=0A=
      key down count: {{count}}=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngKeyup=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on keyup event.=0A=
 *=0A=
 * @element ANY=0A=
 * @priority 0=0A=
 * @param {expression} ngKeyup {@link guide/expression Expression} to =
evaluate upon=0A=
 * keyup. (Event object is available as `$event` and can be interrogated =
for keyCode, altKey, etc.)=0A=
 *=0A=
 * @example=0A=
   &lt;example name=3D"ng-keyup"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
       &lt;p&gt;Typing in the input box below updates the key =
count&lt;/p&gt;=0A=
       &lt;input ng-keyup=3D"count =3D count + 1" =
ng-init=3D"count=3D0"&gt; key up count: {{count}}=0A=
=0A=
       &lt;p&gt;Typing in the input box below updates the =
keycode&lt;/p&gt;=0A=
       &lt;input ng-keyup=3D"event=3D$event"&gt;=0A=
       &lt;p&gt;event keyCode: {{ event.keyCode }}&lt;/p&gt;=0A=
       &lt;p&gt;event altKey: {{ event.altKey }}&lt;/p&gt;=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngKeypress=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on keypress event.=0A=
 *=0A=
 * @element ANY=0A=
 * @param {expression} ngKeypress {@link guide/expression Expression} to =
evaluate upon=0A=
 * keypress. ({@link guide/expression#-event- Event object is available =
as `$event`}=0A=
 * and can be interrogated for keyCode, altKey, etc.)=0A=
 *=0A=
 * @example=0A=
   &lt;example name=3D"ng-keypress"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
      &lt;input ng-keypress=3D"count =3D count + 1" =
ng-init=3D"count=3D0"&gt;=0A=
      key press count: {{count}}=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngSubmit=0A=
 *=0A=
 * @description=0A=
 * Enables binding angular expressions to onsubmit events.=0A=
 *=0A=
 * Additionally it prevents the default action (which for form means =
sending the request to the=0A=
 * server and reloading the current page), but only if the form does not =
contain `action`,=0A=
 * `data-action`, or `x-action` attributes.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * **Warning:** Be careful not to cause "double-submission" by using =
both the `ngClick` and=0A=
 * `ngSubmit` handlers together. See the=0A=
 * {@link form#submitting-a-form-and-preventing-the-default-action =
`form` directive documentation}=0A=
 * for a detailed discussion of when `ngSubmit` may be triggered.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * @element form=0A=
 * @priority 0=0A=
 * @param {expression} ngSubmit {@link guide/expression Expression} to =
eval.=0A=
 * ({@link guide/expression#-event- Event object is available as =
`$event`})=0A=
 *=0A=
 * @example=0A=
   &lt;example module=3D"submitExample" name=3D"ng-submit"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
      &lt;script&gt;=0A=
        angular.module('submitExample', [])=0A=
          .controller('ExampleController', ['$scope', function($scope) {=0A=
            $scope.list =3D [];=0A=
            $scope.text =3D 'hello';=0A=
            $scope.submit =3D function() {=0A=
              if ($scope.text) {=0A=
                $scope.list.push(this.text);=0A=
                $scope.text =3D '';=0A=
              }=0A=
            };=0A=
          }]);=0A=
      &lt;/script&gt;=0A=
      &lt;form ng-submit=3D"submit()" =
ng-controller=3D"ExampleController"&gt;=0A=
        Enter text and hit enter:=0A=
        &lt;input type=3D"text" ng-model=3D"text" name=3D"text" /&gt;=0A=
        &lt;input type=3D"submit" id=3D"submit" value=3D"Submit" /&gt;=0A=
        &lt;pre&gt;list=3D{{list}}&lt;/pre&gt;=0A=
      &lt;/form&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should check ng-submit', function() {=0A=
         expect(element(by.binding('list')).getText()).toBe('list=3D[]');=0A=
         element(by.css('#submit')).click();=0A=
         =
expect(element(by.binding('list')).getText()).toContain('hello');=0A=
         =
expect(element(by.model('text')).getAttribute('value')).toBe('');=0A=
       });=0A=
       it('should ignore empty strings', function() {=0A=
         expect(element(by.binding('list')).getText()).toBe('list=3D[]');=0A=
         element(by.css('#submit')).click();=0A=
         element(by.css('#submit')).click();=0A=
         =
expect(element(by.binding('list')).getText()).toContain('hello');=0A=
        });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngFocus=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on focus event.=0A=
 *=0A=
 * Note: As the `focus` event is executed synchronously when calling =
`input.focus()`=0A=
 * AngularJS executes the expression using `scope.$evalAsync` if the =
event is fired=0A=
 * during an `$apply` to ensure a consistent state.=0A=
 *=0A=
 * @element window, input, select, textarea, a=0A=
 * @priority 0=0A=
 * @param {expression} ngFocus {@link guide/expression Expression} to =
evaluate upon=0A=
 * focus. ({@link guide/expression#-event- Event object is available as =
`$event`})=0A=
 *=0A=
 * @example=0A=
 * See {@link ng.directive:ngClick ngClick}=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngBlur=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on blur event.=0A=
 *=0A=
 * A [blur =
event](https://developer.mozilla.org/en-US/docs/Web/Events/blur) fires =
when=0A=
 * an element has lost focus.=0A=
 *=0A=
 * Note: As the `blur` event is executed synchronously also during DOM =
manipulations=0A=
 * (e.g. removing a focussed input),=0A=
 * AngularJS executes the expression using `scope.$evalAsync` if the =
event is fired=0A=
 * during an `$apply` to ensure a consistent state.=0A=
 *=0A=
 * @element window, input, select, textarea, a=0A=
 * @priority 0=0A=
 * @param {expression} ngBlur {@link guide/expression Expression} to =
evaluate upon=0A=
 * blur. ({@link guide/expression#-event- Event object is available as =
`$event`})=0A=
 *=0A=
 * @example=0A=
 * See {@link ng.directive:ngClick ngClick}=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngCopy=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on copy event.=0A=
 *=0A=
 * @element window, input, select, textarea, a=0A=
 * @priority 0=0A=
 * @param {expression} ngCopy {@link guide/expression Expression} to =
evaluate upon=0A=
 * copy. ({@link guide/expression#-event- Event object is available as =
`$event`})=0A=
 *=0A=
 * @example=0A=
   &lt;example name=3D"ng-copy"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
      &lt;input ng-copy=3D"copied=3Dtrue" ng-init=3D"copied=3Dfalse; =
value=3D'copy me'" ng-model=3D"value"&gt;=0A=
      copied: {{copied}}=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngCut=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on cut event.=0A=
 *=0A=
 * @element window, input, select, textarea, a=0A=
 * @priority 0=0A=
 * @param {expression} ngCut {@link guide/expression Expression} to =
evaluate upon=0A=
 * cut. ({@link guide/expression#-event- Event object is available as =
`$event`})=0A=
 *=0A=
 * @example=0A=
   &lt;example name=3D"ng-cut"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
      &lt;input ng-cut=3D"cut=3Dtrue" ng-init=3D"cut=3Dfalse; =
value=3D'cut me'" ng-model=3D"value"&gt;=0A=
      cut: {{cut}}=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngPaste=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on paste event.=0A=
 *=0A=
 * @element window, input, select, textarea, a=0A=
 * @priority 0=0A=
 * @param {expression} ngPaste {@link guide/expression Expression} to =
evaluate upon=0A=
 * paste. ({@link guide/expression#-event- Event object is available as =
`$event`})=0A=
 *=0A=
 * @example=0A=
   &lt;example name=3D"ng-paste"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
      &lt;input ng-paste=3D"paste=3Dtrue" ng-init=3D"paste=3Dfalse" =
placeholder=3D'paste here'&gt;=0A=
      pasted: {{paste}}=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngIf=0A=
 * @restrict A=0A=
 * @multiElement=0A=
 *=0A=
 * @description=0A=
 * The `ngIf` directive removes or recreates a portion of the DOM tree =
based on an=0A=
 * {expression}. If the expression assigned to `ngIf` evaluates to a =
false=0A=
 * value then the element is removed from the DOM, otherwise a clone of =
the=0A=
 * element is reinserted into the DOM.=0A=
 *=0A=
 * `ngIf` differs from `ngShow` and `ngHide` in that `ngIf` completely =
removes and recreates the=0A=
 * element in the DOM rather than changing its visibility via the =
`display` css property.  A common=0A=
 * case when this difference is significant is when using css selectors =
that rely on an element's=0A=
 * position within the DOM, such as the `:first-child` or `:last-child` =
pseudo-classes.=0A=
 *=0A=
 * Note that when an element is removed using `ngIf` its scope is =
destroyed and a new scope=0A=
 * is created when the element is restored.  The scope created within =
`ngIf` inherits from=0A=
 * its parent scope using=0A=
 * [prototypal =
inheritance](https://github.com/angular/angular.js/wiki/Understanding-Sco=
pes#javascript-prototypal-inheritance).=0A=
 * An important implication of this is if `ngModel` is used within =
`ngIf` to bind to=0A=
 * a javascript primitive defined in the parent scope. In this case any =
modifications made to the=0A=
 * variable within the child scope will override (hide) the value in the =
parent scope.=0A=
 *=0A=
 * Also, `ngIf` recreates elements using their compiled state. An =
example of this behavior=0A=
 * is if an element's class attribute is directly modified after it's =
compiled, using something like=0A=
 * jQuery's `.addClass()` method, and the element is later removed. When =
`ngIf` recreates the element=0A=
 * the added class will be lost because the original compiled state is =
used to regenerate the element.=0A=
 *=0A=
 * Additionally, you can provide animations via the `ngAnimate` module =
to animate the `enter`=0A=
 * and `leave` effects.=0A=
 *=0A=
 * @animations=0A=
 * | Animation                        | Occurs                           =
    |=0A=
 * =
|----------------------------------|-------------------------------------=
|=0A=
 * | {@link ng.$animate#enter enter}  | just after the `ngIf` contents =
change and a new DOM element is created and injected into the `ngIf` =
container |=0A=
 * | {@link ng.$animate#leave leave}  | just before the `ngIf` contents =
are removed from the DOM |=0A=
 *=0A=
 * @element ANY=0A=
 * @scope=0A=
 * @priority 600=0A=
 * @param {expression} ngIf If the {@link guide/expression expression} =
is falsy then=0A=
 *     the element is removed from the DOM tree. If it is truthy a copy =
of the compiled=0A=
 *     element is added to the DOM tree.=0A=
 *=0A=
 * @example=0A=
  &lt;example module=3D"ngAnimate" deps=3D"angular-animate.js" =
animations=3D"true" name=3D"ng-if"&gt;=0A=
    &lt;file name=3D"index.html"&gt;=0A=
      &lt;label&gt;Click me: &lt;input type=3D"checkbox" =
ng-model=3D"checked" ng-init=3D"checked=3Dtrue" =
/&gt;&lt;/label&gt;&lt;br/&gt;=0A=
      Show when checked:=0A=
      &lt;span ng-if=3D"checked" class=3D"animate-if"&gt;=0A=
        This is removed when the checkbox is unchecked.=0A=
      &lt;/span&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"animations.css"&gt;=0A=
      .animate-if {=0A=
        background:white;=0A=
        border:1px solid black;=0A=
        padding:10px;=0A=
      }=0A=
=0A=
      .animate-if.ng-enter, .animate-if.ng-leave {=0A=
        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;=0A=
      }=0A=
=0A=
      .animate-if.ng-enter,=0A=
      .animate-if.ng-leave.ng-leave-active {=0A=
        opacity:0;=0A=
      }=0A=
=0A=
      .animate-if.ng-leave,=0A=
      .animate-if.ng-enter.ng-enter-active {=0A=
        opacity:1;=0A=
      }=0A=
    &lt;/file&gt;=0A=
  &lt;/example&gt;=0A=
 */=0A=
var ngIfDirective =3D ['$animate', '$compile', function($animate, =
$compile) {=0A=
  return {=0A=
    multiElement: true,=0A=
    transclude: 'element',=0A=
    priority: 600,=0A=
    terminal: true,=0A=
    restrict: 'A',=0A=
    $$tlb: true,=0A=
    link: function($scope, $element, $attr, ctrl, $transclude) {=0A=
        var block, childScope, previousElements;=0A=
        $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {=0A=
=0A=
          if (value) {=0A=
            if (!childScope) {=0A=
              $transclude(function(clone, newScope) {=0A=
                childScope =3D newScope;=0A=
                clone[clone.length++] =3D $compile.$$createComment('end =
ngIf', $attr.ngIf);=0A=
                // Note: We only need the first/last node of the cloned =
nodes.=0A=
                // However, we need to keep the reference to the jqlite =
wrapper as it might be changed later=0A=
                // by a directive with templateUrl when its template =
arrives.=0A=
                block =3D {=0A=
                  clone: clone=0A=
                };=0A=
                $animate.enter(clone, $element.parent(), $element);=0A=
              });=0A=
            }=0A=
          } else {=0A=
            if (previousElements) {=0A=
              previousElements.remove();=0A=
              previousElements =3D null;=0A=
            }=0A=
            if (childScope) {=0A=
              childScope.$destroy();=0A=
              childScope =3D null;=0A=
            }=0A=
            if (block) {=0A=
              previousElements =3D getBlockNodes(block.clone);=0A=
              $animate.leave(previousElements).done(function(response) {=0A=
                if (response !=3D=3D false) previousElements =3D null;=0A=
              });=0A=
              block =3D null;=0A=
            }=0A=
          }=0A=
        });=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngInclude=0A=
 * @restrict ECA=0A=
 *=0A=
 * @description=0A=
 * Fetches, compiles and includes an external HTML fragment.=0A=
 *=0A=
 * By default, the template URL is restricted to the same domain and =
protocol as the=0A=
 * application document. This is done by calling {@link =
$sce#getTrustedResourceUrl=0A=
 * $sce.getTrustedResourceUrl} on it. To load templates from other =
domains or protocols=0A=
 * you may either {@link ng.$sceDelegateProvider#resourceUrlWhitelist =
whitelist them} or=0A=
 * {@link $sce#trustAsResourceUrl wrap them} as trusted values. Refer to =
Angular's {@link=0A=
 * ng.$sce Strict Contextual Escaping}.=0A=
 *=0A=
 * In addition, the browser's=0A=
 * [Same Origin =
Policy](https://code.google.com/p/browsersec/wiki/Part2#Same-origin_polic=
y_for_XMLHttpRequest)=0A=
 * and [Cross-Origin Resource Sharing (CORS)](http://www.w3.org/TR/cors/)=0A=
 * policy may further restrict whether the template is successfully =
loaded.=0A=
 * For example, `ngInclude` won't work for cross-domain requests on all =
browsers and for `file://`=0A=
 * access on some browsers.=0A=
 *=0A=
 * @animations=0A=
 * | Animation                        | Occurs                           =
   |=0A=
 * =
|----------------------------------|-------------------------------------=
|=0A=
 * | {@link ng.$animate#enter enter}  | when the expression changes, on =
the new include |=0A=
 * | {@link ng.$animate#leave leave}  | when the expression changes, on =
the old include |=0A=
 *=0A=
 * The enter and leave animation occur concurrently.=0A=
 *=0A=
 * @scope=0A=
 * @priority 400=0A=
 *=0A=
 * @param {string} ngInclude|src angular expression evaluating to URL. =
If the source is a string constant,=0A=
 *                 make sure you wrap it in **single** quotes, e.g. =
`src=3D"'myPartialTemplate.html'"`.=0A=
 * @param {string=3D} onload Expression to evaluate when a new partial =
is loaded.=0A=
 *                  &lt;div class=3D"alert alert-warning"&gt;=0A=
 *                  **Note:** When using onload on SVG elements in IE11, =
the browser will try to call=0A=
 *                  a function with the name on the window element, =
which will usually throw a=0A=
 *                  "function is undefined" error. To fix this, you can =
instead use `data-onload` or a=0A=
 *                  different form that {@link =
guide/directive#normalization matches} `onload`.=0A=
 *                  &lt;/div&gt;=0A=
   *=0A=
 * @param {string=3D} autoscroll Whether `ngInclude` should call {@link =
ng.$anchorScroll=0A=
 *                  $anchorScroll} to scroll the viewport after the =
content is loaded.=0A=
 *=0A=
 *                  - If the attribute is not set, disable scrolling.=0A=
 *                  - If the attribute is set without value, enable =
scrolling.=0A=
 *                  - Otherwise enable scrolling only if the expression =
evaluates to truthy value.=0A=
 *=0A=
 * @example=0A=
  &lt;example module=3D"includeExample" deps=3D"angular-animate.js" =
animations=3D"true" name=3D"ng-include"&gt;=0A=
    &lt;file name=3D"index.html"&gt;=0A=
     &lt;div ng-controller=3D"ExampleController"&gt;=0A=
       &lt;select ng-model=3D"template" ng-options=3D"t.name for t in =
templates"&gt;=0A=
        &lt;option value=3D""&gt;(blank)&lt;/option&gt;=0A=
       &lt;/select&gt;=0A=
       url of the template: &lt;code&gt;{{template.url}}&lt;/code&gt;=0A=
       &lt;hr/&gt;=0A=
       &lt;div class=3D"slide-animate-container"&gt;=0A=
         &lt;div class=3D"slide-animate" =
ng-include=3D"template.url"&gt;&lt;/div&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/div&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"script.js"&gt;=0A=
      angular.module('includeExample', ['ngAnimate'])=0A=
        .controller('ExampleController', ['$scope', function($scope) {=0A=
          $scope.templates =3D=0A=
            [{ name: 'template1.html', url: 'template1.html'},=0A=
             { name: 'template2.html', url: 'template2.html'}];=0A=
          $scope.template =3D $scope.templates[0];=0A=
        }]);=0A=
     &lt;/file&gt;=0A=
    &lt;file name=3D"template1.html"&gt;=0A=
      Content of template1.html=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"template2.html"&gt;=0A=
      Content of template2.html=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"animations.css"&gt;=0A=
      .slide-animate-container {=0A=
        position:relative;=0A=
        background:white;=0A=
        border:1px solid black;=0A=
        height:40px;=0A=
        overflow:hidden;=0A=
      }=0A=
=0A=
      .slide-animate {=0A=
        padding:10px;=0A=
      }=0A=
=0A=
      .slide-animate.ng-enter, .slide-animate.ng-leave {=0A=
        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;=0A=
=0A=
        position:absolute;=0A=
        top:0;=0A=
        left:0;=0A=
        right:0;=0A=
        bottom:0;=0A=
        display:block;=0A=
        padding:10px;=0A=
      }=0A=
=0A=
      .slide-animate.ng-enter {=0A=
        top:-50px;=0A=
      }=0A=
      .slide-animate.ng-enter.ng-enter-active {=0A=
        top:0;=0A=
      }=0A=
=0A=
      .slide-animate.ng-leave {=0A=
        top:0;=0A=
      }=0A=
      .slide-animate.ng-leave.ng-leave-active {=0A=
        top:50px;=0A=
      }=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
      var templateSelect =3D element(by.model('template'));=0A=
      var includeElem =3D element(by.css('[ng-include]'));=0A=
=0A=
      it('should load template1.html', function() {=0A=
        expect(includeElem.getText()).toMatch(/Content of =
template1.html/);=0A=
      });=0A=
=0A=
      it('should load template2.html', function() {=0A=
        if (browser.params.browser =3D=3D=3D 'firefox') {=0A=
          // Firefox can't handle using selects=0A=
          // See https://github.com/angular/protractor/issues/480=0A=
          return;=0A=
        }=0A=
        templateSelect.click();=0A=
        templateSelect.all(by.css('option')).get(2).click();=0A=
        expect(includeElem.getText()).toMatch(/Content of =
template2.html/);=0A=
      });=0A=
=0A=
      it('should change to blank', function() {=0A=
        if (browser.params.browser =3D=3D=3D 'firefox') {=0A=
          // Firefox can't handle using selects=0A=
          return;=0A=
        }=0A=
        templateSelect.click();=0A=
        templateSelect.all(by.css('option')).get(0).click();=0A=
        expect(includeElem.isPresent()).toBe(false);=0A=
      });=0A=
    &lt;/file&gt;=0A=
  &lt;/example&gt;=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc event=0A=
 * @name ngInclude#$includeContentRequested=0A=
 * @eventType emit on the scope ngInclude was declared in=0A=
 * @description=0A=
 * Emitted every time the ngInclude content is requested.=0A=
 *=0A=
 * @param {Object} angularEvent Synthetic event object.=0A=
 * @param {String} src URL of content to load.=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc event=0A=
 * @name ngInclude#$includeContentLoaded=0A=
 * @eventType emit on the current ngInclude scope=0A=
 * @description=0A=
 * Emitted every time the ngInclude content is reloaded.=0A=
 *=0A=
 * @param {Object} angularEvent Synthetic event object.=0A=
 * @param {String} src URL of content to load.=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc event=0A=
 * @name ngInclude#$includeContentError=0A=
 * @eventType emit on the scope ngInclude was declared in=0A=
 * @description=0A=
 * Emitted when a template HTTP request yields an erroneous response =
(status &lt; 200 || status &gt; 299)=0A=
 *=0A=
 * @param {Object} angularEvent Synthetic event object.=0A=
 * @param {String} src URL of content to load.=0A=
 */=0A=
var ngIncludeDirective =3D ['$templateRequest', '$anchorScroll', =
'$animate',=0A=
                  function($templateRequest,   $anchorScroll,   =
$animate) {=0A=
  return {=0A=
    restrict: 'ECA',=0A=
    priority: 400,=0A=
    terminal: true,=0A=
    transclude: 'element',=0A=
    controller: angular.noop,=0A=
    compile: function(element, attr) {=0A=
      var srcExp =3D attr.ngInclude || attr.src,=0A=
          onloadExp =3D attr.onload || '',=0A=
          autoScrollExp =3D attr.autoscroll;=0A=
=0A=
      return function(scope, $element, $attr, ctrl, $transclude) {=0A=
        var changeCounter =3D 0,=0A=
            currentScope,=0A=
            previousElement,=0A=
            currentElement;=0A=
=0A=
        var cleanupLastIncludeContent =3D function() {=0A=
          if (previousElement) {=0A=
            previousElement.remove();=0A=
            previousElement =3D null;=0A=
          }=0A=
          if (currentScope) {=0A=
            currentScope.$destroy();=0A=
            currentScope =3D null;=0A=
          }=0A=
          if (currentElement) {=0A=
            $animate.leave(currentElement).done(function(response) {=0A=
              if (response !=3D=3D false) previousElement =3D null;=0A=
            });=0A=
            previousElement =3D currentElement;=0A=
            currentElement =3D null;=0A=
          }=0A=
        };=0A=
=0A=
        scope.$watch(srcExp, function ngIncludeWatchAction(src) {=0A=
          var afterAnimation =3D function(response) {=0A=
            if (response !=3D=3D false &amp;&amp; =
isDefined(autoScrollExp) &amp;&amp;=0A=
              (!autoScrollExp || scope.$eval(autoScrollExp))) {=0A=
                $anchorScroll();=0A=
            }=0A=
          };=0A=
          var thisChangeId =3D ++changeCounter;=0A=
=0A=
          if (src) {=0A=
            //set the 2nd param to true to ignore the template request =
error so that the inner=0A=
            //contents and scope can be cleaned up.=0A=
            $templateRequest(src, true).then(function(response) {=0A=
              if (scope.$$destroyed) return;=0A=
=0A=
              if (thisChangeId !=3D=3D changeCounter) return;=0A=
              var newScope =3D scope.$new();=0A=
              ctrl.template =3D response;=0A=
=0A=
              // Note: This will also link all children of ng-include =
that were contained in the original=0A=
              // html. If that content contains controllers, ... they =
could pollute/change the scope.=0A=
              // However, using ng-include on an element with additional =
content does not make sense...=0A=
              // Note: We can't remove them in the cloneAttchFn of =
$transclude as that=0A=
              // function is called before linking the content, which =
would apply child=0A=
              // directives to non existing elements.=0A=
              var clone =3D $transclude(newScope, function(clone) {=0A=
                cleanupLastIncludeContent();=0A=
                $animate.enter(clone, null, =
$element).done(afterAnimation);=0A=
              });=0A=
=0A=
              currentScope =3D newScope;=0A=
              currentElement =3D clone;=0A=
=0A=
              currentScope.$emit('$includeContentLoaded', src);=0A=
              scope.$eval(onloadExp);=0A=
            }, function() {=0A=
              if (scope.$$destroyed) return;=0A=
=0A=
              if (thisChangeId =3D=3D=3D changeCounter) {=0A=
                cleanupLastIncludeContent();=0A=
                scope.$emit('$includeContentError', src);=0A=
              }=0A=
            });=0A=
            scope.$emit('$includeContentRequested', src);=0A=
          } else {=0A=
            cleanupLastIncludeContent();=0A=
            ctrl.template =3D null;=0A=
          }=0A=
        });=0A=
      };=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
// This directive is called during the $transclude call of the first =
`ngInclude` directive.=0A=
// It will replace and compile the content of the element with the =
loaded template.=0A=
// We need this directive so that the element content is already filled =
when=0A=
// the link function of another directive on the same element as =
ngInclude=0A=
// is called.=0A=
var ngIncludeFillContentDirective =3D ['$compile',=0A=
  function($compile) {=0A=
    return {=0A=
      restrict: 'ECA',=0A=
      priority: -400,=0A=
      require: 'ngInclude',=0A=
      link: function(scope, $element, $attr, ctrl) {=0A=
        if (toString.call($element[0]).match(/SVG/)) {=0A=
          // WebKit: https://bugs.webkit.org/show_bug.cgi?id=3D135698 =
--- SVG elements do not=0A=
          // support innerHTML, so detect this here and try to generate =
the contents=0A=
          // specially.=0A=
          $element.empty();=0A=
          $compile(jqLiteBuildFragment(ctrl.template, =
window.document).childNodes)(scope,=0A=
              function namespaceAdaptedClone(clone) {=0A=
            $element.append(clone);=0A=
          }, {futureParentElement: $element});=0A=
          return;=0A=
        }=0A=
=0A=
        $element.html(ctrl.template);=0A=
        $compile($element.contents())(scope);=0A=
      }=0A=
    };=0A=
  }];=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngInit=0A=
 * @restrict AC=0A=
 *=0A=
 * @description=0A=
 * The `ngInit` directive allows you to evaluate an expression in the=0A=
 * current scope.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-danger"&gt;=0A=
 * This directive can be abused to add unnecessary amounts of logic into =
your templates.=0A=
 * There are only a few appropriate uses of `ngInit`, such as for =
aliasing special properties of=0A=
 * {@link ng.directive:ngRepeat `ngRepeat`}, as seen in the demo below; =
and for injecting data via=0A=
 * server side scripting. Besides these few cases, you should use {@link =
guide/controller controllers}=0A=
 * rather than `ngInit` to initialize values on a scope.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * **Note**: If you have assignment in `ngInit` along with a {@link =
ng.$filter `filter`}, make=0A=
 * sure you have parentheses to ensure correct operator precedence:=0A=
 * &lt;pre class=3D"prettyprint"&gt;=0A=
 * `&lt;div ng-init=3D"test1 =3D ($index | toString)"&gt;&lt;/div&gt;`=0A=
 * &lt;/pre&gt;=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * @priority 450=0A=
 *=0A=
 * @element ANY=0A=
 * @param {expression} ngInit {@link guide/expression Expression} to =
eval.=0A=
 *=0A=
 * @example=0A=
   &lt;example module=3D"initExample" name=3D"ng-init"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
   &lt;script&gt;=0A=
     angular.module('initExample', [])=0A=
       .controller('ExampleController', ['$scope', function($scope) {=0A=
         $scope.list =3D [['a', 'b'], ['c', 'd']];=0A=
       }]);=0A=
   &lt;/script&gt;=0A=
   &lt;div ng-controller=3D"ExampleController"&gt;=0A=
     &lt;div ng-repeat=3D"innerList in list" ng-init=3D"outerIndex =3D =
$index"&gt;=0A=
       &lt;div ng-repeat=3D"value in innerList" ng-init=3D"innerIndex =
=3D $index"&gt;=0A=
          &lt;span class=3D"example-init"&gt;list[ {{outerIndex}} ][ =
{{innerIndex}} ] =3D {{value}};&lt;/span&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/div&gt;=0A=
   &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should alias index positions', function() {=0A=
         var elements =3D element.all(by.css('.example-init'));=0A=
         expect(elements.get(0).getText()).toBe('list[ 0 ][ 0 ] =3D a;');=0A=
         expect(elements.get(1).getText()).toBe('list[ 0 ][ 1 ] =3D b;');=0A=
         expect(elements.get(2).getText()).toBe('list[ 1 ][ 0 ] =3D c;');=0A=
         expect(elements.get(3).getText()).toBe('list[ 1 ][ 1 ] =3D d;');=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
var ngInitDirective =3D ngDirective({=0A=
  priority: 450,=0A=
  compile: function() {=0A=
    return {=0A=
      pre: function(scope, element, attrs) {=0A=
        scope.$eval(attrs.ngInit);=0A=
      }=0A=
    };=0A=
  }=0A=
});=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngList=0A=
 *=0A=
 * @description=0A=
 * Text input that converts between a delimited string and an array of =
strings. The default=0A=
 * delimiter is a comma followed by a space - equivalent to =
`ng-list=3D", "`. You can specify a custom=0A=
 * delimiter as the value of the `ngList` attribute - for example, =
`ng-list=3D" | "`.=0A=
 *=0A=
 * The behaviour of the directive is affected by the use of the `ngTrim` =
attribute.=0A=
 * * If `ngTrim` is set to `"false"` then whitespace around both the =
separator and each=0A=
 *   list item is respected. This implies that the user of the directive =
is responsible for=0A=
 *   dealing with whitespace but also allows you to use whitespace as a =
delimiter, such as a=0A=
 *   tab or newline character.=0A=
 * * Otherwise whitespace around the delimiter is ignored when splitting =
(although it is respected=0A=
 *   when joining the list items back together) and whitespace around =
each list item is stripped=0A=
 *   before it is added to the model.=0A=
 *=0A=
 * ### Example with Validation=0A=
 *=0A=
 * &lt;example name=3D"ngList-directive" module=3D"listExample"&gt;=0A=
 *   &lt;file name=3D"app.js"&gt;=0A=
 *      angular.module('listExample', [])=0A=
 *        .controller('ExampleController', ['$scope', function($scope) {=0A=
 *          $scope.names =3D ['morpheus', 'neo', 'trinity'];=0A=
 *        }]);=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"index.html"&gt;=0A=
 *    &lt;form name=3D"myForm" ng-controller=3D"ExampleController"&gt;=0A=
 *      &lt;label&gt;List: &lt;input name=3D"namesInput" =
ng-model=3D"names" ng-list required&gt;&lt;/label&gt;=0A=
 *      &lt;span role=3D"alert"&gt;=0A=
 *        &lt;span class=3D"error" =
ng-show=3D"myForm.namesInput.$error.required"&gt;=0A=
 *        Required!&lt;/span&gt;=0A=
 *      &lt;/span&gt;=0A=
 *      &lt;br&gt;=0A=
 *      &lt;tt&gt;names =3D {{names}}&lt;/tt&gt;&lt;br/&gt;=0A=
 *      &lt;tt&gt;myForm.namesInput.$valid =3D =
{{myForm.namesInput.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
 *      &lt;tt&gt;myForm.namesInput.$error =3D =
{{myForm.namesInput.$error}}&lt;/tt&gt;&lt;br/&gt;=0A=
 *      &lt;tt&gt;myForm.$valid =3D =
{{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
 *      &lt;tt&gt;myForm.$error.required =3D =
{{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;=0A=
 *     &lt;/form&gt;=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
 *     var listInput =3D element(by.model('names'));=0A=
 *     var names =3D element(by.exactBinding('names'));=0A=
 *     var valid =3D element(by.binding('myForm.namesInput.$valid'));=0A=
 *     var error =3D element(by.css('span.error'));=0A=
 *=0A=
 *     it('should initialize to model', function() {=0A=
 *       =
expect(names.getText()).toContain('["morpheus","neo","trinity"]');=0A=
 *       expect(valid.getText()).toContain('true');=0A=
 *       expect(error.getCssValue('display')).toBe('none');=0A=
 *     });=0A=
 *=0A=
 *     it('should be invalid if empty', function() {=0A=
 *       listInput.clear();=0A=
 *       listInput.sendKeys('');=0A=
 *=0A=
 *       expect(names.getText()).toContain('');=0A=
 *       expect(valid.getText()).toContain('false');=0A=
 *       expect(error.getCssValue('display')).not.toBe('none');=0A=
 *     });=0A=
 *   &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 *=0A=
 * ### Example - splitting on newline=0A=
 * &lt;example name=3D"ngList-directive-newlines"&gt;=0A=
 *   &lt;file name=3D"index.html"&gt;=0A=
 *    &lt;textarea ng-model=3D"list" ng-list=3D"&amp;#10;" =
ng-trim=3D"false"&gt;&lt;/textarea&gt;=0A=
 *    &lt;pre&gt;{{ list | json }}&lt;/pre&gt;=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
 *     it("should split the text by newlines", function() {=0A=
 *       var listInput =3D element(by.model('list'));=0A=
 *       var output =3D element(by.binding('list | json'));=0A=
 *       listInput.sendKeys('abc\ndef\nghi');=0A=
 *       expect(output.getText()).toContain('[\n  "abc",\n  "def",\n  =
"ghi"\n]');=0A=
 *     });=0A=
 *   &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 *=0A=
 * @element input=0A=
 * @param {string=3D} ngList optional delimiter that should be used to =
split the value.=0A=
 */=0A=
var ngListDirective =3D function() {=0A=
  return {=0A=
    restrict: 'A',=0A=
    priority: 100,=0A=
    require: 'ngModel',=0A=
    link: function(scope, element, attr, ctrl) {=0A=
      var ngList =3D attr.ngList || ', ';=0A=
      var trimValues =3D attr.ngTrim !=3D=3D 'false';=0A=
      var separator =3D trimValues ? trim(ngList) : ngList;=0A=
=0A=
      var parse =3D function(viewValue) {=0A=
        // If the viewValue is invalid (say required but empty) it will =
be `undefined`=0A=
        if (isUndefined(viewValue)) return;=0A=
=0A=
        var list =3D [];=0A=
=0A=
        if (viewValue) {=0A=
          forEach(viewValue.split(separator), function(value) {=0A=
            if (value) list.push(trimValues ? trim(value) : value);=0A=
          });=0A=
        }=0A=
=0A=
        return list;=0A=
      };=0A=
=0A=
      ctrl.$parsers.push(parse);=0A=
      ctrl.$formatters.push(function(value) {=0A=
        if (isArray(value)) {=0A=
          return value.join(ngList);=0A=
        }=0A=
=0A=
        return undefined;=0A=
      });=0A=
=0A=
      // Override the standard $isEmpty because an empty array means the =
input is empty.=0A=
      ctrl.$isEmpty =3D function(value) {=0A=
        return !value || !value.length;=0A=
      };=0A=
    }=0A=
  };=0A=
};=0A=
=0A=
/* global VALID_CLASS: true,=0A=
  INVALID_CLASS: true,=0A=
  PRISTINE_CLASS: true,=0A=
  DIRTY_CLASS: true,=0A=
  UNTOUCHED_CLASS: true,=0A=
  TOUCHED_CLASS: true,=0A=
  PENDING_CLASS: true,=0A=
  addSetValidityMethod: true,=0A=
  setupValidity: true,=0A=
  defaultModelOptions: false=0A=
*/=0A=
=0A=
=0A=
var VALID_CLASS =3D 'ng-valid',=0A=
    INVALID_CLASS =3D 'ng-invalid',=0A=
    PRISTINE_CLASS =3D 'ng-pristine',=0A=
    DIRTY_CLASS =3D 'ng-dirty',=0A=
    UNTOUCHED_CLASS =3D 'ng-untouched',=0A=
    TOUCHED_CLASS =3D 'ng-touched',=0A=
    EMPTY_CLASS =3D 'ng-empty',=0A=
    NOT_EMPTY_CLASS =3D 'ng-not-empty';=0A=
=0A=
var ngModelMinErr =3D minErr('ngModel');=0A=
=0A=
/**=0A=
 * @ngdoc type=0A=
 * @name ngModel.NgModelController=0A=
 *=0A=
 * @property {*} $viewValue The actual value from the control's view. =
For `input` elements, this is a=0A=
 * String. See {@link ngModel.NgModelController#$setViewValue} for =
information about when the $viewValue=0A=
 * is set.=0A=
 *=0A=
 * @property {*} $modelValue The value in the model that the control is =
bound to.=0A=
 *=0A=
 * @property {Array.&lt;Function&gt;} $parsers Array of functions to =
execute, as a pipeline, whenever=0A=
 *  the control updates the ngModelController with a new {@link =
ngModel.NgModelController#$viewValue=0A=
    `$viewValue`} from the DOM, usually via user input.=0A=
    See {@link ngModel.NgModelController#$setViewValue =
`$setViewValue()`} for a detailed lifecycle explanation.=0A=
    Note that the `$parsers` are not called when the bound ngModel =
expression changes programmatically.=0A=
=0A=
  The functions are called in array order, each passing=0A=
    its return value through to the next. The last return value is =
forwarded to the=0A=
    {@link ngModel.NgModelController#$validators `$validators`} =
collection.=0A=
=0A=
  Parsers are used to sanitize / convert the {@link =
ngModel.NgModelController#$viewValue=0A=
    `$viewValue`}.=0A=
=0A=
  Returning `undefined` from a parser means a parse error occurred. In =
that case,=0A=
    no {@link ngModel.NgModelController#$validators `$validators`} will =
run and the `ngModel`=0A=
    will be set to `undefined` unless {@link ngModelOptions =
`ngModelOptions.allowInvalid`}=0A=
    is set to `true`. The parse error is stored in =
`ngModel.$error.parse`.=0A=
=0A=
  This simple example shows a parser that would convert text input value =
to lowercase:=0A=
 * ```js=0A=
 * function parse(value) {=0A=
 *   if (value) {=0A=
 *     return value.toLowerCase();=0A=
 *   }=0A=
 * }=0A=
 * ngModelController.$parsers.push(parse);=0A=
 * ```=0A=
=0A=
 *=0A=
 * @property {Array.&lt;Function&gt;} $formatters Array of functions to =
execute, as a pipeline, whenever=0A=
    the bound ngModel expression changes programmatically. The =
`$formatters` are not called when the=0A=
    value of the control is changed by user interaction.=0A=
=0A=
  Formatters are used to format / convert the {@link =
ngModel.NgModelController#$modelValue=0A=
    `$modelValue`} for display in the control.=0A=
=0A=
  The functions are called in reverse array order, each passing the =
value through to the=0A=
    next. The last return value is used as the actual DOM value.=0A=
=0A=
  This simple example shows a formatter that would convert the model =
value to uppercase:=0A=
=0A=
 * ```js=0A=
 * function format(value) {=0A=
 *   if (value) {=0A=
 *     return value.toUpperCase();=0A=
 *   }=0A=
 * }=0A=
 * ngModel.$formatters.push(format);=0A=
 * ```=0A=
 *=0A=
 * @property {Object.&lt;string, function&gt;} $validators A collection =
of validators that are applied=0A=
 *      whenever the model value changes. The key value within the =
object refers to the name of the=0A=
 *      validator while the function refers to the validation operation. =
The validation operation is=0A=
 *      provided with the model value as an argument and must return a =
true or false value depending=0A=
 *      on the response of that validation.=0A=
 *=0A=
 * ```js=0A=
 * ngModel.$validators.validCharacters =3D function(modelValue, =
viewValue) {=0A=
 *   var value =3D modelValue || viewValue;=0A=
 *   return /[0-9]+/.test(value) &amp;&amp;=0A=
 *          /[a-z]+/.test(value) &amp;&amp;=0A=
 *          /[A-Z]+/.test(value) &amp;&amp;=0A=
 *          /\W+/.test(value);=0A=
 * };=0A=
 * ```=0A=
 *=0A=
 * @property {Object.&lt;string, function&gt;} $asyncValidators A =
collection of validations that are expected to=0A=
 *      perform an asynchronous validation (e.g. a HTTP request). The =
validation function that is provided=0A=
 *      is expected to return a promise when it is run during the model =
validation process. Once the promise=0A=
 *      is delivered then the validation status will be set to true when =
fulfilled and false when rejected.=0A=
 *      When the asynchronous validators are triggered, each of the =
validators will run in parallel and the model=0A=
 *      value will only be updated once all validators have been =
fulfilled. As long as an asynchronous validator=0A=
 *      is unfulfilled, its key will be added to the controllers =
`$pending` property. Also, all asynchronous validators=0A=
 *      will only run once all synchronous validators have passed.=0A=
 *=0A=
 * Please note that if $http is used then it is important that the =
server returns a success HTTP response code=0A=
 * in order to fulfill the validation and a status level of `4xx` in =
order to reject the validation.=0A=
 *=0A=
 * ```js=0A=
 * ngModel.$asyncValidators.uniqueUsername =3D function(modelValue, =
viewValue) {=0A=
 *   var value =3D modelValue || viewValue;=0A=
 *=0A=
 *   // Lookup user by username=0A=
 *   return $http.get('/api/users/' + value).=0A=
 *      then(function resolved() {=0A=
 *        //username exists, this means validation fails=0A=
 *        return $q.reject('exists');=0A=
 *      }, function rejected() {=0A=
 *        //username does not exist, therefore this validation passes=0A=
 *        return true;=0A=
 *      });=0A=
 * };=0A=
 * ```=0A=
 *=0A=
 * @property {Array.&lt;Function&gt;} $viewChangeListeners Array of =
functions to execute whenever the=0A=
 *     view value has changed. It is called with no arguments, and its =
return value is ignored.=0A=
 *     This can be used in place of additional $watches against the =
model value.=0A=
 *=0A=
 * @property {Object} $error An object hash with all failing validator =
ids as keys.=0A=
 * @property {Object} $pending An object hash with all pending validator =
ids as keys.=0A=
 *=0A=
 * @property {boolean} $untouched True if control has not lost focus yet.=0A=
 * @property {boolean} $touched True if control has lost focus.=0A=
 * @property {boolean} $pristine True if user has not interacted with =
the control yet.=0A=
 * @property {boolean} $dirty True if user has already interacted with =
the control.=0A=
 * @property {boolean} $valid True if there is no error.=0A=
 * @property {boolean} $invalid True if at least one error on the =
control.=0A=
 * @property {string} $name The name attribute of the control.=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * `NgModelController` provides API for the {@link ngModel `ngModel`} =
directive.=0A=
 * The controller contains services for data-binding, validation, CSS =
updates, and value formatting=0A=
 * and parsing. It purposefully does not contain any logic which deals =
with DOM rendering or=0A=
 * listening to DOM events.=0A=
 * Such DOM related logic should be provided by other directives which =
make use of=0A=
 * `NgModelController` for data-binding to control elements.=0A=
 * Angular provides this DOM logic for most {@link input `input`} =
elements.=0A=
 * At the end of this page you can find a {@link =
ngModel.NgModelController#custom-control-example=0A=
 * custom control example} that uses `ngModelController` to bind to =
`contenteditable` elements.=0A=
 *=0A=
 * @example=0A=
 * ### Custom Control Example=0A=
 * This example shows how to use `NgModelController` with a custom =
control to achieve=0A=
 * data-binding. Notice how different directives (`contenteditable`, =
`ng-model`, and `required`)=0A=
 * collaborate together to achieve the desired result.=0A=
 *=0A=
 * `contenteditable` is an HTML5 attribute, which tells the browser to =
let the element=0A=
 * contents be edited in place by the user.=0A=
 *=0A=
 * We are using the {@link ng.service:$sce $sce} service here and =
include the {@link ngSanitize $sanitize}=0A=
 * module to automatically remove "bad" content like inline event =
listener (e.g. `&lt;span onclick=3D"..."&gt;`).=0A=
 * However, as we are using `$sce` the model can still decide to provide =
unsafe content if it marks=0A=
 * that content using the `$sce` service.=0A=
 *=0A=
 * &lt;example name=3D"NgModelController" module=3D"customControl" =
deps=3D"angular-sanitize.js"&gt;=0A=
    &lt;file name=3D"style.css"&gt;=0A=
      [contenteditable] {=0A=
        border: 1px solid black;=0A=
        background-color: white;=0A=
        min-height: 20px;=0A=
      }=0A=
=0A=
      .ng-invalid {=0A=
        border: 1px solid red;=0A=
      }=0A=
=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"script.js"&gt;=0A=
      angular.module('customControl', ['ngSanitize']).=0A=
        directive('contenteditable', ['$sce', function($sce) {=0A=
          return {=0A=
            restrict: 'A', // only activate on element attribute=0A=
            require: '?ngModel', // get a hold of NgModelController=0A=
            link: function(scope, element, attrs, ngModel) {=0A=
              if (!ngModel) return; // do nothing if no ng-model=0A=
=0A=
              // Specify how UI should be updated=0A=
              ngModel.$render =3D function() {=0A=
                element.html($sce.getTrustedHtml(ngModel.$viewValue || =
''));=0A=
              };=0A=
=0A=
              // Listen for change events to enable binding=0A=
              element.on('blur keyup change', function() {=0A=
                scope.$evalAsync(read);=0A=
              });=0A=
              read(); // initialize=0A=
=0A=
              // Write data to the model=0A=
              function read() {=0A=
                var html =3D element.html();=0A=
                // When we clear the content editable the browser leaves =
a &lt;br&gt; behind=0A=
                // If strip-br attribute is provided then we strip this =
out=0A=
                if (attrs.stripBr &amp;&amp; html =3D=3D=3D =
'&lt;br&gt;') {=0A=
                  html =3D '';=0A=
                }=0A=
                ngModel.$setViewValue(html);=0A=
              }=0A=
            }=0A=
          };=0A=
        }]);=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"index.html"&gt;=0A=
      &lt;form name=3D"myForm"&gt;=0A=
       &lt;div contenteditable=0A=
            name=3D"myWidget" ng-model=3D"userContent"=0A=
            strip-br=3D"true"=0A=
            required&gt;Change me!&lt;/div&gt;=0A=
        &lt;span =
ng-show=3D"myForm.myWidget.$error.required"&gt;Required!&lt;/span&gt;=0A=
       &lt;hr&gt;=0A=
       &lt;textarea ng-model=3D"userContent" aria-label=3D"Dynamic =
textarea"&gt;&lt;/textarea&gt;=0A=
      &lt;/form&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
    it('should data-bind and become invalid', function() {=0A=
      if (browser.params.browser =3D=3D=3D 'safari' || =
browser.params.browser =3D=3D=3D 'firefox') {=0A=
        // SafariDriver can't handle contenteditable=0A=
        // and Firefox driver can't clear contenteditables very well=0A=
        return;=0A=
      }=0A=
      var contentEditable =3D element(by.css('[contenteditable]'));=0A=
      var content =3D 'Change me!';=0A=
=0A=
      expect(contentEditable.getText()).toEqual(content);=0A=
=0A=
      contentEditable.clear();=0A=
      contentEditable.sendKeys(protractor.Key.BACK_SPACE);=0A=
      expect(contentEditable.getText()).toEqual('');=0A=
      =
expect(contentEditable.getAttribute('class')).toMatch(/ng-invalid-require=
d/);=0A=
    });=0A=
    &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 *=0A=
 *=0A=
 */=0A=
NgModelController.$inject =3D ['$scope', '$exceptionHandler', '$attrs', =
'$element', '$parse', '$animate', '$timeout', '$q', '$interpolate'];=0A=
function NgModelController($scope, $exceptionHandler, $attr, $element, =
$parse, $animate, $timeout, $q, $interpolate) {=0A=
  this.$viewValue =3D Number.NaN;=0A=
  this.$modelValue =3D Number.NaN;=0A=
  this.$$rawModelValue =3D undefined; // stores the parsed modelValue / =
model set from scope regardless of validity.=0A=
  this.$validators =3D {};=0A=
  this.$asyncValidators =3D {};=0A=
  this.$parsers =3D [];=0A=
  this.$formatters =3D [];=0A=
  this.$viewChangeListeners =3D [];=0A=
  this.$untouched =3D true;=0A=
  this.$touched =3D false;=0A=
  this.$pristine =3D true;=0A=
  this.$dirty =3D false;=0A=
  this.$valid =3D true;=0A=
  this.$invalid =3D false;=0A=
  this.$error =3D {}; // keep invalid keys here=0A=
  this.$$success =3D {}; // keep valid keys here=0A=
  this.$pending =3D undefined; // keep pending keys here=0A=
  this.$name =3D $interpolate($attr.name || '', false)($scope);=0A=
  this.$$parentForm =3D nullFormCtrl;=0A=
  this.$options =3D defaultModelOptions;=0A=
=0A=
  this.$$parsedNgModel =3D $parse($attr.ngModel);=0A=
  this.$$parsedNgModelAssign =3D this.$$parsedNgModel.assign;=0A=
  this.$$ngModelGet =3D this.$$parsedNgModel;=0A=
  this.$$ngModelSet =3D this.$$parsedNgModelAssign;=0A=
  this.$$pendingDebounce =3D null;=0A=
  this.$$parserValid =3D undefined;=0A=
=0A=
  this.$$currentValidationRunId =3D 0;=0A=
=0A=
  // https://github.com/angular/angular.js/issues/15833=0A=
  // Prevent `$$scope` from being iterated over by `copy` when =
NgModelController is deep watched=0A=
  Object.defineProperty(this, '$$scope', {value: $scope});=0A=
  this.$$attr =3D $attr;=0A=
  this.$$element =3D $element;=0A=
  this.$$animate =3D $animate;=0A=
  this.$$timeout =3D $timeout;=0A=
  this.$$parse =3D $parse;=0A=
  this.$$q =3D $q;=0A=
  this.$$exceptionHandler =3D $exceptionHandler;=0A=
=0A=
  setupValidity(this);=0A=
  setupModelWatcher(this);=0A=
}=0A=
=0A=
NgModelController.prototype =3D {=0A=
  $$initGetterSetters: function() {=0A=
    if (this.$options.getOption('getterSetter')) {=0A=
      var invokeModelGetter =3D this.$$parse(this.$$attr.ngModel + '()'),=0A=
          invokeModelSetter =3D this.$$parse(this.$$attr.ngModel + =
'($$$p)');=0A=
=0A=
      this.$$ngModelGet =3D function($scope) {=0A=
        var modelValue =3D this.$$parsedNgModel($scope);=0A=
        if (isFunction(modelValue)) {=0A=
          modelValue =3D invokeModelGetter($scope);=0A=
        }=0A=
        return modelValue;=0A=
      };=0A=
      this.$$ngModelSet =3D function($scope, newValue) {=0A=
        if (isFunction(this.$$parsedNgModel($scope))) {=0A=
          invokeModelSetter($scope, {$$$p: newValue});=0A=
        } else {=0A=
          this.$$parsedNgModelAssign($scope, newValue);=0A=
        }=0A=
      };=0A=
    } else if (!this.$$parsedNgModel.assign) {=0A=
      throw ngModelMinErr('nonassign', 'Expression \'{0}\' is =
non-assignable. Element: {1}',=0A=
          this.$$attr.ngModel, startingTag(this.$$element));=0A=
    }=0A=
  },=0A=
=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name ngModel.NgModelController#$render=0A=
   *=0A=
   * @description=0A=
   * Called when the view needs to be updated. It is expected that the =
user of the ng-model=0A=
   * directive will implement this method.=0A=
   *=0A=
   * The `$render()` method is invoked in the following situations:=0A=
   *=0A=
   * * `$rollbackViewValue()` is called.  If we are rolling back the =
view value to the last=0A=
   *   committed value then `$render()` is called to update the input =
control.=0A=
   * * The value referenced by `ng-model` is changed programmatically =
and both the `$modelValue` and=0A=
   *   the `$viewValue` are different from last time.=0A=
   *=0A=
   * Since `ng-model` does not do a deep watch, `$render()` is only =
invoked if the values of=0A=
   * `$modelValue` and `$viewValue` are actually different from their =
previous values. If `$modelValue`=0A=
   * or `$viewValue` are objects (rather than a string or number) then =
`$render()` will not be=0A=
   * invoked if you only change a property on the objects.=0A=
   */=0A=
  $render: noop,=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name ngModel.NgModelController#$isEmpty=0A=
   *=0A=
   * @description=0A=
   * This is called when we need to determine if the value of an input =
is empty.=0A=
   *=0A=
   * For instance, the required directive does this to work out if the =
input has data or not.=0A=
   *=0A=
   * The default `$isEmpty` function checks whether the value is =
`undefined`, `''`, `null` or `NaN`.=0A=
   *=0A=
   * You can override this for input directives whose concept of being =
empty is different from the=0A=
   * default. The `checkboxInputType` directive does this because in its =
case a value of `false`=0A=
   * implies empty.=0A=
   *=0A=
   * @param {*} value The value of the input to check for emptiness.=0A=
   * @returns {boolean} True if `value` is "empty".=0A=
   */=0A=
  $isEmpty: function(value) {=0A=
    // eslint-disable-next-line no-self-compare=0A=
    return isUndefined(value) || value =3D=3D=3D '' || value =3D=3D=3D =
null || value !=3D=3D value;=0A=
  },=0A=
=0A=
  $$updateEmptyClasses: function(value) {=0A=
    if (this.$isEmpty(value)) {=0A=
      this.$$animate.removeClass(this.$$element, NOT_EMPTY_CLASS);=0A=
      this.$$animate.addClass(this.$$element, EMPTY_CLASS);=0A=
    } else {=0A=
      this.$$animate.removeClass(this.$$element, EMPTY_CLASS);=0A=
      this.$$animate.addClass(this.$$element, NOT_EMPTY_CLASS);=0A=
    }=0A=
  },=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name ngModel.NgModelController#$setPristine=0A=
   *=0A=
   * @description=0A=
   * Sets the control to its pristine state.=0A=
   *=0A=
   * This method can be called to remove the `ng-dirty` class and set =
the control to its pristine=0A=
   * state (`ng-pristine` class). A model is considered to be pristine =
when the control=0A=
   * has not been changed from when first compiled.=0A=
   */=0A=
  $setPristine: function() {=0A=
    this.$dirty =3D false;=0A=
    this.$pristine =3D true;=0A=
    this.$$animate.removeClass(this.$$element, DIRTY_CLASS);=0A=
    this.$$animate.addClass(this.$$element, PRISTINE_CLASS);=0A=
  },=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name ngModel.NgModelController#$setDirty=0A=
   *=0A=
   * @description=0A=
   * Sets the control to its dirty state.=0A=
   *=0A=
   * This method can be called to remove the `ng-pristine` class and set =
the control to its dirty=0A=
   * state (`ng-dirty` class). A model is considered to be dirty when =
the control has been changed=0A=
   * from when first compiled.=0A=
   */=0A=
  $setDirty: function() {=0A=
    this.$dirty =3D true;=0A=
    this.$pristine =3D false;=0A=
    this.$$animate.removeClass(this.$$element, PRISTINE_CLASS);=0A=
    this.$$animate.addClass(this.$$element, DIRTY_CLASS);=0A=
    this.$$parentForm.$setDirty();=0A=
  },=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name ngModel.NgModelController#$setUntouched=0A=
   *=0A=
   * @description=0A=
   * Sets the control to its untouched state.=0A=
   *=0A=
   * This method can be called to remove the `ng-touched` class and set =
the control to its=0A=
   * untouched state (`ng-untouched` class). Upon compilation, a model =
is set as untouched=0A=
   * by default, however this function can be used to restore that state =
if the model has=0A=
   * already been touched by the user.=0A=
   */=0A=
  $setUntouched: function() {=0A=
    this.$touched =3D false;=0A=
    this.$untouched =3D true;=0A=
    this.$$animate.setClass(this.$$element, UNTOUCHED_CLASS, =
TOUCHED_CLASS);=0A=
  },=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name ngModel.NgModelController#$setTouched=0A=
   *=0A=
   * @description=0A=
   * Sets the control to its touched state.=0A=
   *=0A=
   * This method can be called to remove the `ng-untouched` class and =
set the control to its=0A=
   * touched state (`ng-touched` class). A model is considered to be =
touched when the user has=0A=
   * first focused the control element and then shifted focus away from =
the control (blur event).=0A=
   */=0A=
  $setTouched: function() {=0A=
    this.$touched =3D true;=0A=
    this.$untouched =3D false;=0A=
    this.$$animate.setClass(this.$$element, TOUCHED_CLASS, =
UNTOUCHED_CLASS);=0A=
  },=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name ngModel.NgModelController#$rollbackViewValue=0A=
   *=0A=
   * @description=0A=
   * Cancel an update and reset the input element's value to prevent an =
update to the `$modelValue`,=0A=
   * which may be caused by a pending debounced event or because the =
input is waiting for some=0A=
   * future event.=0A=
   *=0A=
   * If you have an input that uses `ng-model-options` to set up =
debounced updates or updates that=0A=
   * depend on special events such as `blur`, there can be a period when =
the `$viewValue` is out of=0A=
   * sync with the ngModel's `$modelValue`.=0A=
   *=0A=
   * In this case, you can use `$rollbackViewValue()` to manually cancel =
the debounced / future update=0A=
   * and reset the input to the last committed view value.=0A=
   *=0A=
   * It is also possible that you run into difficulties if you try to =
update the ngModel's `$modelValue`=0A=
   * programmatically before these debounced/future events have =
resolved/occurred, because Angular's=0A=
   * dirty checking mechanism is not able to tell whether the model has =
actually changed or not.=0A=
   *=0A=
   * The `$rollbackViewValue()` method should be called before =
programmatically changing the model of an=0A=
   * input which may have such events pending. This is important in =
order to make sure that the=0A=
   * input field will be updated with the new model value and any =
pending operations are cancelled.=0A=
   *=0A=
   * &lt;example name=3D"ng-model-cancel-update" =
module=3D"cancel-update-example"&gt;=0A=
   *   &lt;file name=3D"app.js"&gt;=0A=
   *     angular.module('cancel-update-example', [])=0A=
   *=0A=
   *     .controller('CancelUpdateController', ['$scope', =
function($scope) {=0A=
   *       $scope.model =3D {value1: '', value2: ''};=0A=
   *=0A=
   *       $scope.setEmpty =3D function(e, value, rollback) {=0A=
   *         if (e.keyCode =3D=3D=3D 27) {=0A=
   *           e.preventDefault();=0A=
   *           if (rollback) {=0A=
   *             $scope.myForm[value].$rollbackViewValue();=0A=
   *           }=0A=
   *           $scope.model[value] =3D '';=0A=
   *         }=0A=
   *       };=0A=
   *     }]);=0A=
   *   &lt;/file&gt;=0A=
   *   &lt;file name=3D"index.html"&gt;=0A=
   *     &lt;div ng-controller=3D"CancelUpdateController"&gt;=0A=
   *       &lt;p&gt;Both of these inputs are only updated if they are =
blurred. Hitting escape should=0A=
   *       empty them. Follow these steps and observe the =
difference:&lt;/p&gt;=0A=
   *       &lt;ol&gt;=0A=
   *         &lt;li&gt;Type something in the input. You will see that =
the model is not yet updated&lt;/li&gt;=0A=
   *         &lt;li&gt;Press the Escape key.=0A=
   *           &lt;ol&gt;=0A=
   *             &lt;li&gt; In the first example, nothing happens, =
because the model is already '', and no=0A=
   *             update is detected. If you blur the input, the model =
will be set to the current view.=0A=
   *             &lt;/li&gt;=0A=
   *             &lt;li&gt; In the second example, the pending update is =
cancelled, and the input is set back=0A=
   *             to the last committed view value (''). Blurring the =
input does nothing.=0A=
   *             &lt;/li&gt;=0A=
   *           &lt;/ol&gt;=0A=
   *         &lt;/li&gt;=0A=
   *       &lt;/ol&gt;=0A=
   *=0A=
   *       &lt;form name=3D"myForm" ng-model-options=3D"{ updateOn: =
'blur' }"&gt;=0A=
   *         &lt;div&gt;=0A=
   *           &lt;p id=3D"inputDescription1"&gt;Without =
$rollbackViewValue():&lt;/p&gt;=0A=
   *           &lt;input name=3D"value1" =
aria-describedby=3D"inputDescription1" ng-model=3D"model.value1"=0A=
   *                  ng-keydown=3D"setEmpty($event, 'value1')"&gt;=0A=
   *           value1: "{{ model.value1 }}"=0A=
   *         &lt;/div&gt;=0A=
   *=0A=
   *         &lt;div&gt;=0A=
   *           &lt;p id=3D"inputDescription2"&gt;With =
$rollbackViewValue():&lt;/p&gt;=0A=
   *           &lt;input name=3D"value2" =
aria-describedby=3D"inputDescription2" ng-model=3D"model.value2"=0A=
   *                  ng-keydown=3D"setEmpty($event, 'value2', true)"&gt;=0A=
   *           value2: "{{ model.value2 }}"=0A=
   *         &lt;/div&gt;=0A=
   *       &lt;/form&gt;=0A=
   *     &lt;/div&gt;=0A=
   *   &lt;/file&gt;=0A=
       &lt;file name=3D"style.css"&gt;=0A=
          div {=0A=
            display: table-cell;=0A=
          }=0A=
          div:nth-child(1) {=0A=
            padding-right: 30px;=0A=
          }=0A=
=0A=
        &lt;/file&gt;=0A=
   * &lt;/example&gt;=0A=
   */=0A=
  $rollbackViewValue: function() {=0A=
    this.$$timeout.cancel(this.$$pendingDebounce);=0A=
    this.$viewValue =3D this.$$lastCommittedViewValue;=0A=
    this.$render();=0A=
  },=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name ngModel.NgModelController#$validate=0A=
   *=0A=
   * @description=0A=
   * Runs each of the registered validators (first synchronous =
validators and then=0A=
   * asynchronous validators).=0A=
   * If the validity changes to invalid, the model will be set to =
`undefined`,=0A=
   * unless {@link ngModelOptions `ngModelOptions.allowInvalid`} is =
`true`.=0A=
   * If the validity changes to valid, it will set the model to the last =
available valid=0A=
   * `$modelValue`, i.e. either the last parsed value or the last value =
set from the scope.=0A=
   */=0A=
  $validate: function() {=0A=
    // ignore $validate before model is initialized=0A=
    if (isNumberNaN(this.$modelValue)) {=0A=
      return;=0A=
    }=0A=
=0A=
    var viewValue =3D this.$$lastCommittedViewValue;=0A=
    // Note: we use the $$rawModelValue as $modelValue might have been=0A=
    // set to undefined during a view -&gt; model update that found =
validation=0A=
    // errors. We can't parse the view here, since that could change=0A=
    // the model although neither viewValue nor the model on the scope =
changed=0A=
    var modelValue =3D this.$$rawModelValue;=0A=
=0A=
    var prevValid =3D this.$valid;=0A=
    var prevModelValue =3D this.$modelValue;=0A=
=0A=
    var allowInvalid =3D this.$options.getOption('allowInvalid');=0A=
=0A=
    var that =3D this;=0A=
    this.$$runValidators(modelValue, viewValue, function(allValid) {=0A=
      // If there was no change in validity, don't update the model=0A=
      // This prevents changing an invalid modelValue to undefined=0A=
      if (!allowInvalid &amp;&amp; prevValid !=3D=3D allValid) {=0A=
        // Note: Don't check this.$valid here, as we could have=0A=
        // external validators (e.g. calculated on the server),=0A=
        // that just call $setValidity and need the model value=0A=
        // to calculate their validity.=0A=
        that.$modelValue =3D allValid ? modelValue : undefined;=0A=
=0A=
        if (that.$modelValue !=3D=3D prevModelValue) {=0A=
          that.$$writeModelToScope();=0A=
        }=0A=
      }=0A=
    });=0A=
  },=0A=
=0A=
  $$runValidators: function(modelValue, viewValue, doneCallback) {=0A=
    this.$$currentValidationRunId++;=0A=
    var localValidationRunId =3D this.$$currentValidationRunId;=0A=
    var that =3D this;=0A=
=0A=
    // check parser error=0A=
    if (!processParseErrors()) {=0A=
      validationDone(false);=0A=
      return;=0A=
    }=0A=
    if (!processSyncValidators()) {=0A=
      validationDone(false);=0A=
      return;=0A=
    }=0A=
    processAsyncValidators();=0A=
=0A=
    function processParseErrors() {=0A=
      var errorKey =3D that.$$parserName || 'parse';=0A=
      if (isUndefined(that.$$parserValid)) {=0A=
        setValidity(errorKey, null);=0A=
      } else {=0A=
        if (!that.$$parserValid) {=0A=
          forEach(that.$validators, function(v, name) {=0A=
            setValidity(name, null);=0A=
          });=0A=
          forEach(that.$asyncValidators, function(v, name) {=0A=
            setValidity(name, null);=0A=
          });=0A=
        }=0A=
        // Set the parse error last, to prevent unsetting it, should a =
$validators key =3D=3D parserName=0A=
        setValidity(errorKey, that.$$parserValid);=0A=
        return that.$$parserValid;=0A=
      }=0A=
      return true;=0A=
    }=0A=
=0A=
    function processSyncValidators() {=0A=
      var syncValidatorsValid =3D true;=0A=
      forEach(that.$validators, function(validator, name) {=0A=
        var result =3D Boolean(validator(modelValue, viewValue));=0A=
        syncValidatorsValid =3D syncValidatorsValid &amp;&amp; result;=0A=
        setValidity(name, result);=0A=
      });=0A=
      if (!syncValidatorsValid) {=0A=
        forEach(that.$asyncValidators, function(v, name) {=0A=
          setValidity(name, null);=0A=
        });=0A=
        return false;=0A=
      }=0A=
      return true;=0A=
    }=0A=
=0A=
    function processAsyncValidators() {=0A=
      var validatorPromises =3D [];=0A=
      var allValid =3D true;=0A=
      forEach(that.$asyncValidators, function(validator, name) {=0A=
        var promise =3D validator(modelValue, viewValue);=0A=
        if (!isPromiseLike(promise)) {=0A=
          throw ngModelMinErr('nopromise',=0A=
            'Expected asynchronous validator to return a promise but got =
\'{0}\' instead.', promise);=0A=
        }=0A=
        setValidity(name, undefined);=0A=
        validatorPromises.push(promise.then(function() {=0A=
          setValidity(name, true);=0A=
        }, function() {=0A=
          allValid =3D false;=0A=
          setValidity(name, false);=0A=
        }));=0A=
      });=0A=
      if (!validatorPromises.length) {=0A=
        validationDone(true);=0A=
      } else {=0A=
        that.$$q.all(validatorPromises).then(function() {=0A=
          validationDone(allValid);=0A=
        }, noop);=0A=
      }=0A=
    }=0A=
=0A=
    function setValidity(name, isValid) {=0A=
      if (localValidationRunId =3D=3D=3D that.$$currentValidationRunId) {=0A=
        that.$setValidity(name, isValid);=0A=
      }=0A=
    }=0A=
=0A=
    function validationDone(allValid) {=0A=
      if (localValidationRunId =3D=3D=3D that.$$currentValidationRunId) {=0A=
=0A=
        doneCallback(allValid);=0A=
      }=0A=
    }=0A=
  },=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name ngModel.NgModelController#$commitViewValue=0A=
   *=0A=
   * @description=0A=
   * Commit a pending update to the `$modelValue`.=0A=
   *=0A=
   * Updates may be pending by a debounced event or because the input is =
waiting for a some future=0A=
   * event defined in `ng-model-options`. this method is rarely needed =
as `NgModelController`=0A=
   * usually handles calling this in response to input events.=0A=
   */=0A=
  $commitViewValue: function() {=0A=
    var viewValue =3D this.$viewValue;=0A=
=0A=
    this.$$timeout.cancel(this.$$pendingDebounce);=0A=
=0A=
    // If the view value has not changed then we should just exit, =
except in the case where there is=0A=
    // a native validator on the element. In this case the validation =
state may have changed even though=0A=
    // the viewValue has stayed empty.=0A=
    if (this.$$lastCommittedViewValue =3D=3D=3D viewValue &amp;&amp; =
(viewValue !=3D=3D '' || !this.$$hasNativeValidators)) {=0A=
      return;=0A=
    }=0A=
    this.$$updateEmptyClasses(viewValue);=0A=
    this.$$lastCommittedViewValue =3D viewValue;=0A=
=0A=
    // change to dirty=0A=
    if (this.$pristine) {=0A=
      this.$setDirty();=0A=
    }=0A=
    this.$$parseAndValidate();=0A=
  },=0A=
=0A=
  $$parseAndValidate: function() {=0A=
    var viewValue =3D this.$$lastCommittedViewValue;=0A=
    var modelValue =3D viewValue;=0A=
    var that =3D this;=0A=
=0A=
    this.$$parserValid =3D isUndefined(modelValue) ? undefined : true;=0A=
=0A=
    if (this.$$parserValid) {=0A=
      for (var i =3D 0; i &lt; this.$parsers.length; i++) {=0A=
        modelValue =3D this.$parsers[i](modelValue);=0A=
        if (isUndefined(modelValue)) {=0A=
          this.$$parserValid =3D false;=0A=
          break;=0A=
        }=0A=
      }=0A=
    }=0A=
    if (isNumberNaN(this.$modelValue)) {=0A=
      // this.$modelValue has not been touched yet...=0A=
      this.$modelValue =3D this.$$ngModelGet(this.$$scope);=0A=
    }=0A=
    var prevModelValue =3D this.$modelValue;=0A=
    var allowInvalid =3D this.$options.getOption('allowInvalid');=0A=
    this.$$rawModelValue =3D modelValue;=0A=
=0A=
    if (allowInvalid) {=0A=
      this.$modelValue =3D modelValue;=0A=
      writeToModelIfNeeded();=0A=
    }=0A=
=0A=
    // Pass the $$lastCommittedViewValue here, because the cached =
viewValue might be out of date.=0A=
    // This can happen if e.g. $setViewValue is called from inside a =
parser=0A=
    this.$$runValidators(modelValue, this.$$lastCommittedViewValue, =
function(allValid) {=0A=
      if (!allowInvalid) {=0A=
        // Note: Don't check this.$valid here, as we could have=0A=
        // external validators (e.g. calculated on the server),=0A=
        // that just call $setValidity and need the model value=0A=
        // to calculate their validity.=0A=
        that.$modelValue =3D allValid ? modelValue : undefined;=0A=
        writeToModelIfNeeded();=0A=
      }=0A=
    });=0A=
=0A=
    function writeToModelIfNeeded() {=0A=
      if (that.$modelValue !=3D=3D prevModelValue) {=0A=
        that.$$writeModelToScope();=0A=
      }=0A=
    }=0A=
  },=0A=
=0A=
  $$writeModelToScope: function() {=0A=
    this.$$ngModelSet(this.$$scope, this.$modelValue);=0A=
    forEach(this.$viewChangeListeners, function(listener) {=0A=
      try {=0A=
        listener();=0A=
      } catch (e) {=0A=
        // eslint-disable-next-line no-invalid-this=0A=
        this.$$exceptionHandler(e);=0A=
      }=0A=
    }, this);=0A=
  },=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name ngModel.NgModelController#$setViewValue=0A=
   *=0A=
   * @description=0A=
   * Update the view value.=0A=
   *=0A=
   * This method should be called when a control wants to change the =
view value; typically,=0A=
   * this is done from within a DOM event handler. For example, the =
{@link ng.directive:input input}=0A=
   * directive calls it when the value of the input changes and {@link =
ng.directive:select select}=0A=
   * calls it when an option is selected.=0A=
   *=0A=
   * When `$setViewValue` is called, the new `value` will be staged for =
committing through the `$parsers`=0A=
   * and `$validators` pipelines. If there are no special {@link =
ngModelOptions} specified then the staged=0A=
   * value is sent directly for processing through the `$parsers` =
pipeline. After this, the `$validators` and=0A=
   * `$asyncValidators` are called and the value is applied to =
`$modelValue`.=0A=
   * Finally, the value is set to the **expression** specified in the =
`ng-model` attribute and=0A=
   * all the registered change listeners, in the `$viewChangeListeners` =
list are called.=0A=
   *=0A=
   * In case the {@link ng.directive:ngModelOptions ngModelOptions} =
directive is used with `updateOn`=0A=
   * and the `default` trigger is not listed, all those actions will =
remain pending until one of the=0A=
   * `updateOn` events is triggered on the DOM element.=0A=
   * All these actions will be debounced if the {@link =
ng.directive:ngModelOptions ngModelOptions}=0A=
   * directive is used with a custom debounce for this particular event.=0A=
   * Note that a `$digest` is only triggered once the `updateOn` events =
are fired, or if `debounce`=0A=
   * is specified, once the timer runs out.=0A=
   *=0A=
   * When used with standard inputs, the view value will always be a =
string (which is in some cases=0A=
   * parsed into another type, such as a `Date` object for =
`input[date]`.)=0A=
   * However, custom controls might also pass objects to this method. In =
this case, we should make=0A=
   * a copy of the object before passing it to `$setViewValue`. This is =
because `ngModel` does not=0A=
   * perform a deep watch of objects, it only looks for a change of =
identity. If you only change=0A=
   * the property of the object then ngModel will not realize that the =
object has changed and=0A=
   * will not invoke the `$parsers` and `$validators` pipelines. For =
this reason, you should=0A=
   * not change properties of the copy once it has been passed to =
`$setViewValue`.=0A=
   * Otherwise you may cause the model value on the scope to change =
incorrectly.=0A=
   *=0A=
   * &lt;div class=3D"alert alert-info"&gt;=0A=
   * In any case, the value passed to the method should always reflect =
the current value=0A=
   * of the control. For example, if you are calling `$setViewValue` for =
an input element,=0A=
   * you should pass the input DOM value. Otherwise, the control and the =
scope model become=0A=
   * out of sync. It's also important to note that `$setViewValue` does =
not call `$render` or change=0A=
   * the control's DOM value in any way. If we want to change the =
control's DOM value=0A=
   * programmatically, we should update the `ngModel` scope expression. =
Its new value will be=0A=
   * picked up by the model controller, which will run it through the =
`$formatters`, `$render` it=0A=
   * to update the DOM, and finally call `$validate` on it.=0A=
   * &lt;/div&gt;=0A=
   *=0A=
   * @param {*} value value from the view.=0A=
   * @param {string} trigger Event that triggered the update.=0A=
   */=0A=
  $setViewValue: function(value, trigger) {=0A=
    this.$viewValue =3D value;=0A=
    if (this.$options.getOption('updateOnDefault')) {=0A=
      this.$$debounceViewValueCommit(trigger);=0A=
    }=0A=
  },=0A=
=0A=
  $$debounceViewValueCommit: function(trigger) {=0A=
    var debounceDelay =3D this.$options.getOption('debounce');=0A=
=0A=
    if (isNumber(debounceDelay[trigger])) {=0A=
      debounceDelay =3D debounceDelay[trigger];=0A=
    } else if (isNumber(debounceDelay['default'])) {=0A=
      debounceDelay =3D debounceDelay['default'];=0A=
    }=0A=
=0A=
    this.$$timeout.cancel(this.$$pendingDebounce);=0A=
    var that =3D this;=0A=
    if (debounceDelay &gt; 0) { // this fails if debounceDelay is an =
object=0A=
      this.$$pendingDebounce =3D this.$$timeout(function() {=0A=
        that.$commitViewValue();=0A=
      }, debounceDelay);=0A=
    } else if (this.$$scope.$root.$$phase) {=0A=
      this.$commitViewValue();=0A=
    } else {=0A=
      this.$$scope.$apply(function() {=0A=
        that.$commitViewValue();=0A=
      });=0A=
    }=0A=
  },=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   *=0A=
   * @name ngModel.NgModelController#$overrideModelOptions=0A=
   *=0A=
   * @description=0A=
   *=0A=
   * Override the current model options settings programmatically.=0A=
   *=0A=
   * The previous `ModelOptions` value will not be modified. Instead, a=0A=
   * new `ModelOptions` object will inherit from the previous one =
overriding=0A=
   * or inheriting settings that are defined in the given parameter.=0A=
   *=0A=
   * See {@link ngModelOptions} for information about what options can =
be specified=0A=
   * and how model option inheritance works.=0A=
   *=0A=
   * @param {Object} options a hash of settings to override the previous =
options=0A=
   *=0A=
   */=0A=
  $overrideModelOptions: function(options) {=0A=
    this.$options =3D this.$options.createChild(options);=0A=
  }=0A=
};=0A=
=0A=
function setupModelWatcher(ctrl) {=0A=
  // model -&gt; value=0A=
  // Note: we cannot use a normal scope.$watch as we want to detect the =
following:=0A=
  // 1. scope value is 'a'=0A=
  // 2. user enters 'b'=0A=
  // 3. ng-change kicks in and reverts scope value to 'a'=0A=
  //    -&gt; scope value did not change since the last digest as=0A=
  //       ng-change executes in apply phase=0A=
  // 4. view should be changed back to 'a'=0A=
  ctrl.$$scope.$watch(function ngModelWatch(scope) {=0A=
    var modelValue =3D ctrl.$$ngModelGet(scope);=0A=
=0A=
    // if scope model value and ngModel value are out of sync=0A=
    // TODO(perf): why not move this to the action fn?=0A=
    if (modelValue !=3D=3D ctrl.$modelValue &amp;&amp;=0A=
       // checks for NaN is needed to allow setting the model to NaN =
when there's an asyncValidator=0A=
        // eslint-disable-next-line no-self-compare=0A=
       (ctrl.$modelValue =3D=3D=3D ctrl.$modelValue || modelValue =
=3D=3D=3D modelValue)=0A=
    ) {=0A=
      ctrl.$modelValue =3D ctrl.$$rawModelValue =3D modelValue;=0A=
      ctrl.$$parserValid =3D undefined;=0A=
=0A=
      var formatters =3D ctrl.$formatters,=0A=
          idx =3D formatters.length;=0A=
=0A=
      var viewValue =3D modelValue;=0A=
      while (idx--) {=0A=
        viewValue =3D formatters[idx](viewValue);=0A=
      }=0A=
      if (ctrl.$viewValue !=3D=3D viewValue) {=0A=
        ctrl.$$updateEmptyClasses(viewValue);=0A=
        ctrl.$viewValue =3D ctrl.$$lastCommittedViewValue =3D viewValue;=0A=
        ctrl.$render();=0A=
=0A=
        // It is possible that model and view value have been updated =
during render=0A=
        ctrl.$$runValidators(ctrl.$modelValue, ctrl.$viewValue, noop);=0A=
      }=0A=
    }=0A=
=0A=
    return modelValue;=0A=
  });=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name ngModel.NgModelController#$setValidity=0A=
 *=0A=
 * @description=0A=
 * Change the validity state, and notify the form.=0A=
 *=0A=
 * This method can be called within $parsers/$formatters or a custom =
validation implementation.=0A=
 * However, in most cases it should be sufficient to use the =
`ngModel.$validators` and=0A=
 * `ngModel.$asyncValidators` collections which will call `$setValidity` =
automatically.=0A=
 *=0A=
 * @param {string} validationErrorKey Name of the validator. The =
`validationErrorKey` will be assigned=0A=
 *        to either `$error[validationErrorKey]` or =
`$pending[validationErrorKey]`=0A=
 *        (for unfulfilled `$asyncValidators`), so that it is available =
for data-binding.=0A=
 *        The `validationErrorKey` should be in camelCase and will get =
converted into dash-case=0A=
 *        for class name. Example: `myError` will result in =
`ng-valid-my-error` and `ng-invalid-my-error`=0A=
 *        classes and can be bound to as `{{ =
someForm.someControl.$error.myError }}`.=0A=
 * @param {boolean} isValid Whether the current state is valid (true), =
invalid (false), pending (undefined),=0A=
 *                          or skipped (null). Pending is used for =
unfulfilled `$asyncValidators`.=0A=
 *                          Skipped is used by Angular when validators =
do not run because of parse errors and=0A=
 *                          when `$asyncValidators` do not run because =
any of the `$validators` failed.=0A=
 */=0A=
addSetValidityMethod({=0A=
  clazz: NgModelController,=0A=
  set: function(object, property) {=0A=
    object[property] =3D true;=0A=
  },=0A=
  unset: function(object, property) {=0A=
    delete object[property];=0A=
  }=0A=
});=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngModel=0A=
 *=0A=
 * @element input=0A=
 * @priority 1=0A=
 *=0A=
 * @description=0A=
 * The `ngModel` directive binds an `input`,`select`, `textarea` (or =
custom form control) to a=0A=
 * property on the scope using {@link ngModel.NgModelController =
NgModelController},=0A=
 * which is created and exposed by this directive.=0A=
 *=0A=
 * `ngModel` is responsible for:=0A=
 *=0A=
 * - Binding the view into the model, which other directives such as =
`input`, `textarea` or `select`=0A=
 *   require.=0A=
 * - Providing validation behavior (i.e. required, number, email, url).=0A=
 * - Keeping the state of the control (valid/invalid, dirty/pristine, =
touched/untouched, validation errors).=0A=
 * - Setting related css classes on the element (`ng-valid`, =
`ng-invalid`, `ng-dirty`, `ng-pristine`, `ng-touched`,=0A=
 *   `ng-untouched`, `ng-empty`, `ng-not-empty`) including animations.=0A=
 * - Registering the control with its parent {@link ng.directive:form =
form}.=0A=
 *=0A=
 * Note: `ngModel` will try to bind to the property given by evaluating =
the expression on the=0A=
 * current scope. If the property doesn't already exist on this scope, =
it will be created=0A=
 * implicitly and added to the scope.=0A=
 *=0A=
 * For best practices on using `ngModel`, see:=0A=
 *=0A=
 *  - [Understanding =
Scopes](https://github.com/angular/angular.js/wiki/Understanding-Scopes)=0A=
 *=0A=
 * For basic examples, how to use `ngModel`, see:=0A=
 *=0A=
 *  - {@link ng.directive:input input}=0A=
 *    - {@link input[text] text}=0A=
 *    - {@link input[checkbox] checkbox}=0A=
 *    - {@link input[radio] radio}=0A=
 *    - {@link input[number] number}=0A=
 *    - {@link input[email] email}=0A=
 *    - {@link input[url] url}=0A=
 *    - {@link input[date] date}=0A=
 *    - {@link input[datetime-local] datetime-local}=0A=
 *    - {@link input[time] time}=0A=
 *    - {@link input[month] month}=0A=
 *    - {@link input[week] week}=0A=
 *  - {@link ng.directive:select select}=0A=
 *  - {@link ng.directive:textarea textarea}=0A=
 *=0A=
 * # Complex Models (objects or collections)=0A=
 *=0A=
 * By default, `ngModel` watches the model by reference, not value. This =
is important to know when=0A=
 * binding inputs to models that are objects (e.g. `Date`) or =
collections (e.g. arrays). If only properties of the=0A=
 * object or collection change, `ngModel` will not be notified and so =
the input will not be  re-rendered.=0A=
 *=0A=
 * The model must be assigned an entirely new object or collection =
before a re-rendering will occur.=0A=
 *=0A=
 * Some directives have options that will cause them to use a custom =
`$watchCollection` on the model expression=0A=
 * - for example, `ngOptions` will do so when a `track by` clause is =
included in the comprehension expression or=0A=
 * if the select is given the `multiple` attribute.=0A=
 *=0A=
 * The `$watchCollection()` method only does a shallow comparison, =
meaning that changing properties deeper than the=0A=
 * first level of the object (or only changing the properties of an item =
in the collection if it's an array) will still=0A=
 * not trigger a re-rendering of the model.=0A=
 *=0A=
 * # CSS classes=0A=
 * The following CSS classes are added and removed on the associated =
input/select/textarea element=0A=
 * depending on the validity of the model.=0A=
 *=0A=
 *  - `ng-valid`: the model is valid=0A=
 *  - `ng-invalid`: the model is invalid=0A=
 *  - `ng-valid-[key]`: for each valid key added by `$setValidity`=0A=
 *  - `ng-invalid-[key]`: for each invalid key added by `$setValidity`=0A=
 *  - `ng-pristine`: the control hasn't been interacted with yet=0A=
 *  - `ng-dirty`: the control has been interacted with=0A=
 *  - `ng-touched`: the control has been blurred=0A=
 *  - `ng-untouched`: the control hasn't been blurred=0A=
 *  - `ng-pending`: any `$asyncValidators` are unfulfilled=0A=
 *  - `ng-empty`: the view does not contain a value or the value is =
deemed "empty", as defined=0A=
 *     by the {@link ngModel.NgModelController#$isEmpty} method=0A=
 *  - `ng-not-empty`: the view contains a non-empty value=0A=
 *=0A=
 * Keep in mind that ngAnimate can detect each of these classes when =
added and removed.=0A=
 *=0A=
 * ## Animation Hooks=0A=
 *=0A=
 * Animations within models are triggered when any of the associated CSS =
classes are added and removed=0A=
 * on the input element which is attached to the model. These classes =
include: `.ng-pristine`, `.ng-dirty`,=0A=
 * `.ng-invalid` and `.ng-valid` as well as any other validations that =
are performed on the model itself.=0A=
 * The animations that are triggered within ngModel are similar to how =
they work in ngClass and=0A=
 * animations can be hooked into using CSS transitions, keyframes as =
well as JS animations.=0A=
 *=0A=
 * The following example shows a simple way to utilize CSS transitions =
to style an input element=0A=
 * that has been rendered as invalid after it has been validated:=0A=
 *=0A=
 * &lt;pre&gt;=0A=
 * //be sure to include ngAnimate as a module to hook into more=0A=
 * //advanced animations=0A=
 * .my-input {=0A=
 *   transition:0.5s linear all;=0A=
 *   background: white;=0A=
 * }=0A=
 * .my-input.ng-invalid {=0A=
 *   background: red;=0A=
 *   color:white;=0A=
 * }=0A=
 * &lt;/pre&gt;=0A=
 *=0A=
 * @example=0A=
 * &lt;example deps=3D"angular-animate.js" animations=3D"true" =
fixBase=3D"true" module=3D"inputExample" name=3D"ng-model"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
       &lt;script&gt;=0A=
        angular.module('inputExample', [])=0A=
          .controller('ExampleController', ['$scope', function($scope) {=0A=
            $scope.val =3D '1';=0A=
          }]);=0A=
       &lt;/script&gt;=0A=
       &lt;style&gt;=0A=
         .my-input {=0A=
           transition:all linear 0.5s;=0A=
           background: transparent;=0A=
         }=0A=
         .my-input.ng-invalid {=0A=
           color:white;=0A=
           background: red;=0A=
         }=0A=
       &lt;/style&gt;=0A=
       &lt;p id=3D"inputDescription"&gt;=0A=
        Update input to see transitions when valid/invalid.=0A=
        Integer is a valid value.=0A=
       &lt;/p&gt;=0A=
       &lt;form name=3D"testForm" ng-controller=3D"ExampleController"&gt;=0A=
         &lt;input ng-model=3D"val" ng-pattern=3D"/^\d+$/" name=3D"anim" =
class=3D"my-input"=0A=
                aria-describedby=3D"inputDescription" /&gt;=0A=
       &lt;/form&gt;=0A=
     &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 *=0A=
 * ## Binding to a getter/setter=0A=
 *=0A=
 * Sometimes it's helpful to bind `ngModel` to a getter/setter function. =
 A getter/setter is a=0A=
 * function that returns a representation of the model when called with =
zero arguments, and sets=0A=
 * the internal state of a model when called with an argument. It's =
sometimes useful to use this=0A=
 * for models that have an internal representation that's different from =
what the model exposes=0A=
 * to the view.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-success"&gt;=0A=
 * **Best Practice:** It's best to keep getters fast because Angular is =
likely to call them more=0A=
 * frequently than other parts of your code.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * You use this behavior by adding `ng-model-options=3D"{ getterSetter: =
true }"` to an element that=0A=
 * has `ng-model` attached to it. You can also add =
`ng-model-options=3D"{ getterSetter: true }"` to=0A=
 * a `&lt;form&gt;`, which will enable this behavior for all =
`&lt;input&gt;`s within it. See=0A=
 * {@link ng.directive:ngModelOptions `ngModelOptions`} for more.=0A=
 *=0A=
 * The following example shows how to use `ngModel` with a getter/setter:=0A=
 *=0A=
 * @example=0A=
 * &lt;example name=3D"ngModel-getter-setter" =
module=3D"getterSetterExample"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
         &lt;form name=3D"userForm"&gt;=0A=
           &lt;label&gt;Name:=0A=
             &lt;input type=3D"text" name=3D"userName"=0A=
                    ng-model=3D"user.name"=0A=
                    ng-model-options=3D"{ getterSetter: true }" /&gt;=0A=
           &lt;/label&gt;=0A=
         &lt;/form&gt;=0A=
         &lt;pre&gt;user.name =3D &lt;span =
ng-bind=3D"user.name()"&gt;&lt;/span&gt;&lt;/pre&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"app.js"&gt;=0A=
       angular.module('getterSetterExample', [])=0A=
         .controller('ExampleController', ['$scope', function($scope) {=0A=
           var _name =3D 'Brian';=0A=
           $scope.user =3D {=0A=
             name: function(newName) {=0A=
              // Note that newName can be undefined for two reasons:=0A=
              // 1. Because it is called as a getter and thus called =
with no arguments=0A=
              // 2. Because the property should actually be set to =
undefined. This happens e.g. if the=0A=
              //    input is invalid=0A=
              return arguments.length ? (_name =3D newName) : _name;=0A=
             }=0A=
           };=0A=
         }]);=0A=
     &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 */=0A=
var ngModelDirective =3D ['$rootScope', function($rootScope) {=0A=
  return {=0A=
    restrict: 'A',=0A=
    require: ['ngModel', '^?form', '^?ngModelOptions'],=0A=
    controller: NgModelController,=0A=
    // Prelink needs to run before any input directive=0A=
    // so that we can set the NgModelOptions in NgModelController=0A=
    // before anyone else uses it.=0A=
    priority: 1,=0A=
    compile: function ngModelCompile(element) {=0A=
      // Setup initial state of the control=0A=
      =
element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID=
_CLASS);=0A=
=0A=
      return {=0A=
        pre: function ngModelPreLink(scope, element, attr, ctrls) {=0A=
          var modelCtrl =3D ctrls[0],=0A=
              formCtrl =3D ctrls[1] || modelCtrl.$$parentForm,=0A=
              optionsCtrl =3D ctrls[2];=0A=
=0A=
          if (optionsCtrl) {=0A=
            modelCtrl.$options =3D optionsCtrl.$options;=0A=
          }=0A=
=0A=
          modelCtrl.$$initGetterSetters();=0A=
=0A=
          // notify others, especially parent forms=0A=
          formCtrl.$addControl(modelCtrl);=0A=
=0A=
          attr.$observe('name', function(newValue) {=0A=
            if (modelCtrl.$name !=3D=3D newValue) {=0A=
              modelCtrl.$$parentForm.$$renameControl(modelCtrl, =
newValue);=0A=
            }=0A=
          });=0A=
=0A=
          scope.$on('$destroy', function() {=0A=
            modelCtrl.$$parentForm.$removeControl(modelCtrl);=0A=
          });=0A=
        },=0A=
        post: function ngModelPostLink(scope, element, attr, ctrls) {=0A=
          var modelCtrl =3D ctrls[0];=0A=
          if (modelCtrl.$options.getOption('updateOn')) {=0A=
            element.on(modelCtrl.$options.getOption('updateOn'), =
function(ev) {=0A=
              modelCtrl.$$debounceViewValueCommit(ev &amp;&amp; ev.type);=0A=
            });=0A=
          }=0A=
=0A=
          function setTouched() {=0A=
            modelCtrl.$setTouched();=0A=
          }=0A=
=0A=
          element.on('blur', function() {=0A=
            if (modelCtrl.$touched) return;=0A=
=0A=
            if ($rootScope.$$phase) {=0A=
              scope.$evalAsync(setTouched);=0A=
            } else {=0A=
              scope.$apply(setTouched);=0A=
            }=0A=
          });=0A=
        }=0A=
      };=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
/* exported defaultModelOptions */=0A=
var defaultModelOptions;=0A=
var DEFAULT_REGEXP =3D /(\s+|^)default(\s+|$)/;=0A=
=0A=
/**=0A=
 * @ngdoc type=0A=
 * @name ModelOptions=0A=
 * @description=0A=
 * A container for the options set by the {@link ngModelOptions} =
directive=0A=
 */=0A=
function ModelOptions(options) {=0A=
  this.$$options =3D options;=0A=
}=0A=
=0A=
ModelOptions.prototype =3D {=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name ModelOptions#getOption=0A=
   * @param {string} name the name of the option to retrieve=0A=
   * @returns {*} the value of the option=0A=
   * @description=0A=
   * Returns the value of the given option=0A=
   */=0A=
  getOption: function(name) {=0A=
    return this.$$options[name];=0A=
  },=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name ModelOptions#createChild=0A=
   * @param {Object} options a hash of options for the new child that =
will override the parent's options=0A=
   * @return {ModelOptions} a new `ModelOptions` object initialized with =
the given options.=0A=
   */=0A=
  createChild: function(options) {=0A=
    var inheritAll =3D false;=0A=
=0A=
    // make a shallow copy=0A=
    options =3D extend({}, options);=0A=
=0A=
    // Inherit options from the parent if specified by the value =
`"$inherit"`=0A=
    forEach(options, /* @this */ function(option, key) {=0A=
      if (option =3D=3D=3D '$inherit') {=0A=
        if (key =3D=3D=3D '*') {=0A=
          inheritAll =3D true;=0A=
        } else {=0A=
          options[key] =3D this.$$options[key];=0A=
          // `updateOn` is special so we must also inherit the =
`updateOnDefault` option=0A=
          if (key =3D=3D=3D 'updateOn') {=0A=
            options.updateOnDefault =3D this.$$options.updateOnDefault;=0A=
          }=0A=
        }=0A=
      } else {=0A=
        if (key =3D=3D=3D 'updateOn') {=0A=
          // If the `updateOn` property contains the `default` event =
then we have to remove=0A=
          // it from the event list and set the `updateOnDefault` flag.=0A=
          options.updateOnDefault =3D false;=0A=
          options[key] =3D trim(option.replace(DEFAULT_REGEXP, =
function() {=0A=
            options.updateOnDefault =3D true;=0A=
            return ' ';=0A=
          }));=0A=
        }=0A=
      }=0A=
    }, this);=0A=
=0A=
    if (inheritAll) {=0A=
      // We have a property of the form: `"*": "$inherit"`=0A=
      delete options['*'];=0A=
      defaults(options, this.$$options);=0A=
    }=0A=
=0A=
    // Finally add in any missing defaults=0A=
    defaults(options, defaultModelOptions.$$options);=0A=
=0A=
    return new ModelOptions(options);=0A=
  }=0A=
};=0A=
=0A=
=0A=
defaultModelOptions =3D new ModelOptions({=0A=
  updateOn: '',=0A=
  updateOnDefault: true,=0A=
  debounce: 0,=0A=
  getterSetter: false,=0A=
  allowInvalid: false,=0A=
  timezone: null=0A=
});=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngModelOptions=0A=
 *=0A=
 * @description=0A=
 * This directive allows you to modify the behaviour of {@link ngModel} =
directives within your=0A=
 * application. You can specify an `ngModelOptions` directive on any =
element. All {@link ngModel}=0A=
 * directives will use the options of their nearest `ngModelOptions` =
ancestor.=0A=
 *=0A=
 * The `ngModelOptions` settings are found by evaluating the value of =
the attribute directive as=0A=
 * an Angular expression. This expression should evaluate to an object, =
whose properties contain=0A=
 * the settings. For example: `&lt;div "ng-model-options"=3D"{ debounce: =
100 }"`.=0A=
 *=0A=
 * ## Inheriting Options=0A=
 *=0A=
 * You can specify that an `ngModelOptions` setting should be inherited =
from a parent `ngModelOptions`=0A=
 * directive by giving it the value of `"$inherit"`.=0A=
 * Then it will inherit that setting from the first `ngModelOptions` =
directive found by traversing up the=0A=
 * DOM tree. If there is no ancestor element containing an =
`ngModelOptions` directive then default settings=0A=
 * will be used.=0A=
 *=0A=
 * For example given the following fragment of HTML=0A=
 *=0A=
 *=0A=
 * ```html=0A=
 * &lt;div ng-model-options=3D"{ allowInvalid: true, debounce: 200 }"&gt;=0A=
 *   &lt;form ng-model-options=3D"{ updateOn: 'blur', allowInvalid: =
'$inherit' }"&gt;=0A=
 *     &lt;input ng-model-options=3D"{ updateOn: 'default', =
allowInvalid: '$inherit' }" /&gt;=0A=
 *   &lt;/form&gt;=0A=
 * &lt;/div&gt;=0A=
 * ```=0A=
 *=0A=
 * the `input` element will have the following settings=0A=
 *=0A=
 * ```js=0A=
 * { allowInvalid: true, updateOn: 'default', debounce: 0 }=0A=
 * ```=0A=
 *=0A=
 * Notice that the `debounce` setting was not inherited and used the =
default value instead.=0A=
 *=0A=
 * You can specify that all undefined settings are automatically =
inherited from an ancestor by=0A=
 * including a property with key of `"*"` and value of `"$inherit"`.=0A=
 *=0A=
 * For example given the following fragment of HTML=0A=
 *=0A=
 *=0A=
 * ```html=0A=
 * &lt;div ng-model-options=3D"{ allowInvalid: true, debounce: 200 }"&gt;=0A=
 *   &lt;form ng-model-options=3D"{ updateOn: 'blur', "*": '$inherit' =
}"&gt;=0A=
 *     &lt;input ng-model-options=3D"{ updateOn: 'default', "*": =
'$inherit' }" /&gt;=0A=
 *   &lt;/form&gt;=0A=
 * &lt;/div&gt;=0A=
 * ```=0A=
 *=0A=
 * the `input` element will have the following settings=0A=
 *=0A=
 * ```js=0A=
 * { allowInvalid: true, updateOn: 'default', debounce: 200 }=0A=
 * ```=0A=
 *=0A=
 * Notice that the `debounce` setting now inherits the value from the =
outer `&lt;div&gt;` element.=0A=
 *=0A=
 * If you are creating a reusable component then you should be careful =
when using `"*": "$inherit"`=0A=
 * since you may inadvertently inherit a setting in the future that =
changes the behavior of your component.=0A=
 *=0A=
 *=0A=
 * ## Triggering and debouncing model updates=0A=
 *=0A=
 * The `updateOn` and `debounce` properties allow you to specify a =
custom list of events that will=0A=
 * trigger a model update and/or a debouncing delay so that the actual =
update only takes place when=0A=
 * a timer expires; this timer will be reset after another change takes =
place.=0A=
 *=0A=
 * Given the nature of `ngModelOptions`, the value displayed inside =
input fields in the view might=0A=
 * be different from the value in the actual model. This means that if =
you update the model you=0A=
 * should also invoke {@link =
ngModel.NgModelController#$rollbackViewValue} on the relevant input =
field in=0A=
 * order to make sure it is synchronized with the model and that any =
debounced action is canceled.=0A=
 *=0A=
 * The easiest way to reference the control's {@link =
ngModel.NgModelController#$rollbackViewValue}=0A=
 * method is by making sure the input is placed inside a form that has a =
`name` attribute. This is=0A=
 * important because `form` controllers are published to the related =
scope under the name in their=0A=
 * `name` attribute.=0A=
 *=0A=
 * Any pending changes will take place immediately when an enclosing =
form is submitted via the=0A=
 * `submit` event. Note that `ngClick` events will occur before the =
model is updated. Use `ngSubmit`=0A=
 * to have access to the updated model.=0A=
 *=0A=
 * The following example shows how to override immediate updates. =
Changes on the inputs within the=0A=
 * form will update the model only when the control loses focus (blur =
event). If `escape` key is=0A=
 * pressed while the input field is focused, the value is reset to the =
value in the current model.=0A=
 *=0A=
 * &lt;example name=3D"ngModelOptions-directive-blur" =
module=3D"optionsExample"&gt;=0A=
 *   &lt;file name=3D"index.html"&gt;=0A=
 *     &lt;div ng-controller=3D"ExampleController"&gt;=0A=
 *       &lt;form name=3D"userForm"&gt;=0A=
 *         &lt;label&gt;=0A=
 *           Name:=0A=
 *           &lt;input type=3D"text" name=3D"userName"=0A=
 *                  ng-model=3D"user.name"=0A=
 *                  ng-model-options=3D"{ updateOn: 'blur' }"=0A=
 *                  ng-keyup=3D"cancel($event)" /&gt;=0A=
 *         &lt;/label&gt;&lt;br /&gt;=0A=
 *         &lt;label&gt;=0A=
 *           Other data:=0A=
 *           &lt;input type=3D"text" ng-model=3D"user.data" /&gt;=0A=
 *         &lt;/label&gt;&lt;br /&gt;=0A=
 *       &lt;/form&gt;=0A=
 *       &lt;pre&gt;user.name =3D &lt;span =
ng-bind=3D"user.name"&gt;&lt;/span&gt;&lt;/pre&gt;=0A=
 *     &lt;/div&gt;=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"app.js"&gt;=0A=
 *     angular.module('optionsExample', [])=0A=
 *       .controller('ExampleController', ['$scope', function($scope) {=0A=
 *         $scope.user =3D { name: 'say', data: '' };=0A=
 *=0A=
 *         $scope.cancel =3D function(e) {=0A=
 *           if (e.keyCode =3D=3D=3D 27) {=0A=
 *             $scope.userForm.userName.$rollbackViewValue();=0A=
 *           }=0A=
 *         };=0A=
 *       }]);=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
 *     var model =3D element(by.binding('user.name'));=0A=
 *     var input =3D element(by.model('user.name'));=0A=
 *     var other =3D element(by.model('user.data'));=0A=
 *=0A=
 *     it('should allow custom events', function() {=0A=
 *       input.sendKeys(' hello');=0A=
 *       input.click();=0A=
 *       expect(model.getText()).toEqual('say');=0A=
 *       other.click();=0A=
 *       expect(model.getText()).toEqual('say hello');=0A=
 *     });=0A=
 *=0A=
 *     it('should $rollbackViewValue when model changes', function() {=0A=
 *       input.sendKeys(' hello');=0A=
 *       expect(input.getAttribute('value')).toEqual('say hello');=0A=
 *       input.sendKeys(protractor.Key.ESCAPE);=0A=
 *       expect(input.getAttribute('value')).toEqual('say');=0A=
 *       other.click();=0A=
 *       expect(model.getText()).toEqual('say');=0A=
 *     });=0A=
 *   &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 *=0A=
 * The next example shows how to debounce model changes. Model will be =
updated only 1 sec after last change.=0A=
 * If the `Clear` button is pressed, any debounced action is canceled =
and the value becomes empty.=0A=
 *=0A=
 * &lt;example name=3D"ngModelOptions-directive-debounce" =
module=3D"optionsExample"&gt;=0A=
 *   &lt;file name=3D"index.html"&gt;=0A=
 *     &lt;div ng-controller=3D"ExampleController"&gt;=0A=
 *       &lt;form name=3D"userForm"&gt;=0A=
 *         Name:=0A=
 *         &lt;input type=3D"text" name=3D"userName"=0A=
 *                ng-model=3D"user.name"=0A=
 *                ng-model-options=3D"{ debounce: 1000 }" /&gt;=0A=
 *         &lt;button =
ng-click=3D"userForm.userName.$rollbackViewValue(); =
user.name=3D''"&gt;Clear&lt;/button&gt;&lt;br /&gt;=0A=
 *       &lt;/form&gt;=0A=
 *       &lt;pre&gt;user.name =3D &lt;span =
ng-bind=3D"user.name"&gt;&lt;/span&gt;&lt;/pre&gt;=0A=
 *     &lt;/div&gt;=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"app.js"&gt;=0A=
 *     angular.module('optionsExample', [])=0A=
 *       .controller('ExampleController', ['$scope', function($scope) {=0A=
 *         $scope.user =3D { name: 'say' };=0A=
 *       }]);=0A=
 *   &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 *=0A=
 * ## Model updates and validation=0A=
 *=0A=
 * The default behaviour in `ngModel` is that the model value is set to =
`undefined` when the=0A=
 * validation determines that the value is invalid. By setting the =
`allowInvalid` property to true,=0A=
 * the model will still be updated even if the value is invalid.=0A=
 *=0A=
 *=0A=
 * ## Connecting to the scope=0A=
 *=0A=
 * By setting the `getterSetter` property to true you are telling =
ngModel that the `ngModel` expression=0A=
 * on the scope refers to a "getter/setter" function rather than the =
value itself.=0A=
 *=0A=
 * The following example shows how to bind to getter/setters:=0A=
 *=0A=
 * &lt;example name=3D"ngModelOptions-directive-getter-setter" =
module=3D"getterSetterExample"&gt;=0A=
 *   &lt;file name=3D"index.html"&gt;=0A=
 *     &lt;div ng-controller=3D"ExampleController"&gt;=0A=
 *       &lt;form name=3D"userForm"&gt;=0A=
 *         &lt;label&gt;=0A=
 *           Name:=0A=
 *           &lt;input type=3D"text" name=3D"userName"=0A=
 *                  ng-model=3D"user.name"=0A=
 *                  ng-model-options=3D"{ getterSetter: true }" /&gt;=0A=
 *         &lt;/label&gt;=0A=
 *       &lt;/form&gt;=0A=
 *       &lt;pre&gt;user.name =3D &lt;span =
ng-bind=3D"user.name()"&gt;&lt;/span&gt;&lt;/pre&gt;=0A=
 *     &lt;/div&gt;=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"app.js"&gt;=0A=
 *     angular.module('getterSetterExample', [])=0A=
 *       .controller('ExampleController', ['$scope', function($scope) {=0A=
 *         var _name =3D 'Brian';=0A=
 *         $scope.user =3D {=0A=
 *           name: function(newName) {=0A=
 *             return angular.isDefined(newName) ? (_name =3D newName) : =
_name;=0A=
 *           }=0A=
 *         };=0A=
 *       }]);=0A=
 *   &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 *=0A=
 *=0A=
 * ## Specifying timezones=0A=
 *=0A=
 * You can specify the timezone that date/time input directives expect =
by providing its name in the=0A=
 * `timezone` property.=0A=
 *=0A=
 * @param {Object} ngModelOptions options to apply to {@link ngModel} =
directives on this element and=0A=
 *   and its descendents. Valid keys are:=0A=
 *   - `updateOn`: string specifying which event should the input be =
bound to. You can set several=0A=
 *     events using an space delimited list. There is a special event =
called `default` that=0A=
 *     matches the default events belonging to the control.=0A=
 *   - `debounce`: integer value which contains the debounce model =
update value in milliseconds. A=0A=
 *     value of 0 triggers an immediate update. If an object is supplied =
instead, you can specify a=0A=
 *     custom value for each event. For example:=0A=
 *     ```=0A=
 *     ng-model-options=3D"{=0A=
 *       updateOn: 'default blur',=0A=
 *       debounce: { 'default': 500, 'blur': 0 }=0A=
 *     }"=0A=
 *     ```=0A=
 *   - `allowInvalid`: boolean value which indicates that the model can =
be set with values that did=0A=
 *     not validate correctly instead of the default behavior of setting =
the model to undefined.=0A=
 *   - `getterSetter`: boolean value which determines whether or not to =
treat functions bound to=0A=
 *     `ngModel` as getters/setters.=0A=
 *   - `timezone`: Defines the timezone to be used to read/write the =
`Date` instance in the model for=0A=
 *     `&lt;input type=3D"date" /&gt;`, `&lt;input type=3D"time" /&gt;`, =
... . It understands UTC/GMT and the=0A=
 *     continental US time zone abbreviations, but for general use, use =
a time zone offset, for=0A=
 *     example, `'+0430'` (4 hours, 30 minutes east of the Greenwich =
meridian)=0A=
 *     If not specified, the timezone of the browser will be used.=0A=
 *=0A=
 */=0A=
var ngModelOptionsDirective =3D function() {=0A=
  NgModelOptionsController.$inject =3D ['$attrs', '$scope'];=0A=
  function NgModelOptionsController($attrs, $scope) {=0A=
    this.$$attrs =3D $attrs;=0A=
    this.$$scope =3D $scope;=0A=
  }=0A=
  NgModelOptionsController.prototype =3D {=0A=
    $onInit: function() {=0A=
      var parentOptions =3D this.parentCtrl ? this.parentCtrl.$options : =
defaultModelOptions;=0A=
      var modelOptionsDefinition =3D =
this.$$scope.$eval(this.$$attrs.ngModelOptions);=0A=
=0A=
      this.$options =3D =
parentOptions.createChild(modelOptionsDefinition);=0A=
    }=0A=
  };=0A=
=0A=
  return {=0A=
    restrict: 'A',=0A=
    // ngModelOptions needs to run before ngModel and input directives=0A=
    priority: 10,=0A=
    require: {parentCtrl: '?^^ngModelOptions'},=0A=
    bindToController: true,=0A=
    controller: NgModelOptionsController=0A=
  };=0A=
};=0A=
=0A=
=0A=
// shallow copy over values from `src` that are not already specified on =
`dst`=0A=
function defaults(dst, src) {=0A=
  forEach(src, function(value, key) {=0A=
    if (!isDefined(dst[key])) {=0A=
      dst[key] =3D value;=0A=
    }=0A=
  });=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngNonBindable=0A=
 * @restrict AC=0A=
 * @priority 1000=0A=
 *=0A=
 * @description=0A=
 * The `ngNonBindable` directive tells Angular not to compile or bind =
the contents of the current=0A=
 * DOM element. This is useful if the element contains what appears to =
be Angular directives and=0A=
 * bindings but which should be ignored by Angular. This could be the =
case if you have a site that=0A=
 * displays snippets of code, for instance.=0A=
 *=0A=
 * @element ANY=0A=
 *=0A=
 * @example=0A=
 * In this example there are two locations where a simple interpolation =
binding (`{{}}`) is present,=0A=
 * but the one wrapped in `ngNonBindable` is left alone.=0A=
 *=0A=
 * @example=0A=
    &lt;example name=3D"ng-non-bindable"&gt;=0A=
      &lt;file name=3D"index.html"&gt;=0A=
        &lt;div&gt;Normal: {{1 + 2}}&lt;/div&gt;=0A=
        &lt;div ng-non-bindable&gt;Ignored: {{1 + 2}}&lt;/div&gt;=0A=
      &lt;/file&gt;=0A=
      &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should check ng-non-bindable', function() {=0A=
         expect(element(by.binding('1 + 2')).getText()).toContain('3');=0A=
         expect(element.all(by.css('div')).last().getText()).toMatch(/1 =
\+ 2/);=0A=
       });=0A=
      &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
 */=0A=
var ngNonBindableDirective =3D ngDirective({ terminal: true, priority: =
1000 });=0A=
=0A=
/* exported ngOptionsDirective */=0A=
=0A=
/* global jqLiteRemove */=0A=
=0A=
var ngOptionsMinErr =3D minErr('ngOptions');=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngOptions=0A=
 * @restrict A=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * The `ngOptions` attribute can be used to dynamically generate a list =
of `&lt;option&gt;`=0A=
 * elements for the `&lt;select&gt;` element using the array or object =
obtained by evaluating the=0A=
 * `ngOptions` comprehension expression.=0A=
 *=0A=
 * In many cases, {@link ng.directive:ngRepeat ngRepeat} can be used on =
`&lt;option&gt;` elements instead of=0A=
 * `ngOptions` to achieve a similar result. However, `ngOptions` =
provides some benefits:=0A=
 * - more flexibility in how the `&lt;select&gt;`'s model is assigned =
via the `select` **`as`** part of the=0A=
 * comprehension expression=0A=
 * - reduced memory consumption by not creating a new scope for each =
repeated instance=0A=
 * - increased render speed by creating the options in a =
documentFragment instead of individually=0A=
 *=0A=
 * When an item in the `&lt;select&gt;` menu is selected, the array =
element or object property=0A=
 * represented by the selected option will be bound to the model =
identified by the `ngModel`=0A=
 * directive.=0A=
 *=0A=
 * Optionally, a single hard-coded `&lt;option&gt;` element, with the =
value set to an empty string, can=0A=
 * be nested into the `&lt;select&gt;` element. This element will then =
represent the `null` or "not selected"=0A=
 * option. See example below for demonstration.=0A=
 *=0A=
 * ## Complex Models (objects or collections)=0A=
 *=0A=
 * By default, `ngModel` watches the model by reference, not value. This =
is important to know when=0A=
 * binding the select to a model that is an object or a collection.=0A=
 *=0A=
 * One issue occurs if you want to preselect an option. For example, if =
you set=0A=
 * the model to an object that is equal to an object in your collection, =
`ngOptions` won't be able to set the selection,=0A=
 * because the objects are not identical. So by default, you should =
always reference the item in your collection=0A=
 * for preselections, e.g.: `$scope.selected =3D $scope.collection[3]`.=0A=
 *=0A=
 * Another solution is to use a `track by` clause, because then =
`ngOptions` will track the identity=0A=
 * of the item not by reference, but by the result of the `track by` =
expression. For example, if your=0A=
 * collection items have an id property, you would `track by item.id`.=0A=
 *=0A=
 * A different issue with objects or collections is that ngModel won't =
detect if an object property or=0A=
 * a collection item changes. For that reason, `ngOptions` additionally =
watches the model using=0A=
 * `$watchCollection`, when the expression contains a `track by` clause =
or the the select has the `multiple` attribute.=0A=
 * This allows ngOptions to trigger a re-rendering of the options even =
if the actual object/collection=0A=
 * has not changed identity, but only a property on the object or an =
item in the collection changes.=0A=
 *=0A=
 * Note that `$watchCollection` does a shallow comparison of the =
properties of the object (or the items in the collection=0A=
 * if the model is an array). This means that changing a property deeper =
than the first level inside the=0A=
 * object/collection will not trigger a re-rendering.=0A=
 *=0A=
 * ## `select` **`as`**=0A=
 *=0A=
 * Using `select` **`as`** will bind the result of the `select` =
expression to the model, but=0A=
 * the value of the `&lt;select&gt;` and `&lt;option&gt;` html elements =
will be either the index (for array data sources)=0A=
 * or property name (for object data sources) of the value within the =
collection. If a **`track by`** expression=0A=
 * is used, the result of that expression will be set as the value of =
the `option` and `select` elements.=0A=
 *=0A=
 *=0A=
 * ### `select` **`as`** and **`track by`**=0A=
 *=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * Be careful when using `select` **`as`** and **`track by`** in the =
same expression.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * Given this array of items on the $scope:=0A=
 *=0A=
 * ```js=0A=
 * $scope.items =3D [{=0A=
 *   id: 1,=0A=
 *   label: 'aLabel',=0A=
 *   subItem: { name: 'aSubItem' }=0A=
 * }, {=0A=
 *   id: 2,=0A=
 *   label: 'bLabel',=0A=
 *   subItem: { name: 'bSubItem' }=0A=
 * }];=0A=
 * ```=0A=
 *=0A=
 * This will work:=0A=
 *=0A=
 * ```html=0A=
 * &lt;select ng-options=3D"item as item.label for item in items track =
by item.id" ng-model=3D"selected"&gt;&lt;/select&gt;=0A=
 * ```=0A=
 * ```js=0A=
 * $scope.selected =3D $scope.items[0];=0A=
 * ```=0A=
 *=0A=
 * but this will not work:=0A=
 *=0A=
 * ```html=0A=
 * &lt;select ng-options=3D"item.subItem as item.label for item in items =
track by item.id" ng-model=3D"selected"&gt;&lt;/select&gt;=0A=
 * ```=0A=
 * ```js=0A=
 * $scope.selected =3D $scope.items[0].subItem;=0A=
 * ```=0A=
 *=0A=
 * In both examples, the **`track by`** expression is applied =
successfully to each `item` in the=0A=
 * `items` array. Because the selected option has been set =
programmatically in the controller, the=0A=
 * **`track by`** expression is also applied to the `ngModel` value. In =
the first example, the=0A=
 * `ngModel` value is `items[0]` and the **`track by`** expression =
evaluates to `items[0].id` with=0A=
 * no issue. In the second example, the `ngModel` value is =
`items[0].subItem` and the **`track by`**=0A=
 * expression evaluates to `items[0].subItem.id` (which is undefined). =
As a result, the model value=0A=
 * is not matched against any `&lt;option&gt;` and the `&lt;select&gt;` =
appears as having no selected value.=0A=
 *=0A=
 *=0A=
 * @param {string} ngModel Assignable AngularJS expression to data-bind =
to.=0A=
 * @param {comprehension_expression} ngOptions in one of the following =
forms:=0A=
 *=0A=
 *   * for array data sources:=0A=
 *     * `label` **`for`** `value` **`in`** `array`=0A=
 *     * `select` **`as`** `label` **`for`** `value` **`in`** `array`=0A=
 *     * `label` **`group by`** `group` **`for`** `value` **`in`** =
`array`=0A=
 *     * `label` **`disable when`** `disable` **`for`** `value` **`in`** =
`array`=0A=
 *     * `label` **`group by`** `group` **`for`** `value` **`in`** =
`array` **`track by`** `trackexpr`=0A=
 *     * `label` **`disable when`** `disable` **`for`** `value` **`in`** =
`array` **`track by`** `trackexpr`=0A=
 *     * `label` **`for`** `value` **`in`** `array` | =
orderBy:`orderexpr` **`track by`** `trackexpr`=0A=
 *        (for including a filter with `track by`)=0A=
 *   * for object data sources:=0A=
 *     * `label` **`for (`**`key` **`,`** `value`**`) in`** `object`=0A=
 *     * `select` **`as`** `label` **`for (`**`key` **`,`** `value`**`) =
in`** `object`=0A=
 *     * `label` **`group by`** `group` **`for (`**`key`**`,`** =
`value`**`) in`** `object`=0A=
 *     * `label` **`disable when`** `disable` **`for (`**`key`**`,`** =
`value`**`) in`** `object`=0A=
 *     * `select` **`as`** `label` **`group by`** `group`=0A=
 *         **`for` `(`**`key`**`,`** `value`**`) in`** `object`=0A=
 *     * `select` **`as`** `label` **`disable when`** `disable`=0A=
 *         **`for` `(`**`key`**`,`** `value`**`) in`** `object`=0A=
 *=0A=
 * Where:=0A=
 *=0A=
 *   * `array` / `object`: an expression which evaluates to an array / =
object to iterate over.=0A=
 *   * `value`: local variable which will refer to each item in the =
`array` or each property value=0A=
 *      of `object` during iteration.=0A=
 *   * `key`: local variable which will refer to a property name in =
`object` during iteration.=0A=
 *   * `label`: The result of this expression will be the label for =
`&lt;option&gt;` element. The=0A=
 *     `expression` will most likely refer to the `value` variable (e.g. =
`value.propertyName`).=0A=
 *   * `select`: The result of this expression will be bound to the =
model of the parent `&lt;select&gt;`=0A=
 *      element. If not specified, `select` expression will default to =
`value`.=0A=
 *   * `group`: The result of this expression will be used to group =
options using the `&lt;optgroup&gt;`=0A=
 *      DOM element.=0A=
 *   * `disable`: The result of this expression will be used to disable =
the rendered `&lt;option&gt;`=0A=
 *      element. Return `true` to disable.=0A=
 *   * `trackexpr`: Used when working with an array of objects. The =
result of this expression will be=0A=
 *      used to identify the objects in the array. The `trackexpr` will =
most likely refer to the=0A=
 *     `value` variable (e.g. `value.propertyName`). With this the =
selection is preserved=0A=
 *      even when the options are recreated (e.g. reloaded from the =
server).=0A=
 * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
 * @param {string=3D} required The control is considered valid only if =
value is entered.=0A=
 * @param {string=3D} ngRequired Adds `required` attribute and =
`required` validation constraint to=0A=
 *    the element when the ngRequired expression evaluates to true. Use =
`ngRequired` instead of=0A=
 *    `required` when you want to data-bind to the `required` attribute.=0A=
 * @param {string=3D} ngAttrSize sets the size of the select element =
dynamically. Uses the=0A=
 * {@link =
guide/interpolation#-ngattr-for-binding-to-arbitrary-attributes ngAttr} =
directive.=0A=
 *=0A=
 * @example=0A=
    &lt;example module=3D"selectExample" name=3D"select"&gt;=0A=
      &lt;file name=3D"index.html"&gt;=0A=
        &lt;script&gt;=0A=
        angular.module('selectExample', [])=0A=
          .controller('ExampleController', ['$scope', function($scope) {=0A=
            $scope.colors =3D [=0A=
              {name:'black', shade:'dark'},=0A=
              {name:'white', shade:'light', notAnOption: true},=0A=
              {name:'red', shade:'dark'},=0A=
              {name:'blue', shade:'dark', notAnOption: true},=0A=
              {name:'yellow', shade:'light', notAnOption: false}=0A=
            ];=0A=
            $scope.myColor =3D $scope.colors[2]; // red=0A=
          }]);=0A=
        &lt;/script&gt;=0A=
        &lt;div ng-controller=3D"ExampleController"&gt;=0A=
          &lt;ul&gt;=0A=
            &lt;li ng-repeat=3D"color in colors"&gt;=0A=
              &lt;label&gt;Name: &lt;input =
ng-model=3D"color.name"&gt;&lt;/label&gt;=0A=
              &lt;label&gt;&lt;input type=3D"checkbox" =
ng-model=3D"color.notAnOption"&gt; Disabled?&lt;/label&gt;=0A=
              &lt;button ng-click=3D"colors.splice($index, 1)" =
aria-label=3D"Remove"&gt;X&lt;/button&gt;=0A=
            &lt;/li&gt;=0A=
            &lt;li&gt;=0A=
              &lt;button =
ng-click=3D"colors.push({})"&gt;add&lt;/button&gt;=0A=
            &lt;/li&gt;=0A=
          &lt;/ul&gt;=0A=
          &lt;hr/&gt;=0A=
          &lt;label&gt;Color (null not allowed):=0A=
            &lt;select ng-model=3D"myColor" ng-options=3D"color.name for =
color in colors"&gt;&lt;/select&gt;=0A=
          &lt;/label&gt;&lt;br/&gt;=0A=
          &lt;label&gt;Color (null allowed):=0A=
          &lt;span  class=3D"nullable"&gt;=0A=
            &lt;select ng-model=3D"myColor" ng-options=3D"color.name for =
color in colors"&gt;=0A=
              &lt;option value=3D""&gt;-- choose color --&lt;/option&gt;=0A=
            &lt;/select&gt;=0A=
          &lt;/span&gt;&lt;/label&gt;&lt;br/&gt;=0A=
=0A=
          &lt;label&gt;Color grouped by shade:=0A=
            &lt;select ng-model=3D"myColor" ng-options=3D"color.name =
group by color.shade for color in colors"&gt;=0A=
            &lt;/select&gt;=0A=
          &lt;/label&gt;&lt;br/&gt;=0A=
=0A=
          &lt;label&gt;Color grouped by shade, with some disabled:=0A=
            &lt;select ng-model=3D"myColor"=0A=
                  ng-options=3D"color.name group by color.shade disable =
when color.notAnOption for color in colors"&gt;=0A=
            &lt;/select&gt;=0A=
          &lt;/label&gt;&lt;br/&gt;=0A=
=0A=
=0A=
=0A=
          Select &lt;button ng-click=3D"myColor =3D { name:'not in =
list', shade: 'other' }"&gt;bogus&lt;/button&gt;.=0A=
          &lt;br/&gt;=0A=
          &lt;hr/&gt;=0A=
          Currently selected: {{ {selected_color:myColor} }}=0A=
          &lt;div style=3D"border:solid 1px black; height:20px"=0A=
               ng-style=3D"{'background-color':myColor.name}"&gt;=0A=
          &lt;/div&gt;=0A=
        &lt;/div&gt;=0A=
      &lt;/file&gt;=0A=
      &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
         it('should check ng-options', function() {=0A=
           =
expect(element(by.binding('{selected_color:myColor}')).getText()).toMatch=
('red');=0A=
           element.all(by.model('myColor')).first().click();=0A=
           element.all(by.css('select[ng-model=3D"myColor"] =
option')).first().click();=0A=
           =
expect(element(by.binding('{selected_color:myColor}')).getText()).toMatch=
('black');=0A=
           element(by.css('.nullable =
select[ng-model=3D"myColor"]')).click();=0A=
           element.all(by.css('.nullable select[ng-model=3D"myColor"] =
option')).first().click();=0A=
           =
expect(element(by.binding('{selected_color:myColor}')).getText()).toMatch=
('null');=0A=
         });=0A=
      &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
 */=0A=
=0A=
/* eslint-disable max-len */=0A=
//                     =
//00001111111111000000000002222222222000000000000000000000333333333300000=
0000000000000000000044444444444000000000000055555555555550000000006666666=
6666660000000777777777777700000000000000088888888880000000000000000000999=
9999999=0A=
var NG_OPTIONS_REGEXP =3D =
/^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\=
s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$=
\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s=
\S]+?))?$/;=0A=
                        // 1: value expression (valueFn)=0A=
                        // 2: label expression (displayFn)=0A=
                        // 3: group by expression (groupByFn)=0A=
                        // 4: disable when expression (disableWhenFn)=0A=
                        // 5: array item variable name=0A=
                        // 6: object item key variable name=0A=
                        // 7: object item value variable name=0A=
                        // 8: collection expression=0A=
                        // 9: track by expression=0A=
/* eslint-enable */=0A=
=0A=
=0A=
var ngOptionsDirective =3D ['$compile', '$document', '$parse', =
function($compile, $document, $parse) {=0A=
=0A=
  function parseOptionsExpression(optionsExp, selectElement, scope) {=0A=
=0A=
    var match =3D optionsExp.match(NG_OPTIONS_REGEXP);=0A=
    if (!(match)) {=0A=
      throw ngOptionsMinErr('iexp',=0A=
        'Expected expression in form of ' +=0A=
        '\'_select_ (as _label_)? for (_key_,)?_value_ in =
_collection_\'' +=0A=
        ' but got \'{0}\'. Element: {1}',=0A=
        optionsExp, startingTag(selectElement));=0A=
    }=0A=
=0A=
    // Extract the parts from the ngOptions expression=0A=
=0A=
    // The variable name for the value of the item in the collection=0A=
    var valueName =3D match[5] || match[7];=0A=
    // The variable name for the key of the item in the collection=0A=
    var keyName =3D match[6];=0A=
=0A=
    // An expression that generates the viewValue for an option if there =
is a label expression=0A=
    var selectAs =3D / as /.test(match[0]) &amp;&amp; match[1];=0A=
    // An expression that is used to track the id of each object in the =
options collection=0A=
    var trackBy =3D match[9];=0A=
    // An expression that generates the viewValue for an option if there =
is no label expression=0A=
    var valueFn =3D $parse(match[2] ? match[1] : valueName);=0A=
    var selectAsFn =3D selectAs &amp;&amp; $parse(selectAs);=0A=
    var viewValueFn =3D selectAsFn || valueFn;=0A=
    var trackByFn =3D trackBy &amp;&amp; $parse(trackBy);=0A=
=0A=
    // Get the value by which we are going to track the option=0A=
    // if we have a trackFn then use that (passing scope and locals)=0A=
    // otherwise just hash the given viewValue=0A=
    var getTrackByValueFn =3D trackBy ?=0A=
                              function(value, locals) { return =
trackByFn(scope, locals); } :=0A=
                              function getHashOfValue(value) { return =
hashKey(value); };=0A=
    var getTrackByValue =3D function(value, key) {=0A=
      return getTrackByValueFn(value, getLocals(value, key));=0A=
    };=0A=
=0A=
    var displayFn =3D $parse(match[2] || match[1]);=0A=
    var groupByFn =3D $parse(match[3] || '');=0A=
    var disableWhenFn =3D $parse(match[4] || '');=0A=
    var valuesFn =3D $parse(match[8]);=0A=
=0A=
    var locals =3D {};=0A=
    var getLocals =3D keyName ? function(value, key) {=0A=
      locals[keyName] =3D key;=0A=
      locals[valueName] =3D value;=0A=
      return locals;=0A=
    } : function(value) {=0A=
      locals[valueName] =3D value;=0A=
      return locals;=0A=
    };=0A=
=0A=
=0A=
    function Option(selectValue, viewValue, label, group, disabled) {=0A=
      this.selectValue =3D selectValue;=0A=
      this.viewValue =3D viewValue;=0A=
      this.label =3D label;=0A=
      this.group =3D group;=0A=
      this.disabled =3D disabled;=0A=
    }=0A=
=0A=
    function getOptionValuesKeys(optionValues) {=0A=
      var optionValuesKeys;=0A=
=0A=
      if (!keyName &amp;&amp; isArrayLike(optionValues)) {=0A=
        optionValuesKeys =3D optionValues;=0A=
      } else {=0A=
        // if object, extract keys, in enumeration order, unsorted=0A=
        optionValuesKeys =3D [];=0A=
        for (var itemKey in optionValues) {=0A=
          if (optionValues.hasOwnProperty(itemKey) &amp;&amp; =
itemKey.charAt(0) !=3D=3D '$') {=0A=
            optionValuesKeys.push(itemKey);=0A=
          }=0A=
        }=0A=
      }=0A=
      return optionValuesKeys;=0A=
    }=0A=
=0A=
    return {=0A=
      trackBy: trackBy,=0A=
      getTrackByValue: getTrackByValue,=0A=
      getWatchables: $parse(valuesFn, function(optionValues) {=0A=
        // Create a collection of things that we would like to watch =
(watchedArray)=0A=
        // so that they can all be watched using a single =
$watchCollection=0A=
        // that only runs the handler once if anything changes=0A=
        var watchedArray =3D [];=0A=
        optionValues =3D optionValues || [];=0A=
=0A=
        var optionValuesKeys =3D getOptionValuesKeys(optionValues);=0A=
        var optionValuesLength =3D optionValuesKeys.length;=0A=
        for (var index =3D 0; index &lt; optionValuesLength; index++) {=0A=
          var key =3D (optionValues =3D=3D=3D optionValuesKeys) ? index =
: optionValuesKeys[index];=0A=
          var value =3D optionValues[key];=0A=
=0A=
          var locals =3D getLocals(value, key);=0A=
          var selectValue =3D getTrackByValueFn(value, locals);=0A=
          watchedArray.push(selectValue);=0A=
=0A=
          // Only need to watch the displayFn if there is a specific =
label expression=0A=
          if (match[2] || match[1]) {=0A=
            var label =3D displayFn(scope, locals);=0A=
            watchedArray.push(label);=0A=
          }=0A=
=0A=
          // Only need to watch the disableWhenFn if there is a specific =
disable expression=0A=
          if (match[4]) {=0A=
            var disableWhen =3D disableWhenFn(scope, locals);=0A=
            watchedArray.push(disableWhen);=0A=
          }=0A=
        }=0A=
        return watchedArray;=0A=
      }),=0A=
=0A=
      getOptions: function() {=0A=
=0A=
        var optionItems =3D [];=0A=
        var selectValueMap =3D {};=0A=
=0A=
        // The option values were already computed in the =
`getWatchables` fn,=0A=
        // which must have been called to trigger `getOptions`=0A=
        var optionValues =3D valuesFn(scope) || [];=0A=
        var optionValuesKeys =3D getOptionValuesKeys(optionValues);=0A=
        var optionValuesLength =3D optionValuesKeys.length;=0A=
=0A=
        for (var index =3D 0; index &lt; optionValuesLength; index++) {=0A=
          var key =3D (optionValues =3D=3D=3D optionValuesKeys) ? index =
: optionValuesKeys[index];=0A=
          var value =3D optionValues[key];=0A=
          var locals =3D getLocals(value, key);=0A=
          var viewValue =3D viewValueFn(scope, locals);=0A=
          var selectValue =3D getTrackByValueFn(viewValue, locals);=0A=
          var label =3D displayFn(scope, locals);=0A=
          var group =3D groupByFn(scope, locals);=0A=
          var disabled =3D disableWhenFn(scope, locals);=0A=
          var optionItem =3D new Option(selectValue, viewValue, label, =
group, disabled);=0A=
=0A=
          optionItems.push(optionItem);=0A=
          selectValueMap[selectValue] =3D optionItem;=0A=
        }=0A=
=0A=
        return {=0A=
          items: optionItems,=0A=
          selectValueMap: selectValueMap,=0A=
          getOptionFromViewValue: function(value) {=0A=
            return selectValueMap[getTrackByValue(value)];=0A=
          },=0A=
          getViewValueFromOption: function(option) {=0A=
            // If the viewValue could be an object that may be mutated =
by the application,=0A=
            // we need to make a copy and not return the reference to =
the value on the option.=0A=
            return trackBy ? copy(option.viewValue) : option.viewValue;=0A=
          }=0A=
        };=0A=
      }=0A=
    };=0A=
  }=0A=
=0A=
=0A=
  // Support: IE 9 only=0A=
  // We can't just jqLite('&lt;option&gt;') since jqLite is not smart =
enough=0A=
  // to create it in &lt;select&gt; and IE barfs otherwise.=0A=
  var optionTemplate =3D window.document.createElement('option'),=0A=
      optGroupTemplate =3D window.document.createElement('optgroup');=0A=
=0A=
    function ngOptionsPostLink(scope, selectElement, attr, ctrls) {=0A=
=0A=
      var selectCtrl =3D ctrls[0];=0A=
      var ngModelCtrl =3D ctrls[1];=0A=
      var multiple =3D attr.multiple;=0A=
=0A=
      // The emptyOption allows the application developer to provide =
their own custom "empty"=0A=
      // option when the viewValue does not match any of the option =
values.=0A=
      for (var i =3D 0, children =3D selectElement.children(), ii =3D =
children.length; i &lt; ii; i++) {=0A=
        if (children[i].value =3D=3D=3D '') {=0A=
          selectCtrl.hasEmptyOption =3D true;=0A=
          selectCtrl.emptyOption =3D children.eq(i);=0A=
          break;=0A=
        }=0A=
      }=0A=
=0A=
      // The empty option will be compiled and rendered before we first =
generate the options=0A=
      selectElement.empty();=0A=
=0A=
      var providedEmptyOption =3D !!selectCtrl.emptyOption;=0A=
=0A=
      var unknownOption =3D jqLite(optionTemplate.cloneNode(false));=0A=
      unknownOption.val('?');=0A=
=0A=
      var options;=0A=
      var ngOptions =3D parseOptionsExpression(attr.ngOptions, =
selectElement, scope);=0A=
      // This stores the newly created options before they are appended =
to the select.=0A=
      // Since the contents are removed from the fragment when it is =
appended,=0A=
      // we only need to create it once.=0A=
      var listFragment =3D $document[0].createDocumentFragment();=0A=
=0A=
      // Overwrite the implementation. ngOptions doesn't use hashes=0A=
      selectCtrl.generateUnknownOptionValue =3D function(val) {=0A=
        return '?';=0A=
      };=0A=
=0A=
      // Update the controller methods for multiple selectable options=0A=
      if (!multiple) {=0A=
=0A=
        selectCtrl.writeValue =3D function writeNgOptionsValue(value) {=0A=
          // The options might not be defined yet when ngModel tries to =
render=0A=
          if (!options) return;=0A=
=0A=
          var selectedOption =3D =
selectElement[0].options[selectElement[0].selectedIndex];=0A=
          var option =3D options.getOptionFromViewValue(value);=0A=
=0A=
          // Make sure to remove the selected attribute from the =
previously selected option=0A=
          // Otherwise, screen readers might get confused=0A=
          if (selectedOption) selectedOption.removeAttribute('selected');=0A=
=0A=
          if (option) {=0A=
            // Don't update the option when it is already selected.=0A=
            // For example, the browser will select the first option by =
default. In that case,=0A=
            // most properties are set automatically - except the =
`selected` attribute, which we=0A=
            // set always=0A=
=0A=
            if (selectElement[0].value !=3D=3D option.selectValue) {=0A=
              selectCtrl.removeUnknownOption();=0A=
=0A=
              selectElement[0].value =3D option.selectValue;=0A=
              option.element.selected =3D true;=0A=
            }=0A=
=0A=
            option.element.setAttribute('selected', 'selected');=0A=
          } else {=0A=
            selectCtrl.selectUnknownOrEmptyOption(value);=0A=
          }=0A=
        };=0A=
=0A=
        selectCtrl.readValue =3D function readNgOptionsValue() {=0A=
=0A=
          var selectedOption =3D =
options.selectValueMap[selectElement.val()];=0A=
=0A=
          if (selectedOption &amp;&amp; !selectedOption.disabled) {=0A=
            selectCtrl.unselectEmptyOption();=0A=
            selectCtrl.removeUnknownOption();=0A=
            return options.getViewValueFromOption(selectedOption);=0A=
          }=0A=
          return null;=0A=
        };=0A=
=0A=
        // If we are using `track by` then we must watch the tracked =
value on the model=0A=
        // since ngModel only watches for object identity change=0A=
        // FIXME: When a user selects an option, this watch will fire =
needlessly=0A=
        if (ngOptions.trackBy) {=0A=
          scope.$watch(=0A=
            function() { return =
ngOptions.getTrackByValue(ngModelCtrl.$viewValue); },=0A=
            function() { ngModelCtrl.$render(); }=0A=
          );=0A=
        }=0A=
=0A=
      } else {=0A=
=0A=
        selectCtrl.writeValue =3D function =
writeNgOptionsMultiple(values) {=0A=
          // The options might not be defined yet when ngModel tries to =
render=0A=
          if (!options) return;=0A=
=0A=
          // Only set `&lt;option&gt;.selected` if necessary, in order =
to prevent some browsers from=0A=
          // scrolling to `&lt;option&gt;` elements that are outside the =
`&lt;select&gt;` element's viewport.=0A=
          var selectedOptions =3D values &amp;&amp; =
values.map(getAndUpdateSelectedOption) || [];=0A=
=0A=
          options.items.forEach(function(option) {=0A=
            if (option.element.selected &amp;&amp; =
!includes(selectedOptions, option)) {=0A=
              option.element.selected =3D false;=0A=
            }=0A=
          });=0A=
        };=0A=
=0A=
=0A=
        selectCtrl.readValue =3D function readNgOptionsMultiple() {=0A=
          var selectedValues =3D selectElement.val() || [],=0A=
              selections =3D [];=0A=
=0A=
          forEach(selectedValues, function(value) {=0A=
            var option =3D options.selectValueMap[value];=0A=
            if (option &amp;&amp; !option.disabled) =
selections.push(options.getViewValueFromOption(option));=0A=
          });=0A=
=0A=
          return selections;=0A=
        };=0A=
=0A=
        // If we are using `track by` then we must watch these tracked =
values on the model=0A=
        // since ngModel only watches for object identity change=0A=
        if (ngOptions.trackBy) {=0A=
=0A=
          scope.$watchCollection(function() {=0A=
            if (isArray(ngModelCtrl.$viewValue)) {=0A=
              return ngModelCtrl.$viewValue.map(function(value) {=0A=
                return ngOptions.getTrackByValue(value);=0A=
              });=0A=
            }=0A=
          }, function() {=0A=
            ngModelCtrl.$render();=0A=
          });=0A=
=0A=
        }=0A=
      }=0A=
=0A=
      if (providedEmptyOption) {=0A=
=0A=
        // compile the element since there might be bindings in it=0A=
        $compile(selectCtrl.emptyOption)(scope);=0A=
=0A=
        selectElement.prepend(selectCtrl.emptyOption);=0A=
=0A=
        if (selectCtrl.emptyOption[0].nodeType =3D=3D=3D =
NODE_TYPE_COMMENT) {=0A=
          // This means the empty option has currently no actual DOM =
node, probably because=0A=
          // it has been modified by a transclusion directive.=0A=
          selectCtrl.hasEmptyOption =3D false;=0A=
=0A=
          // Redefine the registerOption function, which will catch=0A=
          // options that are added by ngIf etc. (rendering of the node =
is async because of=0A=
          // lazy transclusion)=0A=
          selectCtrl.registerOption =3D function(optionScope, optionEl) {=0A=
            if (optionEl.val() =3D=3D=3D '') {=0A=
              selectCtrl.hasEmptyOption =3D true;=0A=
              selectCtrl.emptyOption =3D optionEl;=0A=
              selectCtrl.emptyOption.removeClass('ng-scope');=0A=
              // This ensures the new empty option is selected if =
previously no option was selected=0A=
              ngModelCtrl.$render();=0A=
=0A=
              optionEl.on('$destroy', function() {=0A=
                var needsRerender =3D =
selectCtrl.$isEmptyOptionSelected();=0A=
=0A=
                selectCtrl.hasEmptyOption =3D false;=0A=
                selectCtrl.emptyOption =3D undefined;=0A=
=0A=
                if (needsRerender) ngModelCtrl.$render();=0A=
              });=0A=
            }=0A=
          };=0A=
=0A=
        } else {=0A=
          // remove the class, which is added automatically because we =
recompile the element and it=0A=
          // becomes the compilation root=0A=
          selectCtrl.emptyOption.removeClass('ng-scope');=0A=
        }=0A=
=0A=
      }=0A=
=0A=
      // We will re-render the option elements if the option values or =
labels change=0A=
      scope.$watchCollection(ngOptions.getWatchables, updateOptions);=0A=
=0A=
      // =
------------------------------------------------------------------ //=0A=
=0A=
      function addOptionElement(option, parent) {=0A=
        var optionElement =3D optionTemplate.cloneNode(false);=0A=
        parent.appendChild(optionElement);=0A=
        updateOptionElement(option, optionElement);=0A=
      }=0A=
=0A=
      function getAndUpdateSelectedOption(viewValue) {=0A=
        var option =3D options.getOptionFromViewValue(viewValue);=0A=
        var element =3D option &amp;&amp; option.element;=0A=
=0A=
        if (element &amp;&amp; !element.selected) element.selected =3D =
true;=0A=
=0A=
        return option;=0A=
      }=0A=
=0A=
      function updateOptionElement(option, element) {=0A=
        option.element =3D element;=0A=
        element.disabled =3D option.disabled;=0A=
        // Support: IE 11 only, Edge 12-13 only=0A=
        // NOTE: The label must be set before the value, otherwise IE 11 =
&amp; Edge create unresponsive=0A=
        // selects in certain circumstances when multiple selects are =
next to each other and display=0A=
        // the option list in listbox style, i.e. the select is =
[multiple], or specifies a [size].=0A=
        // See https://github.com/angular/angular.js/issues/11314 for =
more info.=0A=
        // This is unfortunately untestable with unit / e2e tests=0A=
        if (option.label !=3D=3D element.label) {=0A=
          element.label =3D option.label;=0A=
          element.textContent =3D option.label;=0A=
        }=0A=
        element.value =3D option.selectValue;=0A=
      }=0A=
=0A=
      function updateOptions() {=0A=
        var previousValue =3D options &amp;&amp; selectCtrl.readValue();=0A=
=0A=
        // We must remove all current options, but cannot simply set =
innerHTML =3D null=0A=
        // since the providedEmptyOption might have an ngIf on it that =
inserts comments which we=0A=
        // must preserve.=0A=
        // Instead, iterate over the current option elements and remove =
them or their optgroup=0A=
        // parents=0A=
        if (options) {=0A=
=0A=
          for (var i =3D options.items.length - 1; i &gt;=3D 0; i--) {=0A=
            var option =3D options.items[i];=0A=
            if (isDefined(option.group)) {=0A=
              jqLiteRemove(option.element.parentNode);=0A=
            } else {=0A=
              jqLiteRemove(option.element);=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        options =3D ngOptions.getOptions();=0A=
=0A=
        var groupElementMap =3D {};=0A=
=0A=
        options.items.forEach(function addOption(option) {=0A=
          var groupElement;=0A=
=0A=
          if (isDefined(option.group)) {=0A=
=0A=
            // This option is to live in a group=0A=
            // See if we have already created this group=0A=
            groupElement =3D groupElementMap[option.group];=0A=
=0A=
            if (!groupElement) {=0A=
=0A=
              groupElement =3D optGroupTemplate.cloneNode(false);=0A=
              listFragment.appendChild(groupElement);=0A=
=0A=
              // Update the label on the group element=0A=
              // "null" is special cased because of Safari=0A=
              groupElement.label =3D option.group =3D=3D=3D null ? =
'null' : option.group;=0A=
=0A=
              // Store it for use later=0A=
              groupElementMap[option.group] =3D groupElement;=0A=
            }=0A=
=0A=
            addOptionElement(option, groupElement);=0A=
=0A=
          } else {=0A=
=0A=
            // This option is not in a group=0A=
            addOptionElement(option, listFragment);=0A=
          }=0A=
        });=0A=
=0A=
        selectElement[0].appendChild(listFragment);=0A=
=0A=
        ngModelCtrl.$render();=0A=
=0A=
        // Check to see if the value has changed due to the update to =
the options=0A=
        if (!ngModelCtrl.$isEmpty(previousValue)) {=0A=
          var nextValue =3D selectCtrl.readValue();=0A=
          var isNotPrimitive =3D ngOptions.trackBy || multiple;=0A=
          if (isNotPrimitive ? !equals(previousValue, nextValue) : =
previousValue !=3D=3D nextValue) {=0A=
            ngModelCtrl.$setViewValue(nextValue);=0A=
            ngModelCtrl.$render();=0A=
          }=0A=
        }=0A=
      }=0A=
  }=0A=
=0A=
  return {=0A=
    restrict: 'A',=0A=
    terminal: true,=0A=
    require: ['select', 'ngModel'],=0A=
    link: {=0A=
      pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {=0A=
        // Deactivate the SelectController.register method to prevent=0A=
        // option directives from accidentally registering themselves=0A=
        // (and unwanted $destroy handlers etc.)=0A=
        ctrls[0].registerOption =3D noop;=0A=
      },=0A=
      post: ngOptionsPostLink=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngPluralize=0A=
 * @restrict EA=0A=
 *=0A=
 * @description=0A=
 * `ngPluralize` is a directive that displays messages according to =
en-US localization rules.=0A=
 * These rules are bundled with angular.js, but can be overridden=0A=
 * (see {@link guide/i18n Angular i18n} dev guide). You configure =
ngPluralize directive=0A=
 * by specifying the mappings between=0A=
 * [plural =
categories](http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/lan=
guage_plural_rules.html)=0A=
 * and the strings to be displayed.=0A=
 *=0A=
 * # Plural categories and explicit number rules=0A=
 * There are two=0A=
 * [plural =
categories](http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/lan=
guage_plural_rules.html)=0A=
 * in Angular's default en-US locale: "one" and "other".=0A=
 *=0A=
 * While a plural category may match many numbers (for example, in en-US =
locale, "other" can match=0A=
 * any number that is not 1), an explicit number rule can only match one =
number. For example, the=0A=
 * explicit number rule for "3" matches the number 3. There are examples =
of plural categories=0A=
 * and explicit number rules throughout the rest of this documentation.=0A=
 *=0A=
 * # Configuring ngPluralize=0A=
 * You configure ngPluralize by providing 2 attributes: `count` and =
`when`.=0A=
 * You can also provide an optional attribute, `offset`.=0A=
 *=0A=
 * The value of the `count` attribute can be either a string or an =
{@link guide/expression=0A=
 * Angular expression}; these are evaluated on the current scope for its =
bound value.=0A=
 *=0A=
 * The `when` attribute specifies the mappings between plural categories =
and the actual=0A=
 * string to be displayed. The value of the attribute should be a JSON =
object.=0A=
 *=0A=
 * The following example shows how to configure ngPluralize:=0A=
 *=0A=
 * ```html=0A=
 * &lt;ng-pluralize count=3D"personCount"=0A=
                 when=3D"{'0': 'Nobody is viewing.',=0A=
 *                      'one': '1 person is viewing.',=0A=
 *                      'other': '{} people are viewing.'}"&gt;=0A=
 * &lt;/ng-pluralize&gt;=0A=
 *```=0A=
 *=0A=
 * In the example, `"0: Nobody is viewing."` is an explicit number rule. =
If you did not=0A=
 * specify this rule, 0 would be matched to the "other" category and "0 =
people are viewing"=0A=
 * would be shown instead of "Nobody is viewing". You can specify an =
explicit number rule for=0A=
 * other numbers, for example 12, so that instead of showing "12 people =
are viewing", you can=0A=
 * show "a dozen people are viewing".=0A=
 *=0A=
 * You can use a set of closed braces (`{}`) as a placeholder for the =
number that you want substituted=0A=
 * into pluralized strings. In the previous example, Angular will =
replace `{}` with=0A=
 * &lt;span ng-non-bindable&gt;`{{personCount}}`&lt;/span&gt;. The =
closed braces `{}` is a placeholder=0A=
 * for &lt;span ng-non-bindable&gt;{{numberExpression}}&lt;/span&gt;.=0A=
 *=0A=
 * If no rule is defined for a category, then an empty string is =
displayed and a warning is generated.=0A=
 * Note that some locales define more categories than `one` and `other`. =
For example, fr-fr defines `few` and `many`.=0A=
 *=0A=
 * # Configuring ngPluralize with offset=0A=
 * The `offset` attribute allows further customization of pluralized =
text, which can result in=0A=
 * a better user experience. For example, instead of the message "4 =
people are viewing this document",=0A=
 * you might display "John, Kate and 2 others are viewing this document".=0A=
 * The offset attribute allows you to offset a number by any desired =
value.=0A=
 * Let's take a look at an example:=0A=
 *=0A=
 * ```html=0A=
 * &lt;ng-pluralize count=3D"personCount" offset=3D2=0A=
 *               when=3D"{'0': 'Nobody is viewing.',=0A=
 *                      '1': '{{person1}} is viewing.',=0A=
 *                      '2': '{{person1}} and {{person2}} are viewing.',=0A=
 *                      'one': '{{person1}}, {{person2}} and one other =
person are viewing.',=0A=
 *                      'other': '{{person1}}, {{person2}} and {} other =
people are viewing.'}"&gt;=0A=
 * &lt;/ng-pluralize&gt;=0A=
 * ```=0A=
 *=0A=
 * Notice that we are still using two plural categories(one, other), but =
we added=0A=
 * three explicit number rules 0, 1 and 2.=0A=
 * When one person, perhaps John, views the document, "John is viewing" =
will be shown.=0A=
 * When three people view the document, no explicit number rule is =
found, so=0A=
 * an offset of 2 is taken off 3, and Angular uses 1 to decide the =
plural category.=0A=
 * In this case, plural category 'one' is matched and "John, Mary and =
one other person are viewing"=0A=
 * is shown.=0A=
 *=0A=
 * Note that when you specify offsets, you must provide explicit number =
rules for=0A=
 * numbers from 0 up to and including the offset. If you use an offset =
of 3, for example,=0A=
 * you must provide explicit number rules for 0, 1, 2 and 3. You must =
also provide plural strings for=0A=
 * plural categories "one" and "other".=0A=
 *=0A=
 * @param {string|expression} count The variable to be bound to.=0A=
 * @param {string} when The mapping between plural category to its =
corresponding strings.=0A=
 * @param {number=3D} offset Offset to deduct from the total number.=0A=
 *=0A=
 * @example=0A=
    &lt;example module=3D"pluralizeExample" name=3D"ng-pluralize"&gt;=0A=
      &lt;file name=3D"index.html"&gt;=0A=
        &lt;script&gt;=0A=
          angular.module('pluralizeExample', [])=0A=
            .controller('ExampleController', ['$scope', function($scope) =
{=0A=
              $scope.person1 =3D 'Igor';=0A=
              $scope.person2 =3D 'Misko';=0A=
              $scope.personCount =3D 1;=0A=
            }]);=0A=
        &lt;/script&gt;=0A=
        &lt;div ng-controller=3D"ExampleController"&gt;=0A=
          &lt;label&gt;Person 1:&lt;input type=3D"text" =
ng-model=3D"person1" value=3D"Igor" /&gt;&lt;/label&gt;&lt;br/&gt;=0A=
          &lt;label&gt;Person 2:&lt;input type=3D"text" =
ng-model=3D"person2" value=3D"Misko" /&gt;&lt;/label&gt;&lt;br/&gt;=0A=
          &lt;label&gt;Number of People:&lt;input type=3D"text" =
ng-model=3D"personCount" value=3D"1" /&gt;&lt;/label&gt;&lt;br/&gt;=0A=
=0A=
          &lt;!--- Example with simple pluralization rules for en locale =
---&gt;=0A=
          Without Offset:=0A=
          &lt;ng-pluralize count=3D"personCount"=0A=
                        when=3D"{'0': 'Nobody is viewing.',=0A=
                               'one': '1 person is viewing.',=0A=
                               'other': '{} people are viewing.'}"&gt;=0A=
          &lt;/ng-pluralize&gt;&lt;br&gt;=0A=
=0A=
          &lt;!--- Example with offset ---&gt;=0A=
          With Offset(2):=0A=
          &lt;ng-pluralize count=3D"personCount" offset=3D2=0A=
                        when=3D"{'0': 'Nobody is viewing.',=0A=
                               '1': '{{person1}} is viewing.',=0A=
                               '2': '{{person1}} and {{person2}} are =
viewing.',=0A=
                               'one': '{{person1}}, {{person2}} and one =
other person are viewing.',=0A=
                               'other': '{{person1}}, {{person2}} and {} =
other people are viewing.'}"&gt;=0A=
          &lt;/ng-pluralize&gt;=0A=
        &lt;/div&gt;=0A=
      &lt;/file&gt;=0A=
      &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
        it('should show correct pluralized string', function() {=0A=
          var withoutOffset =3D =
element.all(by.css('ng-pluralize')).get(0);=0A=
          var withOffset =3D element.all(by.css('ng-pluralize')).get(1);=0A=
          var countInput =3D element(by.model('personCount'));=0A=
=0A=
          expect(withoutOffset.getText()).toEqual('1 person is =
viewing.');=0A=
          expect(withOffset.getText()).toEqual('Igor is viewing.');=0A=
=0A=
          countInput.clear();=0A=
          countInput.sendKeys('0');=0A=
=0A=
          expect(withoutOffset.getText()).toEqual('Nobody is viewing.');=0A=
          expect(withOffset.getText()).toEqual('Nobody is viewing.');=0A=
=0A=
          countInput.clear();=0A=
          countInput.sendKeys('2');=0A=
=0A=
          expect(withoutOffset.getText()).toEqual('2 people are =
viewing.');=0A=
          expect(withOffset.getText()).toEqual('Igor and Misko are =
viewing.');=0A=
=0A=
          countInput.clear();=0A=
          countInput.sendKeys('3');=0A=
=0A=
          expect(withoutOffset.getText()).toEqual('3 people are =
viewing.');=0A=
          expect(withOffset.getText()).toEqual('Igor, Misko and one =
other person are viewing.');=0A=
=0A=
          countInput.clear();=0A=
          countInput.sendKeys('4');=0A=
=0A=
          expect(withoutOffset.getText()).toEqual('4 people are =
viewing.');=0A=
          expect(withOffset.getText()).toEqual('Igor, Misko and 2 other =
people are viewing.');=0A=
        });=0A=
        it('should show data-bound names', function() {=0A=
          var withOffset =3D element.all(by.css('ng-pluralize')).get(1);=0A=
          var personCount =3D element(by.model('personCount'));=0A=
          var person1 =3D element(by.model('person1'));=0A=
          var person2 =3D element(by.model('person2'));=0A=
          personCount.clear();=0A=
          personCount.sendKeys('4');=0A=
          person1.clear();=0A=
          person1.sendKeys('Di');=0A=
          person2.clear();=0A=
          person2.sendKeys('Vojta');=0A=
          expect(withOffset.getText()).toEqual('Di, Vojta and 2 other =
people are viewing.');=0A=
        });=0A=
      &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
 */=0A=
var ngPluralizeDirective =3D ['$locale', '$interpolate', '$log', =
function($locale, $interpolate, $log) {=0A=
  var BRACE =3D /{}/g,=0A=
      IS_WHEN =3D /^when(Minus)?(.+)$/;=0A=
=0A=
  return {=0A=
    link: function(scope, element, attr) {=0A=
      var numberExp =3D attr.count,=0A=
          whenExp =3D attr.$attr.when &amp;&amp; =
element.attr(attr.$attr.when), // we have {{}} in attrs=0A=
          offset =3D attr.offset || 0,=0A=
          whens =3D scope.$eval(whenExp) || {},=0A=
          whensExpFns =3D {},=0A=
          startSymbol =3D $interpolate.startSymbol(),=0A=
          endSymbol =3D $interpolate.endSymbol(),=0A=
          braceReplacement =3D startSymbol + numberExp + '-' + offset + =
endSymbol,=0A=
          watchRemover =3D angular.noop,=0A=
          lastCount;=0A=
=0A=
      forEach(attr, function(expression, attributeName) {=0A=
        var tmpMatch =3D IS_WHEN.exec(attributeName);=0A=
        if (tmpMatch) {=0A=
          var whenKey =3D (tmpMatch[1] ? '-' : '') + =
lowercase(tmpMatch[2]);=0A=
          whens[whenKey] =3D element.attr(attr.$attr[attributeName]);=0A=
        }=0A=
      });=0A=
      forEach(whens, function(expression, key) {=0A=
        whensExpFns[key] =3D $interpolate(expression.replace(BRACE, =
braceReplacement));=0A=
=0A=
      });=0A=
=0A=
      scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {=0A=
        var count =3D parseFloat(newVal);=0A=
        var countIsNaN =3D isNumberNaN(count);=0A=
=0A=
        if (!countIsNaN &amp;&amp; !(count in whens)) {=0A=
          // If an explicit number rule such as 1, 2, 3... is defined, =
just use it.=0A=
          // Otherwise, check it against pluralization rules in $locale =
service.=0A=
          count =3D $locale.pluralCat(count - offset);=0A=
        }=0A=
=0A=
        // If both `count` and `lastCount` are NaN, we don't need to =
re-register a watch.=0A=
        // In JS `NaN !=3D=3D NaN`, so we have to explicitly check.=0A=
        if ((count !=3D=3D lastCount) &amp;&amp; !(countIsNaN &amp;&amp; =
isNumberNaN(lastCount))) {=0A=
          watchRemover();=0A=
          var whenExpFn =3D whensExpFns[count];=0A=
          if (isUndefined(whenExpFn)) {=0A=
            if (newVal !=3D null) {=0A=
              $log.debug('ngPluralize: no rule defined for \'' + count + =
'\' in ' + whenExp);=0A=
            }=0A=
            watchRemover =3D noop;=0A=
            updateElementText();=0A=
          } else {=0A=
            watchRemover =3D scope.$watch(whenExpFn, updateElementText);=0A=
          }=0A=
          lastCount =3D count;=0A=
        }=0A=
      });=0A=
=0A=
      function updateElementText(newText) {=0A=
        element.text(newText || '');=0A=
      }=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
/* exported ngRepeatDirective */=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngRepeat=0A=
 * @multiElement=0A=
 * @restrict A=0A=
 *=0A=
 * @description=0A=
 * The `ngRepeat` directive instantiates a template once per item from a =
collection. Each template=0A=
 * instance gets its own scope, where the given loop variable is set to =
the current collection item,=0A=
 * and `$index` is set to the item index or key.=0A=
 *=0A=
 * Special properties are exposed on the local scope of each template =
instance, including:=0A=
 *=0A=
 * | Variable  | Type            | Details                               =
                                      |=0A=
 * =
|-----------|-----------------|------------------------------------------=
-----------------------------------|=0A=
 * | `$index`  | {@type number}  | iterator offset of the repeated =
element (0..length-1)                       |=0A=
 * | `$first`  | {@type boolean} | true if the repeated element is first =
in the iterator.                      |=0A=
 * | `$middle` | {@type boolean} | true if the repeated element is =
between the first and last in the iterator. |=0A=
 * | `$last`   | {@type boolean} | true if the repeated element is last =
in the iterator.                       |=0A=
 * | `$even`   | {@type boolean} | true if the iterator position =
`$index` is even (otherwise false).           |=0A=
 * | `$odd`    | {@type boolean} | true if the iterator position =
`$index` is odd (otherwise false).            |=0A=
 *=0A=
 * &lt;div class=3D"alert alert-info"&gt;=0A=
 *   Creating aliases for these properties is possible with {@link =
ng.directive:ngInit `ngInit`}.=0A=
 *   This may be useful when, for instance, nesting ngRepeats.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 *=0A=
 * # Iterating over object properties=0A=
 *=0A=
 * It is possible to get `ngRepeat` to iterate over the properties of an =
object using the following=0A=
 * syntax:=0A=
 *=0A=
 * ```js=0A=
 * &lt;div ng-repeat=3D"(key, value) in myObj"&gt; ... &lt;/div&gt;=0A=
 * ```=0A=
 *=0A=
 * However, there are a few limitations compared to array iteration:=0A=
 *=0A=
 * - The JavaScript specification does not define the order of keys=0A=
 *   returned for an object, so Angular relies on the order returned by =
the browser=0A=
 *   when running `for key in myObj`. Browsers generally follow the =
strategy of providing=0A=
 *   keys in the order in which they were defined, although there are =
exceptions when keys are deleted=0A=
 *   and reinstated. See the=0A=
 *   [MDN page on `delete` for more =
info](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/O=
perators/delete#Cross-browser_notes).=0A=
 *=0A=
 * - `ngRepeat` will silently *ignore* object keys starting with `$`, =
because=0A=
 *   it's a prefix used by Angular for public (`$`) and private (`$$`) =
properties.=0A=
 *=0A=
 * - The built-in filters {@link ng.orderBy orderBy} and {@link =
ng.filter filter} do not work with=0A=
 *   objects, and will throw an error if used with one.=0A=
 *=0A=
 * If you are hitting any of these limitations, the recommended =
workaround is to convert your object into an array=0A=
 * that is sorted into the order that you prefer before providing it to =
`ngRepeat`. You could=0A=
 * do this with a filter such as =
[toArrayFilter](http://ngmodules.org/modules/angular-toArrayFilter)=0A=
 * or implement a `$watch` on the object yourself.=0A=
 *=0A=
 *=0A=
 * # Tracking and Duplicates=0A=
 *=0A=
 * `ngRepeat` uses {@link $rootScope.Scope#$watchCollection =
$watchCollection} to detect changes in=0A=
 * the collection. When a change happens, `ngRepeat` then makes the =
corresponding changes to the DOM:=0A=
 *=0A=
 * * When an item is added, a new instance of the template is added to =
the DOM.=0A=
 * * When an item is removed, its template instance is removed from the =
DOM.=0A=
 * * When items are reordered, their respective templates are reordered =
in the DOM.=0A=
 *=0A=
 * To minimize creation of DOM elements, `ngRepeat` uses a function=0A=
 * to "keep track" of all items in the collection and their =
corresponding DOM elements.=0A=
 * For example, if an item is added to the collection, `ngRepeat` will =
know that all other items=0A=
 * already have DOM elements, and will not re-render them.=0A=
 *=0A=
 * The default tracking function (which tracks items by their identity) =
does not allow=0A=
 * duplicate items in arrays. This is because when there are duplicates, =
it is not possible=0A=
 * to maintain a one-to-one mapping between collection items and DOM =
elements.=0A=
 *=0A=
 * If you do need to repeat duplicate items, you can substitute the =
default tracking behavior=0A=
 * with your own using the `track by` expression.=0A=
 *=0A=
 * For example, you may track items by the index of each item in the =
collection, using the=0A=
 * special scope property `$index`:=0A=
 * ```html=0A=
 *    &lt;div ng-repeat=3D"n in [42, 42, 43, 43] track by $index"&gt;=0A=
 *      {{n}}=0A=
 *    &lt;/div&gt;=0A=
 * ```=0A=
 *=0A=
 * You may also use arbitrary expressions in `track by`, including =
references to custom functions=0A=
 * on the scope:=0A=
 * ```html=0A=
 *    &lt;div ng-repeat=3D"n in [42, 42, 43, 43] track by =
myTrackingFunction(n)"&gt;=0A=
 *      {{n}}=0A=
 *    &lt;/div&gt;=0A=
 * ```=0A=
 *=0A=
 * &lt;div class=3D"alert alert-success"&gt;=0A=
 * If you are working with objects that have a unique identifier =
property, you should track=0A=
 * by this identifier instead of the object instance. Should you reload =
your data later, `ngRepeat`=0A=
 * will not have to rebuild the DOM elements for items it has already =
rendered, even if the=0A=
 * JavaScript objects in the collection have been substituted for new =
ones. For large collections,=0A=
 * this significantly improves rendering performance. If you don't have =
a unique identifier,=0A=
 * `track by $index` can also provide a performance boost.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * ```html=0A=
 *    &lt;div ng-repeat=3D"model in collection track by model.id"&gt;=0A=
 *      {{model.name}}=0A=
 *    &lt;/div&gt;=0A=
 * ```=0A=
 *=0A=
 * &lt;br /&gt;=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * Avoid using `track by $index` when the repeated template contains=0A=
 * {@link guide/expression#one-time-binding one-time bindings}. In such =
cases, the `nth` DOM=0A=
 * element will always be matched with the `nth` item of the array, so =
the bindings on that element=0A=
 * will not be updated even when the corresponding item changes, =
essentially causing the view to get=0A=
 * out-of-sync with the underlying data.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * When no `track by` expression is provided, it is equivalent to =
tracking by the built-in=0A=
 * `$id` function, which tracks items by their identity:=0A=
 * ```html=0A=
 *    &lt;div ng-repeat=3D"obj in collection track by $id(obj)"&gt;=0A=
 *      {{obj.prop}}=0A=
 *    &lt;/div&gt;=0A=
 * ```=0A=
 *=0A=
 * &lt;br /&gt;=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * **Note:** `track by` must always be the last expression:=0A=
 * &lt;/div&gt;=0A=
 * ```=0A=
 *    &lt;div ng-repeat=3D"model in collection | orderBy: 'id' as =
filtered_result track by model.id"&gt;=0A=
 *      {{model.name}}=0A=
 *    &lt;/div&gt;=0A=
 * ```=0A=
 *=0A=
 *=0A=
 * # Special repeat start and end points=0A=
 * To repeat a series of elements instead of just one parent element, =
ngRepeat (as well as other ng directives) supports extending=0A=
 * the range of the repeater by defining explicit start and end points =
by using **ng-repeat-start** and **ng-repeat-end** respectively.=0A=
 * The **ng-repeat-start** directive works the same as **ng-repeat**, =
but will repeat all the HTML code (including the tag it's defined on)=0A=
 * up to and including the ending HTML tag where **ng-repeat-end** is =
placed.=0A=
 *=0A=
 * The example below makes use of this feature:=0A=
 * ```html=0A=
 *   &lt;header ng-repeat-start=3D"item in items"&gt;=0A=
 *     Header {{ item }}=0A=
 *   &lt;/header&gt;=0A=
 *   &lt;div class=3D"body"&gt;=0A=
 *     Body {{ item }}=0A=
 *   &lt;/div&gt;=0A=
 *   &lt;footer ng-repeat-end&gt;=0A=
 *     Footer {{ item }}=0A=
 *   &lt;/footer&gt;=0A=
 * ```=0A=
 *=0A=
 * And with an input of {@type ['A','B']} for the items variable in the =
example above, the output will evaluate to:=0A=
 * ```html=0A=
 *   &lt;header&gt;=0A=
 *     Header A=0A=
 *   &lt;/header&gt;=0A=
 *   &lt;div class=3D"body"&gt;=0A=
 *     Body A=0A=
 *   &lt;/div&gt;=0A=
 *   &lt;footer&gt;=0A=
 *     Footer A=0A=
 *   &lt;/footer&gt;=0A=
 *   &lt;header&gt;=0A=
 *     Header B=0A=
 *   &lt;/header&gt;=0A=
 *   &lt;div class=3D"body"&gt;=0A=
 *     Body B=0A=
 *   &lt;/div&gt;=0A=
 *   &lt;footer&gt;=0A=
 *     Footer B=0A=
 *   &lt;/footer&gt;=0A=
 * ```=0A=
 *=0A=
 * The custom start and end points for ngRepeat also support all other =
HTML directive syntax flavors provided in AngularJS (such=0A=
 * as **data-ng-repeat-start**, **x-ng-repeat-start** and =
**ng:repeat-start**).=0A=
 *=0A=
 * @animations=0A=
 * | Animation                        | Occurs                           =
   |=0A=
 * =
|----------------------------------|-------------------------------------=
|=0A=
 * | {@link ng.$animate#enter enter} | when a new item is added to the =
list or when an item is revealed after a filter |=0A=
 * | {@link ng.$animate#leave leave} | when an item is removed from the =
list or when an item is filtered out |=0A=
 * | {@link ng.$animate#move move } | when an adjacent item is filtered =
out causing a reorder or when the item contents are reordered |=0A=
 *=0A=
 * See the example below for defining CSS animations with ngRepeat.=0A=
 *=0A=
 * @element ANY=0A=
 * @scope=0A=
 * @priority 1000=0A=
 * @param {repeat_expression} ngRepeat The expression indicating how to =
enumerate a collection. These=0A=
 *   formats are currently supported:=0A=
 *=0A=
 *   * `variable in expression` =E2=80&#65533; where variable is the =
user defined loop variable and `expression`=0A=
 *     is a scope expression giving the collection to enumerate.=0A=
 *=0A=
 *     For example: `album in artist.albums`.=0A=
 *=0A=
 *   * `(key, value) in expression` =E2=80&#65533; where `key` and =
`value` can be any user defined identifiers,=0A=
 *     and `expression` is the scope expression giving the collection to =
enumerate.=0A=
 *=0A=
 *     For example: `(name, age) in {'adam':10, 'amalie':12}`.=0A=
 *=0A=
 *   * `variable in expression track by tracking_expression` =
=E2=80&#65533; You can also provide an optional tracking expression=0A=
 *     which can be used to associate the objects in the collection with =
the DOM elements. If no tracking expression=0A=
 *     is specified, ng-repeat associates elements by identity. It is an =
error to have=0A=
 *     more than one tracking expression value resolve to the same key. =
(This would mean that two distinct objects are=0A=
 *     mapped to the same DOM element, which is not possible.)=0A=
 *=0A=
 *     Note that the tracking expression must come last, after any =
filters, and the alias expression.=0A=
 *=0A=
 *     For example: `item in items` is equivalent to `item in items =
track by $id(item)`. This implies that the DOM elements=0A=
 *     will be associated by item identity in the array.=0A=
 *=0A=
 *     For example: `item in items track by $id(item)`. A built in =
`$id()` function can be used to assign a unique=0A=
 *     `$$hashKey` property to each item in the array. This property is =
then used as a key to associated DOM elements=0A=
 *     with the corresponding item in the array by identity. Moving the =
same object in array would move the DOM=0A=
 *     element in the same way in the DOM.=0A=
 *=0A=
 *     For example: `item in items track by item.id` is a typical =
pattern when the items come from the database. In this=0A=
 *     case the object identity does not matter. Two objects are =
considered equivalent as long as their `id`=0A=
 *     property is same.=0A=
 *=0A=
 *     For example: `item in items | filter:searchText track by item.id` =
is a pattern that might be used to apply a filter=0A=
 *     to items in conjunction with a tracking expression.=0A=
 *=0A=
 *   * `variable in expression as alias_expression` =E2=80&#65533; You =
can also provide an optional alias expression which will then store the=0A=
 *     intermediate results of the repeater after the filters have been =
applied. Typically this is used to render a special message=0A=
 *     when a filter is active on the repeater, but the filtered result =
set is empty.=0A=
 *=0A=
 *     For example: `item in items | filter:x as results` will store the =
fragment of the repeated items as `results`, but only after=0A=
 *     the items have been processed through the filter.=0A=
 *=0A=
 *     Please note that `as [variable name] is not an operator but =
rather a part of ngRepeat micro-syntax so it can be used only at the end=0A=
 *     (and not as operator, inside an expression).=0A=
 *=0A=
 *     For example: `item in items | filter : x | orderBy : order | =
limitTo : limit as results` .=0A=
 *=0A=
 * @example=0A=
 * This example uses `ngRepeat` to display a list of people. A filter is =
used to restrict the displayed=0A=
 * results by name or by age. New (entering) and removed (leaving) items =
are animated.=0A=
  &lt;example module=3D"ngRepeat" name=3D"ngRepeat" =
deps=3D"angular-animate.js" animations=3D"true" name=3D"ng-repeat"&gt;=0A=
    &lt;file name=3D"index.html"&gt;=0A=
      &lt;div ng-controller=3D"repeatController"&gt;=0A=
        I have {{friends.length}} friends. They are:=0A=
        &lt;input type=3D"search" ng-model=3D"q" placeholder=3D"filter =
friends..." aria-label=3D"filter friends" /&gt;=0A=
        &lt;ul class=3D"example-animate-container"&gt;=0A=
          &lt;li class=3D"animate-repeat" ng-repeat=3D"friend in friends =
| filter:q as results"&gt;=0A=
            [{{$index + 1}}] {{friend.name}} who is {{friend.age}} years =
old.=0A=
          &lt;/li&gt;=0A=
          &lt;li class=3D"animate-repeat" ng-if=3D"results.length =
=3D=3D=3D 0"&gt;=0A=
            &lt;strong&gt;No results found...&lt;/strong&gt;=0A=
          &lt;/li&gt;=0A=
        &lt;/ul&gt;=0A=
      &lt;/div&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"script.js"&gt;=0A=
      angular.module('ngRepeat', =
['ngAnimate']).controller('repeatController', function($scope) {=0A=
        $scope.friends =3D [=0A=
          {name:'John', age:25, gender:'boy'},=0A=
          {name:'Jessie', age:30, gender:'girl'},=0A=
          {name:'Johanna', age:28, gender:'girl'},=0A=
          {name:'Joy', age:15, gender:'girl'},=0A=
          {name:'Mary', age:28, gender:'girl'},=0A=
          {name:'Peter', age:95, gender:'boy'},=0A=
          {name:'Sebastian', age:50, gender:'boy'},=0A=
          {name:'Erika', age:27, gender:'girl'},=0A=
          {name:'Patrick', age:40, gender:'boy'},=0A=
          {name:'Samantha', age:60, gender:'girl'}=0A=
        ];=0A=
      });=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"animations.css"&gt;=0A=
      .example-animate-container {=0A=
        background:white;=0A=
        border:1px solid black;=0A=
        list-style:none;=0A=
        margin:0;=0A=
        padding:0 10px;=0A=
      }=0A=
=0A=
      .animate-repeat {=0A=
        line-height:30px;=0A=
        list-style:none;=0A=
        box-sizing:border-box;=0A=
      }=0A=
=0A=
      .animate-repeat.ng-move,=0A=
      .animate-repeat.ng-enter,=0A=
      .animate-repeat.ng-leave {=0A=
        transition:all linear 0.5s;=0A=
      }=0A=
=0A=
      .animate-repeat.ng-leave.ng-leave-active,=0A=
      .animate-repeat.ng-move,=0A=
      .animate-repeat.ng-enter {=0A=
        opacity:0;=0A=
        max-height:0;=0A=
      }=0A=
=0A=
      .animate-repeat.ng-leave,=0A=
      .animate-repeat.ng-move.ng-move-active,=0A=
      .animate-repeat.ng-enter.ng-enter-active {=0A=
        opacity:1;=0A=
        max-height:30px;=0A=
      }=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
      var friends =3D element.all(by.repeater('friend in friends'));=0A=
=0A=
      it('should render initial data set', function() {=0A=
        expect(friends.count()).toBe(10);=0A=
        expect(friends.get(0).getText()).toEqual('[1] John who is 25 =
years old.');=0A=
        expect(friends.get(1).getText()).toEqual('[2] Jessie who is 30 =
years old.');=0A=
        expect(friends.last().getText()).toEqual('[10] Samantha who is =
60 years old.');=0A=
        expect(element(by.binding('friends.length')).getText())=0A=
            .toMatch("I have 10 friends. They are:");=0A=
      });=0A=
=0A=
       it('should update repeater when filter predicate changes', =
function() {=0A=
         expect(friends.count()).toBe(10);=0A=
=0A=
         element(by.model('q')).sendKeys('ma');=0A=
=0A=
         expect(friends.count()).toBe(2);=0A=
         expect(friends.get(0).getText()).toEqual('[1] Mary who is 28 =
years old.');=0A=
         expect(friends.last().getText()).toEqual('[2] Samantha who is =
60 years old.');=0A=
       });=0A=
      &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
 */=0A=
var ngRepeatDirective =3D ['$parse', '$animate', '$compile', =
function($parse, $animate, $compile) {=0A=
  var NG_REMOVED =3D '$$NG_REMOVED';=0A=
  var ngRepeatMinErr =3D minErr('ngRepeat');=0A=
=0A=
  var updateScope =3D function(scope, index, valueIdentifier, value, =
keyIdentifier, key, arrayLength) {=0A=
    // TODO(perf): generate setters to shave off ~40ms or 1-1.5%=0A=
    scope[valueIdentifier] =3D value;=0A=
    if (keyIdentifier) scope[keyIdentifier] =3D key;=0A=
    scope.$index =3D index;=0A=
    scope.$first =3D (index =3D=3D=3D 0);=0A=
    scope.$last =3D (index =3D=3D=3D (arrayLength - 1));=0A=
    scope.$middle =3D !(scope.$first || scope.$last);=0A=
    // eslint-disable-next-line no-bitwise=0A=
    scope.$odd =3D !(scope.$even =3D (index &amp; 1) =3D=3D=3D 0);=0A=
  };=0A=
=0A=
  var getBlockStart =3D function(block) {=0A=
    return block.clone[0];=0A=
  };=0A=
=0A=
  var getBlockEnd =3D function(block) {=0A=
    return block.clone[block.clone.length - 1];=0A=
  };=0A=
=0A=
=0A=
  return {=0A=
    restrict: 'A',=0A=
    multiElement: true,=0A=
    transclude: 'element',=0A=
    priority: 1000,=0A=
    terminal: true,=0A=
    $$tlb: true,=0A=
    compile: function ngRepeatCompile($element, $attr) {=0A=
      var expression =3D $attr.ngRepeat;=0A=
      var ngRepeatEndComment =3D $compile.$$createComment('end =
ngRepeat', expression);=0A=
=0A=
      var match =3D =
expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?=
(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);=0A=
=0A=
      if (!match) {=0A=
        throw ngRepeatMinErr('iexp', 'Expected expression in form of =
\'_item_ in _collection_[ track by _id_]\' but got \'{0}\'.',=0A=
            expression);=0A=
      }=0A=
=0A=
      var lhs =3D match[1];=0A=
      var rhs =3D match[2];=0A=
      var aliasAs =3D match[3];=0A=
      var trackByExp =3D match[4];=0A=
=0A=
      match =3D =
lhs.match(/^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/);=0A=
=0A=
      if (!match) {=0A=
        throw ngRepeatMinErr('iidexp', '\'_item_\' in \'_item_ in =
_collection_\' should be an identifier or \'(_key_, _value_)\' =
expression, but got \'{0}\'.',=0A=
            lhs);=0A=
      }=0A=
      var valueIdentifier =3D match[3] || match[1];=0A=
      var keyIdentifier =3D match[2];=0A=
=0A=
      if (aliasAs &amp;&amp; =
(!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) ||=0A=
          =
/^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$par=
ent|\$root|\$id)$/.test(aliasAs))) {=0A=
        throw ngRepeatMinErr('badident', 'alias \'{0}\' is invalid --- =
must be a valid JS identifier which is not a reserved name.',=0A=
          aliasAs);=0A=
      }=0A=
=0A=
      var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, =
trackByIdObjFn;=0A=
      var hashFnLocals =3D {$id: hashKey};=0A=
=0A=
      if (trackByExp) {=0A=
        trackByExpGetter =3D $parse(trackByExp);=0A=
      } else {=0A=
        trackByIdArrayFn =3D function(key, value) {=0A=
          return hashKey(value);=0A=
        };=0A=
        trackByIdObjFn =3D function(key) {=0A=
          return key;=0A=
        };=0A=
      }=0A=
=0A=
      return function ngRepeatLink($scope, $element, $attr, ctrl, =
$transclude) {=0A=
=0A=
        if (trackByExpGetter) {=0A=
          trackByIdExpFn =3D function(key, value, index) {=0A=
            // assign key, value, and $index to the locals so that they =
can be used in hash functions=0A=
            if (keyIdentifier) hashFnLocals[keyIdentifier] =3D key;=0A=
            hashFnLocals[valueIdentifier] =3D value;=0A=
            hashFnLocals.$index =3D index;=0A=
            return trackByExpGetter($scope, hashFnLocals);=0A=
          };=0A=
        }=0A=
=0A=
        // Store a list of elements from previous run. This is a hash =
where key is the item from the=0A=
        // iterator, and the value is objects with following properties.=0A=
        //   - scope: bound scope=0A=
        //   - clone: previous element.=0A=
        //   - index: position=0A=
        //=0A=
        // We are using no-proto object so that we don't need to guard =
against inherited props via=0A=
        // hasOwnProperty.=0A=
        var lastBlockMap =3D createMap();=0A=
=0A=
        //watch props=0A=
        $scope.$watchCollection(rhs, function ngRepeatAction(collection) =
{=0A=
          var index, length,=0A=
              previousNode =3D $element[0],     // node that cloned =
nodes should be inserted after=0A=
                                              // initialized to the =
comment node anchor=0A=
              nextNode,=0A=
              // Same as lastBlockMap but it has the current state. It =
will become the=0A=
              // lastBlockMap on the next iteration.=0A=
              nextBlockMap =3D createMap(),=0A=
              collectionLength,=0A=
              key, value, // key/value of iteration=0A=
              trackById,=0A=
              trackByIdFn,=0A=
              collectionKeys,=0A=
              block,       // last object information {scope, element, =
id}=0A=
              nextBlockOrder,=0A=
              elementsToRemove;=0A=
=0A=
          if (aliasAs) {=0A=
            $scope[aliasAs] =3D collection;=0A=
          }=0A=
=0A=
          if (isArrayLike(collection)) {=0A=
            collectionKeys =3D collection;=0A=
            trackByIdFn =3D trackByIdExpFn || trackByIdArrayFn;=0A=
          } else {=0A=
            trackByIdFn =3D trackByIdExpFn || trackByIdObjFn;=0A=
            // if object, extract keys, in enumeration order, unsorted=0A=
            collectionKeys =3D [];=0A=
            for (var itemKey in collection) {=0A=
              if (hasOwnProperty.call(collection, itemKey) &amp;&amp; =
itemKey.charAt(0) !=3D=3D '$') {=0A=
                collectionKeys.push(itemKey);=0A=
              }=0A=
            }=0A=
          }=0A=
=0A=
          collectionLength =3D collectionKeys.length;=0A=
          nextBlockOrder =3D new Array(collectionLength);=0A=
=0A=
          // locate existing items=0A=
          for (index =3D 0; index &lt; collectionLength; index++) {=0A=
            key =3D (collection =3D=3D=3D collectionKeys) ? index : =
collectionKeys[index];=0A=
            value =3D collection[key];=0A=
            trackById =3D trackByIdFn(key, value, index);=0A=
            if (lastBlockMap[trackById]) {=0A=
              // found previously seen block=0A=
              block =3D lastBlockMap[trackById];=0A=
              delete lastBlockMap[trackById];=0A=
              nextBlockMap[trackById] =3D block;=0A=
              nextBlockOrder[index] =3D block;=0A=
            } else if (nextBlockMap[trackById]) {=0A=
              // if collision detected. restore lastBlockMap and throw =
an error=0A=
              forEach(nextBlockOrder, function(block) {=0A=
                if (block &amp;&amp; block.scope) lastBlockMap[block.id] =
=3D block;=0A=
              });=0A=
              throw ngRepeatMinErr('dupes',=0A=
                  'Duplicates in a repeater are not allowed. Use \'track =
by\' expression to specify unique keys. Repeater: {0}, Duplicate key: =
{1}, Duplicate value: {2}',=0A=
                  expression, trackById, value);=0A=
            } else {=0A=
              // new never before seen block=0A=
              nextBlockOrder[index] =3D {id: trackById, scope: =
undefined, clone: undefined};=0A=
              nextBlockMap[trackById] =3D true;=0A=
            }=0A=
          }=0A=
=0A=
          // remove leftover items=0A=
          for (var blockKey in lastBlockMap) {=0A=
            block =3D lastBlockMap[blockKey];=0A=
            elementsToRemove =3D getBlockNodes(block.clone);=0A=
            $animate.leave(elementsToRemove);=0A=
            if (elementsToRemove[0].parentNode) {=0A=
              // if the element was not removed yet because of pending =
animation, mark it as deleted=0A=
              // so that we can ignore it later=0A=
              for (index =3D 0, length =3D elementsToRemove.length; =
index &lt; length; index++) {=0A=
                elementsToRemove[index][NG_REMOVED] =3D true;=0A=
              }=0A=
            }=0A=
            block.scope.$destroy();=0A=
          }=0A=
=0A=
          // we are not using forEach for perf reasons (trying to avoid =
#call)=0A=
          for (index =3D 0; index &lt; collectionLength; index++) {=0A=
            key =3D (collection =3D=3D=3D collectionKeys) ? index : =
collectionKeys[index];=0A=
            value =3D collection[key];=0A=
            block =3D nextBlockOrder[index];=0A=
=0A=
            if (block.scope) {=0A=
              // if we have already seen this object, then we need to =
reuse the=0A=
              // associated scope/element=0A=
=0A=
              nextNode =3D previousNode;=0A=
=0A=
              // skip nodes that are already pending removal via leave =
animation=0A=
              do {=0A=
                nextNode =3D nextNode.nextSibling;=0A=
              } while (nextNode &amp;&amp; nextNode[NG_REMOVED]);=0A=
=0A=
              if (getBlockStart(block) !=3D=3D nextNode) {=0A=
                // existing item which got moved=0A=
                $animate.move(getBlockNodes(block.clone), null, =
previousNode);=0A=
              }=0A=
              previousNode =3D getBlockEnd(block);=0A=
              updateScope(block.scope, index, valueIdentifier, value, =
keyIdentifier, key, collectionLength);=0A=
            } else {=0A=
              // new item which we don't know about=0A=
              $transclude(function ngRepeatTransclude(clone, scope) {=0A=
                block.scope =3D scope;=0A=
                // http://jsperf.com/clone-vs-createcomment=0A=
                var endNode =3D ngRepeatEndComment.cloneNode(false);=0A=
                clone[clone.length++] =3D endNode;=0A=
=0A=
                $animate.enter(clone, null, previousNode);=0A=
                previousNode =3D endNode;=0A=
                // Note: We only need the first/last node of the cloned =
nodes.=0A=
                // However, we need to keep the reference to the jqlite =
wrapper as it might be changed later=0A=
                // by a directive with templateUrl when its template =
arrives.=0A=
                block.clone =3D clone;=0A=
                nextBlockMap[block.id] =3D block;=0A=
                updateScope(block.scope, index, valueIdentifier, value, =
keyIdentifier, key, collectionLength);=0A=
              });=0A=
            }=0A=
          }=0A=
          lastBlockMap =3D nextBlockMap;=0A=
        });=0A=
      };=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
var NG_HIDE_CLASS =3D 'ng-hide';=0A=
var NG_HIDE_IN_PROGRESS_CLASS =3D 'ng-hide-animate';=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngShow=0A=
 * @multiElement=0A=
 *=0A=
 * @description=0A=
 * The `ngShow` directive shows or hides the given HTML element based on =
the expression provided to=0A=
 * the `ngShow` attribute.=0A=
 *=0A=
 * The element is shown or hidden by removing or adding the `.ng-hide` =
CSS class onto the element.=0A=
 * The `.ng-hide` CSS class is predefined in AngularJS and sets the =
display style to none (using an=0A=
 * `!important` flag). For CSP mode please add `angular-csp.css` to your =
HTML file (see=0A=
 * {@link ng.directive:ngCsp ngCsp}).=0A=
 *=0A=
 * ```html=0A=
 * &lt;!-- when $scope.myValue is truthy (element is visible) --&gt;=0A=
 * &lt;div ng-show=3D"myValue"&gt;&lt;/div&gt;=0A=
 *=0A=
 * &lt;!-- when $scope.myValue is falsy (element is hidden) --&gt;=0A=
 * &lt;div ng-show=3D"myValue" class=3D"ng-hide"&gt;&lt;/div&gt;=0A=
 * ```=0A=
 *=0A=
 * When the `ngShow` expression evaluates to a falsy value then the =
`.ng-hide` CSS class is added=0A=
 * to the class attribute on the element causing it to become hidden. =
When truthy, the `.ng-hide`=0A=
 * CSS class is removed from the element causing the element not to =
appear hidden.=0A=
 *=0A=
 * ## Why is `!important` used?=0A=
 *=0A=
 * You may be wondering why `!important` is used for the `.ng-hide` CSS =
class. This is because the=0A=
 * `.ng-hide` selector can be easily overridden by heavier selectors. =
For example, something as=0A=
 * simple as changing the display style on a HTML list item would make =
hidden elements appear=0A=
 * visible. This also becomes a bigger issue when dealing with CSS =
frameworks.=0A=
 *=0A=
 * By using `!important`, the show and hide behavior will work as =
expected despite any clash between=0A=
 * CSS selector specificity (when `!important` isn't used with any =
conflicting styles). If a=0A=
 * developer chooses to override the styling to change how to hide an =
element then it is just a=0A=
 * matter of using `!important` in their own CSS code.=0A=
 *=0A=
 * ### Overriding `.ng-hide`=0A=
 *=0A=
 * By default, the `.ng-hide` class will style the element with =
`display: none !important`. If you=0A=
 * wish to change the hide behavior with `ngShow`/`ngHide`, you can =
simply overwrite the styles for=0A=
 * the `.ng-hide` CSS class. Note that the selector that needs to be =
used is actually=0A=
 * `.ng-hide:not(.ng-hide-animate)` to cope with extra animation classes =
that can be added.=0A=
 *=0A=
 * ```css=0A=
 * .ng-hide:not(.ng-hide-animate) {=0A=
 *   /&amp;#42; These are just alternative ways of hiding an element =
&amp;#42;/=0A=
 *   display: block!important;=0A=
 *   position: absolute;=0A=
 *   top: -9999px;=0A=
 *   left: -9999px;=0A=
 * }=0A=
 * ```=0A=
 *=0A=
 * By default you don't need to override anything in CSS and the =
animations will work around the=0A=
 * display style.=0A=
 *=0A=
 * ## A note about animations with `ngShow`=0A=
 *=0A=
 * Animations in `ngShow`/`ngHide` work with the show and hide events =
that are triggered when the=0A=
 * directive expression is true and false. This system works like the =
animation system present with=0A=
 * `ngClass` except that you must also include the `!important` flag to =
override the display=0A=
 * property so that the elements are not actually hidden during the =
animation.=0A=
 *=0A=
 * ```css=0A=
 * /&amp;#42; A working example can be found at the bottom of this page. =
&amp;#42;/=0A=
 * .my-element.ng-hide-add, .my-element.ng-hide-remove {=0A=
 *   transition: all 0.5s linear;=0A=
 * }=0A=
 *=0A=
 * .my-element.ng-hide-add { ... }=0A=
 * .my-element.ng-hide-add.ng-hide-add-active { ... }=0A=
 * .my-element.ng-hide-remove { ... }=0A=
 * .my-element.ng-hide-remove.ng-hide-remove-active { ... }=0A=
 * ```=0A=
 *=0A=
 * Keep in mind that, as of AngularJS version 1.3, there is no need to =
change the display property=0A=
 * to block during animation states - ngAnimate will automatically =
handle the style toggling for you.=0A=
 *=0A=
 * @animations=0A=
 * | Animation                                           | Occurs        =
                                                                         =
                       |=0A=
 * =
|-----------------------------------------------------|------------------=
-------------------------------------------------------------------------=
--------------------|=0A=
 * | {@link $animate#addClass addClass} `.ng-hide`       | After the =
`ngShow` expression evaluates to a non truthy value and just before the =
contents are set to hidden. |=0A=
 * | {@link $animate#removeClass removeClass} `.ng-hide` | After the =
`ngShow` expression evaluates to a truthy value and just before contents =
are set to visible.        |=0A=
 *=0A=
 * @element ANY=0A=
 * @param {expression} ngShow If the {@link guide/expression expression} =
is truthy/falsy then the=0A=
 *                            element is shown/hidden respectively.=0A=
 *=0A=
 * @example=0A=
 * A simple example, animating the element's opacity:=0A=
 *=0A=
  &lt;example module=3D"ngAnimate" deps=3D"angular-animate.js" =
animations=3D"true" name=3D"ng-show-simple"&gt;=0A=
    &lt;file name=3D"index.html"&gt;=0A=
      Show: &lt;input type=3D"checkbox" ng-model=3D"checked" =
aria-label=3D"Toggle ngShow"&gt;&lt;br /&gt;=0A=
      &lt;div class=3D"check-element animate-show-hide" =
ng-show=3D"checked"&gt;=0A=
        I show up when your checkbox is checked.=0A=
      &lt;/div&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"animations.css"&gt;=0A=
      .animate-show-hide.ng-hide {=0A=
        opacity: 0;=0A=
      }=0A=
=0A=
      .animate-show-hide.ng-hide-add,=0A=
      .animate-show-hide.ng-hide-remove {=0A=
        transition: all linear 0.5s;=0A=
      }=0A=
=0A=
      .check-element {=0A=
        border: 1px solid black;=0A=
        opacity: 1;=0A=
        padding: 10px;=0A=
      }=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
      it('should check ngShow', function() {=0A=
        var checkbox =3D element(by.model('checked'));=0A=
        var checkElem =3D element(by.css('.check-element'));=0A=
=0A=
        expect(checkElem.isDisplayed()).toBe(false);=0A=
        checkbox.click();=0A=
        expect(checkElem.isDisplayed()).toBe(true);=0A=
      });=0A=
    &lt;/file&gt;=0A=
  &lt;/example&gt;=0A=
 *=0A=
 * &lt;hr /&gt;=0A=
 * @example=0A=
 * A more complex example, featuring different show/hide animations:=0A=
 *=0A=
  &lt;example module=3D"ngAnimate" deps=3D"angular-animate.js" =
animations=3D"true" name=3D"ng-show-complex"&gt;=0A=
    &lt;file name=3D"index.html"&gt;=0A=
      Show: &lt;input type=3D"checkbox" ng-model=3D"checked" =
aria-label=3D"Toggle ngShow"&gt;&lt;br /&gt;=0A=
      &lt;div class=3D"check-element funky-show-hide" =
ng-show=3D"checked"&gt;=0A=
        I show up when your checkbox is checked.=0A=
      &lt;/div&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"animations.css"&gt;=0A=
      body {=0A=
        overflow: hidden;=0A=
        perspective: 1000px;=0A=
      }=0A=
=0A=
      .funky-show-hide.ng-hide-add {=0A=
        transform: rotateZ(0);=0A=
        transform-origin: right;=0A=
        transition: all 0.5s ease-in-out;=0A=
      }=0A=
=0A=
      .funky-show-hide.ng-hide-add.ng-hide-add-active {=0A=
        transform: rotateZ(-135deg);=0A=
      }=0A=
=0A=
      .funky-show-hide.ng-hide-remove {=0A=
        transform: rotateY(90deg);=0A=
        transform-origin: left;=0A=
        transition: all 0.5s ease;=0A=
      }=0A=
=0A=
      .funky-show-hide.ng-hide-remove.ng-hide-remove-active {=0A=
        transform: rotateY(0);=0A=
      }=0A=
=0A=
      .check-element {=0A=
        border: 1px solid black;=0A=
        opacity: 1;=0A=
        padding: 10px;=0A=
      }=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
      it('should check ngShow', function() {=0A=
        var checkbox =3D element(by.model('checked'));=0A=
        var checkElem =3D element(by.css('.check-element'));=0A=
=0A=
        expect(checkElem.isDisplayed()).toBe(false);=0A=
        checkbox.click();=0A=
        expect(checkElem.isDisplayed()).toBe(true);=0A=
      });=0A=
    &lt;/file&gt;=0A=
  &lt;/example&gt;=0A=
 */=0A=
var ngShowDirective =3D ['$animate', function($animate) {=0A=
  return {=0A=
    restrict: 'A',=0A=
    multiElement: true,=0A=
    link: function(scope, element, attr) {=0A=
      scope.$watch(attr.ngShow, function ngShowWatchAction(value) {=0A=
        // we're adding a temporary, animation-specific class for =
ng-hide since this way=0A=
        // we can control when the element is actually displayed on =
screen without having=0A=
        // to have a global/greedy CSS selector that breaks when other =
animations are run.=0A=
        // Read: =
https://github.com/angular/angular.js/issues/9103#issuecomment-58335845=0A=
        $animate[value ? 'removeClass' : 'addClass'](element, =
NG_HIDE_CLASS, {=0A=
          tempClasses: NG_HIDE_IN_PROGRESS_CLASS=0A=
        });=0A=
      });=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngHide=0A=
 * @multiElement=0A=
 *=0A=
 * @description=0A=
 * The `ngHide` directive shows or hides the given HTML element based on =
the expression provided to=0A=
 * the `ngHide` attribute.=0A=
 *=0A=
 * The element is shown or hidden by removing or adding the `.ng-hide` =
CSS class onto the element.=0A=
 * The `.ng-hide` CSS class is predefined in AngularJS and sets the =
display style to none (using an=0A=
 * `!important` flag). For CSP mode please add `angular-csp.css` to your =
HTML file (see=0A=
 * {@link ng.directive:ngCsp ngCsp}).=0A=
 *=0A=
 * ```html=0A=
 * &lt;!-- when $scope.myValue is truthy (element is hidden) --&gt;=0A=
 * &lt;div ng-hide=3D"myValue" class=3D"ng-hide"&gt;&lt;/div&gt;=0A=
 *=0A=
 * &lt;!-- when $scope.myValue is falsy (element is visible) --&gt;=0A=
 * &lt;div ng-hide=3D"myValue"&gt;&lt;/div&gt;=0A=
 * ```=0A=
 *=0A=
 * When the `ngHide` expression evaluates to a truthy value then the =
`.ng-hide` CSS class is added=0A=
 * to the class attribute on the element causing it to become hidden. =
When falsy, the `.ng-hide`=0A=
 * CSS class is removed from the element causing the element not to =
appear hidden.=0A=
 *=0A=
 * ## Why is `!important` used?=0A=
 *=0A=
 * You may be wondering why `!important` is used for the `.ng-hide` CSS =
class. This is because the=0A=
 * `.ng-hide` selector can be easily overridden by heavier selectors. =
For example, something as=0A=
 * simple as changing the display style on a HTML list item would make =
hidden elements appear=0A=
 * visible. This also becomes a bigger issue when dealing with CSS =
frameworks.=0A=
 *=0A=
 * By using `!important`, the show and hide behavior will work as =
expected despite any clash between=0A=
 * CSS selector specificity (when `!important` isn't used with any =
conflicting styles). If a=0A=
 * developer chooses to override the styling to change how to hide an =
element then it is just a=0A=
 * matter of using `!important` in their own CSS code.=0A=
 *=0A=
 * ### Overriding `.ng-hide`=0A=
 *=0A=
 * By default, the `.ng-hide` class will style the element with =
`display: none !important`. If you=0A=
 * wish to change the hide behavior with `ngShow`/`ngHide`, you can =
simply overwrite the styles for=0A=
 * the `.ng-hide` CSS class. Note that the selector that needs to be =
used is actually=0A=
 * `.ng-hide:not(.ng-hide-animate)` to cope with extra animation classes =
that can be added.=0A=
 *=0A=
 * ```css=0A=
 * .ng-hide:not(.ng-hide-animate) {=0A=
 *   /&amp;#42; These are just alternative ways of hiding an element =
&amp;#42;/=0A=
 *   display: block!important;=0A=
 *   position: absolute;=0A=
 *   top: -9999px;=0A=
 *   left: -9999px;=0A=
 * }=0A=
 * ```=0A=
 *=0A=
 * By default you don't need to override in CSS anything and the =
animations will work around the=0A=
 * display style.=0A=
 *=0A=
 * ## A note about animations with `ngHide`=0A=
 *=0A=
 * Animations in `ngShow`/`ngHide` work with the show and hide events =
that are triggered when the=0A=
 * directive expression is true and false. This system works like the =
animation system present with=0A=
 * `ngClass` except that you must also include the `!important` flag to =
override the display=0A=
 * property so that the elements are not actually hidden during the =
animation.=0A=
 *=0A=
 * ```css=0A=
 * /&amp;#42; A working example can be found at the bottom of this page. =
&amp;#42;/=0A=
 * .my-element.ng-hide-add, .my-element.ng-hide-remove {=0A=
 *   transition: all 0.5s linear;=0A=
 * }=0A=
 *=0A=
 * .my-element.ng-hide-add { ... }=0A=
 * .my-element.ng-hide-add.ng-hide-add-active { ... }=0A=
 * .my-element.ng-hide-remove { ... }=0A=
 * .my-element.ng-hide-remove.ng-hide-remove-active { ... }=0A=
 * ```=0A=
 *=0A=
 * Keep in mind that, as of AngularJS version 1.3, there is no need to =
change the display property=0A=
 * to block during animation states - ngAnimate will automatically =
handle the style toggling for you.=0A=
 *=0A=
 * @animations=0A=
 * | Animation                                           | Occurs        =
                                                                         =
                    |=0A=
 * =
|-----------------------------------------------------|------------------=
-------------------------------------------------------------------------=
-----------------|=0A=
 * | {@link $animate#addClass addClass} `.ng-hide`       | After the =
`ngHide` expression evaluates to a truthy value and just before the =
contents are set to hidden.  |=0A=
 * | {@link $animate#removeClass removeClass} `.ng-hide` | After the =
`ngHide` expression evaluates to a non truthy value and just before =
contents are set to visible. |=0A=
 *=0A=
 *=0A=
 * @element ANY=0A=
 * @param {expression} ngHide If the {@link guide/expression expression} =
is truthy/falsy then the=0A=
 *                            element is hidden/shown respectively.=0A=
 *=0A=
 * @example=0A=
 * A simple example, animating the element's opacity:=0A=
 *=0A=
  &lt;example module=3D"ngAnimate" deps=3D"angular-animate.js" =
animations=3D"true" name=3D"ng-hide-simple"&gt;=0A=
    &lt;file name=3D"index.html"&gt;=0A=
      Hide: &lt;input type=3D"checkbox" ng-model=3D"checked" =
aria-label=3D"Toggle ngHide"&gt;&lt;br /&gt;=0A=
      &lt;div class=3D"check-element animate-show-hide" =
ng-hide=3D"checked"&gt;=0A=
        I hide when your checkbox is checked.=0A=
      &lt;/div&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"animations.css"&gt;=0A=
      .animate-show-hide.ng-hide {=0A=
        opacity: 0;=0A=
      }=0A=
=0A=
      .animate-show-hide.ng-hide-add,=0A=
      .animate-show-hide.ng-hide-remove {=0A=
        transition: all linear 0.5s;=0A=
      }=0A=
=0A=
      .check-element {=0A=
        border: 1px solid black;=0A=
        opacity: 1;=0A=
        padding: 10px;=0A=
      }=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
      it('should check ngHide', function() {=0A=
        var checkbox =3D element(by.model('checked'));=0A=
        var checkElem =3D element(by.css('.check-element'));=0A=
=0A=
        expect(checkElem.isDisplayed()).toBe(true);=0A=
        checkbox.click();=0A=
        expect(checkElem.isDisplayed()).toBe(false);=0A=
      });=0A=
    &lt;/file&gt;=0A=
  &lt;/example&gt;=0A=
 *=0A=
 * &lt;hr /&gt;=0A=
 * @example=0A=
 * A more complex example, featuring different show/hide animations:=0A=
 *=0A=
  &lt;example module=3D"ngAnimate" deps=3D"angular-animate.js" =
animations=3D"true" name=3D"ng-hide-complex"&gt;=0A=
    &lt;file name=3D"index.html"&gt;=0A=
      Hide: &lt;input type=3D"checkbox" ng-model=3D"checked" =
aria-label=3D"Toggle ngHide"&gt;&lt;br /&gt;=0A=
      &lt;div class=3D"check-element funky-show-hide" =
ng-hide=3D"checked"&gt;=0A=
        I hide when your checkbox is checked.=0A=
      &lt;/div&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"animations.css"&gt;=0A=
      body {=0A=
        overflow: hidden;=0A=
        perspective: 1000px;=0A=
      }=0A=
=0A=
      .funky-show-hide.ng-hide-add {=0A=
        transform: rotateZ(0);=0A=
        transform-origin: right;=0A=
        transition: all 0.5s ease-in-out;=0A=
      }=0A=
=0A=
      .funky-show-hide.ng-hide-add.ng-hide-add-active {=0A=
        transform: rotateZ(-135deg);=0A=
      }=0A=
=0A=
      .funky-show-hide.ng-hide-remove {=0A=
        transform: rotateY(90deg);=0A=
        transform-origin: left;=0A=
        transition: all 0.5s ease;=0A=
      }=0A=
=0A=
      .funky-show-hide.ng-hide-remove.ng-hide-remove-active {=0A=
        transform: rotateY(0);=0A=
      }=0A=
=0A=
      .check-element {=0A=
        border: 1px solid black;=0A=
        opacity: 1;=0A=
        padding: 10px;=0A=
      }=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
      it('should check ngHide', function() {=0A=
        var checkbox =3D element(by.model('checked'));=0A=
        var checkElem =3D element(by.css('.check-element'));=0A=
=0A=
        expect(checkElem.isDisplayed()).toBe(true);=0A=
        checkbox.click();=0A=
        expect(checkElem.isDisplayed()).toBe(false);=0A=
      });=0A=
    &lt;/file&gt;=0A=
  &lt;/example&gt;=0A=
 */=0A=
var ngHideDirective =3D ['$animate', function($animate) {=0A=
  return {=0A=
    restrict: 'A',=0A=
    multiElement: true,=0A=
    link: function(scope, element, attr) {=0A=
      scope.$watch(attr.ngHide, function ngHideWatchAction(value) {=0A=
        // The comment inside of the ngShowDirective explains why we add =
and=0A=
        // remove a temporary class for the show/hide animation=0A=
        $animate[value ? 'addClass' : =
'removeClass'](element,NG_HIDE_CLASS, {=0A=
          tempClasses: NG_HIDE_IN_PROGRESS_CLASS=0A=
        });=0A=
      });=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngStyle=0A=
 * @restrict AC=0A=
 *=0A=
 * @description=0A=
 * The `ngStyle` directive allows you to set CSS style on an HTML =
element conditionally.=0A=
 *=0A=
 * @knownIssue=0A=
 * You should not use {@link guide/interpolation interpolation} in the =
value of the `style`=0A=
 * attribute, when using the `ngStyle` directive on the same element.=0A=
 * See {@link guide/interpolation#known-issues here} for more info.=0A=
 *=0A=
 * @element ANY=0A=
 * @param {expression} ngStyle=0A=
 *=0A=
 * {@link guide/expression Expression} which evals to an=0A=
 * object whose keys are CSS style names and values are corresponding =
values for those CSS=0A=
 * keys.=0A=
 *=0A=
 * Since some CSS style names are not valid keys for an object, they =
must be quoted.=0A=
 * See the 'background-color' style in the example below.=0A=
 *=0A=
 * @example=0A=
   &lt;example name=3D"ng-style"&gt;=0A=
     &lt;file name=3D"index.html"&gt;=0A=
        &lt;input type=3D"button" value=3D"set color" =
ng-click=3D"myStyle=3D{color:'red'}"&gt;=0A=
        &lt;input type=3D"button" value=3D"set background" =
ng-click=3D"myStyle=3D{'background-color':'blue'}"&gt;=0A=
        &lt;input type=3D"button" value=3D"clear" =
ng-click=3D"myStyle=3D{}"&gt;=0A=
        &lt;br/&gt;=0A=
        &lt;span ng-style=3D"myStyle"&gt;Sample Text&lt;/span&gt;=0A=
        &lt;pre&gt;myStyle=3D{{myStyle}}&lt;/pre&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"style.css"&gt;=0A=
       span {=0A=
         color: black;=0A=
       }=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       var colorSpan =3D element(by.css('span'));=0A=
=0A=
       it('should check ng-style', function() {=0A=
         expect(colorSpan.getCssValue('color')).toBe('rgba(0, 0, 0, 1)');=0A=
         element(by.css('input[value=3D\'set color\']')).click();=0A=
         expect(colorSpan.getCssValue('color')).toBe('rgba(255, 0, 0, =
1)');=0A=
         element(by.css('input[value=3Dclear]')).click();=0A=
         expect(colorSpan.getCssValue('color')).toBe('rgba(0, 0, 0, 1)');=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
var ngStyleDirective =3D ngDirective(function(scope, element, attr) {=0A=
  scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, =
oldStyles) {=0A=
    if (oldStyles &amp;&amp; (newStyles !=3D=3D oldStyles)) {=0A=
      forEach(oldStyles, function(val, style) { element.css(style, =
'');});=0A=
    }=0A=
    if (newStyles) element.css(newStyles);=0A=
  }, true);=0A=
});=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngSwitch=0A=
 * @restrict EA=0A=
 *=0A=
 * @description=0A=
 * The `ngSwitch` directive is used to conditionally swap DOM structure =
on your template based on a scope expression.=0A=
 * Elements within `ngSwitch` but without `ngSwitchWhen` or =
`ngSwitchDefault` directives will be preserved at the location=0A=
 * as specified in the template.=0A=
 *=0A=
 * The directive itself works similar to ngInclude, however, instead of =
downloading template code (or loading it=0A=
 * from the template cache), `ngSwitch` simply chooses one of the nested =
elements and makes it visible based on which element=0A=
 * matches the value obtained from the evaluated expression. In other =
words, you define a container element=0A=
 * (where you place the directive), place an expression on the =
**`on=3D"..."` attribute**=0A=
 * (or the **`ng-switch=3D"..."` attribute**), define any inner elements =
inside of the directive and place=0A=
 * a when attribute per element. The when attribute is used to inform =
ngSwitch which element to display when the on=0A=
 * expression is evaluated. If a matching expression is not found via a =
when attribute then an element with the default=0A=
 * attribute is displayed.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-info"&gt;=0A=
 * Be aware that the attribute values to match against cannot be =
expressions. They are interpreted=0A=
 * as literal string values to match against.=0A=
 * For example, **`ng-switch-when=3D"someVal"`** will match against the =
string `"someVal"` not against the=0A=
 * value of the expression `$scope.someVal`.=0A=
 * &lt;/div&gt;=0A=
=0A=
 * @animations=0A=
 * | Animation                        | Occurs                           =
   |=0A=
 * =
|----------------------------------|-------------------------------------=
|=0A=
 * | {@link ng.$animate#enter enter}  | after the ngSwitch contents =
change and the matched child element is placed inside the container |=0A=
 * | {@link ng.$animate#leave leave}  | after the ngSwitch contents =
change and just before the former contents are removed from the DOM |=0A=
 *=0A=
 * @usage=0A=
 *=0A=
 * ```=0A=
 * &lt;ANY ng-switch=3D"expression"&gt;=0A=
 *   &lt;ANY ng-switch-when=3D"matchValue1"&gt;...&lt;/ANY&gt;=0A=
 *   &lt;ANY ng-switch-when=3D"matchValue2"&gt;...&lt;/ANY&gt;=0A=
 *   &lt;ANY ng-switch-default&gt;...&lt;/ANY&gt;=0A=
 * &lt;/ANY&gt;=0A=
 * ```=0A=
 *=0A=
 *=0A=
 * @scope=0A=
 * @priority 1200=0A=
 * @param {*} ngSwitch|on expression to match against =
&lt;code&gt;ng-switch-when&lt;/code&gt;.=0A=
 * On child elements add:=0A=
 *=0A=
 * * `ngSwitchWhen`: the case statement to match against. If match then =
this=0A=
 *   case will be displayed. If the same match appears multiple times, =
all the=0A=
 *   elements will be displayed. It is possible to associate multiple =
values to=0A=
 *   the same `ngSwitchWhen` by defining the optional attribute=0A=
 *   `ngSwitchWhenSeparator`. The separator will be used to split the =
value of=0A=
 *   the `ngSwitchWhen` attribute into multiple tokens, and the element =
will show=0A=
 *   if any of the `ngSwitch` evaluates to any of these tokens.=0A=
 * * `ngSwitchDefault`: the default case when no other case match. If =
there=0A=
 *   are multiple default cases, all of them will be displayed when no =
other=0A=
 *   case match.=0A=
 *=0A=
 *=0A=
 * @example=0A=
  &lt;example module=3D"switchExample" deps=3D"angular-animate.js" =
animations=3D"true" name=3D"ng-switch"&gt;=0A=
    &lt;file name=3D"index.html"&gt;=0A=
      &lt;div ng-controller=3D"ExampleController"&gt;=0A=
        &lt;select ng-model=3D"selection" ng-options=3D"item for item in =
items"&gt;=0A=
        &lt;/select&gt;=0A=
        &lt;code&gt;selection=3D{{selection}}&lt;/code&gt;=0A=
        &lt;hr/&gt;=0A=
        &lt;div class=3D"animate-switch-container"=0A=
          ng-switch on=3D"selection"&gt;=0A=
            &lt;div class=3D"animate-switch" =
ng-switch-when=3D"settings|options" =
ng-switch-when-separator=3D"|"&gt;Settings Div&lt;/div&gt;=0A=
            &lt;div class=3D"animate-switch" =
ng-switch-when=3D"home"&gt;Home Span&lt;/div&gt;=0A=
            &lt;div class=3D"animate-switch" =
ng-switch-default&gt;default&lt;/div&gt;=0A=
        &lt;/div&gt;=0A=
      &lt;/div&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"script.js"&gt;=0A=
      angular.module('switchExample', ['ngAnimate'])=0A=
        .controller('ExampleController', ['$scope', function($scope) {=0A=
          $scope.items =3D ['settings', 'home', 'options', 'other'];=0A=
          $scope.selection =3D $scope.items[0];=0A=
        }]);=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"animations.css"&gt;=0A=
      .animate-switch-container {=0A=
        position:relative;=0A=
        background:white;=0A=
        border:1px solid black;=0A=
        height:40px;=0A=
        overflow:hidden;=0A=
      }=0A=
=0A=
      .animate-switch {=0A=
        padding:10px;=0A=
      }=0A=
=0A=
      .animate-switch.ng-animate {=0A=
        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;=0A=
=0A=
        position:absolute;=0A=
        top:0;=0A=
        left:0;=0A=
        right:0;=0A=
        bottom:0;=0A=
      }=0A=
=0A=
      .animate-switch.ng-leave.ng-leave-active,=0A=
      .animate-switch.ng-enter {=0A=
        top:-50px;=0A=
      }=0A=
      .animate-switch.ng-leave,=0A=
      .animate-switch.ng-enter.ng-enter-active {=0A=
        top:0;=0A=
      }=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
      var switchElem =3D element(by.css('[ng-switch]'));=0A=
      var select =3D element(by.model('selection'));=0A=
=0A=
      it('should start in settings', function() {=0A=
        expect(switchElem.getText()).toMatch(/Settings Div/);=0A=
      });=0A=
      it('should change to home', function() {=0A=
        select.all(by.css('option')).get(1).click();=0A=
        expect(switchElem.getText()).toMatch(/Home Span/);=0A=
      });=0A=
      it('should change to settings via "options"', function() {=0A=
        select.all(by.css('option')).get(2).click();=0A=
        expect(switchElem.getText()).toMatch(/Settings Div/);=0A=
      });=0A=
      it('should select default', function() {=0A=
        select.all(by.css('option')).get(3).click();=0A=
        expect(switchElem.getText()).toMatch(/default/);=0A=
      });=0A=
    &lt;/file&gt;=0A=
  &lt;/example&gt;=0A=
 */=0A=
var ngSwitchDirective =3D ['$animate', '$compile', function($animate, =
$compile) {=0A=
  return {=0A=
    require: 'ngSwitch',=0A=
=0A=
    // asks for $scope to fool the BC controller module=0A=
    controller: ['$scope', function NgSwitchController() {=0A=
     this.cases =3D {};=0A=
    }],=0A=
    link: function(scope, element, attr, ngSwitchController) {=0A=
      var watchExpr =3D attr.ngSwitch || attr.on,=0A=
          selectedTranscludes =3D [],=0A=
          selectedElements =3D [],=0A=
          previousLeaveAnimations =3D [],=0A=
          selectedScopes =3D [];=0A=
=0A=
      var spliceFactory =3D function(array, index) {=0A=
          return function(response) {=0A=
            if (response !=3D=3D false) array.splice(index, 1);=0A=
          };=0A=
      };=0A=
=0A=
      scope.$watch(watchExpr, function ngSwitchWatchAction(value) {=0A=
        var i, ii;=0A=
=0A=
        // Start with the last, in case the array is modified during the =
loop=0A=
        while (previousLeaveAnimations.length) {=0A=
          $animate.cancel(previousLeaveAnimations.pop());=0A=
        }=0A=
=0A=
        for (i =3D 0, ii =3D selectedScopes.length; i &lt; ii; ++i) {=0A=
          var selected =3D getBlockNodes(selectedElements[i].clone);=0A=
          selectedScopes[i].$destroy();=0A=
          var runner =3D previousLeaveAnimations[i] =3D =
$animate.leave(selected);=0A=
          runner.done(spliceFactory(previousLeaveAnimations, i));=0A=
        }=0A=
=0A=
        selectedElements.length =3D 0;=0A=
        selectedScopes.length =3D 0;=0A=
=0A=
        if ((selectedTranscludes =3D ngSwitchController.cases['!' + =
value] || ngSwitchController.cases['?'])) {=0A=
          forEach(selectedTranscludes, function(selectedTransclude) {=0A=
            selectedTransclude.transclude(function(caseElement, =
selectedScope) {=0A=
              selectedScopes.push(selectedScope);=0A=
              var anchor =3D selectedTransclude.element;=0A=
              caseElement[caseElement.length++] =3D =
$compile.$$createComment('end ngSwitchWhen');=0A=
              var block =3D { clone: caseElement };=0A=
=0A=
              selectedElements.push(block);=0A=
              $animate.enter(caseElement, anchor.parent(), anchor);=0A=
            });=0A=
          });=0A=
        }=0A=
      });=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
var ngSwitchWhenDirective =3D ngDirective({=0A=
  transclude: 'element',=0A=
  priority: 1200,=0A=
  require: '^ngSwitch',=0A=
  multiElement: true,=0A=
  link: function(scope, element, attrs, ctrl, $transclude) {=0A=
=0A=
    var cases =3D =
attrs.ngSwitchWhen.split(attrs.ngSwitchWhenSeparator).sort().filter(=0A=
      // Filter duplicate cases=0A=
      function(element, index, array) { return array[index - 1] !=3D=3D =
element; }=0A=
    );=0A=
=0A=
    forEach(cases, function(whenCase) {=0A=
      ctrl.cases['!' + whenCase] =3D (ctrl.cases['!' + whenCase] || []);=0A=
      ctrl.cases['!' + whenCase].push({ transclude: $transclude, =
element: element });=0A=
    });=0A=
  }=0A=
});=0A=
=0A=
var ngSwitchDefaultDirective =3D ngDirective({=0A=
  transclude: 'element',=0A=
  priority: 1200,=0A=
  require: '^ngSwitch',=0A=
  multiElement: true,=0A=
  link: function(scope, element, attr, ctrl, $transclude) {=0A=
    ctrl.cases['?'] =3D (ctrl.cases['?'] || []);=0A=
    ctrl.cases['?'].push({ transclude: $transclude, element: element });=0A=
   }=0A=
});=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngTransclude=0A=
 * @restrict EAC=0A=
 *=0A=
 * @description=0A=
 * Directive that marks the insertion point for the transcluded DOM of =
the nearest parent directive that uses transclusion.=0A=
 *=0A=
 * You can specify that you want to insert a named transclusion slot, =
instead of the default slot, by providing the slot name=0A=
 * as the value of the `ng-transclude` or `ng-transclude-slot` attribute.=0A=
 *=0A=
 * If the transcluded content is not empty (i.e. contains one or more =
DOM nodes, including whitespace text nodes), any existing=0A=
 * content of this element will be removed before the transcluded =
content is inserted.=0A=
 * If the transcluded content is empty (or only whitespace), the =
existing content is left intact. This lets you provide fallback=0A=
 * content in the case that no transcluded content is provided.=0A=
 *=0A=
 * @element ANY=0A=
 *=0A=
 * @param {string} ngTransclude|ngTranscludeSlot the name of the slot to =
insert at this point. If this is not provided, is empty=0A=
 *                                               or its value is the =
same as the name of the attribute then the default slot is used.=0A=
 *=0A=
 * @example=0A=
 * ### Basic transclusion=0A=
 * This example demonstrates basic transclusion of content into a =
component directive.=0A=
 * &lt;example name=3D"simpleTranscludeExample" =
module=3D"transcludeExample"&gt;=0A=
 *   &lt;file name=3D"index.html"&gt;=0A=
 *     &lt;script&gt;=0A=
 *       angular.module('transcludeExample', [])=0A=
 *        .directive('pane', function(){=0A=
 *           return {=0A=
 *             restrict: 'E',=0A=
 *             transclude: true,=0A=
 *             scope: { title:'@' },=0A=
 *             template: '&lt;div style=3D"border: 1px solid =
black;"&gt;' +=0A=
 *                         '&lt;div style=3D"background-color: =
gray"&gt;{{title}}&lt;/div&gt;' +=0A=
 *                         '&lt;ng-transclude&gt;&lt;/ng-transclude&gt;' =
+=0A=
 *                       '&lt;/div&gt;'=0A=
 *           };=0A=
 *       })=0A=
 *       .controller('ExampleController', ['$scope', function($scope) {=0A=
 *         $scope.title =3D 'Lorem Ipsum';=0A=
 *         $scope.text =3D 'Neque porro quisquam est qui dolorem ipsum =
quia dolor...';=0A=
 *       }]);=0A=
 *     &lt;/script&gt;=0A=
 *     &lt;div ng-controller=3D"ExampleController"&gt;=0A=
 *       &lt;input ng-model=3D"title" aria-label=3D"title"&gt; =
&lt;br/&gt;=0A=
 *       &lt;textarea ng-model=3D"text" =
aria-label=3D"text"&gt;&lt;/textarea&gt; &lt;br/&gt;=0A=
 *       &lt;pane =
title=3D"{{title}}"&gt;&lt;span&gt;{{text}}&lt;/span&gt;&lt;/pane&gt;=0A=
 *     &lt;/div&gt;=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
 *      it('should have transcluded', function() {=0A=
 *        var titleElement =3D element(by.model('title'));=0A=
 *        titleElement.clear();=0A=
 *        titleElement.sendKeys('TITLE');=0A=
 *        var textElement =3D element(by.model('text'));=0A=
 *        textElement.clear();=0A=
 *        textElement.sendKeys('TEXT');=0A=
 *        =
expect(element(by.binding('title')).getText()).toEqual('TITLE');=0A=
 *        expect(element(by.binding('text')).getText()).toEqual('TEXT');=0A=
 *      });=0A=
 *   &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 *=0A=
 * @example=0A=
 * ### Transclude fallback content=0A=
 * This example shows how to use `NgTransclude` with fallback content, =
that=0A=
 * is displayed if no transcluded content is provided.=0A=
 *=0A=
 * &lt;example module=3D"transcludeFallbackContentExample" =
name=3D"ng-transclude"&gt;=0A=
 * &lt;file name=3D"index.html"&gt;=0A=
 * &lt;script&gt;=0A=
 * angular.module('transcludeFallbackContentExample', [])=0A=
 * .directive('myButton', function(){=0A=
 *             return {=0A=
 *               restrict: 'E',=0A=
 *               transclude: true,=0A=
 *               scope: true,=0A=
 *               template: '&lt;button style=3D"cursor: pointer;"&gt;' +=0A=
 *                           '&lt;ng-transclude&gt;' +=0A=
 *                             '&lt;b style=3D"color: =
red;"&gt;Button1&lt;/b&gt;' +=0A=
 *                           '&lt;/ng-transclude&gt;' +=0A=
 *                         '&lt;/button&gt;'=0A=
 *             };=0A=
 *         });=0A=
 * &lt;/script&gt;=0A=
 * &lt;!-- fallback button content --&gt;=0A=
 * &lt;my-button id=3D"fallback"&gt;&lt;/my-button&gt;=0A=
 * &lt;!-- modified button content --&gt;=0A=
 * &lt;my-button id=3D"modified"&gt;=0A=
 *   &lt;i style=3D"color: green;"&gt;Button2&lt;/i&gt;=0A=
 * &lt;/my-button&gt;=0A=
 * &lt;/file&gt;=0A=
 * &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
 * it('should have different transclude element content', function() {=0A=
 *          expect(element(by.id('fallback')).getText()).toBe('Button1');=0A=
 *          expect(element(by.id('modified')).getText()).toBe('Button2');=0A=
 *        });=0A=
 * &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 *=0A=
 * @example=0A=
 * ### Multi-slot transclusion=0A=
 * This example demonstrates using multi-slot transclusion in a =
component directive.=0A=
 * &lt;example name=3D"multiSlotTranscludeExample" =
module=3D"multiSlotTranscludeExample"&gt;=0A=
 *   &lt;file name=3D"index.html"&gt;=0A=
 *    &lt;style&gt;=0A=
 *      .title, .footer {=0A=
 *        background-color: gray=0A=
 *      }=0A=
 *    &lt;/style&gt;=0A=
 *    &lt;div ng-controller=3D"ExampleController"&gt;=0A=
 *      &lt;input ng-model=3D"title" aria-label=3D"title"&gt; &lt;br/&gt;=0A=
 *      &lt;textarea ng-model=3D"text" =
aria-label=3D"text"&gt;&lt;/textarea&gt; &lt;br/&gt;=0A=
 *      &lt;pane&gt;=0A=
 *        &lt;pane-title&gt;&lt;a =
ng-href=3D"{{link}}"&gt;{{title}}&lt;/a&gt;&lt;/pane-title&gt;=0A=
 *        &lt;pane-body&gt;&lt;p&gt;{{text}}&lt;/p&gt;&lt;/pane-body&gt;=0A=
 *      &lt;/pane&gt;=0A=
 *    &lt;/div&gt;=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"app.js"&gt;=0A=
 *    angular.module('multiSlotTranscludeExample', [])=0A=
 *     .directive('pane', function() {=0A=
 *        return {=0A=
 *          restrict: 'E',=0A=
 *          transclude: {=0A=
 *            'title': '?paneTitle',=0A=
 *            'body': 'paneBody',=0A=
 *            'footer': '?paneFooter'=0A=
 *          },=0A=
 *          template: '&lt;div style=3D"border: 1px solid black;"&gt;' +=0A=
 *                      '&lt;div class=3D"title" =
ng-transclude=3D"title"&gt;Fallback Title&lt;/div&gt;' +=0A=
 *                      '&lt;div ng-transclude=3D"body"&gt;&lt;/div&gt;' =
+=0A=
 *                      '&lt;div class=3D"footer" =
ng-transclude=3D"footer"&gt;Fallback Footer&lt;/div&gt;' +=0A=
 *                    '&lt;/div&gt;'=0A=
 *        };=0A=
 *    })=0A=
 *    .controller('ExampleController', ['$scope', function($scope) {=0A=
 *      $scope.title =3D 'Lorem Ipsum';=0A=
 *      $scope.link =3D 'https://google.com';=0A=
 *      $scope.text =3D 'Neque porro quisquam est qui dolorem ipsum quia =
dolor...';=0A=
 *    }]);=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
 *      it('should have transcluded the title and the body', function() {=0A=
 *        var titleElement =3D element(by.model('title'));=0A=
 *        titleElement.clear();=0A=
 *        titleElement.sendKeys('TITLE');=0A=
 *        var textElement =3D element(by.model('text'));=0A=
 *        textElement.clear();=0A=
 *        textElement.sendKeys('TEXT');=0A=
 *        expect(element(by.css('.title')).getText()).toEqual('TITLE');=0A=
 *        expect(element(by.binding('text')).getText()).toEqual('TEXT');=0A=
 *        expect(element(by.css('.footer')).getText()).toEqual('Fallback =
Footer');=0A=
 *      });=0A=
 *   &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 */=0A=
var ngTranscludeMinErr =3D minErr('ngTransclude');=0A=
var ngTranscludeDirective =3D ['$compile', function($compile) {=0A=
  return {=0A=
    restrict: 'EAC',=0A=
    terminal: true,=0A=
    compile: function ngTranscludeCompile(tElement) {=0A=
=0A=
      // Remove and cache any original content to act as a fallback=0A=
      var fallbackLinkFn =3D $compile(tElement.contents());=0A=
      tElement.empty();=0A=
=0A=
      return function ngTranscludePostLink($scope, $element, $attrs, =
controller, $transclude) {=0A=
=0A=
        if (!$transclude) {=0A=
          throw ngTranscludeMinErr('orphan',=0A=
          'Illegal use of ngTransclude directive in the template! ' +=0A=
          'No parent directive that requires a transclusion found. ' +=0A=
          'Element: {0}',=0A=
          startingTag($element));=0A=
        }=0A=
=0A=
=0A=
        // If the attribute is of the form: =
`ng-transclude=3D"ng-transclude"` then treat it like the default=0A=
        if ($attrs.ngTransclude =3D=3D=3D $attrs.$attr.ngTransclude) {=0A=
          $attrs.ngTransclude =3D '';=0A=
        }=0A=
        var slotName =3D $attrs.ngTransclude || $attrs.ngTranscludeSlot;=0A=
=0A=
        // If the slot is required and no transclusion content is =
provided then this call will throw an error=0A=
        $transclude(ngTranscludeCloneAttachFn, null, slotName);=0A=
=0A=
        // If the slot is optional and no transclusion content is =
provided then use the fallback content=0A=
        if (slotName &amp;&amp; !$transclude.isSlotFilled(slotName)) {=0A=
          useFallbackContent();=0A=
        }=0A=
=0A=
        function ngTranscludeCloneAttachFn(clone, transcludedScope) {=0A=
          if (clone.length &amp;&amp; notWhitespace(clone)) {=0A=
            $element.append(clone);=0A=
          } else {=0A=
            useFallbackContent();=0A=
            // There is nothing linked against the transcluded scope =
since no content was available,=0A=
            // so it should be safe to clean up the generated scope.=0A=
            transcludedScope.$destroy();=0A=
          }=0A=
        }=0A=
=0A=
        function useFallbackContent() {=0A=
          // Since this is the fallback content rather than the =
transcluded content,=0A=
          // we link against the scope of this directive rather than the =
transcluded scope=0A=
          fallbackLinkFn($scope, function(clone) {=0A=
            $element.append(clone);=0A=
          });=0A=
        }=0A=
=0A=
        function notWhitespace(nodes) {=0A=
          for (var i =3D 0, ii =3D nodes.length; i &lt; ii; i++) {=0A=
            var node =3D nodes[i];=0A=
            if (node.nodeType !=3D=3D NODE_TYPE_TEXT || =
node.nodeValue.trim()) {=0A=
              return true;=0A=
            }=0A=
          }=0A=
        }=0A=
      };=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name script=0A=
 * @restrict E=0A=
 *=0A=
 * @description=0A=
 * Load the content of a `&lt;script&gt;` element into {@link =
ng.$templateCache `$templateCache`}, so that the=0A=
 * template can be used by {@link ng.directive:ngInclude `ngInclude`},=0A=
 * {@link ngRoute.directive:ngView `ngView`}, or {@link guide/directive =
directives}. The type of the=0A=
 * `&lt;script&gt;` element must be specified as `text/ng-template`, and =
a cache name for the template must be=0A=
 * assigned through the element's `id`, which can then be used as a =
directive's `templateUrl`.=0A=
 *=0A=
 * @param {string} type Must be set to `'text/ng-template'`.=0A=
 * @param {string} id Cache name of the template.=0A=
 *=0A=
 * @example=0A=
  &lt;example  name=3D"script-tag"&gt;=0A=
    &lt;file name=3D"index.html"&gt;=0A=
      &lt;script type=3D"text/ng-template" id=3D"/tpl.html"&gt;=0A=
        Content of the template.=0A=
      &lt;/script&gt;=0A=
=0A=
      &lt;a ng-click=3D"currentTpl=3D'/tpl.html'" =
id=3D"tpl-link"&gt;Load inlined template&lt;/a&gt;=0A=
      &lt;div id=3D"tpl-content" ng-include =
src=3D"currentTpl"&gt;&lt;/div&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
      it('should load template defined inside script tag', function() {=0A=
        element(by.css('#tpl-link')).click();=0A=
        =
expect(element(by.css('#tpl-content')).getText()).toMatch(/Content of =
the template/);=0A=
      });=0A=
    &lt;/file&gt;=0A=
  &lt;/example&gt;=0A=
 */=0A=
var scriptDirective =3D ['$templateCache', function($templateCache) {=0A=
  return {=0A=
    restrict: 'E',=0A=
    terminal: true,=0A=
    compile: function(element, attr) {=0A=
      if (attr.type =3D=3D=3D 'text/ng-template') {=0A=
        var templateUrl =3D attr.id,=0A=
            text =3D element[0].text;=0A=
=0A=
        $templateCache.put(templateUrl, text);=0A=
      }=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
/* exported selectDirective, optionDirective */=0A=
=0A=
var noopNgModelController =3D { $setViewValue: noop, $render: noop };=0A=
=0A=
function setOptionSelectedStatus(optionEl, value) {=0A=
  optionEl.prop('selected', value);=0A=
  /**=0A=
   * When unselecting an option, setting the property to null / false =
should be enough=0A=
   * However, screenreaders might react to the selected attribute =
instead, see=0A=
   * https://github.com/angular/angular.js/issues/14419=0A=
   * Note: "selected" is a boolean attr and will be removed when the =
"value" arg in attr() is false=0A=
   * or null=0A=
   */=0A=
  optionEl.attr('selected', value);=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc type=0A=
 * @name  select.SelectController=0A=
 *=0A=
 * @description=0A=
 * The controller for the {@link ng.select select} directive. The =
controller exposes=0A=
 * a few utility methods that can be used to augment the behavior of a =
regular or an=0A=
 * {@link ng.ngOptions ngOptions} select element.=0A=
 *=0A=
 * @example=0A=
 * ### Set a custom error when the unknown option is selected=0A=
 *=0A=
 * This example sets a custom error "unknownValue" on the =
ngModelController=0A=
 * when the select element's unknown option is selected, i.e. when the =
model is set to a value=0A=
 * that is not matched by any option.=0A=
 *=0A=
 * &lt;example name=3D"select-unknown-value-error" =
module=3D"staticSelect"&gt;=0A=
 * &lt;file name=3D"index.html"&gt;=0A=
 * &lt;div ng-controller=3D"ExampleController"&gt;=0A=
 *   &lt;form name=3D"myForm"&gt;=0A=
 *     &lt;label for=3D"testSelect"&gt; Single select: =
&lt;/label&gt;&lt;br&gt;=0A=
 *     &lt;select name=3D"testSelect" ng-model=3D"selected" =
unknown-value-error&gt;=0A=
 *       &lt;option value=3D"option-1"&gt;Option 1&lt;/option&gt;=0A=
 *       &lt;option value=3D"option-2"&gt;Option 2&lt;/option&gt;=0A=
 *     &lt;/select&gt;&lt;br&gt;=0A=
 *     &lt;span =
ng-if=3D"myForm.testSelect.$error.unknownValue"&gt;Error: The current =
model doesn't match any option&lt;/span&gt;=0A=
 *=0A=
 *     &lt;button ng-click=3D"forceUnknownOption()"&gt;Force unknown =
option&lt;/button&gt;&lt;br&gt;=0A=
 *   &lt;/form&gt;=0A=
 * &lt;/div&gt;=0A=
 * &lt;/file&gt;=0A=
 * &lt;file name=3D"app.js"&gt;=0A=
 *  angular.module('staticSelect', [])=0A=
 *    .controller('ExampleController', ['$scope', function($scope) {=0A=
 *      $scope.selected =3D null;=0A=
 *=0A=
 *      $scope.forceUnknownOption =3D function() {=0A=
 *        $scope.selected =3D 'nonsense';=0A=
 *      };=0A=
 *   }])=0A=
 *   .directive('unknownValueError', function() {=0A=
 *     return {=0A=
 *       require: ['ngModel', 'select'],=0A=
 *       link: function(scope, element, attrs, ctrls) {=0A=
 *         var ngModelCtrl =3D ctrls[0];=0A=
 *         var selectCtrl =3D ctrls[1];=0A=
 *=0A=
 *         ngModelCtrl.$validators.unknownValue =3D function(modelValue, =
viewValue) {=0A=
 *           if (selectCtrl.$isUnknownOptionSelected()) {=0A=
 *             return false;=0A=
 *           }=0A=
 *=0A=
 *           return true;=0A=
 *         };=0A=
 *       }=0A=
 *=0A=
 *     };=0A=
 *   });=0A=
 * &lt;/file&gt;=0A=
 *&lt;/example&gt;=0A=
 *=0A=
 *=0A=
 * @example=0A=
 * ### Set the "required" error when the unknown option is selected.=0A=
 *=0A=
 * By default, the "required" error on the ngModelController is only set =
on a required select=0A=
 * when the empty option is selected. This example adds a custom =
directive that also sets the=0A=
 * error when the unknown option is selected.=0A=
 *=0A=
 * &lt;example name=3D"select-unknown-value-required" =
module=3D"staticSelect"&gt;=0A=
 * &lt;file name=3D"index.html"&gt;=0A=
 * &lt;div ng-controller=3D"ExampleController"&gt;=0A=
 *   &lt;form name=3D"myForm"&gt;=0A=
 *     &lt;label for=3D"testSelect"&gt; Select: &lt;/label&gt;&lt;br&gt;=0A=
 *     &lt;select name=3D"testSelect" ng-model=3D"selected" =
unknown-value-required&gt;=0A=
 *       &lt;option value=3D"option-1"&gt;Option 1&lt;/option&gt;=0A=
 *       &lt;option value=3D"option-2"&gt;Option 2&lt;/option&gt;=0A=
 *     &lt;/select&gt;&lt;br&gt;=0A=
 *     &lt;span ng-if=3D"myForm.testSelect.$error.required"&gt;Error: =
Please select a value&lt;/span&gt;&lt;br&gt;=0A=
 *=0A=
 *     &lt;button ng-click=3D"forceUnknownOption()"&gt;Force unknown =
option&lt;/button&gt;&lt;br&gt;=0A=
 *   &lt;/form&gt;=0A=
 * &lt;/div&gt;=0A=
 * &lt;/file&gt;=0A=
 * &lt;file name=3D"app.js"&gt;=0A=
 *  angular.module('staticSelect', [])=0A=
 *    .controller('ExampleController', ['$scope', function($scope) {=0A=
 *      $scope.selected =3D null;=0A=
 *=0A=
 *      $scope.forceUnknownOption =3D function() {=0A=
 *        $scope.selected =3D 'nonsense';=0A=
 *      };=0A=
 *   }])=0A=
 *   .directive('unknownValueRequired', function() {=0A=
 *     return {=0A=
 *       priority: 1, // This directive must run after the required =
directive has added its validator=0A=
 *       require: ['ngModel', 'select'],=0A=
 *       link: function(scope, element, attrs, ctrls) {=0A=
 *         var ngModelCtrl =3D ctrls[0];=0A=
 *         var selectCtrl =3D ctrls[1];=0A=
 *=0A=
 *         var originalRequiredValidator =3D =
ngModelCtrl.$validators.required;=0A=
 *=0A=
 *         ngModelCtrl.$validators.required =3D function() {=0A=
 *           if (attrs.required &amp;&amp; =
selectCtrl.$isUnknownOptionSelected()) {=0A=
 *             return false;=0A=
 *           }=0A=
 *=0A=
 *           return originalRequiredValidator.apply(this, arguments);=0A=
 *         };=0A=
 *       }=0A=
 *     };=0A=
 *   });=0A=
 * &lt;/file&gt;=0A=
 *&lt;/example&gt;=0A=
 *=0A=
 *=0A=
 */=0A=
var SelectController =3D=0A=
        ['$element', '$scope', /** @this */ function($element, $scope) {=0A=
=0A=
  var self =3D this,=0A=
      optionsMap =3D new NgMap();=0A=
=0A=
  self.selectValueMap =3D {}; // Keys are the hashed values, values the =
original values=0A=
=0A=
  // If the ngModel doesn't get provided then provide a dummy noop =
version to prevent errors=0A=
  self.ngModelCtrl =3D noopNgModelController;=0A=
  self.multiple =3D false;=0A=
=0A=
  // The "unknown" option is one that is prepended to the list if the =
viewValue=0A=
  // does not match any of the options. When it is rendered the value of =
the unknown=0A=
  // option is '? XXX ?' where XXX is the hashKey of the value that is =
not known.=0A=
  //=0A=
  // Support: IE 9 only=0A=
  // We can't just jqLite('&lt;option&gt;') since jqLite is not smart =
enough=0A=
  // to create it in &lt;select&gt; and IE barfs otherwise.=0A=
  self.unknownOption =3D jqLite(window.document.createElement('option'));=0A=
=0A=
  // The empty option is an option with the value '' that the =
application developer can=0A=
  // provide inside the select. It is always selectable and indicates =
that a "null" selection has=0A=
  // been made by the user.=0A=
  // If the select has an empty option, and the model of the select is =
set to "undefined" or "null",=0A=
  // the empty option is selected.=0A=
  // If the model is set to a different unmatched value, the unknown =
option is rendered and=0A=
  // selected, i.e both are present, because a "null" selection and an =
unknown value are different.=0A=
  self.hasEmptyOption =3D false;=0A=
  self.emptyOption =3D undefined;=0A=
=0A=
  self.renderUnknownOption =3D function(val) {=0A=
    var unknownVal =3D self.generateUnknownOptionValue(val);=0A=
    self.unknownOption.val(unknownVal);=0A=
    $element.prepend(self.unknownOption);=0A=
    setOptionSelectedStatus(self.unknownOption, true);=0A=
    $element.val(unknownVal);=0A=
  };=0A=
=0A=
  self.updateUnknownOption =3D function(val) {=0A=
    var unknownVal =3D self.generateUnknownOptionValue(val);=0A=
    self.unknownOption.val(unknownVal);=0A=
    setOptionSelectedStatus(self.unknownOption, true);=0A=
    $element.val(unknownVal);=0A=
  };=0A=
=0A=
  self.generateUnknownOptionValue =3D function(val) {=0A=
    return '? ' + hashKey(val) + ' ?';=0A=
  };=0A=
=0A=
  self.removeUnknownOption =3D function() {=0A=
    if (self.unknownOption.parent()) self.unknownOption.remove();=0A=
  };=0A=
=0A=
  self.selectEmptyOption =3D function() {=0A=
    if (self.emptyOption) {=0A=
      $element.val('');=0A=
      setOptionSelectedStatus(self.emptyOption, true);=0A=
    }=0A=
  };=0A=
=0A=
  self.unselectEmptyOption =3D function() {=0A=
    if (self.hasEmptyOption) {=0A=
      setOptionSelectedStatus(self.emptyOption, false);=0A=
    }=0A=
  };=0A=
=0A=
  $scope.$on('$destroy', function() {=0A=
    // disable unknown option so that we don't do work when the whole =
select is being destroyed=0A=
    self.renderUnknownOption =3D noop;=0A=
  });=0A=
=0A=
  // Read the value of the select control, the implementation of this =
changes depending=0A=
  // upon whether the select can have multiple values and whether =
ngOptions is at work.=0A=
  self.readValue =3D function readSingleValue() {=0A=
    var val =3D $element.val();=0A=
    // ngValue added option values are stored in the selectValueMap, =
normal interpolations are not=0A=
    var realVal =3D val in self.selectValueMap ? =
self.selectValueMap[val] : val;=0A=
=0A=
    if (self.hasOption(realVal)) {=0A=
      return realVal;=0A=
    }=0A=
=0A=
    return null;=0A=
  };=0A=
=0A=
=0A=
  // Write the value to the select control, the implementation of this =
changes depending=0A=
  // upon whether the select can have multiple values and whether =
ngOptions is at work.=0A=
  self.writeValue =3D function writeSingleValue(value) {=0A=
    // Make sure to remove the selected attribute from the previously =
selected option=0A=
    // Otherwise, screen readers might get confused=0A=
    var currentlySelectedOption =3D =
$element[0].options[$element[0].selectedIndex];=0A=
    if (currentlySelectedOption) =
setOptionSelectedStatus(jqLite(currentlySelectedOption), false);=0A=
=0A=
    if (self.hasOption(value)) {=0A=
      self.removeUnknownOption();=0A=
=0A=
      var hashedVal =3D hashKey(value);=0A=
      $element.val(hashedVal in self.selectValueMap ? hashedVal : value);=0A=
=0A=
      // Set selected attribute and property on selected option for =
screen readers=0A=
      var selectedOption =3D =
$element[0].options[$element[0].selectedIndex];=0A=
      setOptionSelectedStatus(jqLite(selectedOption), true);=0A=
    } else {=0A=
      self.selectUnknownOrEmptyOption(value);=0A=
    }=0A=
  };=0A=
=0A=
=0A=
  // Tell the select control that an option, with the given value, has =
been added=0A=
  self.addOption =3D function(value, element) {=0A=
    // Skip comment nodes, as they only pollute the `optionsMap`=0A=
    if (element[0].nodeType =3D=3D=3D NODE_TYPE_COMMENT) return;=0A=
=0A=
    assertNotHasOwnProperty(value, '"option value"');=0A=
    if (value =3D=3D=3D '') {=0A=
      self.hasEmptyOption =3D true;=0A=
      self.emptyOption =3D element;=0A=
    }=0A=
    var count =3D optionsMap.get(value) || 0;=0A=
    optionsMap.set(value, count + 1);=0A=
    // Only render at the end of a digest. This improves render =
performance when many options=0A=
    // are added during a digest and ensures all relevant options are =
correctly marked as selected=0A=
    scheduleRender();=0A=
  };=0A=
=0A=
  // Tell the select control that an option, with the given value, has =
been removed=0A=
  self.removeOption =3D function(value) {=0A=
    var count =3D optionsMap.get(value);=0A=
    if (count) {=0A=
      if (count =3D=3D=3D 1) {=0A=
        optionsMap.delete(value);=0A=
        if (value =3D=3D=3D '') {=0A=
          self.hasEmptyOption =3D false;=0A=
          self.emptyOption =3D undefined;=0A=
        }=0A=
      } else {=0A=
        optionsMap.set(value, count - 1);=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  // Check whether the select control has an option matching the given =
value=0A=
  self.hasOption =3D function(value) {=0A=
    return !!optionsMap.get(value);=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name select.SelectController#$hasEmptyOption=0A=
   *=0A=
   * @description=0A=
   *=0A=
   * Returns `true` if the select element currently has an empty option=0A=
   * element, i.e. an option that signifies that the select is empty / =
the selection is null.=0A=
   *=0A=
   */=0A=
  self.$hasEmptyOption =3D function() {=0A=
    return self.hasEmptyOption;=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name select.SelectController#$isUnknownOptionSelected=0A=
   *=0A=
   * @description=0A=
   *=0A=
   * Returns `true` if the select element's unknown option is selected. =
The unknown option is added=0A=
   * and automatically selected whenever the select model doesn't match =
any option.=0A=
   *=0A=
   */=0A=
  self.$isUnknownOptionSelected =3D function() {=0A=
    // Presence of the unknown option means it is selected=0A=
    return $element[0].options[0] =3D=3D=3D self.unknownOption[0];=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name select.SelectController#$isEmptyOptionSelected=0A=
   *=0A=
   * @description=0A=
   *=0A=
   * Returns `true` if the select element has an empty option and this =
empty option is currently=0A=
   * selected. Returns `false` if the select element has no empty option =
or it is not selected.=0A=
   *=0A=
   */=0A=
  self.$isEmptyOptionSelected =3D function() {=0A=
    return self.hasEmptyOption &amp;&amp; =
$element[0].options[$element[0].selectedIndex] =3D=3D=3D =
self.emptyOption[0];=0A=
  };=0A=
=0A=
  self.selectUnknownOrEmptyOption =3D function(value) {=0A=
    if (value =3D=3D null &amp;&amp; self.emptyOption) {=0A=
      self.removeUnknownOption();=0A=
      self.selectEmptyOption();=0A=
    } else if (self.unknownOption.parent().length) {=0A=
      self.updateUnknownOption(value);=0A=
    } else {=0A=
      self.renderUnknownOption(value);=0A=
    }=0A=
  };=0A=
=0A=
  var renderScheduled =3D false;=0A=
  function scheduleRender() {=0A=
    if (renderScheduled) return;=0A=
    renderScheduled =3D true;=0A=
    $scope.$$postDigest(function() {=0A=
      renderScheduled =3D false;=0A=
      self.ngModelCtrl.$render();=0A=
    });=0A=
  }=0A=
=0A=
  var updateScheduled =3D false;=0A=
  function scheduleViewValueUpdate(renderAfter) {=0A=
    if (updateScheduled) return;=0A=
=0A=
    updateScheduled =3D true;=0A=
=0A=
    $scope.$$postDigest(function() {=0A=
      if ($scope.$$destroyed) return;=0A=
=0A=
      updateScheduled =3D false;=0A=
      self.ngModelCtrl.$setViewValue(self.readValue());=0A=
      if (renderAfter) self.ngModelCtrl.$render();=0A=
    });=0A=
  }=0A=
=0A=
=0A=
  self.registerOption =3D function(optionScope, optionElement, =
optionAttrs, interpolateValueFn, interpolateTextFn) {=0A=
=0A=
    if (optionAttrs.$attr.ngValue) {=0A=
      // The value attribute is set by ngValue=0A=
      var oldVal, hashedVal =3D NaN;=0A=
      optionAttrs.$observe('value', function =
valueAttributeObserveAction(newVal) {=0A=
=0A=
        var removal;=0A=
        var previouslySelected =3D optionElement.prop('selected');=0A=
=0A=
        if (isDefined(hashedVal)) {=0A=
          self.removeOption(oldVal);=0A=
          delete self.selectValueMap[hashedVal];=0A=
          removal =3D true;=0A=
        }=0A=
=0A=
        hashedVal =3D hashKey(newVal);=0A=
        oldVal =3D newVal;=0A=
        self.selectValueMap[hashedVal] =3D newVal;=0A=
        self.addOption(newVal, optionElement);=0A=
        // Set the attribute directly instead of using optionAttrs.$set =
- this stops the observer=0A=
        // from firing a second time. Other $observers on value will =
also get the result of the=0A=
        // ngValue expression, not the hashed value=0A=
        optionElement.attr('value', hashedVal);=0A=
=0A=
        if (removal &amp;&amp; previouslySelected) {=0A=
          scheduleViewValueUpdate();=0A=
        }=0A=
=0A=
      });=0A=
    } else if (interpolateValueFn) {=0A=
      // The value attribute is interpolated=0A=
      optionAttrs.$observe('value', function =
valueAttributeObserveAction(newVal) {=0A=
        // This method is overwritten in ngOptions and has side-effects!=0A=
        self.readValue();=0A=
=0A=
        var removal;=0A=
        var previouslySelected =3D optionElement.prop('selected');=0A=
=0A=
        if (isDefined(oldVal)) {=0A=
          self.removeOption(oldVal);=0A=
          removal =3D true;=0A=
        }=0A=
        oldVal =3D newVal;=0A=
        self.addOption(newVal, optionElement);=0A=
=0A=
        if (removal &amp;&amp; previouslySelected) {=0A=
          scheduleViewValueUpdate();=0A=
        }=0A=
      });=0A=
    } else if (interpolateTextFn) {=0A=
      // The text content is interpolated=0A=
      optionScope.$watch(interpolateTextFn, function =
interpolateWatchAction(newVal, oldVal) {=0A=
        optionAttrs.$set('value', newVal);=0A=
        var previouslySelected =3D optionElement.prop('selected');=0A=
        if (oldVal !=3D=3D newVal) {=0A=
          self.removeOption(oldVal);=0A=
        }=0A=
        self.addOption(newVal, optionElement);=0A=
=0A=
        if (oldVal &amp;&amp; previouslySelected) {=0A=
          scheduleViewValueUpdate();=0A=
        }=0A=
      });=0A=
    } else {=0A=
      // The value attribute is static=0A=
      self.addOption(optionAttrs.value, optionElement);=0A=
    }=0A=
=0A=
=0A=
    optionAttrs.$observe('disabled', function(newVal) {=0A=
=0A=
      // Since model updates will also select disabled options (like =
ngOptions),=0A=
      // we only have to handle options becoming disabled, not enabled=0A=
=0A=
      if (newVal =3D=3D=3D 'true' || newVal &amp;&amp; =
optionElement.prop('selected')) {=0A=
        if (self.multiple) {=0A=
          scheduleViewValueUpdate(true);=0A=
        } else {=0A=
          self.ngModelCtrl.$setViewValue(null);=0A=
          self.ngModelCtrl.$render();=0A=
        }=0A=
      }=0A=
    });=0A=
=0A=
    optionElement.on('$destroy', function() {=0A=
      var currentValue =3D self.readValue();=0A=
      var removeValue =3D optionAttrs.value;=0A=
=0A=
      self.removeOption(removeValue);=0A=
      scheduleRender();=0A=
=0A=
      if (self.multiple &amp;&amp; currentValue &amp;&amp; =
currentValue.indexOf(removeValue) !=3D=3D -1 ||=0A=
          currentValue =3D=3D=3D removeValue=0A=
      ) {=0A=
        // When multiple (selected) options are destroyed at the same =
time, we don't want=0A=
        // to run a model update for each of them. Instead, run a single =
update in the $$postDigest=0A=
        scheduleViewValueUpdate(true);=0A=
      }=0A=
    });=0A=
  };=0A=
}];=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name select=0A=
 * @restrict E=0A=
 *=0A=
 * @description=0A=
 * HTML `select` element with angular data-binding.=0A=
 *=0A=
 * The `select` directive is used together with {@link ngModel =
`ngModel`} to provide data-binding=0A=
 * between the scope and the `&lt;select&gt;` control (including setting =
default values).=0A=
 * It also handles dynamic `&lt;option&gt;` elements, which can be added =
using the {@link ngRepeat `ngRepeat}` or=0A=
 * {@link ngOptions `ngOptions`} directives.=0A=
 *=0A=
 * When an item in the `&lt;select&gt;` menu is selected, the value of =
the selected option will be bound=0A=
 * to the model identified by the `ngModel` directive. With static or =
repeated options, this is=0A=
 * the content of the `value` attribute or the textContent of the =
`&lt;option&gt;`, if the value attribute is missing.=0A=
 * Value and textContent can be interpolated.=0A=
 *=0A=
 * The {@link select.SelectController select controller} exposes utility =
functions that can be used=0A=
 * to manipulate the select's behavior.=0A=
 *=0A=
 * ## Matching model and option values=0A=
 *=0A=
 * In general, the match between the model and an option is evaluated by =
strictly comparing the model=0A=
 * value against the value of the available options.=0A=
 *=0A=
 * If you are setting the option value with the option's `value` =
attribute, or textContent, the=0A=
 * value will always be a `string` which means that the model value must =
also be a string.=0A=
 * Otherwise the `select` directive cannot match them correctly.=0A=
 *=0A=
 * To bind the model to a non-string value, you can use one of the =
following strategies:=0A=
 * - the {@link ng.ngOptions `ngOptions`} directive=0A=
 *   ({@link =
ng.select#using-select-with-ngoptions-and-setting-a-default-value})=0A=
 * - the {@link ng.ngValue `ngValue`} directive, which allows arbitrary =
expressions to be=0A=
 *   option values ({@link =
ng.select#using-ngvalue-to-bind-the-model-to-an-array-of-objects =
Example})=0A=
 * - model $parsers / $formatters to convert the string value=0A=
 *   ({@link =
ng.select#binding-select-to-a-non-string-value-via-ngmodel-parsing-format=
ting Example})=0A=
 *=0A=
 * If the viewValue of `ngModel` does not match any of the options, then =
the control=0A=
 * will automatically add an "unknown" option, which it then removes =
when the mismatch is resolved.=0A=
 *=0A=
 * Optionally, a single hard-coded `&lt;option&gt;` element, with the =
value set to an empty string, can=0A=
 * be nested into the `&lt;select&gt;` element. This element will then =
represent the `null` or "not selected"=0A=
 * option. See example below for demonstration.=0A=
 *=0A=
 * ## Choosing between `ngRepeat` and `ngOptions`=0A=
 *=0A=
 * In many cases, `ngRepeat` can be used on `&lt;option&gt;` elements =
instead of {@link ng.directive:ngOptions=0A=
 * ngOptions} to achieve a similar result. However, `ngOptions` provides =
some benefits:=0A=
 * - more flexibility in how the `&lt;select&gt;`'s model is assigned =
via the `select` **`as`** part of the=0A=
 * comprehension expression=0A=
 * - reduced memory consumption by not creating a new scope for each =
repeated instance=0A=
 * - increased render speed by creating the options in a =
documentFragment instead of individually=0A=
 *=0A=
 * Specifically, select with repeated options slows down significantly =
starting at 2000 options in=0A=
 * Chrome and Internet Explorer / Edge.=0A=
 *=0A=
 *=0A=
 * @param {string} ngModel Assignable angular expression to data-bind to.=0A=
 * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
 * @param {string=3D} multiple Allows multiple options to be selected. =
The selected values will be=0A=
 *     bound to the model as an array.=0A=
 * @param {string=3D} required Sets `required` validation error key if =
the value is not entered.=0A=
 * @param {string=3D} ngRequired Adds required attribute and required =
validation constraint to=0A=
 * the element when the ngRequired expression evaluates to true. Use =
ngRequired instead of required=0A=
 * when you want to data-bind to the required attribute.=0A=
 * @param {string=3D} ngChange Angular expression to be executed when =
selected option(s) changes due to user=0A=
 *    interaction with the select element.=0A=
 * @param {string=3D} ngOptions sets the options that the select is =
populated with and defines what is=0A=
 * set on the model on selection. See {@link ngOptions `ngOptions`}.=0A=
 * @param {string=3D} ngAttrSize sets the size of the select element =
dynamically. Uses the=0A=
 * {@link =
guide/interpolation#-ngattr-for-binding-to-arbitrary-attributes ngAttr} =
directive.=0A=
 *=0A=
 *=0A=
 * @knownIssue=0A=
 *=0A=
 * In Firefox, the select model is only updated when the select element =
is blurred. For example,=0A=
 * when switching between options with the keyboard, the select model is =
only set to the=0A=
 * currently selected option when the select is blurred, e.g via tab key =
or clicking the mouse=0A=
 * outside the select.=0A=
 *=0A=
 * This is due to an ambiguity in the select element specification. See =
the=0A=
 * [issue on the Firefox bug =
tracker](https://bugzilla.mozilla.org/show_bug.cgi?id=3D126379)=0A=
 * for more information, and this=0A=
 * [Github comment for a =
workaround](https://github.com/angular/angular.js/issues/9134#issuecommen=
t-130800488)=0A=
 *=0A=
 * @example=0A=
 * ### Simple `select` elements with static options=0A=
 *=0A=
 * &lt;example name=3D"static-select" module=3D"staticSelect"&gt;=0A=
 * &lt;file name=3D"index.html"&gt;=0A=
 * &lt;div ng-controller=3D"ExampleController"&gt;=0A=
 *   &lt;form name=3D"myForm"&gt;=0A=
 *     &lt;label for=3D"singleSelect"&gt; Single select: =
&lt;/label&gt;&lt;br&gt;=0A=
 *     &lt;select name=3D"singleSelect" =
ng-model=3D"data.singleSelect"&gt;=0A=
 *       &lt;option value=3D"option-1"&gt;Option 1&lt;/option&gt;=0A=
 *       &lt;option value=3D"option-2"&gt;Option 2&lt;/option&gt;=0A=
 *     &lt;/select&gt;&lt;br&gt;=0A=
 *=0A=
 *     &lt;label for=3D"singleSelect"&gt; Single select with "not =
selected" option and dynamic option values: &lt;/label&gt;&lt;br&gt;=0A=
 *     &lt;select name=3D"singleSelect" id=3D"singleSelect" =
ng-model=3D"data.singleSelect"&gt;=0A=
 *       &lt;option value=3D""&gt;---Please select---&lt;/option&gt; =
&lt;!-- not selected / blank option --&gt;=0A=
 *       &lt;option value=3D"{{data.option1}}"&gt;Option =
1&lt;/option&gt; &lt;!-- interpolation --&gt;=0A=
 *       &lt;option value=3D"option-2"&gt;Option 2&lt;/option&gt;=0A=
 *     &lt;/select&gt;&lt;br&gt;=0A=
 *     &lt;button ng-click=3D"forceUnknownOption()"&gt;Force unknown =
option&lt;/button&gt;&lt;br&gt;=0A=
 *     &lt;tt&gt;singleSelect =3D {{data.singleSelect}}&lt;/tt&gt;=0A=
 *=0A=
 *     &lt;hr&gt;=0A=
 *     &lt;label for=3D"multipleSelect"&gt; Multiple select: =
&lt;/label&gt;&lt;br&gt;=0A=
 *     &lt;select name=3D"multipleSelect" id=3D"multipleSelect" =
ng-model=3D"data.multipleSelect" multiple&gt;=0A=
 *       &lt;option value=3D"option-1"&gt;Option 1&lt;/option&gt;=0A=
 *       &lt;option value=3D"option-2"&gt;Option 2&lt;/option&gt;=0A=
 *       &lt;option value=3D"option-3"&gt;Option 3&lt;/option&gt;=0A=
 *     &lt;/select&gt;&lt;br&gt;=0A=
 *     &lt;tt&gt;multipleSelect =3D =
{{data.multipleSelect}}&lt;/tt&gt;&lt;br/&gt;=0A=
 *   &lt;/form&gt;=0A=
 * &lt;/div&gt;=0A=
 * &lt;/file&gt;=0A=
 * &lt;file name=3D"app.js"&gt;=0A=
 *  angular.module('staticSelect', [])=0A=
 *    .controller('ExampleController', ['$scope', function($scope) {=0A=
 *      $scope.data =3D {=0A=
 *       singleSelect: null,=0A=
 *       multipleSelect: [],=0A=
 *       option1: 'option-1'=0A=
 *      };=0A=
 *=0A=
 *      $scope.forceUnknownOption =3D function() {=0A=
 *        $scope.data.singleSelect =3D 'nonsense';=0A=
 *      };=0A=
 *   }]);=0A=
 * &lt;/file&gt;=0A=
 *&lt;/example&gt;=0A=
 *=0A=
 * ### Using `ngRepeat` to generate `select` options=0A=
 * &lt;example name=3D"select-ngrepeat" module=3D"ngrepeatSelect"&gt;=0A=
 * &lt;file name=3D"index.html"&gt;=0A=
 * &lt;div ng-controller=3D"ExampleController"&gt;=0A=
 *   &lt;form name=3D"myForm"&gt;=0A=
 *     &lt;label for=3D"repeatSelect"&gt; Repeat select: &lt;/label&gt;=0A=
 *     &lt;select name=3D"repeatSelect" id=3D"repeatSelect" =
ng-model=3D"data.model"&gt;=0A=
 *       &lt;option ng-repeat=3D"option in data.availableOptions" =
value=3D"{{option.id}}"&gt;{{option.name}}&lt;/option&gt;=0A=
 *     &lt;/select&gt;=0A=
 *   &lt;/form&gt;=0A=
 *   &lt;hr&gt;=0A=
 *   &lt;tt&gt;model =3D {{data.model}}&lt;/tt&gt;&lt;br/&gt;=0A=
 * &lt;/div&gt;=0A=
 * &lt;/file&gt;=0A=
 * &lt;file name=3D"app.js"&gt;=0A=
 *  angular.module('ngrepeatSelect', [])=0A=
 *    .controller('ExampleController', ['$scope', function($scope) {=0A=
 *      $scope.data =3D {=0A=
 *       model: null,=0A=
 *       availableOptions: [=0A=
 *         {id: '1', name: 'Option A'},=0A=
 *         {id: '2', name: 'Option B'},=0A=
 *         {id: '3', name: 'Option C'}=0A=
 *       ]=0A=
 *      };=0A=
 *   }]);=0A=
 * &lt;/file&gt;=0A=
 *&lt;/example&gt;=0A=
 *=0A=
 * ### Using `ngValue` to bind the model to an array of objects=0A=
 * &lt;example name=3D"select-ngvalue" module=3D"ngvalueSelect"&gt;=0A=
 * &lt;file name=3D"index.html"&gt;=0A=
 * &lt;div ng-controller=3D"ExampleController"&gt;=0A=
 *   &lt;form name=3D"myForm"&gt;=0A=
 *     &lt;label for=3D"ngvalueselect"&gt; ngvalue select: &lt;/label&gt;=0A=
 *     &lt;select size=3D"6" name=3D"ngvalueselect" =
ng-model=3D"data.model" multiple&gt;=0A=
 *       &lt;option ng-repeat=3D"option in data.availableOptions" =
ng-value=3D"option.value"&gt;{{option.name}}&lt;/option&gt;=0A=
 *     &lt;/select&gt;=0A=
 *   &lt;/form&gt;=0A=
 *   &lt;hr&gt;=0A=
 *   &lt;pre&gt;model =3D {{data.model | json}}&lt;/pre&gt;&lt;br/&gt;=0A=
 * &lt;/div&gt;=0A=
 * &lt;/file&gt;=0A=
 * &lt;file name=3D"app.js"&gt;=0A=
 *  angular.module('ngvalueSelect', [])=0A=
 *    .controller('ExampleController', ['$scope', function($scope) {=0A=
 *      $scope.data =3D {=0A=
 *       model: null,=0A=
 *       availableOptions: [=0A=
           {value: 'myString', name: 'string'},=0A=
           {value: 1, name: 'integer'},=0A=
           {value: true, name: 'boolean'},=0A=
           {value: null, name: 'null'},=0A=
           {value: {prop: 'value'}, name: 'object'},=0A=
           {value: ['a'], name: 'array'}=0A=
 *       ]=0A=
 *      };=0A=
 *   }]);=0A=
 * &lt;/file&gt;=0A=
 *&lt;/example&gt;=0A=
 *=0A=
 * ### Using `select` with `ngOptions` and setting a default value=0A=
 * See the {@link ngOptions ngOptions documentation} for more =
`ngOptions` usage examples.=0A=
 *=0A=
 * &lt;example name=3D"select-with-default-values" =
module=3D"defaultValueSelect"&gt;=0A=
 * &lt;file name=3D"index.html"&gt;=0A=
 * &lt;div ng-controller=3D"ExampleController"&gt;=0A=
 *   &lt;form name=3D"myForm"&gt;=0A=
 *     &lt;label for=3D"mySelect"&gt;Make a choice:&lt;/label&gt;=0A=
 *     &lt;select name=3D"mySelect" id=3D"mySelect"=0A=
 *       ng-options=3D"option.name for option in data.availableOptions =
track by option.id"=0A=
 *       ng-model=3D"data.selectedOption"&gt;&lt;/select&gt;=0A=
 *   &lt;/form&gt;=0A=
 *   &lt;hr&gt;=0A=
 *   &lt;tt&gt;option =3D {{data.selectedOption}}&lt;/tt&gt;&lt;br/&gt;=0A=
 * &lt;/div&gt;=0A=
 * &lt;/file&gt;=0A=
 * &lt;file name=3D"app.js"&gt;=0A=
 *  angular.module('defaultValueSelect', [])=0A=
 *    .controller('ExampleController', ['$scope', function($scope) {=0A=
 *      $scope.data =3D {=0A=
 *       availableOptions: [=0A=
 *         {id: '1', name: 'Option A'},=0A=
 *         {id: '2', name: 'Option B'},=0A=
 *         {id: '3', name: 'Option C'}=0A=
 *       ],=0A=
 *       selectedOption: {id: '3', name: 'Option C'} //This sets the =
default value of the select in the ui=0A=
 *       };=0A=
 *   }]);=0A=
 * &lt;/file&gt;=0A=
 *&lt;/example&gt;=0A=
 *=0A=
 *=0A=
 * ### Binding `select` to a non-string value via `ngModel` parsing / =
formatting=0A=
 *=0A=
 * &lt;example name=3D"select-with-non-string-options" =
module=3D"nonStringSelect"&gt;=0A=
 *   &lt;file name=3D"index.html"&gt;=0A=
 *     &lt;select ng-model=3D"model.id" convert-to-number&gt;=0A=
 *       &lt;option value=3D"0"&gt;Zero&lt;/option&gt;=0A=
 *       &lt;option value=3D"1"&gt;One&lt;/option&gt;=0A=
 *       &lt;option value=3D"2"&gt;Two&lt;/option&gt;=0A=
 *     &lt;/select&gt;=0A=
 *     {{ model }}=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"app.js"&gt;=0A=
 *     angular.module('nonStringSelect', [])=0A=
 *       .run(function($rootScope) {=0A=
 *         $rootScope.model =3D { id: 2 };=0A=
 *       })=0A=
 *       .directive('convertToNumber', function() {=0A=
 *         return {=0A=
 *           require: 'ngModel',=0A=
 *           link: function(scope, element, attrs, ngModel) {=0A=
 *             ngModel.$parsers.push(function(val) {=0A=
 *               return parseInt(val, 10);=0A=
 *             });=0A=
 *             ngModel.$formatters.push(function(val) {=0A=
 *               return '' + val;=0A=
 *             });=0A=
 *           }=0A=
 *         };=0A=
 *       });=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
 *     it('should initialize to model', function() {=0A=
 *       =
expect(element(by.model('model.id')).$('option:checked').getText()).toEqu=
al('Two');=0A=
 *     });=0A=
 *   &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 *=0A=
 */=0A=
var selectDirective =3D function() {=0A=
=0A=
  return {=0A=
    restrict: 'E',=0A=
    require: ['select', '?ngModel'],=0A=
    controller: SelectController,=0A=
    priority: 1,=0A=
    link: {=0A=
      pre: selectPreLink,=0A=
      post: selectPostLink=0A=
    }=0A=
  };=0A=
=0A=
  function selectPreLink(scope, element, attr, ctrls) {=0A=
=0A=
      var selectCtrl =3D ctrls[0];=0A=
      var ngModelCtrl =3D ctrls[1];=0A=
=0A=
      // if ngModel is not defined, we don't need to do anything but set =
the registerOption=0A=
      // function to noop, so options don't get added internally=0A=
      if (!ngModelCtrl) {=0A=
        selectCtrl.registerOption =3D noop;=0A=
        return;=0A=
      }=0A=
=0A=
=0A=
      selectCtrl.ngModelCtrl =3D ngModelCtrl;=0A=
=0A=
      // When the selected item(s) changes we delegate getting the value =
of the select control=0A=
      // to the `readValue` method, which can be changed if the select =
can have multiple=0A=
      // selected values or if the options are being generated by =
`ngOptions`=0A=
      element.on('change', function() {=0A=
        selectCtrl.removeUnknownOption();=0A=
        scope.$apply(function() {=0A=
          ngModelCtrl.$setViewValue(selectCtrl.readValue());=0A=
        });=0A=
      });=0A=
=0A=
      // If the select allows multiple values then we need to modify how =
we read and write=0A=
      // values from and to the control; also what it means for the =
value to be empty and=0A=
      // we have to add an extra watch since ngModel doesn't work well =
with arrays - it=0A=
      // doesn't trigger rendering if only an item in the array changes.=0A=
      if (attr.multiple) {=0A=
        selectCtrl.multiple =3D true;=0A=
=0A=
        // Read value now needs to check each option to see if it is =
selected=0A=
        selectCtrl.readValue =3D function readMultipleValue() {=0A=
          var array =3D [];=0A=
          forEach(element.find('option'), function(option) {=0A=
            if (option.selected &amp;&amp; !option.disabled) {=0A=
              var val =3D option.value;=0A=
              array.push(val in selectCtrl.selectValueMap ? =
selectCtrl.selectValueMap[val] : val);=0A=
            }=0A=
          });=0A=
          return array;=0A=
        };=0A=
=0A=
        // Write value now needs to set the selected property of each =
matching option=0A=
        selectCtrl.writeValue =3D function writeMultipleValue(value) {=0A=
          forEach(element.find('option'), function(option) {=0A=
            var shouldBeSelected =3D !!value &amp;&amp; (includes(value, =
option.value) ||=0A=
                                               includes(value, =
selectCtrl.selectValueMap[option.value]));=0A=
            var currentlySelected =3D option.selected;=0A=
=0A=
            // Support: IE 9-11 only, Edge 12-15+=0A=
            // In IE and Edge adding options to the selection via =
shift+click/UP/DOWN=0A=
            // will de-select already selected options if "selected" on =
those options was set=0A=
            // more than once (i.e. when the options were already =
selected)=0A=
            // So we only modify the selected property if necessary.=0A=
            // Note: this behavior cannot be replicated via unit tests =
because it only shows in the=0A=
            // actual user interface.=0A=
            if (shouldBeSelected !=3D=3D currentlySelected) {=0A=
              setOptionSelectedStatus(jqLite(option), shouldBeSelected);=0A=
            }=0A=
=0A=
          });=0A=
        };=0A=
=0A=
        // we have to do it on each watch since ngModel watches =
reference, but=0A=
        // we need to work of an array, so we need to see if anything =
was inserted/removed=0A=
        var lastView, lastViewRef =3D NaN;=0A=
        scope.$watch(function selectMultipleWatch() {=0A=
          if (lastViewRef =3D=3D=3D ngModelCtrl.$viewValue &amp;&amp; =
!equals(lastView, ngModelCtrl.$viewValue)) {=0A=
            lastView =3D shallowCopy(ngModelCtrl.$viewValue);=0A=
            ngModelCtrl.$render();=0A=
          }=0A=
          lastViewRef =3D ngModelCtrl.$viewValue;=0A=
        });=0A=
=0A=
        // If we are a multiple select then value is now a collection=0A=
        // so the meaning of $isEmpty changes=0A=
        ngModelCtrl.$isEmpty =3D function(value) {=0A=
          return !value || value.length =3D=3D=3D 0;=0A=
        };=0A=
=0A=
      }=0A=
    }=0A=
=0A=
    function selectPostLink(scope, element, attrs, ctrls) {=0A=
      // if ngModel is not defined, we don't need to do anything=0A=
      var ngModelCtrl =3D ctrls[1];=0A=
      if (!ngModelCtrl) return;=0A=
=0A=
      var selectCtrl =3D ctrls[0];=0A=
=0A=
      // We delegate rendering to the `writeValue` method, which can be =
changed=0A=
      // if the select can have multiple selected values or if the =
options are being=0A=
      // generated by `ngOptions`.=0A=
      // This must be done in the postLink fn to prevent $render to be =
called before=0A=
      // all nodes have been linked correctly.=0A=
      ngModelCtrl.$render =3D function() {=0A=
        selectCtrl.writeValue(ngModelCtrl.$viewValue);=0A=
      };=0A=
    }=0A=
};=0A=
=0A=
=0A=
// The option directive is purely designed to communicate the existence =
(or lack of)=0A=
// of dynamically created (and destroyed) option elements to their =
containing select=0A=
// directive via its controller.=0A=
var optionDirective =3D ['$interpolate', function($interpolate) {=0A=
  return {=0A=
    restrict: 'E',=0A=
    priority: 100,=0A=
    compile: function(element, attr) {=0A=
      var interpolateValueFn, interpolateTextFn;=0A=
=0A=
      if (isDefined(attr.ngValue)) {=0A=
        // Will be handled by registerOption=0A=
      } else if (isDefined(attr.value)) {=0A=
        // If the value attribute is defined, check if it contains an =
interpolation=0A=
        interpolateValueFn =3D $interpolate(attr.value, true);=0A=
      } else {=0A=
        // If the value attribute is not defined then we fall back to the=0A=
        // text content of the option element, which may be interpolated=0A=
        interpolateTextFn =3D $interpolate(element.text(), true);=0A=
        if (!interpolateTextFn) {=0A=
          attr.$set('value', element.text());=0A=
        }=0A=
      }=0A=
=0A=
      return function(scope, element, attr) {=0A=
        // This is an optimization over using ^^ since we don't want to =
have to search=0A=
        // all the way to the root of the DOM for every single option =
element=0A=
        var selectCtrlName =3D '$selectController',=0A=
            parent =3D element.parent(),=0A=
            selectCtrl =3D parent.data(selectCtrlName) ||=0A=
              parent.parent().data(selectCtrlName); // in case we are in =
optgroup=0A=
=0A=
        if (selectCtrl) {=0A=
          selectCtrl.registerOption(scope, element, attr, =
interpolateValueFn, interpolateTextFn);=0A=
        }=0A=
      };=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngRequired=0A=
 * @restrict A=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * ngRequired adds the required {@link =
ngModel.NgModelController#$validators `validator`} to {@link ngModel =
`ngModel`}.=0A=
 * It is most often used for {@link input `input`} and {@link select =
`select`} controls, but can also be=0A=
 * applied to custom controls.=0A=
 *=0A=
 * The directive sets the `required` attribute on the element if the =
Angular expression inside=0A=
 * `ngRequired` evaluates to true. A special directive for setting =
`required` is necessary because we=0A=
 * cannot use interpolation inside `required`. See the {@link =
guide/interpolation interpolation guide}=0A=
 * for more info.=0A=
 *=0A=
 * The validator will set the `required` error key to true if the =
`required` attribute is set and=0A=
 * calling {@link ngModel.NgModelController#$isEmpty =
`NgModelController.$isEmpty`} with the=0A=
 * {@link ngModel.NgModelController#$viewValue `ngModel.$viewValue`} =
returns `true`. For example, the=0A=
 * `$isEmpty()` implementation for `input[text]` checks the length of =
the `$viewValue`. When developing=0A=
 * custom controls, `$isEmpty()` can be overwritten to account for a =
$viewValue that is not string-based.=0A=
 *=0A=
 * @example=0A=
 * &lt;example name=3D"ngRequiredDirective" =
module=3D"ngRequiredExample"&gt;=0A=
 *   &lt;file name=3D"index.html"&gt;=0A=
 *     &lt;script&gt;=0A=
 *       angular.module('ngRequiredExample', [])=0A=
 *         .controller('ExampleController', ['$scope', function($scope) {=0A=
 *           $scope.required =3D true;=0A=
 *         }]);=0A=
 *     &lt;/script&gt;=0A=
 *     &lt;div ng-controller=3D"ExampleController"&gt;=0A=
 *       &lt;form name=3D"form"&gt;=0A=
 *         &lt;label for=3D"required"&gt;Toggle required: &lt;/label&gt;=0A=
 *         &lt;input type=3D"checkbox" ng-model=3D"required" =
id=3D"required" /&gt;=0A=
 *         &lt;br&gt;=0A=
 *         &lt;label for=3D"input"&gt;This input must be filled if =
`required` is true: &lt;/label&gt;=0A=
 *         &lt;input type=3D"text" ng-model=3D"model" id=3D"input" =
name=3D"input" ng-required=3D"required" /&gt;&lt;br&gt;=0A=
 *         &lt;hr&gt;=0A=
 *         required error set? =3D =
&lt;code&gt;{{form.input.$error.required}}&lt;/code&gt;&lt;br&gt;=0A=
 *         model =3D &lt;code&gt;{{model}}&lt;/code&gt;=0A=
 *       &lt;/form&gt;=0A=
 *     &lt;/div&gt;=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       var required =3D =
element(by.binding('form.input.$error.required'));=0A=
       var model =3D element(by.binding('model'));=0A=
       var input =3D element(by.id('input'));=0A=
=0A=
       it('should set the required error', function() {=0A=
         expect(required.getText()).toContain('true');=0A=
=0A=
         input.sendKeys('123');=0A=
         expect(required.getText()).not.toContain('true');=0A=
         expect(model.getText()).toContain('123');=0A=
       });=0A=
 *   &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 */=0A=
var requiredDirective =3D function() {=0A=
  return {=0A=
    restrict: 'A',=0A=
    require: '?ngModel',=0A=
    link: function(scope, elm, attr, ctrl) {=0A=
      if (!ctrl) return;=0A=
      attr.required =3D true; // force truthy in case we are on non =
input element=0A=
=0A=
      ctrl.$validators.required =3D function(modelValue, viewValue) {=0A=
        return !attr.required || !ctrl.$isEmpty(viewValue);=0A=
      };=0A=
=0A=
      attr.$observe('required', function() {=0A=
        ctrl.$validate();=0A=
      });=0A=
    }=0A=
  };=0A=
};=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngPattern=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * ngPattern adds the pattern {@link =
ngModel.NgModelController#$validators `validator`} to {@link ngModel =
`ngModel`}.=0A=
 * It is most often used for text-based {@link input `input`} controls, =
but can also be applied to custom text-based controls.=0A=
 *=0A=
 * The validator sets the `pattern` error key if the {@link =
ngModel.NgModelController#$viewValue `ngModel.$viewValue`}=0A=
 * does not match a RegExp which is obtained by evaluating the Angular =
expression given in the=0A=
 * `ngPattern` attribute value:=0A=
 * * If the expression evaluates to a RegExp object, then this is used =
directly.=0A=
 * * If the expression evaluates to a string, then it will be converted =
to a RegExp after wrapping it=0A=
 * in `^` and `$` characters. For instance, `"abc"` will be converted to =
`new RegExp('^abc$')`.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-info"&gt;=0A=
 * **Note:** Avoid using the `g` flag on the RegExp, as it will cause =
each successive search to=0A=
 * start at the index of the last search's match, thus not taking the =
whole input value into=0A=
 * account.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * &lt;div class=3D"alert alert-info"&gt;=0A=
 * **Note:** This directive is also added when the plain `pattern` =
attribute is used, with two=0A=
 * differences:=0A=
 * &lt;ol&gt;=0A=
 *   &lt;li&gt;=0A=
 *     `ngPattern` does not set the `pattern` attribute and therefore =
HTML5 constraint validation is=0A=
 *     not available.=0A=
 *   &lt;/li&gt;=0A=
 *   &lt;li&gt;=0A=
 *     The `ngPattern` attribute must be an expression, while the =
`pattern` value must be=0A=
 *     interpolated.=0A=
 *   &lt;/li&gt;=0A=
 * &lt;/ol&gt;=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * @example=0A=
 * &lt;example name=3D"ngPatternDirective" =
module=3D"ngPatternExample"&gt;=0A=
 *   &lt;file name=3D"index.html"&gt;=0A=
 *     &lt;script&gt;=0A=
 *       angular.module('ngPatternExample', [])=0A=
 *         .controller('ExampleController', ['$scope', function($scope) {=0A=
 *           $scope.regex =3D '\\d+';=0A=
 *         }]);=0A=
 *     &lt;/script&gt;=0A=
 *     &lt;div ng-controller=3D"ExampleController"&gt;=0A=
 *       &lt;form name=3D"form"&gt;=0A=
 *         &lt;label for=3D"regex"&gt;Set a pattern (regex string): =
&lt;/label&gt;=0A=
 *         &lt;input type=3D"text" ng-model=3D"regex" id=3D"regex" /&gt;=0A=
 *         &lt;br&gt;=0A=
 *         &lt;label for=3D"input"&gt;This input is restricted by the =
current pattern: &lt;/label&gt;=0A=
 *         &lt;input type=3D"text" ng-model=3D"model" id=3D"input" =
name=3D"input" ng-pattern=3D"regex" /&gt;&lt;br&gt;=0A=
 *         &lt;hr&gt;=0A=
 *         input valid? =3D =
&lt;code&gt;{{form.input.$valid}}&lt;/code&gt;&lt;br&gt;=0A=
 *         model =3D &lt;code&gt;{{model}}&lt;/code&gt;=0A=
 *       &lt;/form&gt;=0A=
 *     &lt;/div&gt;=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       var model =3D element(by.binding('model'));=0A=
       var input =3D element(by.id('input'));=0A=
=0A=
       it('should validate the input with the default pattern', =
function() {=0A=
         input.sendKeys('aaa');=0A=
         expect(model.getText()).not.toContain('aaa');=0A=
=0A=
         input.clear().then(function() {=0A=
           input.sendKeys('123');=0A=
           expect(model.getText()).toContain('123');=0A=
         });=0A=
       });=0A=
 *   &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 */=0A=
var patternDirective =3D function() {=0A=
  return {=0A=
    restrict: 'A',=0A=
    require: '?ngModel',=0A=
    link: function(scope, elm, attr, ctrl) {=0A=
      if (!ctrl) return;=0A=
=0A=
      var regexp, patternExp =3D attr.ngPattern || attr.pattern;=0A=
      attr.$observe('pattern', function(regex) {=0A=
        if (isString(regex) &amp;&amp; regex.length &gt; 0) {=0A=
          regex =3D new RegExp('^' + regex + '$');=0A=
        }=0A=
=0A=
        if (regex &amp;&amp; !regex.test) {=0A=
          throw minErr('ngPattern')('noregexp',=0A=
            'Expected {0} to be a RegExp but was {1}. Element: {2}', =
patternExp,=0A=
            regex, startingTag(elm));=0A=
        }=0A=
=0A=
        regexp =3D regex || undefined;=0A=
        ctrl.$validate();=0A=
      });=0A=
=0A=
      ctrl.$validators.pattern =3D function(modelValue, viewValue) {=0A=
        // HTML5 pattern constraint validates the input value, so we =
validate the viewValue=0A=
        return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || =
regexp.test(viewValue);=0A=
      };=0A=
    }=0A=
  };=0A=
};=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngMaxlength=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * ngMaxlength adds the maxlength {@link =
ngModel.NgModelController#$validators `validator`} to {@link ngModel =
`ngModel`}.=0A=
 * It is most often used for text-based {@link input `input`} controls, =
but can also be applied to custom text-based controls.=0A=
 *=0A=
 * The validator sets the `maxlength` error key if the {@link =
ngModel.NgModelController#$viewValue `ngModel.$viewValue`}=0A=
 * is longer than the integer obtained by evaluating the Angular =
expression given in the=0A=
 * `ngMaxlength` attribute value.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-info"&gt;=0A=
 * **Note:** This directive is also added when the plain `maxlength` =
attribute is used, with two=0A=
 * differences:=0A=
 * &lt;ol&gt;=0A=
 *   &lt;li&gt;=0A=
 *     `ngMaxlength` does not set the `maxlength` attribute and =
therefore HTML5 constraint=0A=
 *     validation is not available.=0A=
 *   &lt;/li&gt;=0A=
 *   &lt;li&gt;=0A=
 *     The `ngMaxlength` attribute must be an expression, while the =
`maxlength` value must be=0A=
 *     interpolated.=0A=
 *   &lt;/li&gt;=0A=
 * &lt;/ol&gt;=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * @example=0A=
 * &lt;example name=3D"ngMaxlengthDirective" =
module=3D"ngMaxlengthExample"&gt;=0A=
 *   &lt;file name=3D"index.html"&gt;=0A=
 *     &lt;script&gt;=0A=
 *       angular.module('ngMaxlengthExample', [])=0A=
 *         .controller('ExampleController', ['$scope', function($scope) {=0A=
 *           $scope.maxlength =3D 5;=0A=
 *         }]);=0A=
 *     &lt;/script&gt;=0A=
 *     &lt;div ng-controller=3D"ExampleController"&gt;=0A=
 *       &lt;form name=3D"form"&gt;=0A=
 *         &lt;label for=3D"maxlength"&gt;Set a maxlength: &lt;/label&gt;=0A=
 *         &lt;input type=3D"number" ng-model=3D"maxlength" =
id=3D"maxlength" /&gt;=0A=
 *         &lt;br&gt;=0A=
 *         &lt;label for=3D"input"&gt;This input is restricted by the =
current maxlength: &lt;/label&gt;=0A=
 *         &lt;input type=3D"text" ng-model=3D"model" id=3D"input" =
name=3D"input" ng-maxlength=3D"maxlength" /&gt;&lt;br&gt;=0A=
 *         &lt;hr&gt;=0A=
 *         input valid? =3D =
&lt;code&gt;{{form.input.$valid}}&lt;/code&gt;&lt;br&gt;=0A=
 *         model =3D &lt;code&gt;{{model}}&lt;/code&gt;=0A=
 *       &lt;/form&gt;=0A=
 *     &lt;/div&gt;=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       var model =3D element(by.binding('model'));=0A=
       var input =3D element(by.id('input'));=0A=
=0A=
       it('should validate the input with the default maxlength', =
function() {=0A=
         input.sendKeys('abcdef');=0A=
         expect(model.getText()).not.toContain('abcdef');=0A=
=0A=
         input.clear().then(function() {=0A=
           input.sendKeys('abcde');=0A=
           expect(model.getText()).toContain('abcde');=0A=
         });=0A=
       });=0A=
 *   &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 */=0A=
var maxlengthDirective =3D function() {=0A=
  return {=0A=
    restrict: 'A',=0A=
    require: '?ngModel',=0A=
    link: function(scope, elm, attr, ctrl) {=0A=
      if (!ctrl) return;=0A=
=0A=
      var maxlength =3D -1;=0A=
      attr.$observe('maxlength', function(value) {=0A=
        var intVal =3D toInt(value);=0A=
        maxlength =3D isNumberNaN(intVal) ? -1 : intVal;=0A=
        ctrl.$validate();=0A=
      });=0A=
      ctrl.$validators.maxlength =3D function(modelValue, viewValue) {=0A=
        return (maxlength &lt; 0) || ctrl.$isEmpty(viewValue) || =
(viewValue.length &lt;=3D maxlength);=0A=
      };=0A=
    }=0A=
  };=0A=
};=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngMinlength=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * ngMinlength adds the minlength {@link =
ngModel.NgModelController#$validators `validator`} to {@link ngModel =
`ngModel`}.=0A=
 * It is most often used for text-based {@link input `input`} controls, =
but can also be applied to custom text-based controls.=0A=
 *=0A=
 * The validator sets the `minlength` error key if the {@link =
ngModel.NgModelController#$viewValue `ngModel.$viewValue`}=0A=
 * is shorter than the integer obtained by evaluating the Angular =
expression given in the=0A=
 * `ngMinlength` attribute value.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-info"&gt;=0A=
 * **Note:** This directive is also added when the plain `minlength` =
attribute is used, with two=0A=
 * differences:=0A=
 * &lt;ol&gt;=0A=
 *   &lt;li&gt;=0A=
 *     `ngMinlength` does not set the `minlength` attribute and =
therefore HTML5 constraint=0A=
 *     validation is not available.=0A=
 *   &lt;/li&gt;=0A=
 *   &lt;li&gt;=0A=
 *     The `ngMinlength` value must be an expression, while the =
`minlength` value must be=0A=
 *     interpolated.=0A=
 *   &lt;/li&gt;=0A=
 * &lt;/ol&gt;=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * @example=0A=
 * &lt;example name=3D"ngMinlengthDirective" =
module=3D"ngMinlengthExample"&gt;=0A=
 *   &lt;file name=3D"index.html"&gt;=0A=
 *     &lt;script&gt;=0A=
 *       angular.module('ngMinlengthExample', [])=0A=
 *         .controller('ExampleController', ['$scope', function($scope) {=0A=
 *           $scope.minlength =3D 3;=0A=
 *         }]);=0A=
 *     &lt;/script&gt;=0A=
 *     &lt;div ng-controller=3D"ExampleController"&gt;=0A=
 *       &lt;form name=3D"form"&gt;=0A=
 *         &lt;label for=3D"minlength"&gt;Set a minlength: &lt;/label&gt;=0A=
 *         &lt;input type=3D"number" ng-model=3D"minlength" =
id=3D"minlength" /&gt;=0A=
 *         &lt;br&gt;=0A=
 *         &lt;label for=3D"input"&gt;This input is restricted by the =
current minlength: &lt;/label&gt;=0A=
 *         &lt;input type=3D"text" ng-model=3D"model" id=3D"input" =
name=3D"input" ng-minlength=3D"minlength" /&gt;&lt;br&gt;=0A=
 *         &lt;hr&gt;=0A=
 *         input valid? =3D =
&lt;code&gt;{{form.input.$valid}}&lt;/code&gt;&lt;br&gt;=0A=
 *         model =3D &lt;code&gt;{{model}}&lt;/code&gt;=0A=
 *       &lt;/form&gt;=0A=
 *     &lt;/div&gt;=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       var model =3D element(by.binding('model'));=0A=
       var input =3D element(by.id('input'));=0A=
=0A=
       it('should validate the input with the default minlength', =
function() {=0A=
         input.sendKeys('ab');=0A=
         expect(model.getText()).not.toContain('ab');=0A=
=0A=
         input.sendKeys('abc');=0A=
         expect(model.getText()).toContain('abc');=0A=
       });=0A=
 *   &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 */=0A=
var minlengthDirective =3D function() {=0A=
  return {=0A=
    restrict: 'A',=0A=
    require: '?ngModel',=0A=
    link: function(scope, elm, attr, ctrl) {=0A=
      if (!ctrl) return;=0A=
=0A=
      var minlength =3D 0;=0A=
      attr.$observe('minlength', function(value) {=0A=
        minlength =3D toInt(value) || 0;=0A=
        ctrl.$validate();=0A=
      });=0A=
      ctrl.$validators.minlength =3D function(modelValue, viewValue) {=0A=
        return ctrl.$isEmpty(viewValue) || viewValue.length &gt;=3D =
minlength;=0A=
      };=0A=
    }=0A=
  };=0A=
};=0A=
=0A=
if (window.angular.bootstrap) {=0A=
  // AngularJS is already loaded, so we can return here...=0A=
  if (window.console) {=0A=
    console.log('WARNING: Tried to load angular more than once.');=0A=
  }=0A=
  return;=0A=
}=0A=
=0A=
// try to bind to jquery now so that one can write jqLite(fn)=0A=
// but we will rebind on bootstrap again.=0A=
bindJQuery();=0A=
=0A=
publishExternalAPI(angular);=0A=
=0A=
angular.module("ngLocale", [], ["$provide", function($provide) {=0A=
var PLURAL_CATEGORY =3D {ZERO: "zero", ONE: "one", TWO: "two", FEW: =
"few", MANY: "many", OTHER: "other"};=0A=
function getDecimals(n) {=0A=
  n =3D n + '';=0A=
  var i =3D n.indexOf('.');=0A=
  return (i =3D=3D -1) ? 0 : n.length - i - 1;=0A=
}=0A=
=0A=
function getVF(n, opt_precision) {=0A=
  var v =3D opt_precision;=0A=
=0A=
  if (undefined =3D=3D=3D v) {=0A=
    v =3D Math.min(getDecimals(n), 3);=0A=
  }=0A=
=0A=
  var base =3D Math.pow(10, v);=0A=
  var f =3D ((n * base) | 0) % base;=0A=
  return {v: v, f: f};=0A=
}=0A=
=0A=
$provide.value("$locale", {=0A=
  "DATETIME_FORMATS": {=0A=
    "AMPMS": [=0A=
      "AM",=0A=
      "PM"=0A=
    ],=0A=
    "DAY": [=0A=
      "Sunday",=0A=
      "Monday",=0A=
      "Tuesday",=0A=
      "Wednesday",=0A=
      "Thursday",=0A=
      "Friday",=0A=
      "Saturday"=0A=
    ],=0A=
    "ERANAMES": [=0A=
      "Before Christ",=0A=
      "Anno Domini"=0A=
    ],=0A=
    "ERAS": [=0A=
      "BC",=0A=
      "AD"=0A=
    ],=0A=
    "FIRSTDAYOFWEEK": 6,=0A=
    "MONTH": [=0A=
      "January",=0A=
      "February",=0A=
      "March",=0A=
      "April",=0A=
      "May",=0A=
      "June",=0A=
      "July",=0A=
      "August",=0A=
      "September",=0A=
      "October",=0A=
      "November",=0A=
      "December"=0A=
    ],=0A=
    "SHORTDAY": [=0A=
      "Sun",=0A=
      "Mon",=0A=
      "Tue",=0A=
      "Wed",=0A=
      "Thu",=0A=
      "Fri",=0A=
      "Sat"=0A=
    ],=0A=
    "SHORTMONTH": [=0A=
      "Jan",=0A=
      "Feb",=0A=
      "Mar",=0A=
      "Apr",=0A=
      "May",=0A=
      "Jun",=0A=
      "Jul",=0A=
      "Aug",=0A=
      "Sep",=0A=
      "Oct",=0A=
      "Nov",=0A=
      "Dec"=0A=
    ],=0A=
    "STANDALONEMONTH": [=0A=
      "January",=0A=
      "February",=0A=
      "March",=0A=
      "April",=0A=
      "May",=0A=
      "June",=0A=
      "July",=0A=
      "August",=0A=
      "September",=0A=
      "October",=0A=
      "November",=0A=
      "December"=0A=
    ],=0A=
    "WEEKENDRANGE": [=0A=
      5,=0A=
      6=0A=
    ],=0A=
    "fullDate": "EEEE, MMMM d, y",=0A=
    "longDate": "MMMM d, y",=0A=
    "medium": "MMM d, y h:mm:ss a",=0A=
    "mediumDate": "MMM d, y",=0A=
    "mediumTime": "h:mm:ss a",=0A=
    "short": "M/d/yy h:mm a",=0A=
    "shortDate": "M/d/yy",=0A=
    "shortTime": "h:mm a"=0A=
  },=0A=
  "NUMBER_FORMATS": {=0A=
    "CURRENCY_SYM": "$",=0A=
    "DECIMAL_SEP": ".",=0A=
    "GROUP_SEP": ",",=0A=
    "PATTERNS": [=0A=
      {=0A=
        "gSize": 3,=0A=
        "lgSize": 3,=0A=
        "maxFrac": 3,=0A=
        "minFrac": 0,=0A=
        "minInt": 1,=0A=
        "negPre": "-",=0A=
        "negSuf": "",=0A=
        "posPre": "",=0A=
        "posSuf": ""=0A=
      },=0A=
      {=0A=
        "gSize": 3,=0A=
        "lgSize": 3,=0A=
        "maxFrac": 2,=0A=
        "minFrac": 2,=0A=
        "minInt": 1,=0A=
        "negPre": "-\u00a4",=0A=
        "negSuf": "",=0A=
        "posPre": "\u00a4",=0A=
        "posSuf": ""=0A=
      }=0A=
    ]=0A=
  },=0A=
  "id": "en-us",=0A=
  "localeID": "en_US",=0A=
  "pluralCat": function(n, opt_precision) {  var i =3D n | 0;  var vf =
=3D getVF(n, opt_precision);  if (i =3D=3D 1 &amp;&amp; vf.v =3D=3D 0) { =
   return PLURAL_CATEGORY.ONE;  }  return PLURAL_CATEGORY.OTHER;}=0A=
});=0A=
}]);=0A=
=0A=
  jqLite(function() {=0A=
    angularInit(window.document, bootstrap);=0A=
  });=0A=
=0A=
})(window);=0A=
=0A=
!window.angular.$$csp().noInlineStyle &amp;&amp; =
window.angular.element(document.head).prepend('&lt;style =
type=3D"text/css"&gt;@charset =
"UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x=
-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none =
!important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}=
.ng-anchor{position:absolute;}&lt;/style&gt;');</PRE></BODY></HTML>
