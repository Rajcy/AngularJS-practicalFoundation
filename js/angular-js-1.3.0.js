From: =?gb2312?B?0tHTySBJbnRlcm5ldCBFeHBsb3JlciAxMSCxo7Tm?=
Subject:
Date: Tue, 15 Aug 2017 22:02:41 +0800
MIME-Version: 1.0
Content-Type: text/html;
	charset="gb2312"
Content-Transfer-Encoding: quoted-printable
Content-Location: https://code.angularjs.org/1.3.0/angular.js
X-MimeOLE: Produced By Microsoft MimeOLE

<!DOCTYPE HTML>
<!DOCTYPE html PUBLIC "" ""><HTML><HEAD><META content=3D"IE=3D11.0000"=20
http-equiv=3D"X-UA-Compatible">

<META http-equiv=3D"Content-Type" content=3D"text/html; =
charset=3Dgb2312">
<META name=3D"GENERATOR" content=3D"MSHTML 11.00.10570.1001"></HEAD>
<BODY>
<PRE>/**=0A=
 * @license AngularJS v1.3.0=0A=
 * (c) 2010-2014 Google, Inc. http://angularjs.org=0A=
 * License: MIT=0A=
 */=0A=
(function(window, document, undefined) {'use strict';=0A=
=0A=
/**=0A=
 * @description=0A=
 *=0A=
 * This object provides a utility for producing rich Error messages =
within=0A=
 * Angular. It can be called as follows:=0A=
 *=0A=
 * var exampleMinErr =3D minErr('example');=0A=
 * throw exampleMinErr('one', 'This {0} is {1}', foo, bar);=0A=
 *=0A=
 * The above creates an instance of minErr in the example namespace. The=0A=
 * resulting error will have a namespaced error code of example.one.  The=0A=
 * resulting error will replace {0} with the value of foo, and {1} with =
the=0A=
 * value of bar. The object is not restricted in the number of arguments =
it can=0A=
 * take.=0A=
 *=0A=
 * If fewer arguments are specified than necessary for interpolation, =
the extra=0A=
 * interpolation markers will be preserved in the final string.=0A=
 *=0A=
 * Since data will be parsed statically during a build step, some =
restrictions=0A=
 * are applied with respect to how minErr instances are created and =
called.=0A=
 * Instances should have names of the form namespaceMinErr for a minErr =
created=0A=
 * using minErr('namespace') . Error codes, namespaces and template =
strings=0A=
 * should all be static strings, not variables or general expressions.=0A=
 *=0A=
 * @param {string} module The namespace to use for the new minErr =
instance.=0A=
 * @param {function} ErrorConstructor Custom error constructor to be =
instantiated when returning=0A=
 *   error from returned function, for cases when a particular type of =
error is useful.=0A=
 * @returns {function(code:string, template:string, ...templateArgs): =
Error} minErr instance=0A=
 */=0A=
=0A=
function minErr(module, ErrorConstructor) {=0A=
  ErrorConstructor =3D ErrorConstructor || Error;=0A=
  return function () {=0A=
    var code =3D arguments[0],=0A=
      prefix =3D '[' + (module ? module + ':' : '') + code + '] ',=0A=
      template =3D arguments[1],=0A=
      templateArgs =3D arguments,=0A=
      stringify =3D function (obj) {=0A=
        if (typeof obj =3D=3D=3D 'function') {=0A=
          return obj.toString().replace(/ \{[\s\S]*$/, '');=0A=
        } else if (typeof obj =3D=3D=3D 'undefined') {=0A=
          return 'undefined';=0A=
        } else if (typeof obj !=3D=3D 'string') {=0A=
          return JSON.stringify(obj);=0A=
        }=0A=
        return obj;=0A=
      },=0A=
      message, i;=0A=
=0A=
    message =3D prefix + template.replace(/\{\d+\}/g, function (match) {=0A=
      var index =3D +match.slice(1, -1), arg;=0A=
=0A=
      if (index + 2 &lt; templateArgs.length) {=0A=
        arg =3D templateArgs[index + 2];=0A=
        if (typeof arg =3D=3D=3D 'function') {=0A=
          return arg.toString().replace(/ ?\{[\s\S]*$/, '');=0A=
        } else if (typeof arg =3D=3D=3D 'undefined') {=0A=
          return 'undefined';=0A=
        } else if (typeof arg !=3D=3D 'string') {=0A=
          return toJson(arg);=0A=
        }=0A=
        return arg;=0A=
      }=0A=
      return match;=0A=
    });=0A=
=0A=
    message =3D message + '\nhttp://errors.angularjs.org/1.3.0/' +=0A=
      (module ? module + '/' : '') + code;=0A=
    for (i =3D 2; i &lt; arguments.length; i++) {=0A=
      message =3D message + (i =3D=3D 2 ? '?' : '&amp;') + 'p' + (i-2) + =
'=3D' +=0A=
        encodeURIComponent(stringify(arguments[i]));=0A=
    }=0A=
    return new ErrorConstructor(message);=0A=
  };=0A=
}=0A=
=0A=
/* We need to tell jshint what variables are being exported */=0A=
/* global angular: true,=0A=
  msie: true,=0A=
  jqLite: true,=0A=
  jQuery: true,=0A=
  slice: true,=0A=
  splice: true,=0A=
  push: true,=0A=
  toString: true,=0A=
  ngMinErr: true,=0A=
  angularModule: true,=0A=
  uid: true,=0A=
  REGEX_STRING_REGEXP: true,=0A=
  VALIDITY_STATE_PROPERTY: true,=0A=
=0A=
  lowercase: true,=0A=
  uppercase: true,=0A=
  manualLowercase: true,=0A=
  manualUppercase: true,=0A=
  nodeName_: true,=0A=
  isArrayLike: true,=0A=
  forEach: true,=0A=
  sortedKeys: true,=0A=
  forEachSorted: true,=0A=
  reverseParams: true,=0A=
  nextUid: true,=0A=
  setHashKey: true,=0A=
  extend: true,=0A=
  int: true,=0A=
  inherit: true,=0A=
  noop: true,=0A=
  identity: true,=0A=
  valueFn: true,=0A=
  isUndefined: true,=0A=
  isDefined: true,=0A=
  isObject: true,=0A=
  isString: true,=0A=
  isNumber: true,=0A=
  isDate: true,=0A=
  isArray: true,=0A=
  isFunction: true,=0A=
  isRegExp: true,=0A=
  isWindow: true,=0A=
  isScope: true,=0A=
  isFile: true,=0A=
  isBlob: true,=0A=
  isBoolean: true,=0A=
  isPromiseLike: true,=0A=
  trim: true,=0A=
  isElement: true,=0A=
  makeMap: true,=0A=
  size: true,=0A=
  includes: true,=0A=
  arrayRemove: true,=0A=
  isLeafNode: true,=0A=
  copy: true,=0A=
  shallowCopy: true,=0A=
  equals: true,=0A=
  csp: true,=0A=
  concat: true,=0A=
  sliceArgs: true,=0A=
  bind: true,=0A=
  toJsonReplacer: true,=0A=
  toJson: true,=0A=
  fromJson: true,=0A=
  startingTag: true,=0A=
  tryDecodeURIComponent: true,=0A=
  parseKeyValue: true,=0A=
  toKeyValue: true,=0A=
  encodeUriSegment: true,=0A=
  encodeUriQuery: true,=0A=
  angularInit: true,=0A=
  bootstrap: true,=0A=
  getTestability: true,=0A=
  snake_case: true,=0A=
  bindJQuery: true,=0A=
  assertArg: true,=0A=
  assertArgFn: true,=0A=
  assertNotHasOwnProperty: true,=0A=
  getter: true,=0A=
  getBlockNodes: true,=0A=
  hasOwnProperty: true,=0A=
  createMap: true,=0A=
=0A=
  NODE_TYPE_ELEMENT: true,=0A=
  NODE_TYPE_TEXT: true,=0A=
  NODE_TYPE_COMMENT: true,=0A=
  NODE_TYPE_DOCUMENT: true,=0A=
  NODE_TYPE_DOCUMENT_FRAGMENT: true,=0A=
*/=0A=
=0A=
////////////////////////////////////=0A=
=0A=
/**=0A=
 * @ngdoc module=0A=
 * @name ng=0A=
 * @module ng=0A=
 * @description=0A=
 *=0A=
 * # ng (core module)=0A=
 * The ng module is loaded by default when an AngularJS application is =
started. The module itself=0A=
 * contains the essential components for an AngularJS application to =
function. The table below=0A=
 * lists a high level breakdown of each of the services/factories, =
filters, directives and testing=0A=
 * components available within this core module.=0A=
 *=0A=
 * &lt;div doc-module-components=3D"ng"&gt;&lt;/div&gt;=0A=
 */=0A=
=0A=
var REGEX_STRING_REGEXP =3D /^\/(.+)\/([a-z]*)$/;=0A=
=0A=
// The name of a form control's ValidityState property.=0A=
// This is used so that it's possible for internal tests to create mock =
ValidityStates.=0A=
var VALIDITY_STATE_PROPERTY =3D 'validity';=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.lowercase=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description Converts the specified string to lowercase.=0A=
 * @param {string} string String to be converted to lowercase.=0A=
 * @returns {string} Lowercased string.=0A=
 */=0A=
var lowercase =3D function(string){return isString(string) ? =
string.toLowerCase() : string;};=0A=
var hasOwnProperty =3D Object.prototype.hasOwnProperty;=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.uppercase=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description Converts the specified string to uppercase.=0A=
 * @param {string} string String to be converted to uppercase.=0A=
 * @returns {string} Uppercased string.=0A=
 */=0A=
var uppercase =3D function(string){return isString(string) ? =
string.toUpperCase() : string;};=0A=
=0A=
=0A=
var manualLowercase =3D function(s) {=0A=
  /* jshint bitwise: false */=0A=
  return isString(s)=0A=
      ? s.replace(/[A-Z]/g, function(ch) {return =
String.fromCharCode(ch.charCodeAt(0) | 32);})=0A=
      : s;=0A=
};=0A=
var manualUppercase =3D function(s) {=0A=
  /* jshint bitwise: false */=0A=
  return isString(s)=0A=
      ? s.replace(/[a-z]/g, function(ch) {return =
String.fromCharCode(ch.charCodeAt(0) &amp; ~32);})=0A=
      : s;=0A=
};=0A=
=0A=
=0A=
// String#toLowerCase and String#toUpperCase don't produce correct =
results in browsers with Turkish=0A=
// locale, for this reason we need to detect this case and redefine =
lowercase/uppercase methods=0A=
// with correct but slower alternatives.=0A=
if ('i' !=3D=3D 'I'.toLowerCase()) {=0A=
  lowercase =3D manualLowercase;=0A=
  uppercase =3D manualUppercase;=0A=
}=0A=
=0A=
=0A=
var /** holds major version number for IE or NaN for real browsers */=0A=
    msie,=0A=
    jqLite,           // delay binding since jQuery could be loaded =
after us.=0A=
    jQuery,           // delay binding=0A=
    slice             =3D [].slice,=0A=
    splice            =3D [].splice,=0A=
    push              =3D [].push,=0A=
    toString          =3D Object.prototype.toString,=0A=
    ngMinErr          =3D minErr('ng'),=0A=
=0A=
    /** @name angular */=0A=
    angular           =3D window.angular || (window.angular =3D {}),=0A=
    angularModule,=0A=
    uid               =3D 0;=0A=
=0A=
/**=0A=
 * documentMode is an IE-only property=0A=
 * http://msdn.microsoft.com/en-us/library/ie/cc196988(v=3Dvs.85).aspx=0A=
 */=0A=
msie =3D document.documentMode;=0A=
=0A=
=0A=
/**=0A=
 * @private=0A=
 * @param {*} obj=0A=
 * @return {boolean} Returns true if `obj` is an array or array-like =
object (NodeList, Arguments,=0A=
 *                   String ...)=0A=
 */=0A=
function isArrayLike(obj) {=0A=
  if (obj =3D=3D null || isWindow(obj)) {=0A=
    return false;=0A=
  }=0A=
=0A=
  var length =3D obj.length;=0A=
=0A=
  if (obj.nodeType =3D=3D=3D NODE_TYPE_ELEMENT &amp;&amp; length) {=0A=
    return true;=0A=
  }=0A=
=0A=
  return isString(obj) || isArray(obj) || length =3D=3D=3D 0 ||=0A=
         typeof length =3D=3D=3D 'number' &amp;&amp; length &gt; 0 =
&amp;&amp; (length - 1) in obj;=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.forEach=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Invokes the `iterator` function once for each item in `obj` =
collection, which can be either an=0A=
 * object or an array. The `iterator` function is invoked with =
`iterator(value, key, obj)`, where `value`=0A=
 * is the value of an object property or an array element, `key` is the =
object property key or=0A=
 * array element index and obj is the `obj` itself. Specifying a =
`context` for the function is optional.=0A=
 *=0A=
 * It is worth noting that `.forEach` does not iterate over inherited =
properties because it filters=0A=
 * using the `hasOwnProperty` method.=0A=
 *=0A=
   ```js=0A=
     var values =3D {name: 'misko', gender: 'male'};=0A=
     var log =3D [];=0A=
     angular.forEach(values, function(value, key) {=0A=
       this.push(key + ': ' + value);=0A=
     }, log);=0A=
     expect(log).toEqual(['name: misko', 'gender: male']);=0A=
   ```=0A=
 *=0A=
 * @param {Object|Array} obj Object to iterate over.=0A=
 * @param {Function} iterator Iterator function.=0A=
 * @param {Object=3D} context Object to become context (`this`) for the =
iterator function.=0A=
 * @returns {Object|Array} Reference to `obj`.=0A=
 */=0A=
=0A=
function forEach(obj, iterator, context) {=0A=
  var key, length;=0A=
  if (obj) {=0A=
    if (isFunction(obj)) {=0A=
      for (key in obj) {=0A=
        // Need to check if hasOwnProperty exists,=0A=
        // as on IE8 the result of querySelectorAll is an object without =
a hasOwnProperty function=0A=
        if (key !=3D 'prototype' &amp;&amp; key !=3D 'length' &amp;&amp; =
key !=3D 'name' &amp;&amp; (!obj.hasOwnProperty || =
obj.hasOwnProperty(key))) {=0A=
          iterator.call(context, obj[key], key, obj);=0A=
        }=0A=
      }=0A=
    } else if (isArray(obj) || isArrayLike(obj)) {=0A=
      var isPrimitive =3D typeof obj !=3D=3D 'object';=0A=
      for (key =3D 0, length =3D obj.length; key &lt; length; key++) {=0A=
        if (isPrimitive || key in obj) {=0A=
          iterator.call(context, obj[key], key, obj);=0A=
        }=0A=
      }=0A=
    } else if (obj.forEach &amp;&amp; obj.forEach !=3D=3D forEach) {=0A=
        obj.forEach(iterator, context, obj);=0A=
    } else {=0A=
      for (key in obj) {=0A=
        if (obj.hasOwnProperty(key)) {=0A=
          iterator.call(context, obj[key], key, obj);=0A=
        }=0A=
      }=0A=
    }=0A=
  }=0A=
  return obj;=0A=
}=0A=
=0A=
function sortedKeys(obj) {=0A=
  var keys =3D [];=0A=
  for (var key in obj) {=0A=
    if (obj.hasOwnProperty(key)) {=0A=
      keys.push(key);=0A=
    }=0A=
  }=0A=
  return keys.sort();=0A=
}=0A=
=0A=
function forEachSorted(obj, iterator, context) {=0A=
  var keys =3D sortedKeys(obj);=0A=
  for ( var i =3D 0; i &lt; keys.length; i++) {=0A=
    iterator.call(context, obj[keys[i]], keys[i]);=0A=
  }=0A=
  return keys;=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * when using forEach the params are value, key, but it is often useful =
to have key, value.=0A=
 * @param {function(string, *)} iteratorFn=0A=
 * @returns {function(*, string)}=0A=
 */=0A=
function reverseParams(iteratorFn) {=0A=
  return function(value, key) { iteratorFn(key, value); };=0A=
}=0A=
=0A=
/**=0A=
 * A consistent way of creating unique IDs in angular.=0A=
 *=0A=
 * Using simple numbers allows us to generate 28.6 million unique ids =
per second for 10 years before=0A=
 * we hit number precision issues in JavaScript.=0A=
 *=0A=
 * Math.pow(2,53) / 60 / 60 / 24 / 365 / 10 =3D 28.6M=0A=
 *=0A=
 * @returns {number} an unique alpha-numeric string=0A=
 */=0A=
function nextUid() {=0A=
  return ++uid;=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * Set or clear the hashkey for an object.=0A=
 * @param obj object=0A=
 * @param h the hashkey (!truthy to delete the hashkey)=0A=
 */=0A=
function setHashKey(obj, h) {=0A=
  if (h) {=0A=
    obj.$$hashKey =3D h;=0A=
  }=0A=
  else {=0A=
    delete obj.$$hashKey;=0A=
  }=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.extend=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Extends the destination object `dst` by copying own enumerable =
properties from the `src` object(s)=0A=
 * to `dst`. You can specify multiple `src` objects. If you want to =
preserve original objects, you can do so=0A=
 * by passing an empty object as the target: `var object =3D =
angular.extend({}, object1, object2)`.=0A=
 *=0A=
 * @param {Object} dst Destination object.=0A=
 * @param {...Object} src Source object(s).=0A=
 * @returns {Object} Reference to `dst`.=0A=
 */=0A=
function extend(dst) {=0A=
  var h =3D dst.$$hashKey;=0A=
=0A=
  for (var i =3D 1, ii =3D arguments.length; i &lt; ii; i++) {=0A=
    var obj =3D arguments[i];=0A=
    if (obj) {=0A=
      var keys =3D Object.keys(obj);=0A=
      for (var j =3D 0, jj =3D keys.length; j &lt; jj; j++) {=0A=
        var key =3D keys[j];=0A=
        dst[key] =3D obj[key];=0A=
      }=0A=
    }=0A=
  }=0A=
=0A=
  setHashKey(dst, h);=0A=
  return dst;=0A=
}=0A=
=0A=
function int(str) {=0A=
  return parseInt(str, 10);=0A=
}=0A=
=0A=
=0A=
function inherit(parent, extra) {=0A=
  return extend(new (extend(function() {}, {prototype:parent}))(), =
extra);=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.noop=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * A function that performs no operations. This function can be useful =
when writing code in the=0A=
 * functional style.=0A=
   ```js=0A=
     function foo(callback) {=0A=
       var result =3D calculateResult();=0A=
       (callback || angular.noop)(result);=0A=
     }=0A=
   ```=0A=
 */=0A=
function noop() {}=0A=
noop.$inject =3D [];=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.identity=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * A function that returns its first argument. This function is useful =
when writing code in the=0A=
 * functional style.=0A=
 *=0A=
   ```js=0A=
     function transformer(transformationFn, value) {=0A=
       return (transformationFn || angular.identity)(value);=0A=
     };=0A=
   ```=0A=
 */=0A=
function identity($) {return $;}=0A=
identity.$inject =3D [];=0A=
=0A=
=0A=
function valueFn(value) {return function() {return value;};}=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.isUndefined=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Determines if a reference is undefined.=0A=
 *=0A=
 * @param {*} value Reference to check.=0A=
 * @returns {boolean} True if `value` is undefined.=0A=
 */=0A=
function isUndefined(value){return typeof value =3D=3D=3D 'undefined';}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.isDefined=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Determines if a reference is defined.=0A=
 *=0A=
 * @param {*} value Reference to check.=0A=
 * @returns {boolean} True if `value` is defined.=0A=
 */=0A=
function isDefined(value){return typeof value !=3D=3D 'undefined';}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.isObject=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Determines if a reference is an `Object`. Unlike `typeof` in =
JavaScript, `null`s are not=0A=
 * considered to be objects. Note that JavaScript arrays are objects.=0A=
 *=0A=
 * @param {*} value Reference to check.=0A=
 * @returns {boolean} True if `value` is an `Object` but not `null`.=0A=
 */=0A=
function isObject(value){=0A=
  // http://jsperf.com/isobject4=0A=
  return value !=3D=3D null &amp;&amp; typeof value =3D=3D=3D 'object';=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.isString=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Determines if a reference is a `String`.=0A=
 *=0A=
 * @param {*} value Reference to check.=0A=
 * @returns {boolean} True if `value` is a `String`.=0A=
 */=0A=
function isString(value){return typeof value =3D=3D=3D 'string';}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.isNumber=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Determines if a reference is a `Number`.=0A=
 *=0A=
 * @param {*} value Reference to check.=0A=
 * @returns {boolean} True if `value` is a `Number`.=0A=
 */=0A=
function isNumber(value){return typeof value =3D=3D=3D 'number';}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.isDate=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Determines if a value is a date.=0A=
 *=0A=
 * @param {*} value Reference to check.=0A=
 * @returns {boolean} True if `value` is a `Date`.=0A=
 */=0A=
function isDate(value) {=0A=
  return toString.call(value) =3D=3D=3D '[object Date]';=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.isArray=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Determines if a reference is an `Array`.=0A=
 *=0A=
 * @param {*} value Reference to check.=0A=
 * @returns {boolean} True if `value` is an `Array`.=0A=
 */=0A=
var isArray =3D Array.isArray;=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.isFunction=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Determines if a reference is a `Function`.=0A=
 *=0A=
 * @param {*} value Reference to check.=0A=
 * @returns {boolean} True if `value` is a `Function`.=0A=
 */=0A=
function isFunction(value){return typeof value =3D=3D=3D 'function';}=0A=
=0A=
=0A=
/**=0A=
 * Determines if a value is a regular expression object.=0A=
 *=0A=
 * @private=0A=
 * @param {*} value Reference to check.=0A=
 * @returns {boolean} True if `value` is a `RegExp`.=0A=
 */=0A=
function isRegExp(value) {=0A=
  return toString.call(value) =3D=3D=3D '[object RegExp]';=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * Checks if `obj` is a window object.=0A=
 *=0A=
 * @private=0A=
 * @param {*} obj Object to check=0A=
 * @returns {boolean} True if `obj` is a window obj.=0A=
 */=0A=
function isWindow(obj) {=0A=
  return obj &amp;&amp; obj.window =3D=3D=3D obj;=0A=
}=0A=
=0A=
=0A=
function isScope(obj) {=0A=
  return obj &amp;&amp; obj.$evalAsync &amp;&amp; obj.$watch;=0A=
}=0A=
=0A=
=0A=
function isFile(obj) {=0A=
  return toString.call(obj) =3D=3D=3D '[object File]';=0A=
}=0A=
=0A=
=0A=
function isBlob(obj) {=0A=
  return toString.call(obj) =3D=3D=3D '[object Blob]';=0A=
}=0A=
=0A=
=0A=
function isBoolean(value) {=0A=
  return typeof value =3D=3D=3D 'boolean';=0A=
}=0A=
=0A=
=0A=
function isPromiseLike(obj) {=0A=
  return obj &amp;&amp; isFunction(obj.then);=0A=
}=0A=
=0A=
=0A=
var trim =3D function(value) {=0A=
  return isString(value) ? value.trim() : value;=0A=
};=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.isElement=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Determines if a reference is a DOM element (or wrapped jQuery =
element).=0A=
 *=0A=
 * @param {*} value Reference to check.=0A=
 * @returns {boolean} True if `value` is a DOM element (or wrapped =
jQuery element).=0A=
 */=0A=
function isElement(node) {=0A=
  return !!(node &amp;&amp;=0A=
    (node.nodeName  // we are a direct element=0A=
    || (node.prop &amp;&amp; node.attr &amp;&amp; node.find)));  // we =
have an on and find method part of jQuery API=0A=
}=0A=
=0A=
/**=0A=
 * @param str 'key1,key2,...'=0A=
 * @returns {object} in the form of {key1:true, key2:true, ...}=0A=
 */=0A=
function makeMap(str) {=0A=
  var obj =3D {}, items =3D str.split(","), i;=0A=
  for ( i =3D 0; i &lt; items.length; i++ )=0A=
    obj[ items[i] ] =3D true;=0A=
  return obj;=0A=
}=0A=
=0A=
=0A=
function nodeName_(element) {=0A=
  return lowercase(element.nodeName || element[0].nodeName);=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @description=0A=
 * Determines the number of elements in an array, the number of =
properties an object has, or=0A=
 * the length of a string.=0A=
 *=0A=
 * Note: This function is used to augment the Object type in Angular =
expressions. See=0A=
 * {@link angular.Object} for more information about Angular arrays.=0A=
 *=0A=
 * @param {Object|Array|string} obj Object, array, or string to inspect.=0A=
 * @param {boolean} [ownPropsOnly=3Dfalse] Count only "own" properties =
in an object=0A=
 * @returns {number} The size of `obj` or `0` if `obj` is neither an =
object nor an array.=0A=
 */=0A=
function size(obj, ownPropsOnly) {=0A=
  var count =3D 0, key;=0A=
=0A=
  if (isArray(obj) || isString(obj)) {=0A=
    return obj.length;=0A=
  } else if (isObject(obj)) {=0A=
    for (key in obj)=0A=
      if (!ownPropsOnly || obj.hasOwnProperty(key))=0A=
        count++;=0A=
  }=0A=
=0A=
  return count;=0A=
}=0A=
=0A=
=0A=
function includes(array, obj) {=0A=
  return Array.prototype.indexOf.call(array, obj) !=3D -1;=0A=
}=0A=
=0A=
function arrayRemove(array, value) {=0A=
  var index =3D array.indexOf(value);=0A=
  if (index &gt;=3D0)=0A=
    array.splice(index, 1);=0A=
  return value;=0A=
}=0A=
=0A=
function isLeafNode (node) {=0A=
  if (node) {=0A=
    switch (nodeName_(node)) {=0A=
    case "option":=0A=
    case "pre":=0A=
    case "title":=0A=
      return true;=0A=
    }=0A=
  }=0A=
  return false;=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.copy=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Creates a deep copy of `source`, which should be an object or an =
array.=0A=
 *=0A=
 * * If no destination is supplied, a copy of the object or array is =
created.=0A=
 * * If a destination is provided, all of its elements (for array) or =
properties (for objects)=0A=
 *   are deleted and then all elements/properties from the source are =
copied to it.=0A=
 * * If `source` is not an object or array (inc. `null` and =
`undefined`), `source` is returned.=0A=
 * * If `source` is identical to 'destination' an exception will be =
thrown.=0A=
 *=0A=
 * @param {*} source The source that will be used to make a copy.=0A=
 *                   Can be any type, including primitives, `null`, and =
`undefined`.=0A=
 * @param {(Object|Array)=3D} destination Destination into which the =
source is copied. If=0A=
 *     provided, must be of the same type as `source`.=0A=
 * @returns {*} The copy or updated `destination`, if `destination` was =
specified.=0A=
 *=0A=
 * @example=0A=
 &lt;example module=3D"copyExample"&gt;=0A=
 &lt;file name=3D"todoList.html"&gt;=0A=
 &lt;div ng-controller=3D"ExampleController"&gt;=0A=
 &lt;form novalidate class=3D"simple-form"&gt;=0A=
 Name: &lt;input type=3D"text" ng-model=3D"user.name" /&gt;&lt;br /&gt;=0A=
 E-mail: &lt;input type=3D"email" ng-model=3D"user.email" /&gt;&lt;br =
/&gt;=0A=
 Gender: &lt;input type=3D"radio" ng-model=3D"user.gender" =
value=3D"male" /&gt;male=0A=
 &lt;input type=3D"radio" ng-model=3D"user.gender" value=3D"female" =
/&gt;female&lt;br /&gt;=0A=
 &lt;button ng-click=3D"reset()"&gt;RESET&lt;/button&gt;=0A=
 &lt;button ng-click=3D"update(user)"&gt;SAVE&lt;/button&gt;=0A=
 &lt;/form&gt;=0A=
 &lt;pre&gt;form =3D {{user | json}}&lt;/pre&gt;=0A=
 &lt;pre&gt;master =3D {{master | json}}&lt;/pre&gt;=0A=
 &lt;/div&gt;=0A=
=0A=
 &lt;script&gt;=0A=
  angular.module('copyExample', [])=0A=
    .controller('ExampleController', ['$scope', function($scope) {=0A=
      $scope.master=3D {};=0A=
=0A=
      $scope.update =3D function(user) {=0A=
        // Example with 1 argument=0A=
        $scope.master=3D angular.copy(user);=0A=
      };=0A=
=0A=
      $scope.reset =3D function() {=0A=
        // Example with 2 arguments=0A=
        angular.copy($scope.master, $scope.user);=0A=
      };=0A=
=0A=
      $scope.reset();=0A=
    }]);=0A=
 &lt;/script&gt;=0A=
 &lt;/file&gt;=0A=
 &lt;/example&gt;=0A=
 */=0A=
function copy(source, destination, stackSource, stackDest) {=0A=
  if (isWindow(source) || isScope(source)) {=0A=
    throw ngMinErr('cpws',=0A=
      "Can't copy! Making copies of Window or Scope instances is not =
supported.");=0A=
  }=0A=
=0A=
  if (!destination) {=0A=
    destination =3D source;=0A=
    if (source) {=0A=
      if (isArray(source)) {=0A=
        destination =3D copy(source, [], stackSource, stackDest);=0A=
      } else if (isDate(source)) {=0A=
        destination =3D new Date(source.getTime());=0A=
      } else if (isRegExp(source)) {=0A=
        destination =3D new RegExp(source.source, =
source.toString().match(/[^\/]*$/)[0]);=0A=
        destination.lastIndex =3D source.lastIndex;=0A=
      } else if (isObject(source)) {=0A=
        var emptyObject =3D Object.create(Object.getPrototypeOf(source));=0A=
        destination =3D copy(source, emptyObject, stackSource, =
stackDest);=0A=
      }=0A=
    }=0A=
  } else {=0A=
    if (source =3D=3D=3D destination) throw ngMinErr('cpi',=0A=
      "Can't copy! Source and destination are identical.");=0A=
=0A=
    stackSource =3D stackSource || [];=0A=
    stackDest =3D stackDest || [];=0A=
=0A=
    if (isObject(source)) {=0A=
      var index =3D stackSource.indexOf(source);=0A=
      if (index !=3D=3D -1) return stackDest[index];=0A=
=0A=
      stackSource.push(source);=0A=
      stackDest.push(destination);=0A=
    }=0A=
=0A=
    var result;=0A=
    if (isArray(source)) {=0A=
      destination.length =3D 0;=0A=
      for ( var i =3D 0; i &lt; source.length; i++) {=0A=
        result =3D copy(source[i], null, stackSource, stackDest);=0A=
        if (isObject(source[i])) {=0A=
          stackSource.push(source[i]);=0A=
          stackDest.push(result);=0A=
        }=0A=
        destination.push(result);=0A=
      }=0A=
    } else {=0A=
      var h =3D destination.$$hashKey;=0A=
      if (isArray(destination)) {=0A=
        destination.length =3D 0;=0A=
      } else {=0A=
        forEach(destination, function(value, key) {=0A=
          delete destination[key];=0A=
        });=0A=
      }=0A=
      for ( var key in source) {=0A=
        if(source.hasOwnProperty(key)) {=0A=
          result =3D copy(source[key], null, stackSource, stackDest);=0A=
          if (isObject(source[key])) {=0A=
            stackSource.push(source[key]);=0A=
            stackDest.push(result);=0A=
          }=0A=
          destination[key] =3D result;=0A=
        }=0A=
      }=0A=
      setHashKey(destination,h);=0A=
    }=0A=
=0A=
  }=0A=
  return destination;=0A=
}=0A=
=0A=
/**=0A=
 * Creates a shallow copy of an object, an array or a primitive.=0A=
 *=0A=
 * Assumes that there are no proto properties for objects.=0A=
 */=0A=
function shallowCopy(src, dst) {=0A=
  if (isArray(src)) {=0A=
    dst =3D dst || [];=0A=
=0A=
    for (var i =3D 0, ii =3D src.length; i &lt; ii; i++) {=0A=
      dst[i] =3D src[i];=0A=
    }=0A=
  } else if (isObject(src)) {=0A=
    dst =3D dst || {};=0A=
=0A=
    for (var key in src) {=0A=
      if (!(key.charAt(0) =3D=3D=3D '$' &amp;&amp; key.charAt(1) =
=3D=3D=3D '$')) {=0A=
        dst[key] =3D src[key];=0A=
      }=0A=
    }=0A=
  }=0A=
=0A=
  return dst || src;=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.equals=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Determines if two objects or two values are equivalent. Supports =
value types, regular=0A=
 * expressions, arrays and objects.=0A=
 *=0A=
 * Two objects or values are considered equivalent if at least one of =
the following is true:=0A=
 *=0A=
 * * Both objects or values pass `=3D=3D=3D` comparison.=0A=
 * * Both objects or values are of the same type and all of their =
properties are equal by=0A=
 *   comparing them with `angular.equals`.=0A=
 * * Both values are NaN. (In JavaScript, NaN =3D=3D NaN =3D&gt; false. =
But we consider two NaN as equal)=0A=
 * * Both values represent the same regular expression (In JavaScript,=0A=
 *   /abc/ =3D=3D /abc/ =3D&gt; false. But we consider two regular =
expressions as equal when their textual=0A=
 *   representation matches).=0A=
 *=0A=
 * During a property comparison, properties of `function` type and =
properties with names=0A=
 * that begin with `$` are ignored.=0A=
 *=0A=
 * Scope and DOMWindow objects are being compared only by identify =
(`=3D=3D=3D`).=0A=
 *=0A=
 * @param {*} o1 Object or value to compare.=0A=
 * @param {*} o2 Object or value to compare.=0A=
 * @returns {boolean} True if arguments are equal.=0A=
 */=0A=
function equals(o1, o2) {=0A=
  if (o1 =3D=3D=3D o2) return true;=0A=
  if (o1 =3D=3D=3D null || o2 =3D=3D=3D null) return false;=0A=
  if (o1 !=3D=3D o1 &amp;&amp; o2 !=3D=3D o2) return true; // NaN =
=3D=3D=3D NaN=0A=
  var t1 =3D typeof o1, t2 =3D typeof o2, length, key, keySet;=0A=
  if (t1 =3D=3D t2) {=0A=
    if (t1 =3D=3D 'object') {=0A=
      if (isArray(o1)) {=0A=
        if (!isArray(o2)) return false;=0A=
        if ((length =3D o1.length) =3D=3D o2.length) {=0A=
          for(key=3D0; key&lt;length; key++) {=0A=
            if (!equals(o1[key], o2[key])) return false;=0A=
          }=0A=
          return true;=0A=
        }=0A=
      } else if (isDate(o1)) {=0A=
        if (!isDate(o2)) return false;=0A=
        return equals(o1.getTime(), o2.getTime());=0A=
      } else if (isRegExp(o1) &amp;&amp; isRegExp(o2)) {=0A=
        return o1.toString() =3D=3D o2.toString();=0A=
      } else {=0A=
        if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) =
|| isArray(o2)) return false;=0A=
        keySet =3D {};=0A=
        for(key in o1) {=0A=
          if (key.charAt(0) =3D=3D=3D '$' || isFunction(o1[key])) =
continue;=0A=
          if (!equals(o1[key], o2[key])) return false;=0A=
          keySet[key] =3D true;=0A=
        }=0A=
        for(key in o2) {=0A=
          if (!keySet.hasOwnProperty(key) &amp;&amp;=0A=
              key.charAt(0) !=3D=3D '$' &amp;&amp;=0A=
              o2[key] !=3D=3D undefined &amp;&amp;=0A=
              !isFunction(o2[key])) return false;=0A=
        }=0A=
        return true;=0A=
      }=0A=
    }=0A=
  }=0A=
  return false;=0A=
}=0A=
=0A=
var csp =3D function() {=0A=
  if (isDefined(csp.isActive_)) return csp.isActive_;=0A=
=0A=
  var active =3D !!(document.querySelector('[ng-csp]') ||=0A=
                  document.querySelector('[data-ng-csp]'));=0A=
=0A=
  if (!active) {=0A=
    try {=0A=
      /* jshint -W031, -W054 */=0A=
      new Function('');=0A=
      /* jshint +W031, +W054 */=0A=
    } catch (e) {=0A=
      active =3D true;=0A=
    }=0A=
  }=0A=
=0A=
  return (csp.isActive_ =3D active);=0A=
};=0A=
=0A=
=0A=
=0A=
function concat(array1, array2, index) {=0A=
  return array1.concat(slice.call(array2, index));=0A=
}=0A=
=0A=
function sliceArgs(args, startIndex) {=0A=
  return slice.call(args, startIndex || 0);=0A=
}=0A=
=0A=
=0A=
/* jshint -W101 */=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.bind=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Returns a function which calls function `fn` bound to `self` (`self` =
becomes the `this` for=0A=
 * `fn`). You can supply optional `args` that are prebound to the =
function. This feature is also=0A=
 * known as [partial =
application](http://en.wikipedia.org/wiki/Partial_application), as=0A=
 * distinguished from [function =
currying](http://en.wikipedia.org/wiki/Currying#Contrast_with_partial_fun=
ction_application).=0A=
 *=0A=
 * @param {Object} self Context which `fn` should be evaluated in.=0A=
 * @param {function()} fn Function to be bound.=0A=
 * @param {...*} args Optional arguments to be prebound to the `fn` =
function call.=0A=
 * @returns {function()} Function that wraps the `fn` with all the =
specified bindings.=0A=
 */=0A=
/* jshint +W101 */=0A=
function bind(self, fn) {=0A=
  var curryArgs =3D arguments.length &gt; 2 ? sliceArgs(arguments, 2) : =
[];=0A=
  if (isFunction(fn) &amp;&amp; !(fn instanceof RegExp)) {=0A=
    return curryArgs.length=0A=
      ? function() {=0A=
          return arguments.length=0A=
            ? fn.apply(self, curryArgs.concat(slice.call(arguments, 0)))=0A=
            : fn.apply(self, curryArgs);=0A=
        }=0A=
      : function() {=0A=
          return arguments.length=0A=
            ? fn.apply(self, arguments)=0A=
            : fn.call(self);=0A=
        };=0A=
  } else {=0A=
    // in IE, native methods are not functions so they cannot be bound =
(note: they don't need to be)=0A=
    return fn;=0A=
  }=0A=
}=0A=
=0A=
=0A=
function toJsonReplacer(key, value) {=0A=
  var val =3D value;=0A=
=0A=
  if (typeof key =3D=3D=3D 'string' &amp;&amp; key.charAt(0) =3D=3D=3D =
'$' &amp;&amp; key.charAt(1) =3D=3D=3D '$') {=0A=
    val =3D undefined;=0A=
  } else if (isWindow(value)) {=0A=
    val =3D '$WINDOW';=0A=
  } else if (value &amp;&amp;  document =3D=3D=3D value) {=0A=
    val =3D '$DOCUMENT';=0A=
  } else if (isScope(value)) {=0A=
    val =3D '$SCOPE';=0A=
  }=0A=
=0A=
  return val;=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.toJson=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Serializes input into a JSON-formatted string. Properties with =
leading $$ characters will be=0A=
 * stripped since angular uses this notation internally.=0A=
 *=0A=
 * @param {Object|Array|Date|string|number} obj Input to be serialized =
into JSON.=0A=
 * @param {boolean=3D} pretty If set to true, the JSON output will =
contain newlines and whitespace.=0A=
 * @returns {string|undefined} JSON-ified string representing `obj`.=0A=
 */=0A=
function toJson(obj, pretty) {=0A=
  if (typeof obj =3D=3D=3D 'undefined') return undefined;=0A=
  return JSON.stringify(obj, toJsonReplacer, pretty ? '  ' : null);=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.fromJson=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Deserializes a JSON string.=0A=
 *=0A=
 * @param {string} json JSON string to deserialize.=0A=
 * @returns {Object|Array|string|number} Deserialized thingy.=0A=
 */=0A=
function fromJson(json) {=0A=
  return isString(json)=0A=
      ? JSON.parse(json)=0A=
      : json;=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @returns {string} Returns the string representation of the element.=0A=
 */=0A=
function startingTag(element) {=0A=
  element =3D jqLite(element).clone();=0A=
  try {=0A=
    // turns out IE does not let you set .html() on elements which=0A=
    // are not allowed to have children. So we just ignore it.=0A=
    element.empty();=0A=
  } catch(e) {}=0A=
  var elemHtml =3D jqLite('&lt;div&gt;').append(element).html();=0A=
  try {=0A=
    return element[0].nodeType =3D=3D=3D NODE_TYPE_TEXT ? =
lowercase(elemHtml) :=0A=
        elemHtml.=0A=
          match(/^(&lt;[^&gt;]+&gt;)/)[1].=0A=
          replace(/^&lt;([\w\-]+)/, function(match, nodeName) { return =
'&lt;' + lowercase(nodeName); });=0A=
  } catch(e) {=0A=
    return lowercase(elemHtml);=0A=
  }=0A=
=0A=
}=0A=
=0A=
=0A=
/////////////////////////////////////////////////=0A=
=0A=
/**=0A=
 * Tries to decode the URI component without throwing an exception.=0A=
 *=0A=
 * @private=0A=
 * @param str value potential URI component to check.=0A=
 * @returns {boolean} True if `value` can be decoded=0A=
 * with the decodeURIComponent function.=0A=
 */=0A=
function tryDecodeURIComponent(value) {=0A=
  try {=0A=
    return decodeURIComponent(value);=0A=
  } catch(e) {=0A=
    // Ignore any invalid uri component=0A=
  }=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * Parses an escaped url query string into key-value pairs.=0A=
 * @returns {Object.&lt;string,boolean|Array&gt;}=0A=
 */=0A=
function parseKeyValue(/**string*/keyValue) {=0A=
  var obj =3D {}, key_value, key;=0A=
  forEach((keyValue || "").split('&amp;'), function(keyValue) {=0A=
    if ( keyValue ) {=0A=
      key_value =3D keyValue.replace(/\+/g,'%20').split('=3D');=0A=
      key =3D tryDecodeURIComponent(key_value[0]);=0A=
      if ( isDefined(key) ) {=0A=
        var val =3D isDefined(key_value[1]) ? =
tryDecodeURIComponent(key_value[1]) : true;=0A=
        if (!hasOwnProperty.call(obj, key)) {=0A=
          obj[key] =3D val;=0A=
        } else if(isArray(obj[key])) {=0A=
          obj[key].push(val);=0A=
        } else {=0A=
          obj[key] =3D [obj[key],val];=0A=
        }=0A=
      }=0A=
    }=0A=
  });=0A=
  return obj;=0A=
}=0A=
=0A=
function toKeyValue(obj) {=0A=
  var parts =3D [];=0A=
  forEach(obj, function(value, key) {=0A=
    if (isArray(value)) {=0A=
      forEach(value, function(arrayValue) {=0A=
        parts.push(encodeUriQuery(key, true) +=0A=
                   (arrayValue =3D=3D=3D true ? '' : '=3D' + =
encodeUriQuery(arrayValue, true)));=0A=
      });=0A=
    } else {=0A=
    parts.push(encodeUriQuery(key, true) +=0A=
               (value =3D=3D=3D true ? '' : '=3D' + =
encodeUriQuery(value, true)));=0A=
    }=0A=
  });=0A=
  return parts.length ? parts.join('&amp;') : '';=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * We need our custom method because encodeURIComponent is too =
aggressive and doesn't follow=0A=
 * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set =
(pchar) allowed in path=0A=
 * segments:=0A=
 *    segment       =3D *pchar=0A=
 *    pchar         =3D unreserved / pct-encoded / sub-delims / ":" / "@"=0A=
 *    pct-encoded   =3D "%" HEXDIG HEXDIG=0A=
 *    unreserved    =3D ALPHA / DIGIT / "-" / "." / "_" / "~"=0A=
 *    sub-delims    =3D "!" / "$" / "&amp;" / "'" / "(" / ")"=0A=
 *                     / "*" / "+" / "," / ";" / "=3D"=0A=
 */=0A=
function encodeUriSegment(val) {=0A=
  return encodeUriQuery(val, true).=0A=
             replace(/%26/gi, '&amp;').=0A=
             replace(/%3D/gi, '=3D').=0A=
             replace(/%2B/gi, '+');=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * This method is intended for encoding *key* or *value* parts of query =
component. We need a custom=0A=
 * method because encodeURIComponent is too aggressive and encodes stuff =
that doesn't have to be=0A=
 * encoded per http://tools.ietf.org/html/rfc3986:=0A=
 *    query       =3D *( pchar / "/" / "?" )=0A=
 *    pchar         =3D unreserved / pct-encoded / sub-delims / ":" / "@"=0A=
 *    unreserved    =3D ALPHA / DIGIT / "-" / "." / "_" / "~"=0A=
 *    pct-encoded   =3D "%" HEXDIG HEXDIG=0A=
 *    sub-delims    =3D "!" / "$" / "&amp;" / "'" / "(" / ")"=0A=
 *                     / "*" / "+" / "," / ";" / "=3D"=0A=
 */=0A=
function encodeUriQuery(val, pctEncodeSpaces) {=0A=
  return encodeURIComponent(val).=0A=
             replace(/%40/gi, '@').=0A=
             replace(/%3A/gi, ':').=0A=
             replace(/%24/g, '$').=0A=
             replace(/%2C/gi, ',').=0A=
             replace(/%3B/gi, ';').=0A=
             replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));=0A=
}=0A=
=0A=
var ngAttrPrefixes =3D ['ng-', 'data-ng-', 'ng:', 'x-ng-'];=0A=
=0A=
function getNgAttribute(element, ngAttr) {=0A=
  var attr, i, ii =3D ngAttrPrefixes.length;=0A=
  element =3D jqLite(element);=0A=
  for (i=3D0; i&lt;ii; ++i) {=0A=
    attr =3D ngAttrPrefixes[i] + ngAttr;=0A=
    if (isString(attr =3D element.attr(attr))) {=0A=
      return attr;=0A=
    }=0A=
  }=0A=
  return null;=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngApp=0A=
 * @module ng=0A=
 *=0A=
 * @element ANY=0A=
 * @param {angular.Module} ngApp an optional application=0A=
 *   {@link angular.module module} name to load.=0A=
 * @param {boolean=3D} ngStrictDi if this attribute is present on the =
app element, the injector will be=0A=
 *   created in "strict-di" mode. This means that the application will =
fail to invoke functions which=0A=
 *   do not use explicit function annotation (and are thus unsuitable =
for minification), as described=0A=
 *   in {@link guide/di the Dependency Injection guide}, and useful =
debugging info will assist in=0A=
 *   tracking down the root of these bugs.=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * Use this directive to **auto-bootstrap** an AngularJS application. =
The `ngApp` directive=0A=
 * designates the **root element** of the application and is typically =
placed near the root element=0A=
 * of the page - e.g. on the `&lt;body&gt;` or `&lt;html&gt;` tags.=0A=
 *=0A=
 * Only one AngularJS application can be auto-bootstrapped per HTML =
document. The first `ngApp`=0A=
 * found in the document will be used to define the root element to =
auto-bootstrap as an=0A=
 * application. To run multiple applications in an HTML document you =
must manually bootstrap them using=0A=
 * {@link angular.bootstrap} instead. AngularJS applications cannot be =
nested within each other.=0A=
 *=0A=
 * You can specify an **AngularJS module** to be used as the root module =
for the application.  This=0A=
 * module will be loaded into the {@link auto.$injector} when the =
application is bootstrapped and=0A=
 * should contain the application code needed or have dependencies on =
other modules that will=0A=
 * contain the code. See {@link angular.module} for more information.=0A=
 *=0A=
 * In the example below if the `ngApp` directive were not placed on the =
`html` element then the=0A=
 * document would not be compiled, the `AppController` would not be =
instantiated and the `{{ a+b }}`=0A=
 * would not be resolved to `3`.=0A=
 *=0A=
 * `ngApp` is the easiest, and most common, way to bootstrap an =
application.=0A=
 *=0A=
 &lt;example module=3D"ngAppDemo"&gt;=0A=
   &lt;file name=3D"todoList.html"&gt;=0A=
   &lt;div ng-controller=3D"ngAppDemoController"&gt;=0A=
     I can add: {{a}} + {{b}} =3D  {{ a+b }}=0A=
   &lt;/div&gt;=0A=
   &lt;/file&gt;=0A=
   &lt;file name=3D"script.js"&gt;=0A=
   angular.module('ngAppDemo', []).controller('ngAppDemoController', =
function($scope) {=0A=
     $scope.a =3D 1;=0A=
     $scope.b =3D 2;=0A=
   });=0A=
   &lt;/file&gt;=0A=
 &lt;/example&gt;=0A=
 *=0A=
 * Using `ngStrictDi`, you would see something like this:=0A=
 *=0A=
 &lt;example ng-app-included=3D"true"&gt;=0A=
   &lt;file name=3D"todoList.html"&gt;=0A=
   &lt;div ng-app=3D"ngAppStrictDemo" ng-strict-di&gt;=0A=
       &lt;div ng-controller=3D"GoodController1"&gt;=0A=
           I can add: {{a}} + {{b}} =3D  {{ a+b }}=0A=
=0A=
           &lt;p&gt;This renders because the controller does not fail to=0A=
              instantiate, by using explicit annotation style (see=0A=
              script.js for details)=0A=
           &lt;/p&gt;=0A=
       &lt;/div&gt;=0A=
=0A=
       &lt;div ng-controller=3D"GoodController2"&gt;=0A=
           Name: &lt;input ng-model=3D"name"&gt;&lt;br /&gt;=0A=
           Hello, {{name}}!=0A=
=0A=
           &lt;p&gt;This renders because the controller does not fail to=0A=
              instantiate, by using explicit annotation style=0A=
              (see script.js for details)=0A=
           &lt;/p&gt;=0A=
       &lt;/div&gt;=0A=
=0A=
       &lt;div ng-controller=3D"BadController"&gt;=0A=
           I can add: {{a}} + {{b}} =3D  {{ a+b }}=0A=
=0A=
           &lt;p&gt;The controller could not be instantiated, due to =
relying=0A=
              on automatic function annotations (which are disabled in=0A=
              strict mode). As such, the content of this section is not=0A=
              interpolated, and there should be an error in your web =
console.=0A=
           &lt;/p&gt;=0A=
       &lt;/div&gt;=0A=
   &lt;/div&gt;=0A=
   &lt;/file&gt;=0A=
   &lt;file name=3D"script.js"&gt;=0A=
   angular.module('ngAppStrictDemo', [])=0A=
     // BadController will fail to instantiate, due to relying on =
automatic function annotation,=0A=
     // rather than an explicit annotation=0A=
     .controller('BadController', function($scope) {=0A=
       $scope.a =3D 1;=0A=
       $scope.b =3D 2;=0A=
     })=0A=
     // Unlike BadController, GoodController1 and GoodController2 will =
not fail to be instantiated,=0A=
     // due to using explicit annotations using the array style and =
$inject property, respectively.=0A=
     .controller('GoodController1', ['$scope', function($scope) {=0A=
       $scope.a =3D 1;=0A=
       $scope.b =3D 2;=0A=
     }])=0A=
     .controller('GoodController2', GoodController2);=0A=
     function GoodController2($scope) {=0A=
       $scope.name =3D "World";=0A=
     }=0A=
     GoodController2.$inject =3D ['$scope'];=0A=
   &lt;/file&gt;=0A=
   &lt;file name=3D"style.css"&gt;=0A=
   div[ng-controller] {=0A=
       margin-bottom: 1em;=0A=
       -webkit-border-radius: 4px;=0A=
       border-radius: 4px;=0A=
       border: 1px solid;=0A=
       padding: .5em;=0A=
   }=0A=
   div[ng-controller^=3DGood] {=0A=
       border-color: #d6e9c6;=0A=
       background-color: #dff0d8;=0A=
       color: #3c763d;=0A=
   }=0A=
   div[ng-controller^=3DBad] {=0A=
       border-color: #ebccd1;=0A=
       background-color: #f2dede;=0A=
       color: #a94442;=0A=
       margin-bottom: 0;=0A=
   }=0A=
   &lt;/file&gt;=0A=
 &lt;/example&gt;=0A=
 */=0A=
function angularInit(element, bootstrap) {=0A=
  var appElement,=0A=
      module,=0A=
      config =3D {};=0A=
=0A=
  // The element `element` has priority over any other element=0A=
  forEach(ngAttrPrefixes, function(prefix) {=0A=
    var name =3D prefix + 'app';=0A=
=0A=
    if (!appElement &amp;&amp; element.hasAttribute &amp;&amp; =
element.hasAttribute(name)) {=0A=
      appElement =3D element;=0A=
      module =3D element.getAttribute(name);=0A=
    }=0A=
  });=0A=
  forEach(ngAttrPrefixes, function(prefix) {=0A=
    var name =3D prefix + 'app';=0A=
    var candidate;=0A=
=0A=
    if (!appElement &amp;&amp; (candidate =3D element.querySelector('[' =
+ name.replace(':', '\\:') + ']'))) {=0A=
      appElement =3D candidate;=0A=
      module =3D candidate.getAttribute(name);=0A=
    }=0A=
  });=0A=
  if (appElement) {=0A=
    config.strictDi =3D getNgAttribute(appElement, "strict-di") !=3D=3D =
null;=0A=
    bootstrap(appElement, module ? [module] : [], config);=0A=
  }=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.bootstrap=0A=
 * @module ng=0A=
 * @description=0A=
 * Use this function to manually start up angular application.=0A=
 *=0A=
 * See: {@link guide/bootstrap Bootstrap}=0A=
 *=0A=
 * Note that Protractor based end-to-end tests cannot use this function =
to bootstrap manually.=0A=
 * They must use {@link ng.directive:ngApp ngApp}.=0A=
 *=0A=
 * Angular will detect if it has been loaded into the browser more than =
once and only allow the=0A=
 * first loaded script to be bootstrapped and will report a warning to =
the browser console for=0A=
 * each of the subsequent scripts. This prevents strange results in =
applications, where otherwise=0A=
 * multiple instances of Angular try to work on the DOM.=0A=
 *=0A=
 * ```html=0A=
 * &lt;!doctype html&gt;=0A=
 * &lt;html&gt;=0A=
 * &lt;body&gt;=0A=
 * &lt;div ng-controller=3D"WelcomeController"&gt;=0A=
 *   {{greeting}}=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * &lt;script src=3D"angular.js"&gt;&lt;/script&gt;=0A=
 * &lt;script&gt;=0A=
 *   var app =3D angular.module('demo', [])=0A=
 *   .controller('WelcomeController', function($scope) {=0A=
 *       $scope.greeting =3D 'Welcome!';=0A=
 *   });=0A=
 *   angular.bootstrap(document, ['demo']);=0A=
 * &lt;/script&gt;=0A=
 * &lt;/body&gt;=0A=
 * &lt;/html&gt;=0A=
 * ```=0A=
 *=0A=
 * @param {DOMElement} element DOM element which is the root of angular =
application.=0A=
 * @param {Array&lt;String|Function|Array&gt;=3D} modules an array of =
modules to load into the application.=0A=
 *     Each item in the array should be the name of a predefined module =
or a (DI annotated)=0A=
 *     function that will be invoked by the injector as a run block.=0A=
 *     See: {@link angular.module modules}=0A=
 * @param {Object=3D} config an object for defining configuration =
options for the application. The=0A=
 *     following keys are supported:=0A=
 *=0A=
 *     - `strictDi`: disable automatic function annotation for the =
application. This is meant to=0A=
 *       assist in finding bugs which break minified code.=0A=
 *=0A=
 * @returns {auto.$injector} Returns the newly created injector for this =
app.=0A=
 */=0A=
function bootstrap(element, modules, config) {=0A=
  if (!isObject(config)) config =3D {};=0A=
  var defaultConfig =3D {=0A=
    strictDi: false=0A=
  };=0A=
  config =3D extend(defaultConfig, config);=0A=
  var doBootstrap =3D function() {=0A=
    element =3D jqLite(element);=0A=
=0A=
    if (element.injector()) {=0A=
      var tag =3D (element[0] =3D=3D=3D document) ? 'document' : =
startingTag(element);=0A=
      //Encode angle brackets to prevent input from being sanitized to =
empty string #8683=0A=
      throw ngMinErr(=0A=
          'btstrpd',=0A=
          "App Already Bootstrapped with this Element '{0}'",=0A=
          tag.replace(/&lt;/,'&amp;lt;').replace(/&gt;/,'&amp;gt;'));=0A=
    }=0A=
=0A=
    modules =3D modules || [];=0A=
    modules.unshift(['$provide', function($provide) {=0A=
      $provide.value('$rootElement', element);=0A=
    }]);=0A=
=0A=
    if (config.debugInfoEnabled) {=0A=
      // Pushing so that this overrides `debugInfoEnabled` setting =
defined in user's `modules`.=0A=
      modules.push(['$compileProvider', function($compileProvider) {=0A=
        $compileProvider.debugInfoEnabled(true);=0A=
      }]);=0A=
    }=0A=
=0A=
    modules.unshift('ng');=0A=
    var injector =3D createInjector(modules, config.strictDi);=0A=
    injector.invoke(['$rootScope', '$rootElement', '$compile', =
'$injector',=0A=
       function bootstrapApply(scope, element, compile, injector) {=0A=
        scope.$apply(function() {=0A=
          element.data('$injector', injector);=0A=
          compile(element)(scope);=0A=
        });=0A=
      }]=0A=
    );=0A=
    return injector;=0A=
  };=0A=
=0A=
  var NG_ENABLE_DEBUG_INFO =3D /^NG_ENABLE_DEBUG_INFO!/;=0A=
  var NG_DEFER_BOOTSTRAP =3D /^NG_DEFER_BOOTSTRAP!/;=0A=
=0A=
  if (window &amp;&amp; NG_ENABLE_DEBUG_INFO.test(window.name)) {=0A=
    config.debugInfoEnabled =3D true;=0A=
    window.name =3D window.name.replace(NG_ENABLE_DEBUG_INFO, '');=0A=
  }=0A=
=0A=
  if (window &amp;&amp; !NG_DEFER_BOOTSTRAP.test(window.name)) {=0A=
    return doBootstrap();=0A=
  }=0A=
=0A=
  window.name =3D window.name.replace(NG_DEFER_BOOTSTRAP, '');=0A=
  angular.resumeBootstrap =3D function(extraModules) {=0A=
    forEach(extraModules, function(module) {=0A=
      modules.push(module);=0A=
    });=0A=
    doBootstrap();=0A=
  };=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.reloadWithDebugInfo=0A=
 * @module ng=0A=
 * @description=0A=
 * Use this function to reload the current application with debug =
information turned on.=0A=
 * This takes precedence over a call to =
`$compileProvider.debugInfoEnabled(false)`.=0A=
 *=0A=
 * See {@link ng.$compileProvider#debugInfoEnabled} for more.=0A=
 */=0A=
function reloadWithDebugInfo() {=0A=
  window.name =3D 'NG_ENABLE_DEBUG_INFO!' + window.name;=0A=
  window.location.reload();=0A=
}=0A=
=0A=
/**=0A=
 * @name angular.getTestability=0A=
 * @module ng=0A=
 * @description=0A=
 * Get the testability service for the instance of Angular on the given=0A=
 * element.=0A=
 * @param {DOMElement} element DOM element which is the root of angular =
application.=0A=
 */=0A=
function getTestability(rootElement) {=0A=
  return angular.element(rootElement).injector().get('$$testability');=0A=
}=0A=
=0A=
var SNAKE_CASE_REGEXP =3D /[A-Z]/g;=0A=
function snake_case(name, separator) {=0A=
  separator =3D separator || '_';=0A=
  return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {=0A=
    return (pos ? separator : '') + letter.toLowerCase();=0A=
  });=0A=
}=0A=
=0A=
var bindJQueryFired =3D false;=0A=
var skipDestroyOnNextJQueryCleanData;=0A=
function bindJQuery() {=0A=
  var originalCleanData;=0A=
=0A=
  if (bindJQueryFired) {=0A=
    return;=0A=
  }=0A=
=0A=
  // bind to jQuery if present;=0A=
  jQuery =3D window.jQuery;=0A=
  // Use jQuery if it exists with proper functionality, otherwise =
default to us.=0A=
  // Angular 1.2+ requires jQuery 1.7+ for on()/off() support.=0A=
  // Angular 1.3+ technically requires at least jQuery 2.1+ but it may =
work with older=0A=
  // versions. It will not work for sure with jQuery &lt;1.7, though.=0A=
  if (jQuery &amp;&amp; jQuery.fn.on) {=0A=
    jqLite =3D jQuery;=0A=
    extend(jQuery.fn, {=0A=
      scope: JQLitePrototype.scope,=0A=
      isolateScope: JQLitePrototype.isolateScope,=0A=
      controller: JQLitePrototype.controller,=0A=
      injector: JQLitePrototype.injector,=0A=
      inheritedData: JQLitePrototype.inheritedData=0A=
    });=0A=
=0A=
    // All nodes removed from the DOM via various jQuery APIs like =
.remove()=0A=
    // are passed through jQuery.cleanData. Monkey-patch this method to =
fire=0A=
    // the $destroy event on all removed nodes.=0A=
    originalCleanData =3D jQuery.cleanData;=0A=
    jQuery.cleanData =3D function(elems) {=0A=
      var events;=0A=
      if (!skipDestroyOnNextJQueryCleanData) {=0A=
        for (var i =3D 0, elem; (elem =3D elems[i]) !=3D null; i++) {=0A=
          events =3D jQuery._data(elem, "events");=0A=
          if (events &amp;&amp; events.$destroy) {=0A=
            jQuery(elem).triggerHandler('$destroy');=0A=
          }=0A=
        }=0A=
      } else {=0A=
        skipDestroyOnNextJQueryCleanData =3D false;=0A=
      }=0A=
      originalCleanData(elems);=0A=
    };=0A=
  } else {=0A=
    jqLite =3D JQLite;=0A=
  }=0A=
=0A=
  angular.element =3D jqLite;=0A=
=0A=
  // Prevent double-proxying.=0A=
  bindJQueryFired =3D true;=0A=
}=0A=
=0A=
/**=0A=
 * throw error if the argument is falsy.=0A=
 */=0A=
function assertArg(arg, name, reason) {=0A=
  if (!arg) {=0A=
    throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), =
(reason || "required"));=0A=
  }=0A=
  return arg;=0A=
}=0A=
=0A=
function assertArgFn(arg, name, acceptArrayAnnotation) {=0A=
  if (acceptArrayAnnotation &amp;&amp; isArray(arg)) {=0A=
      arg =3D arg[arg.length - 1];=0A=
  }=0A=
=0A=
  assertArg(isFunction(arg), name, 'not a function, got ' +=0A=
      (arg &amp;&amp; typeof arg =3D=3D=3D 'object' ? =
arg.constructor.name || 'Object' : typeof arg));=0A=
  return arg;=0A=
}=0A=
=0A=
/**=0A=
 * throw error if the name given is hasOwnProperty=0A=
 * @param  {String} name    the name to test=0A=
 * @param  {String} context the context in which the name is used, such =
as module or directive=0A=
 */=0A=
function assertNotHasOwnProperty(name, context) {=0A=
  if (name =3D=3D=3D 'hasOwnProperty') {=0A=
    throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", =
context);=0A=
  }=0A=
}=0A=
=0A=
/**=0A=
 * Return the value accessible from the object by path. Any undefined =
traversals are ignored=0A=
 * @param {Object} obj starting object=0A=
 * @param {String} path path to traverse=0A=
 * @param {boolean} [bindFnToScope=3Dtrue]=0A=
 * @returns {Object} value as accessible by path=0A=
 */=0A=
//TODO(misko): this function needs to be removed=0A=
function getter(obj, path, bindFnToScope) {=0A=
  if (!path) return obj;=0A=
  var keys =3D path.split('.');=0A=
  var key;=0A=
  var lastInstance =3D obj;=0A=
  var len =3D keys.length;=0A=
=0A=
  for (var i =3D 0; i &lt; len; i++) {=0A=
    key =3D keys[i];=0A=
    if (obj) {=0A=
      obj =3D (lastInstance =3D obj)[key];=0A=
    }=0A=
  }=0A=
  if (!bindFnToScope &amp;&amp; isFunction(obj)) {=0A=
    return bind(lastInstance, obj);=0A=
  }=0A=
  return obj;=0A=
}=0A=
=0A=
/**=0A=
 * Return the DOM siblings between the first and last node in the given =
array.=0A=
 * @param {Array} array like object=0A=
 * @returns {jqLite} jqLite collection containing the nodes=0A=
 */=0A=
function getBlockNodes(nodes) {=0A=
  // TODO(perf): just check if all items in `nodes` are siblings and if =
they are return the original=0A=
  //             collection, otherwise update the original collection.=0A=
  var node =3D nodes[0];=0A=
  var endNode =3D nodes[nodes.length - 1];=0A=
  var blockNodes =3D [node];=0A=
=0A=
  do {=0A=
    node =3D node.nextSibling;=0A=
    if (!node) break;=0A=
    blockNodes.push(node);=0A=
  } while (node !=3D=3D endNode);=0A=
=0A=
  return jqLite(blockNodes);=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * Creates a new object without a prototype. This object is useful for =
lookup without having to=0A=
 * guard against prototypically inherited properties via hasOwnProperty.=0A=
 *=0A=
 * Related micro-benchmarks:=0A=
 * - http://jsperf.com/object-create2=0A=
 * - http://jsperf.com/proto-map-lookup/2=0A=
 * - http://jsperf.com/for-in-vs-object-keys2=0A=
 *=0A=
 * @returns {Object}=0A=
 */=0A=
function createMap() {=0A=
  return Object.create(null);=0A=
}=0A=
=0A=
var NODE_TYPE_ELEMENT =3D 1;=0A=
var NODE_TYPE_TEXT =3D 3;=0A=
var NODE_TYPE_COMMENT =3D 8;=0A=
var NODE_TYPE_DOCUMENT =3D 9;=0A=
var NODE_TYPE_DOCUMENT_FRAGMENT =3D 11;=0A=
=0A=
/**=0A=
 * @ngdoc type=0A=
 * @name angular.Module=0A=
 * @module ng=0A=
 * @description=0A=
 *=0A=
 * Interface for configuring angular {@link angular.module modules}.=0A=
 */=0A=
=0A=
function setupModuleLoader(window) {=0A=
=0A=
  var $injectorMinErr =3D minErr('$injector');=0A=
  var ngMinErr =3D minErr('ng');=0A=
=0A=
  function ensure(obj, name, factory) {=0A=
    return obj[name] || (obj[name] =3D factory());=0A=
  }=0A=
=0A=
  var angular =3D ensure(window, 'angular', Object);=0A=
=0A=
  // We need to expose `angular.$$minErr` to modules such as =
`ngResource` that reference it during bootstrap=0A=
  angular.$$minErr =3D angular.$$minErr || minErr;=0A=
=0A=
  return ensure(angular, 'module', function() {=0A=
    /** @type {Object.&lt;string, angular.Module&gt;} */=0A=
    var modules =3D {};=0A=
=0A=
    /**=0A=
     * @ngdoc function=0A=
     * @name angular.module=0A=
     * @module ng=0A=
     * @description=0A=
     *=0A=
     * The `angular.module` is a global place for creating, registering =
and retrieving Angular=0A=
     * modules.=0A=
     * All modules (angular core or 3rd party) that should be available =
to an application must be=0A=
     * registered using this mechanism.=0A=
     *=0A=
     * When passed two or more arguments, a new module is created.  If =
passed only one argument, an=0A=
     * existing module (the name passed as the first argument to =
`module`) is retrieved.=0A=
     *=0A=
     *=0A=
     * # Module=0A=
     *=0A=
     * A module is a collection of services, directives, controllers, =
filters, and configuration information.=0A=
     * `angular.module` is used to configure the {@link auto.$injector =
$injector}.=0A=
     *=0A=
     * ```js=0A=
     * // Create a new module=0A=
     * var myModule =3D angular.module('myModule', []);=0A=
     *=0A=
     * // register a new service=0A=
     * myModule.value('appName', 'MyCoolApp');=0A=
     *=0A=
     * // configure existing services inside initialization blocks.=0A=
     * myModule.config(['$locationProvider', function($locationProvider) =
{=0A=
     *   // Configure existing providers=0A=
     *   $locationProvider.hashPrefix('!');=0A=
     * }]);=0A=
     * ```=0A=
     *=0A=
     * Then you can create an injector and load your modules like this:=0A=
     *=0A=
     * ```js=0A=
     * var injector =3D angular.injector(['ng', 'myModule'])=0A=
     * ```=0A=
     *=0A=
     * However it's more likely that you'll just use=0A=
     * {@link ng.directive:ngApp ngApp} or=0A=
     * {@link angular.bootstrap} to simplify this process for you.=0A=
     *=0A=
     * @param {!string} name The name of the module to create or =
retrieve.=0A=
     * @param {!Array.&lt;string&gt;=3D} requires If specified then new =
module is being created. If=0A=
     *        unspecified then the module is being retrieved for further =
configuration.=0A=
     * @param {Function=3D} configFn Optional configuration function for =
the module. Same as=0A=
     *        {@link angular.Module#config Module#config()}.=0A=
     * @returns {module} new module with the {@link angular.Module} api.=0A=
     */=0A=
    return function module(name, requires, configFn) {=0A=
      var assertNotHasOwnProperty =3D function(name, context) {=0A=
        if (name =3D=3D=3D 'hasOwnProperty') {=0A=
          throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} =
name', context);=0A=
        }=0A=
      };=0A=
=0A=
      assertNotHasOwnProperty(name, 'module');=0A=
      if (requires &amp;&amp; modules.hasOwnProperty(name)) {=0A=
        modules[name] =3D null;=0A=
      }=0A=
      return ensure(modules, name, function() {=0A=
        if (!requires) {=0A=
          throw $injectorMinErr('nomod', "Module '{0}' is not available! =
You either misspelled " +=0A=
             "the module name or forgot to load it. If registering a =
module ensure that you " +=0A=
             "specify the dependencies as the second argument.", name);=0A=
        }=0A=
=0A=
        /** @type {!Array.&lt;Array.&lt;*&gt;&gt;} */=0A=
        var invokeQueue =3D [];=0A=
=0A=
        /** @type {!Array.&lt;Function&gt;} */=0A=
        var configBlocks =3D [];=0A=
=0A=
        /** @type {!Array.&lt;Function&gt;} */=0A=
        var runBlocks =3D [];=0A=
=0A=
        var config =3D invokeLater('$injector', 'invoke', 'push', =
configBlocks);=0A=
=0A=
        /** @type {angular.Module} */=0A=
        var moduleInstance =3D {=0A=
          // Private state=0A=
          _invokeQueue: invokeQueue,=0A=
          _configBlocks: configBlocks,=0A=
          _runBlocks: runBlocks,=0A=
=0A=
          /**=0A=
           * @ngdoc property=0A=
           * @name angular.Module#requires=0A=
           * @module ng=0A=
           *=0A=
           * @description=0A=
           * Holds the list of modules which the injector will load =
before the current module is=0A=
           * loaded.=0A=
           */=0A=
          requires: requires,=0A=
=0A=
          /**=0A=
           * @ngdoc property=0A=
           * @name angular.Module#name=0A=
           * @module ng=0A=
           *=0A=
           * @description=0A=
           * Name of the module.=0A=
           */=0A=
          name: name,=0A=
=0A=
=0A=
          /**=0A=
           * @ngdoc method=0A=
           * @name angular.Module#provider=0A=
           * @module ng=0A=
           * @param {string} name service name=0A=
           * @param {Function} providerType Construction function for =
creating new instance of the=0A=
           *                                service.=0A=
           * @description=0A=
           * See {@link auto.$provide#provider $provide.provider()}.=0A=
           */=0A=
          provider: invokeLater('$provide', 'provider'),=0A=
=0A=
          /**=0A=
           * @ngdoc method=0A=
           * @name angular.Module#factory=0A=
           * @module ng=0A=
           * @param {string} name service name=0A=
           * @param {Function} providerFunction Function for creating =
new instance of the service.=0A=
           * @description=0A=
           * See {@link auto.$provide#factory $provide.factory()}.=0A=
           */=0A=
          factory: invokeLater('$provide', 'factory'),=0A=
=0A=
          /**=0A=
           * @ngdoc method=0A=
           * @name angular.Module#service=0A=
           * @module ng=0A=
           * @param {string} name service name=0A=
           * @param {Function} constructor A constructor function that =
will be instantiated.=0A=
           * @description=0A=
           * See {@link auto.$provide#service $provide.service()}.=0A=
           */=0A=
          service: invokeLater('$provide', 'service'),=0A=
=0A=
          /**=0A=
           * @ngdoc method=0A=
           * @name angular.Module#value=0A=
           * @module ng=0A=
           * @param {string} name service name=0A=
           * @param {*} object Service instance object.=0A=
           * @description=0A=
           * See {@link auto.$provide#value $provide.value()}.=0A=
           */=0A=
          value: invokeLater('$provide', 'value'),=0A=
=0A=
          /**=0A=
           * @ngdoc method=0A=
           * @name angular.Module#constant=0A=
           * @module ng=0A=
           * @param {string} name constant name=0A=
           * @param {*} object Constant value.=0A=
           * @description=0A=
           * Because the constant are fixed, they get applied before =
other provide methods.=0A=
           * See {@link auto.$provide#constant $provide.constant()}.=0A=
           */=0A=
          constant: invokeLater('$provide', 'constant', 'unshift'),=0A=
=0A=
          /**=0A=
           * @ngdoc method=0A=
           * @name angular.Module#animation=0A=
           * @module ng=0A=
           * @param {string} name animation name=0A=
           * @param {Function} animationFactory Factory function for =
creating new instance of an=0A=
           *                                    animation.=0A=
           * @description=0A=
           *=0A=
           * **NOTE**: animations take effect only if the **ngAnimate** =
module is loaded.=0A=
           *=0A=
           *=0A=
           * Defines an animation hook that can be later used with=0A=
           * {@link ngAnimate.$animate $animate} service and directives =
that use this service.=0A=
           *=0A=
           * ```js=0A=
           * module.animation('.animation-name', function($inject1, =
$inject2) {=0A=
           *   return {=0A=
           *     eventName : function(element, done) {=0A=
           *       //code to run the animation=0A=
           *       //once complete, then run done()=0A=
           *       return function cancellationFunction(element) {=0A=
           *         //code to cancel the animation=0A=
           *       }=0A=
           *     }=0A=
           *   }=0A=
           * })=0A=
           * ```=0A=
           *=0A=
           * See {@link ng.$animateProvider#register =
$animateProvider.register()} and=0A=
           * {@link ngAnimate ngAnimate module} for more information.=0A=
           */=0A=
          animation: invokeLater('$animateProvider', 'register'),=0A=
=0A=
          /**=0A=
           * @ngdoc method=0A=
           * @name angular.Module#filter=0A=
           * @module ng=0A=
           * @param {string} name Filter name.=0A=
           * @param {Function} filterFactory Factory function for =
creating new instance of filter.=0A=
           * @description=0A=
           * See {@link ng.$filterProvider#register =
$filterProvider.register()}.=0A=
           */=0A=
          filter: invokeLater('$filterProvider', 'register'),=0A=
=0A=
          /**=0A=
           * @ngdoc method=0A=
           * @name angular.Module#controller=0A=
           * @module ng=0A=
           * @param {string|Object} name Controller name, or an object =
map of controllers where the=0A=
           *    keys are the names and the values are the constructors.=0A=
           * @param {Function} constructor Controller constructor =
function.=0A=
           * @description=0A=
           * See {@link ng.$controllerProvider#register =
$controllerProvider.register()}.=0A=
           */=0A=
          controller: invokeLater('$controllerProvider', 'register'),=0A=
=0A=
          /**=0A=
           * @ngdoc method=0A=
           * @name angular.Module#directive=0A=
           * @module ng=0A=
           * @param {string|Object} name Directive name, or an object =
map of directives where the=0A=
           *    keys are the names and the values are the factories.=0A=
           * @param {Function} directiveFactory Factory function for =
creating new instance of=0A=
           * directives.=0A=
           * @description=0A=
           * See {@link ng.$compileProvider#directive =
$compileProvider.directive()}.=0A=
           */=0A=
          directive: invokeLater('$compileProvider', 'directive'),=0A=
=0A=
          /**=0A=
           * @ngdoc method=0A=
           * @name angular.Module#config=0A=
           * @module ng=0A=
           * @param {Function} configFn Execute this function on module =
load. Useful for service=0A=
           *    configuration.=0A=
           * @description=0A=
           * Use this method to register work which needs to be =
performed on module loading.=0A=
           * For more about how to configure services, see=0A=
           * {@link providers#provider-recipe Provider Recipe}.=0A=
           */=0A=
          config: config,=0A=
=0A=
          /**=0A=
           * @ngdoc method=0A=
           * @name angular.Module#run=0A=
           * @module ng=0A=
           * @param {Function} initializationFn Execute this function =
after injector creation.=0A=
           *    Useful for application initialization.=0A=
           * @description=0A=
           * Use this method to register work which should be performed =
when the injector is done=0A=
           * loading all modules.=0A=
           */=0A=
          run: function(block) {=0A=
            runBlocks.push(block);=0A=
            return this;=0A=
          }=0A=
        };=0A=
=0A=
        if (configFn) {=0A=
          config(configFn);=0A=
        }=0A=
=0A=
        return  moduleInstance;=0A=
=0A=
        /**=0A=
         * @param {string} provider=0A=
         * @param {string} method=0A=
         * @param {String=3D} insertMethod=0A=
         * @returns {angular.Module}=0A=
         */=0A=
        function invokeLater(provider, method, insertMethod, queue) {=0A=
          if (!queue) queue =3D invokeQueue;=0A=
          return function() {=0A=
            queue[insertMethod || 'push']([provider, method, arguments]);=0A=
            return moduleInstance;=0A=
          };=0A=
        }=0A=
      });=0A=
    };=0A=
  });=0A=
=0A=
}=0A=
=0A=
/* global angularModule: true,=0A=
  version: true,=0A=
=0A=
  $LocaleProvider,=0A=
  $CompileProvider,=0A=
=0A=
  htmlAnchorDirective,=0A=
  inputDirective,=0A=
  inputDirective,=0A=
  formDirective,=0A=
  scriptDirective,=0A=
  selectDirective,=0A=
  styleDirective,=0A=
  optionDirective,=0A=
  ngBindDirective,=0A=
  ngBindHtmlDirective,=0A=
  ngBindTemplateDirective,=0A=
  ngClassDirective,=0A=
  ngClassEvenDirective,=0A=
  ngClassOddDirective,=0A=
  ngCspDirective,=0A=
  ngCloakDirective,=0A=
  ngControllerDirective,=0A=
  ngFormDirective,=0A=
  ngHideDirective,=0A=
  ngIfDirective,=0A=
  ngIncludeDirective,=0A=
  ngIncludeFillContentDirective,=0A=
  ngInitDirective,=0A=
  ngNonBindableDirective,=0A=
  ngPluralizeDirective,=0A=
  ngRepeatDirective,=0A=
  ngShowDirective,=0A=
  ngStyleDirective,=0A=
  ngSwitchDirective,=0A=
  ngSwitchWhenDirective,=0A=
  ngSwitchDefaultDirective,=0A=
  ngOptionsDirective,=0A=
  ngTranscludeDirective,=0A=
  ngModelDirective,=0A=
  ngListDirective,=0A=
  ngChangeDirective,=0A=
  patternDirective,=0A=
  patternDirective,=0A=
  requiredDirective,=0A=
  requiredDirective,=0A=
  minlengthDirective,=0A=
  minlengthDirective,=0A=
  maxlengthDirective,=0A=
  maxlengthDirective,=0A=
  ngValueDirective,=0A=
  ngModelOptionsDirective,=0A=
  ngAttributeAliasDirectives,=0A=
  ngEventDirectives,=0A=
=0A=
  $AnchorScrollProvider,=0A=
  $AnimateProvider,=0A=
  $BrowserProvider,=0A=
  $CacheFactoryProvider,=0A=
  $ControllerProvider,=0A=
  $DocumentProvider,=0A=
  $ExceptionHandlerProvider,=0A=
  $FilterProvider,=0A=
  $InterpolateProvider,=0A=
  $IntervalProvider,=0A=
  $HttpProvider,=0A=
  $HttpBackendProvider,=0A=
  $LocationProvider,=0A=
  $LogProvider,=0A=
  $ParseProvider,=0A=
  $RootScopeProvider,=0A=
  $QProvider,=0A=
  $$QProvider,=0A=
  $$SanitizeUriProvider,=0A=
  $SceProvider,=0A=
  $SceDelegateProvider,=0A=
  $SnifferProvider,=0A=
  $TemplateCacheProvider,=0A=
  $TemplateRequestProvider,=0A=
  $$TestabilityProvider,=0A=
  $TimeoutProvider,=0A=
  $$RAFProvider,=0A=
  $$AsyncCallbackProvider,=0A=
  $WindowProvider=0A=
*/=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc object=0A=
 * @name angular.version=0A=
 * @module ng=0A=
 * @description=0A=
 * An object that contains information about the current AngularJS =
version. This object has the=0A=
 * following properties:=0A=
 *=0A=
 * - `full` =E2=80&#65533; `{string}` =E2=80&#65533; Full version =
string, such as "0.9.18".=0A=
 * - `major` =E2=80&#65533; `{number}` =E2=80&#65533; Major version =
number, such as "0".=0A=
 * - `minor` =E2=80&#65533; `{number}` =E2=80&#65533; Minor version =
number, such as "9".=0A=
 * - `dot` =E2=80&#65533; `{number}` =E2=80&#65533; Dot version number, =
such as "18".=0A=
 * - `codeName` =E2=80&#65533; `{string}` =E2=80&#65533; Code name of =
the release, such as "jiggling-armfat".=0A=
 */=0A=
var version =3D {=0A=
  full: '1.3.0',    // all of these placeholder strings will be replaced =
by grunt's=0A=
  major: 1,    // package task=0A=
  minor: 3,=0A=
  dot: 0,=0A=
  codeName: 'superluminal-nudge'=0A=
};=0A=
=0A=
=0A=
function publishExternalAPI(angular){=0A=
  extend(angular, {=0A=
    'bootstrap': bootstrap,=0A=
    'copy': copy,=0A=
    'extend': extend,=0A=
    'equals': equals,=0A=
    'element': jqLite,=0A=
    'forEach': forEach,=0A=
    'injector': createInjector,=0A=
    'noop': noop,=0A=
    'bind': bind,=0A=
    'toJson': toJson,=0A=
    'fromJson': fromJson,=0A=
    'identity': identity,=0A=
    'isUndefined': isUndefined,=0A=
    'isDefined': isDefined,=0A=
    'isString': isString,=0A=
    'isFunction': isFunction,=0A=
    'isObject': isObject,=0A=
    'isNumber': isNumber,=0A=
    'isElement': isElement,=0A=
    'isArray': isArray,=0A=
    'version': version,=0A=
    'isDate': isDate,=0A=
    'lowercase': lowercase,=0A=
    'uppercase': uppercase,=0A=
    'callbacks': {counter: 0},=0A=
    'getTestability': getTestability,=0A=
    '$$minErr': minErr,=0A=
    '$$csp': csp,=0A=
    'reloadWithDebugInfo': reloadWithDebugInfo=0A=
  });=0A=
=0A=
  angularModule =3D setupModuleLoader(window);=0A=
  try {=0A=
    angularModule('ngLocale');=0A=
  } catch (e) {=0A=
    angularModule('ngLocale', []).provider('$locale', $LocaleProvider);=0A=
  }=0A=
=0A=
  angularModule('ng', ['ngLocale'], ['$provide',=0A=
    function ngModule($provide) {=0A=
      // $$sanitizeUriProvider needs to be before $compileProvider as it =
is used by it.=0A=
      $provide.provider({=0A=
        $$sanitizeUri: $$SanitizeUriProvider=0A=
      });=0A=
      $provide.provider('$compile', $CompileProvider).=0A=
        directive({=0A=
            a: htmlAnchorDirective,=0A=
            input: inputDirective,=0A=
            textarea: inputDirective,=0A=
            form: formDirective,=0A=
            script: scriptDirective,=0A=
            select: selectDirective,=0A=
            style: styleDirective,=0A=
            option: optionDirective,=0A=
            ngBind: ngBindDirective,=0A=
            ngBindHtml: ngBindHtmlDirective,=0A=
            ngBindTemplate: ngBindTemplateDirective,=0A=
            ngClass: ngClassDirective,=0A=
            ngClassEven: ngClassEvenDirective,=0A=
            ngClassOdd: ngClassOddDirective,=0A=
            ngCloak: ngCloakDirective,=0A=
            ngController: ngControllerDirective,=0A=
            ngForm: ngFormDirective,=0A=
            ngHide: ngHideDirective,=0A=
            ngIf: ngIfDirective,=0A=
            ngInclude: ngIncludeDirective,=0A=
            ngInit: ngInitDirective,=0A=
            ngNonBindable: ngNonBindableDirective,=0A=
            ngPluralize: ngPluralizeDirective,=0A=
            ngRepeat: ngRepeatDirective,=0A=
            ngShow: ngShowDirective,=0A=
            ngStyle: ngStyleDirective,=0A=
            ngSwitch: ngSwitchDirective,=0A=
            ngSwitchWhen: ngSwitchWhenDirective,=0A=
            ngSwitchDefault: ngSwitchDefaultDirective,=0A=
            ngOptions: ngOptionsDirective,=0A=
            ngTransclude: ngTranscludeDirective,=0A=
            ngModel: ngModelDirective,=0A=
            ngList: ngListDirective,=0A=
            ngChange: ngChangeDirective,=0A=
            pattern: patternDirective,=0A=
            ngPattern: patternDirective,=0A=
            required: requiredDirective,=0A=
            ngRequired: requiredDirective,=0A=
            minlength: minlengthDirective,=0A=
            ngMinlength: minlengthDirective,=0A=
            maxlength: maxlengthDirective,=0A=
            ngMaxlength: maxlengthDirective,=0A=
            ngValue: ngValueDirective,=0A=
            ngModelOptions: ngModelOptionsDirective=0A=
        }).=0A=
        directive({=0A=
          ngInclude: ngIncludeFillContentDirective=0A=
        }).=0A=
        directive(ngAttributeAliasDirectives).=0A=
        directive(ngEventDirectives);=0A=
      $provide.provider({=0A=
        $anchorScroll: $AnchorScrollProvider,=0A=
        $animate: $AnimateProvider,=0A=
        $browser: $BrowserProvider,=0A=
        $cacheFactory: $CacheFactoryProvider,=0A=
        $controller: $ControllerProvider,=0A=
        $document: $DocumentProvider,=0A=
        $exceptionHandler: $ExceptionHandlerProvider,=0A=
        $filter: $FilterProvider,=0A=
        $interpolate: $InterpolateProvider,=0A=
        $interval: $IntervalProvider,=0A=
        $http: $HttpProvider,=0A=
        $httpBackend: $HttpBackendProvider,=0A=
        $location: $LocationProvider,=0A=
        $log: $LogProvider,=0A=
        $parse: $ParseProvider,=0A=
        $rootScope: $RootScopeProvider,=0A=
        $q: $QProvider,=0A=
        $$q: $$QProvider,=0A=
        $sce: $SceProvider,=0A=
        $sceDelegate: $SceDelegateProvider,=0A=
        $sniffer: $SnifferProvider,=0A=
        $templateCache: $TemplateCacheProvider,=0A=
        $templateRequest: $TemplateRequestProvider,=0A=
        $$testability: $$TestabilityProvider,=0A=
        $timeout: $TimeoutProvider,=0A=
        $window: $WindowProvider,=0A=
        $$rAF: $$RAFProvider,=0A=
        $$asyncCallback : $$AsyncCallbackProvider=0A=
      });=0A=
    }=0A=
  ]);=0A=
}=0A=
=0A=
/* global JQLitePrototype: true,=0A=
  addEventListenerFn: true,=0A=
  removeEventListenerFn: true,=0A=
  BOOLEAN_ATTR: true,=0A=
  ALIASED_ATTR: true,=0A=
*/=0A=
=0A=
//////////////////////////////////=0A=
//JQLite=0A=
//////////////////////////////////=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @name angular.element=0A=
 * @module ng=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Wraps a raw DOM element or HTML string as a =
[jQuery](http://jquery.com) element.=0A=
 *=0A=
 * If jQuery is available, `angular.element` is an alias for the=0A=
 * [jQuery](http://api.jquery.com/jQuery/) function. If jQuery is not =
available, `angular.element`=0A=
 * delegates to Angular's built-in subset of jQuery, called "jQuery =
lite" or "jqLite."=0A=
 *=0A=
 * &lt;div class=3D"alert alert-success"&gt;jqLite is a tiny, =
API-compatible subset of jQuery that allows=0A=
 * Angular to manipulate the DOM in a cross-browser compatible way. =
**jqLite** implements only the most=0A=
 * commonly needed functionality with the goal of having a very small =
footprint.&lt;/div&gt;=0A=
 *=0A=
 * To use jQuery, simply load it before `DOMContentLoaded` event fired.=0A=
 *=0A=
 * &lt;div class=3D"alert"&gt;**Note:** all element references in =
Angular are always wrapped with jQuery or=0A=
 * jqLite; they are never raw DOM references.&lt;/div&gt;=0A=
 *=0A=
 * ## Angular's jqLite=0A=
 * jqLite provides only the following jQuery methods:=0A=
 *=0A=
 * - [`addClass()`](http://api.jquery.com/addClass/)=0A=
 * - [`after()`](http://api.jquery.com/after/)=0A=
 * - [`append()`](http://api.jquery.com/append/)=0A=
 * - [`attr()`](http://api.jquery.com/attr/) - Does not support =
functions as parameters=0A=
 * - [`bind()`](http://api.jquery.com/bind/) - Does not support =
namespaces, selectors or eventData=0A=
 * - [`children()`](http://api.jquery.com/children/) - Does not support =
selectors=0A=
 * - [`clone()`](http://api.jquery.com/clone/)=0A=
 * - [`contents()`](http://api.jquery.com/contents/)=0A=
 * - [`css()`](http://api.jquery.com/css/) - Only retrieves =
inline-styles, does not call `getComputedStyles()`=0A=
 * - [`data()`](http://api.jquery.com/data/)=0A=
 * - [`detach()`](http://api.jquery.com/detach/)=0A=
 * - [`empty()`](http://api.jquery.com/empty/)=0A=
 * - [`eq()`](http://api.jquery.com/eq/)=0A=
 * - [`find()`](http://api.jquery.com/find/) - Limited to lookups by tag =
name=0A=
 * - [`hasClass()`](http://api.jquery.com/hasClass/)=0A=
 * - [`html()`](http://api.jquery.com/html/)=0A=
 * - [`next()`](http://api.jquery.com/next/) - Does not support selectors=0A=
 * - [`on()`](http://api.jquery.com/on/) - Does not support namespaces, =
selectors or eventData=0A=
 * - [`off()`](http://api.jquery.com/off/) - Does not support namespaces =
or selectors=0A=
 * - [`one()`](http://api.jquery.com/one/) - Does not support namespaces =
or selectors=0A=
 * - [`parent()`](http://api.jquery.com/parent/) - Does not support =
selectors=0A=
 * - [`prepend()`](http://api.jquery.com/prepend/)=0A=
 * - [`prop()`](http://api.jquery.com/prop/)=0A=
 * - [`ready()`](http://api.jquery.com/ready/)=0A=
 * - [`remove()`](http://api.jquery.com/remove/)=0A=
 * - [`removeAttr()`](http://api.jquery.com/removeAttr/)=0A=
 * - [`removeClass()`](http://api.jquery.com/removeClass/)=0A=
 * - [`removeData()`](http://api.jquery.com/removeData/)=0A=
 * - [`replaceWith()`](http://api.jquery.com/replaceWith/)=0A=
 * - [`text()`](http://api.jquery.com/text/)=0A=
 * - [`toggleClass()`](http://api.jquery.com/toggleClass/)=0A=
 * - [`triggerHandler()`](http://api.jquery.com/triggerHandler/) - =
Passes a dummy event object to handlers.=0A=
 * - [`unbind()`](http://api.jquery.com/unbind/) - Does not support =
namespaces=0A=
 * - [`val()`](http://api.jquery.com/val/)=0A=
 * - [`wrap()`](http://api.jquery.com/wrap/)=0A=
 *=0A=
 * ## jQuery/jqLite Extras=0A=
 * Angular also provides the following additional methods and events to =
both jQuery and jqLite:=0A=
 *=0A=
 * ### Events=0A=
 * - `$destroy` - AngularJS intercepts all jqLite/jQuery's DOM =
destruction apis and fires this event=0A=
 *    on all DOM nodes being removed.  This can be used to clean up any =
3rd party bindings to the DOM=0A=
 *    element before it is removed.=0A=
 *=0A=
 * ### Methods=0A=
 * - `controller(name)` - retrieves the controller of the current =
element or its parent. By default=0A=
 *   retrieves controller associated with the `ngController` directive. =
If `name` is provided as=0A=
 *   camelCase directive name, then the controller for this directive =
will be retrieved (e.g.=0A=
 *   `'ngModel'`).=0A=
 * - `injector()` - retrieves the injector of the current element or its =
parent.=0A=
 * - `scope()` - retrieves the {@link ng.$rootScope.Scope scope} of the =
current=0A=
 *   element or its parent.=0A=
 * - `isolateScope()` - retrieves an isolate {@link ng.$rootScope.Scope =
scope} if one is attached directly to the=0A=
 *   current element. This getter should be used only on elements that =
contain a directive which starts a new isolate=0A=
 *   scope. Calling `scope()` on this element always returns the =
original non-isolate scope.=0A=
 * - `inheritedData()` - same as `data()`, but walks up the DOM until a =
value is found or the top=0A=
 *   parent element is reached.=0A=
 *=0A=
 * @param {string|DOMElement} element HTML string or DOMElement to be =
wrapped into jQuery.=0A=
 * @returns {Object} jQuery object.=0A=
 */=0A=
=0A=
JQLite.expando =3D 'ng339';=0A=
=0A=
var jqCache =3D JQLite.cache =3D {},=0A=
    jqId =3D 1,=0A=
    addEventListenerFn =3D function(element, type, fn) {=0A=
      element.addEventListener(type, fn, false);=0A=
    },=0A=
    removeEventListenerFn =3D function(element, type, fn) {=0A=
      element.removeEventListener(type, fn, false);=0A=
    };=0A=
=0A=
/*=0A=
 * !!! This is an undocumented "private" function !!!=0A=
 */=0A=
JQLite._data =3D function(node) {=0A=
  //jQuery always returns an object on cache miss=0A=
  return this.cache[node[this.expando]] || {};=0A=
};=0A=
=0A=
function jqNextId() { return ++jqId; }=0A=
=0A=
=0A=
var SPECIAL_CHARS_REGEXP =3D /([\:\-\_]+(.))/g;=0A=
var MOZ_HACK_REGEXP =3D /^moz([A-Z])/;=0A=
var MOUSE_EVENT_MAP=3D { mouseleave : "mouseout", mouseenter : =
"mouseover"};=0A=
var jqLiteMinErr =3D minErr('jqLite');=0A=
=0A=
/**=0A=
 * Converts snake_case to camelCase.=0A=
 * Also there is special case for Moz prefix starting with upper case =
letter.=0A=
 * @param name Name to normalize=0A=
 */=0A=
function camelCase(name) {=0A=
  return name.=0A=
    replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) =
{=0A=
      return offset ? letter.toUpperCase() : letter;=0A=
    }).=0A=
    replace(MOZ_HACK_REGEXP, 'Moz$1');=0A=
}=0A=
=0A=
var SINGLE_TAG_REGEXP =3D /^&lt;(\w+)\s*\/?&gt;(?:&lt;\/\1&gt;|)$/;=0A=
var HTML_REGEXP =3D /&lt;|&amp;#?\w+;/;=0A=
var TAG_NAME_REGEXP =3D /&lt;([\w:]+)/;=0A=
var XHTML_TAG_REGEXP =3D =
/&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^&gt;]*)=
\/&gt;/gi;=0A=
=0A=
var wrapMap =3D {=0A=
  'option': [1, '&lt;select multiple=3D"multiple"&gt;', =
'&lt;/select&gt;'],=0A=
=0A=
  'thead': [1, '&lt;table&gt;', '&lt;/table&gt;'],=0A=
  'col': [2, '&lt;table&gt;&lt;colgroup&gt;', =
'&lt;/colgroup&gt;&lt;/table&gt;'],=0A=
  'tr': [2, '&lt;table&gt;&lt;tbody&gt;', =
'&lt;/tbody&gt;&lt;/table&gt;'],=0A=
  'td': [3, '&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;', =
'&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;'],=0A=
  '_default': [0, "", ""]=0A=
};=0A=
=0A=
wrapMap.optgroup =3D wrapMap.option;=0A=
wrapMap.tbody =3D wrapMap.tfoot =3D wrapMap.colgroup =3D wrapMap.caption =
=3D wrapMap.thead;=0A=
wrapMap.th =3D wrapMap.td;=0A=
=0A=
=0A=
function jqLiteIsTextNode(html) {=0A=
  return !HTML_REGEXP.test(html);=0A=
}=0A=
=0A=
function jqLiteAcceptsData(node) {=0A=
  // The window object can accept data but has no nodeType=0A=
  // Otherwise we are only interested in elements (1) and documents (9)=0A=
  var nodeType =3D node.nodeType;=0A=
  return nodeType =3D=3D=3D NODE_TYPE_ELEMENT || !nodeType || nodeType =
=3D=3D=3D NODE_TYPE_DOCUMENT;=0A=
}=0A=
=0A=
function jqLiteBuildFragment(html, context) {=0A=
  var tmp, tag, wrap,=0A=
      fragment =3D context.createDocumentFragment(),=0A=
      nodes =3D [], i;=0A=
=0A=
  if (jqLiteIsTextNode(html)) {=0A=
    // Convert non-html into a text node=0A=
    nodes.push(context.createTextNode(html));=0A=
  } else {=0A=
    // Convert html into DOM nodes=0A=
    tmp =3D tmp || fragment.appendChild(context.createElement("div"));=0A=
    tag =3D (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();=0A=
    wrap =3D wrapMap[tag] || wrapMap._default;=0A=
    tmp.innerHTML =3D wrap[1] + html.replace(XHTML_TAG_REGEXP, =
"&lt;$1&gt;&lt;/$2&gt;") + wrap[2];=0A=
=0A=
    // Descend through wrappers to the right content=0A=
    i =3D wrap[0];=0A=
    while (i--) {=0A=
      tmp =3D tmp.lastChild;=0A=
    }=0A=
=0A=
    nodes =3D concat(nodes, tmp.childNodes);=0A=
=0A=
    tmp =3D fragment.firstChild;=0A=
    tmp.textContent =3D "";=0A=
  }=0A=
=0A=
  // Remove wrapper from fragment=0A=
  fragment.textContent =3D "";=0A=
  fragment.innerHTML =3D ""; // Clear inner HTML=0A=
  forEach(nodes, function(node) {=0A=
    fragment.appendChild(node);=0A=
  });=0A=
=0A=
  return fragment;=0A=
}=0A=
=0A=
function jqLiteParseHTML(html, context) {=0A=
  context =3D context || document;=0A=
  var parsed;=0A=
=0A=
  if ((parsed =3D SINGLE_TAG_REGEXP.exec(html))) {=0A=
    return [context.createElement(parsed[1])];=0A=
  }=0A=
=0A=
  if ((parsed =3D jqLiteBuildFragment(html, context))) {=0A=
    return parsed.childNodes;=0A=
  }=0A=
=0A=
  return [];=0A=
}=0A=
=0A=
/////////////////////////////////////////////=0A=
function JQLite(element) {=0A=
  if (element instanceof JQLite) {=0A=
    return element;=0A=
  }=0A=
=0A=
  var argIsString;=0A=
=0A=
  if (isString(element)) {=0A=
    element =3D trim(element);=0A=
    argIsString =3D true;=0A=
  }=0A=
  if (!(this instanceof JQLite)) {=0A=
    if (argIsString &amp;&amp; element.charAt(0) !=3D '&lt;') {=0A=
      throw jqLiteMinErr('nosel', 'Looking up elements via selectors is =
not supported by jqLite! See: =
http://docs.angularjs.org/api/angular.element');=0A=
    }=0A=
    return new JQLite(element);=0A=
  }=0A=
=0A=
  if (argIsString) {=0A=
    jqLiteAddNodes(this, jqLiteParseHTML(element));=0A=
  } else {=0A=
    jqLiteAddNodes(this, element);=0A=
  }=0A=
}=0A=
=0A=
function jqLiteClone(element) {=0A=
  return element.cloneNode(true);=0A=
}=0A=
=0A=
function jqLiteDealoc(element, onlyDescendants){=0A=
  if (!onlyDescendants) jqLiteRemoveData(element);=0A=
=0A=
  if (element.querySelectorAll) {=0A=
    var descendants =3D element.querySelectorAll('*');=0A=
    for (var i =3D 0, l =3D descendants.length; i &lt; l; i++) {=0A=
      jqLiteRemoveData(descendants[i]);=0A=
    }=0A=
  }=0A=
}=0A=
=0A=
function jqLiteOff(element, type, fn, unsupported) {=0A=
  if (isDefined(unsupported)) throw jqLiteMinErr('offargs', =
'jqLite#off() does not support the `selector` argument');=0A=
=0A=
  var expandoStore =3D jqLiteExpandoStore(element);=0A=
  var events =3D expandoStore &amp;&amp; expandoStore.events;=0A=
  var handle =3D expandoStore &amp;&amp; expandoStore.handle;=0A=
=0A=
  if (!handle) return; //no listeners registered=0A=
=0A=
  if (!type) {=0A=
    for (type in events) {=0A=
      if (type !=3D=3D '$destroy') {=0A=
        removeEventListenerFn(element, type, handle);=0A=
      }=0A=
      delete events[type];=0A=
    }=0A=
  } else {=0A=
    forEach(type.split(' '), function(type) {=0A=
      if (isDefined(fn)) {=0A=
        var listenerFns =3D events[type];=0A=
        arrayRemove(listenerFns || [], fn);=0A=
        if (listenerFns &amp;&amp; listenerFns.length &gt; 0) {=0A=
          return;=0A=
        }=0A=
      }=0A=
=0A=
      removeEventListenerFn(element, type, handle);=0A=
      delete events[type];=0A=
    });=0A=
  }=0A=
}=0A=
=0A=
function jqLiteRemoveData(element, name) {=0A=
  var expandoId =3D element.ng339;=0A=
  var expandoStore =3D expandoId &amp;&amp; jqCache[expandoId];=0A=
=0A=
  if (expandoStore) {=0A=
    if (name) {=0A=
      delete expandoStore.data[name];=0A=
      return;=0A=
    }=0A=
=0A=
    if (expandoStore.handle) {=0A=
      if (expandoStore.events.$destroy) {=0A=
        expandoStore.handle({}, '$destroy');=0A=
      }=0A=
      jqLiteOff(element);=0A=
    }=0A=
    delete jqCache[expandoId];=0A=
    element.ng339 =3D undefined; // don't delete DOM expandos. IE and =
Chrome don't like it=0A=
  }=0A=
}=0A=
=0A=
=0A=
function jqLiteExpandoStore(element, createIfNecessary) {=0A=
  var expandoId =3D element.ng339,=0A=
      expandoStore =3D expandoId &amp;&amp; jqCache[expandoId];=0A=
=0A=
  if (createIfNecessary &amp;&amp; !expandoStore) {=0A=
    element.ng339 =3D expandoId =3D jqNextId();=0A=
    expandoStore =3D jqCache[expandoId] =3D {events: {}, data: {}, =
handle: undefined};=0A=
  }=0A=
=0A=
  return expandoStore;=0A=
}=0A=
=0A=
=0A=
function jqLiteData(element, key, value) {=0A=
  if (jqLiteAcceptsData(element)) {=0A=
=0A=
    var isSimpleSetter =3D isDefined(value);=0A=
    var isSimpleGetter =3D !isSimpleSetter &amp;&amp; key &amp;&amp; =
!isObject(key);=0A=
    var massGetter =3D !key;=0A=
    var expandoStore =3D jqLiteExpandoStore(element, !isSimpleGetter);=0A=
    var data =3D expandoStore &amp;&amp; expandoStore.data;=0A=
=0A=
    if (isSimpleSetter) { // data('key', value)=0A=
      data[key] =3D value;=0A=
    } else {=0A=
      if (massGetter) {  // data()=0A=
        return data;=0A=
      } else {=0A=
        if (isSimpleGetter) { // data('key')=0A=
          // don't force creation of expandoStore if it doesn't exist yet=0A=
          return data &amp;&amp; data[key];=0A=
        } else { // mass-setter: data({key1: val1, key2: val2})=0A=
          extend(data, key);=0A=
        }=0A=
      }=0A=
    }=0A=
  }=0A=
}=0A=
=0A=
function jqLiteHasClass(element, selector) {=0A=
  if (!element.getAttribute) return false;=0A=
  return ((" " + (element.getAttribute('class') || '') + " =
").replace(/[\n\t]/g, " ").=0A=
      indexOf( " " + selector + " " ) &gt; -1);=0A=
}=0A=
=0A=
function jqLiteRemoveClass(element, cssClasses) {=0A=
  if (cssClasses &amp;&amp; element.setAttribute) {=0A=
    forEach(cssClasses.split(' '), function(cssClass) {=0A=
      element.setAttribute('class', trim(=0A=
          (" " + (element.getAttribute('class') || '') + " ")=0A=
          .replace(/[\n\t]/g, " ")=0A=
          .replace(" " + trim(cssClass) + " ", " "))=0A=
      );=0A=
    });=0A=
  }=0A=
}=0A=
=0A=
function jqLiteAddClass(element, cssClasses) {=0A=
  if (cssClasses &amp;&amp; element.setAttribute) {=0A=
    var existingClasses =3D (' ' + (element.getAttribute('class') || '') =
+ ' ')=0A=
                            .replace(/[\n\t]/g, " ");=0A=
=0A=
    forEach(cssClasses.split(' '), function(cssClass) {=0A=
      cssClass =3D trim(cssClass);=0A=
      if (existingClasses.indexOf(' ' + cssClass + ' ') =3D=3D=3D -1) {=0A=
        existingClasses +=3D cssClass + ' ';=0A=
      }=0A=
    });=0A=
=0A=
    element.setAttribute('class', trim(existingClasses));=0A=
  }=0A=
}=0A=
=0A=
=0A=
function jqLiteAddNodes(root, elements) {=0A=
  // THIS CODE IS VERY HOT. Don't make changes without benchmarking.=0A=
=0A=
  if (elements) {=0A=
=0A=
    // if a Node (the most common case)=0A=
    if (elements.nodeType) {=0A=
      root[root.length++] =3D elements;=0A=
    } else {=0A=
      var length =3D elements.length;=0A=
=0A=
      // if an Array or NodeList and not a Window=0A=
      if (typeof length =3D=3D=3D 'number' &amp;&amp; elements.window =
!=3D=3D elements) {=0A=
        if (length) {=0A=
          for (var i =3D 0; i &lt; length; i++) {=0A=
            root[root.length++] =3D elements[i];=0A=
          }=0A=
        }=0A=
      } else {=0A=
        root[root.length++] =3D elements;=0A=
      }=0A=
    }=0A=
  }=0A=
}=0A=
=0A=
=0A=
function jqLiteController(element, name) {=0A=
  return jqLiteInheritedData(element, '$' + (name || 'ngController' ) + =
'Controller');=0A=
}=0A=
=0A=
function jqLiteInheritedData(element, name, value) {=0A=
  // if element is the document object work with the html element instead=0A=
  // this makes $(document).scope() possible=0A=
  if(element.nodeType =3D=3D NODE_TYPE_DOCUMENT) {=0A=
    element =3D element.documentElement;=0A=
  }=0A=
  var names =3D isArray(name) ? name : [name];=0A=
=0A=
  while (element) {=0A=
    for (var i =3D 0, ii =3D names.length; i &lt; ii; i++) {=0A=
      if ((value =3D jqLite.data(element, names[i])) !=3D=3D undefined) =
return value;=0A=
    }=0A=
=0A=
    // If dealing with a document fragment node with a host element, and =
no parent, use the host=0A=
    // element as the parent. This enables directives within a Shadow =
DOM or polyfilled Shadow DOM=0A=
    // to lookup parent controllers.=0A=
    element =3D element.parentNode || (element.nodeType =3D=3D=3D =
NODE_TYPE_DOCUMENT_FRAGMENT &amp;&amp; element.host);=0A=
  }=0A=
}=0A=
=0A=
function jqLiteEmpty(element) {=0A=
  jqLiteDealoc(element, true);=0A=
  while (element.firstChild) {=0A=
    element.removeChild(element.firstChild);=0A=
  }=0A=
}=0A=
=0A=
function jqLiteRemove(element, keepData) {=0A=
  if (!keepData) jqLiteDealoc(element);=0A=
  var parent =3D element.parentNode;=0A=
  if (parent) parent.removeChild(element);=0A=
}=0A=
=0A=
=0A=
function jqLiteDocumentLoaded(action, win) {=0A=
  win =3D win || window;=0A=
  if (win.document.readyState =3D=3D=3D 'complete') {=0A=
    // Force the action to be run async for consistent behaviour=0A=
    // from the action's point of view=0A=
    // i.e. it will definitely not be in a $apply=0A=
    win.setTimeout(action);=0A=
  } else {=0A=
    // No need to unbind this handler as load is only ever called once=0A=
    jqLite(win).on('load', action);=0A=
  }=0A=
}=0A=
=0A=
//////////////////////////////////////////=0A=
// Functions which are declared directly.=0A=
//////////////////////////////////////////=0A=
var JQLitePrototype =3D JQLite.prototype =3D {=0A=
  ready: function(fn) {=0A=
    var fired =3D false;=0A=
=0A=
    function trigger() {=0A=
      if (fired) return;=0A=
      fired =3D true;=0A=
      fn();=0A=
    }=0A=
=0A=
    // check if document is already loaded=0A=
    if (document.readyState =3D=3D=3D 'complete'){=0A=
      setTimeout(trigger);=0A=
    } else {=0A=
      this.on('DOMContentLoaded', trigger); // works for modern browsers =
and IE9=0A=
      // we can not use jqLite since we are not done loading and jQuery =
could be loaded later.=0A=
      // jshint -W064=0A=
      JQLite(window).on('load', trigger); // fallback to window.onload =
for others=0A=
      // jshint +W064=0A=
      this.on('DOMContentLoaded', trigger);=0A=
    }=0A=
  },=0A=
  toString: function() {=0A=
    var value =3D [];=0A=
    forEach(this, function(e){ value.push('' + e);});=0A=
    return '[' + value.join(', ') + ']';=0A=
  },=0A=
=0A=
  eq: function(index) {=0A=
      return (index &gt;=3D 0) ? jqLite(this[index]) : =
jqLite(this[this.length + index]);=0A=
  },=0A=
=0A=
  length: 0,=0A=
  push: push,=0A=
  sort: [].sort,=0A=
  splice: [].splice=0A=
};=0A=
=0A=
//////////////////////////////////////////=0A=
// Functions iterating getter/setters.=0A=
// these functions return self on setter and=0A=
// value on get.=0A=
//////////////////////////////////////////=0A=
var BOOLEAN_ATTR =3D {};=0A=
forEach('multiple,selected,checked,disabled,readOnly,required,open'.split=
(','), function(value) {=0A=
  BOOLEAN_ATTR[lowercase(value)] =3D value;=0A=
});=0A=
var BOOLEAN_ELEMENTS =3D {};=0A=
forEach('input,select,option,textarea,button,form,details'.split(','), =
function(value) {=0A=
  BOOLEAN_ELEMENTS[value] =3D true;=0A=
});=0A=
var ALIASED_ATTR =3D {=0A=
  'ngMinlength' : 'minlength',=0A=
  'ngMaxlength' : 'maxlength',=0A=
  'ngMin' : 'min',=0A=
  'ngMax' : 'max',=0A=
  'ngPattern' : 'pattern'=0A=
};=0A=
=0A=
function getBooleanAttrName(element, name) {=0A=
  // check dom last since we will most likely fail on name=0A=
  var booleanAttr =3D BOOLEAN_ATTR[name.toLowerCase()];=0A=
=0A=
  // booleanAttr is here twice to minimize DOM access=0A=
  return booleanAttr &amp;&amp; BOOLEAN_ELEMENTS[nodeName_(element)] =
&amp;&amp; booleanAttr;=0A=
}=0A=
=0A=
function getAliasedAttrName(element, name) {=0A=
  var nodeName =3D element.nodeName;=0A=
  return (nodeName =3D=3D=3D 'INPUT' || nodeName =3D=3D=3D 'TEXTAREA') =
&amp;&amp; ALIASED_ATTR[name];=0A=
}=0A=
=0A=
forEach({=0A=
  data: jqLiteData,=0A=
  removeData: jqLiteRemoveData=0A=
}, function(fn, name) {=0A=
  JQLite[name] =3D fn;=0A=
});=0A=
=0A=
forEach({=0A=
  data: jqLiteData,=0A=
  inheritedData: jqLiteInheritedData,=0A=
=0A=
  scope: function(element) {=0A=
    // Can't use jqLiteData here directly so we stay compatible with =
jQuery!=0A=
    return jqLite.data(element, '$scope') || =
jqLiteInheritedData(element.parentNode || element, ['$isolateScope', =
'$scope']);=0A=
  },=0A=
=0A=
  isolateScope: function(element) {=0A=
    // Can't use jqLiteData here directly so we stay compatible with =
jQuery!=0A=
    return jqLite.data(element, '$isolateScope') || jqLite.data(element, =
'$isolateScopeNoTemplate');=0A=
  },=0A=
=0A=
  controller: jqLiteController,=0A=
=0A=
  injector: function(element) {=0A=
    return jqLiteInheritedData(element, '$injector');=0A=
  },=0A=
=0A=
  removeAttr: function(element, name) {=0A=
    element.removeAttribute(name);=0A=
  },=0A=
=0A=
  hasClass: jqLiteHasClass,=0A=
=0A=
  css: function(element, name, value) {=0A=
    name =3D camelCase(name);=0A=
=0A=
    if (isDefined(value)) {=0A=
      element.style[name] =3D value;=0A=
    } else {=0A=
      return element.style[name];=0A=
    }=0A=
  },=0A=
=0A=
  attr: function(element, name, value){=0A=
    var lowercasedName =3D lowercase(name);=0A=
    if (BOOLEAN_ATTR[lowercasedName]) {=0A=
      if (isDefined(value)) {=0A=
        if (!!value) {=0A=
          element[name] =3D true;=0A=
          element.setAttribute(name, lowercasedName);=0A=
        } else {=0A=
          element[name] =3D false;=0A=
          element.removeAttribute(lowercasedName);=0A=
        }=0A=
      } else {=0A=
        return (element[name] ||=0A=
                 (element.attributes.getNamedItem(name)|| =
noop).specified)=0A=
               ? lowercasedName=0A=
               : undefined;=0A=
      }=0A=
    } else if (isDefined(value)) {=0A=
      element.setAttribute(name, value);=0A=
    } else if (element.getAttribute) {=0A=
      // the extra argument "2" is to get the right thing for a.href in =
IE, see jQuery code=0A=
      // some elements (e.g. Document) don't have get attribute, so =
return undefined=0A=
      var ret =3D element.getAttribute(name, 2);=0A=
      // normalize non-existing attributes to undefined (as jQuery)=0A=
      return ret =3D=3D=3D null ? undefined : ret;=0A=
    }=0A=
  },=0A=
=0A=
  prop: function(element, name, value) {=0A=
    if (isDefined(value)) {=0A=
      element[name] =3D value;=0A=
    } else {=0A=
      return element[name];=0A=
    }=0A=
  },=0A=
=0A=
  text: (function() {=0A=
    getText.$dv =3D '';=0A=
    return getText;=0A=
=0A=
    function getText(element, value) {=0A=
      if (isUndefined(value)) {=0A=
        var nodeType =3D element.nodeType;=0A=
        return (nodeType =3D=3D=3D NODE_TYPE_ELEMENT || nodeType =
=3D=3D=3D NODE_TYPE_TEXT) ? element.textContent : '';=0A=
      }=0A=
      element.textContent =3D value;=0A=
    }=0A=
  })(),=0A=
=0A=
  val: function(element, value) {=0A=
    if (isUndefined(value)) {=0A=
      if (element.multiple &amp;&amp; nodeName_(element) =3D=3D=3D =
'select') {=0A=
        var result =3D [];=0A=
        forEach(element.options, function (option) {=0A=
          if (option.selected) {=0A=
            result.push(option.value || option.text);=0A=
          }=0A=
        });=0A=
        return result.length =3D=3D=3D 0 ? null : result;=0A=
      }=0A=
      return element.value;=0A=
    }=0A=
    element.value =3D value;=0A=
  },=0A=
=0A=
  html: function(element, value) {=0A=
    if (isUndefined(value)) {=0A=
      return element.innerHTML;=0A=
    }=0A=
    jqLiteDealoc(element, true);=0A=
    element.innerHTML =3D value;=0A=
  },=0A=
=0A=
  empty: jqLiteEmpty=0A=
}, function(fn, name){=0A=
  /**=0A=
   * Properties: writes return selection, reads return first value=0A=
   */=0A=
  JQLite.prototype[name] =3D function(arg1, arg2) {=0A=
    var i, key;=0A=
    var nodeCount =3D this.length;=0A=
=0A=
    // jqLiteHasClass has only two arguments, but is a getter-only fn, =
so we need to special-case it=0A=
    // in a way that survives minification.=0A=
    // jqLiteEmpty takes no arguments but is a setter.=0A=
    if (fn !=3D=3D jqLiteEmpty &amp;&amp;=0A=
        (((fn.length =3D=3D 2 &amp;&amp; (fn !=3D=3D jqLiteHasClass =
&amp;&amp; fn !=3D=3D jqLiteController)) ? arg1 : arg2) =3D=3D=3D =
undefined)) {=0A=
      if (isObject(arg1)) {=0A=
=0A=
        // we are a write, but the object properties are the key/values=0A=
        for (i =3D 0; i &lt; nodeCount; i++) {=0A=
          if (fn =3D=3D=3D jqLiteData) {=0A=
            // data() takes the whole object in jQuery=0A=
            fn(this[i], arg1);=0A=
          } else {=0A=
            for (key in arg1) {=0A=
              fn(this[i], key, arg1[key]);=0A=
            }=0A=
          }=0A=
        }=0A=
        // return self for chaining=0A=
        return this;=0A=
      } else {=0A=
        // we are a read, so read the first child.=0A=
        // TODO: do we still need this?=0A=
        var value =3D fn.$dv;=0A=
        // Only if we have $dv do we iterate over all, otherwise it is =
just the first element.=0A=
        var jj =3D (value =3D=3D=3D undefined) ? Math.min(nodeCount, 1) =
: nodeCount;=0A=
        for (var j =3D 0; j &lt; jj; j++) {=0A=
          var nodeValue =3D fn(this[j], arg1, arg2);=0A=
          value =3D value ? value + nodeValue : nodeValue;=0A=
        }=0A=
        return value;=0A=
      }=0A=
    } else {=0A=
      // we are a write, so apply to all children=0A=
      for (i =3D 0; i &lt; nodeCount; i++) {=0A=
        fn(this[i], arg1, arg2);=0A=
      }=0A=
      // return self for chaining=0A=
      return this;=0A=
    }=0A=
  };=0A=
});=0A=
=0A=
function createEventHandler(element, events) {=0A=
  var eventHandler =3D function (event, type) {=0A=
    // jQuery specific api=0A=
    event.isDefaultPrevented =3D function() {=0A=
      return event.defaultPrevented;=0A=
    };=0A=
=0A=
    var eventFns =3D events[type || event.type];=0A=
    var eventFnsLength =3D eventFns ? eventFns.length : 0;=0A=
=0A=
    if (!eventFnsLength) return;=0A=
=0A=
    if (isUndefined(event.immediatePropagationStopped)) {=0A=
      var originalStopImmediatePropagation =3D =
event.stopImmediatePropagation;=0A=
      event.stopImmediatePropagation =3D function() {=0A=
        event.immediatePropagationStopped =3D true;=0A=
=0A=
        if (event.stopPropagation) {=0A=
          event.stopPropagation();=0A=
        }=0A=
=0A=
        if (originalStopImmediatePropagation) {=0A=
          originalStopImmediatePropagation.call(event);=0A=
        }=0A=
      };=0A=
    }=0A=
=0A=
    event.isImmediatePropagationStopped =3D function() {=0A=
      return event.immediatePropagationStopped =3D=3D=3D true;=0A=
    };=0A=
=0A=
    // Copy event handlers in case event handlers array is modified =
during execution.=0A=
    if ((eventFnsLength &gt; 1)) {=0A=
      eventFns =3D shallowCopy(eventFns);=0A=
    }=0A=
=0A=
    for (var i =3D 0; i &lt; eventFnsLength; i++) {=0A=
      if (!event.isImmediatePropagationStopped()) {=0A=
        eventFns[i].call(element, event);=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  // TODO: this is a hack for angularMocks/clearDataCache that makes it =
possible to deregister all=0A=
  //       events on `element`=0A=
  eventHandler.elem =3D element;=0A=
  return eventHandler;=0A=
}=0A=
=0A=
//////////////////////////////////////////=0A=
// Functions iterating traversal.=0A=
// These functions chain results into a single=0A=
// selector.=0A=
//////////////////////////////////////////=0A=
forEach({=0A=
  removeData: jqLiteRemoveData,=0A=
=0A=
  on: function jqLiteOn(element, type, fn, unsupported){=0A=
    if (isDefined(unsupported)) throw jqLiteMinErr('onargs', =
'jqLite#on() does not support the `selector` or `eventData` parameters');=0A=
=0A=
    // Do not add event handlers to non-elements because they will not =
be cleaned up.=0A=
    if (!jqLiteAcceptsData(element)) {=0A=
      return;=0A=
    }=0A=
=0A=
    var expandoStore =3D jqLiteExpandoStore(element, true);=0A=
    var events =3D expandoStore.events;=0A=
    var handle =3D expandoStore.handle;=0A=
=0A=
    if (!handle) {=0A=
      handle =3D expandoStore.handle =3D createEventHandler(element, =
events);=0A=
    }=0A=
=0A=
    // http://jsperf.com/string-indexof-vs-split=0A=
    var types =3D type.indexOf(' ') &gt;=3D 0 ? type.split(' ') : [type];=0A=
    var i =3D types.length;=0A=
=0A=
    while (i--) {=0A=
      type =3D types[i];=0A=
      var eventFns =3D events[type];=0A=
=0A=
      if (!eventFns) {=0A=
        events[type] =3D [];=0A=
=0A=
        if (type =3D=3D=3D 'mouseenter' || type =3D=3D=3D 'mouseleave') {=0A=
          // Refer to jQuery's implementation of mouseenter &amp; =
mouseleave=0A=
          // Read about mouseenter and mouseleave:=0A=
          // http://www.quirksmode.org/js/events_mouse.html#link8=0A=
=0A=
          jqLiteOn(element, MOUSE_EVENT_MAP[type], function(event) {=0A=
            var target =3D this, related =3D event.relatedTarget;=0A=
            // For mousenter/leave call the handler if related is =
outside the target.=0A=
            // NB: No relatedTarget if the mouse left/entered the =
browser window=0A=
            if ( !related || (related !=3D=3D target &amp;&amp; =
!target.contains(related)) ){=0A=
              handle(event, type);=0A=
            }=0A=
          });=0A=
=0A=
        } else {=0A=
          if (type !=3D=3D '$destroy') {=0A=
            addEventListenerFn(element, type, handle);=0A=
          }=0A=
        }=0A=
        eventFns =3D events[type];=0A=
      }=0A=
      eventFns.push(fn);=0A=
    }=0A=
  },=0A=
=0A=
  off: jqLiteOff,=0A=
=0A=
  one: function(element, type, fn) {=0A=
    element =3D jqLite(element);=0A=
=0A=
    //add the listener twice so that when it is called=0A=
    //you can remove the original function and still be=0A=
    //able to call element.off(ev, fn) normally=0A=
    element.on(type, function onFn() {=0A=
      element.off(type, fn);=0A=
      element.off(type, onFn);=0A=
    });=0A=
    element.on(type, fn);=0A=
  },=0A=
=0A=
  replaceWith: function(element, replaceNode) {=0A=
    var index, parent =3D element.parentNode;=0A=
    jqLiteDealoc(element);=0A=
    forEach(new JQLite(replaceNode), function(node){=0A=
      if (index) {=0A=
        parent.insertBefore(node, index.nextSibling);=0A=
      } else {=0A=
        parent.replaceChild(node, element);=0A=
      }=0A=
      index =3D node;=0A=
    });=0A=
  },=0A=
=0A=
  children: function(element) {=0A=
    var children =3D [];=0A=
    forEach(element.childNodes, function(element){=0A=
      if (element.nodeType =3D=3D=3D NODE_TYPE_ELEMENT)=0A=
        children.push(element);=0A=
    });=0A=
    return children;=0A=
  },=0A=
=0A=
  contents: function(element) {=0A=
    return element.contentDocument || element.childNodes || [];=0A=
  },=0A=
=0A=
  append: function(element, node) {=0A=
    var nodeType =3D element.nodeType;=0A=
    if (nodeType !=3D=3D NODE_TYPE_ELEMENT &amp;&amp; nodeType !=3D=3D =
NODE_TYPE_DOCUMENT_FRAGMENT) return;=0A=
=0A=
    node =3D new JQLite(node);=0A=
=0A=
    for (var i =3D 0, ii =3D node.length; i &lt; ii; i++) {=0A=
      var child =3D node[i];=0A=
      element.appendChild(child);=0A=
    }=0A=
  },=0A=
=0A=
  prepend: function(element, node) {=0A=
    if (element.nodeType =3D=3D=3D NODE_TYPE_ELEMENT) {=0A=
      var index =3D element.firstChild;=0A=
      forEach(new JQLite(node), function(child){=0A=
        element.insertBefore(child, index);=0A=
      });=0A=
    }=0A=
  },=0A=
=0A=
  wrap: function(element, wrapNode) {=0A=
    wrapNode =3D jqLite(wrapNode).eq(0).clone()[0];=0A=
    var parent =3D element.parentNode;=0A=
    if (parent) {=0A=
      parent.replaceChild(wrapNode, element);=0A=
    }=0A=
    wrapNode.appendChild(element);=0A=
  },=0A=
=0A=
  remove: jqLiteRemove,=0A=
=0A=
  detach: function(element) {=0A=
    jqLiteRemove(element, true);=0A=
  },=0A=
=0A=
  after: function(element, newElement) {=0A=
    var index =3D element, parent =3D element.parentNode;=0A=
    newElement =3D new JQLite(newElement);=0A=
=0A=
    for (var i =3D 0, ii =3D newElement.length; i &lt; ii; i++) {=0A=
      var node =3D newElement[i];=0A=
      parent.insertBefore(node, index.nextSibling);=0A=
      index =3D node;=0A=
    }=0A=
  },=0A=
=0A=
  addClass: jqLiteAddClass,=0A=
  removeClass: jqLiteRemoveClass,=0A=
=0A=
  toggleClass: function(element, selector, condition) {=0A=
    if (selector) {=0A=
      forEach(selector.split(' '), function(className){=0A=
        var classCondition =3D condition;=0A=
        if (isUndefined(classCondition)) {=0A=
          classCondition =3D !jqLiteHasClass(element, className);=0A=
        }=0A=
        (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, =
className);=0A=
      });=0A=
    }=0A=
  },=0A=
=0A=
  parent: function(element) {=0A=
    var parent =3D element.parentNode;=0A=
    return parent &amp;&amp; parent.nodeType !=3D=3D =
NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;=0A=
  },=0A=
=0A=
  next: function(element) {=0A=
    return element.nextElementSibling;=0A=
  },=0A=
=0A=
  find: function(element, selector) {=0A=
    if (element.getElementsByTagName) {=0A=
      return element.getElementsByTagName(selector);=0A=
    } else {=0A=
      return [];=0A=
    }=0A=
  },=0A=
=0A=
  clone: jqLiteClone,=0A=
=0A=
  triggerHandler: function(element, event, extraParameters) {=0A=
=0A=
    var dummyEvent, eventFnsCopy, handlerArgs;=0A=
    var eventName =3D event.type || event;=0A=
    var expandoStore =3D jqLiteExpandoStore(element);=0A=
    var events =3D expandoStore &amp;&amp; expandoStore.events;=0A=
    var eventFns =3D events &amp;&amp; events[eventName];=0A=
=0A=
    if (eventFns) {=0A=
      // Create a dummy event to pass to the handlers=0A=
      dummyEvent =3D {=0A=
        preventDefault: function() { this.defaultPrevented =3D true; },=0A=
        isDefaultPrevented: function() { return this.defaultPrevented =
=3D=3D=3D true; },=0A=
        stopImmediatePropagation: function() { =
this.immediatePropagationStopped =3D true; },=0A=
        isImmediatePropagationStopped: function() { return =
this.immediatePropagationStopped =3D=3D=3D true; },=0A=
        stopPropagation: noop,=0A=
        type: eventName,=0A=
        target: element=0A=
      };=0A=
=0A=
      // If a custom event was provided then extend our dummy event with =
it=0A=
      if (event.type) {=0A=
        dummyEvent =3D extend(dummyEvent, event);=0A=
      }=0A=
=0A=
      // Copy event handlers in case event handlers array is modified =
during execution.=0A=
      eventFnsCopy =3D shallowCopy(eventFns);=0A=
      handlerArgs =3D extraParameters ? =
[dummyEvent].concat(extraParameters) : [dummyEvent];=0A=
=0A=
      forEach(eventFnsCopy, function(fn) {=0A=
        if (!dummyEvent.isImmediatePropagationStopped()) {=0A=
          fn.apply(element, handlerArgs);=0A=
        }=0A=
      });=0A=
    }=0A=
  }=0A=
}, function(fn, name){=0A=
  /**=0A=
   * chaining functions=0A=
   */=0A=
  JQLite.prototype[name] =3D function(arg1, arg2, arg3) {=0A=
    var value;=0A=
=0A=
    for(var i =3D 0, ii =3D this.length; i &lt; ii; i++) {=0A=
      if (isUndefined(value)) {=0A=
        value =3D fn(this[i], arg1, arg2, arg3);=0A=
        if (isDefined(value)) {=0A=
          // any function which returns a value needs to be wrapped=0A=
          value =3D jqLite(value);=0A=
        }=0A=
      } else {=0A=
        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));=0A=
      }=0A=
    }=0A=
    return isDefined(value) ? value : this;=0A=
  };=0A=
=0A=
  // bind legacy bind/unbind to on/off=0A=
  JQLite.prototype.bind =3D JQLite.prototype.on;=0A=
  JQLite.prototype.unbind =3D JQLite.prototype.off;=0A=
});=0A=
=0A=
/**=0A=
 * Computes a hash of an 'obj'.=0A=
 * Hash of a:=0A=
 *  string is string=0A=
 *  number is number as string=0A=
 *  object is either result of calling $$hashKey function on the object =
or uniquely generated id,=0A=
 *         that is also assigned to the $$hashKey property of the object.=0A=
 *=0A=
 * @param obj=0A=
 * @returns {string} hash string such that the same input will have the =
same hash string.=0A=
 *         The resulting string key is in 'type:hashKey' format.=0A=
 */=0A=
function hashKey(obj, nextUidFn) {=0A=
  var key =3D obj &amp;&amp; obj.$$hashKey;=0A=
=0A=
  if (key) {=0A=
    if (typeof key =3D=3D=3D 'function') {=0A=
      key =3D obj.$$hashKey();=0A=
    }=0A=
    return key;=0A=
  }=0A=
=0A=
  var objType =3D typeof obj;=0A=
  if (objType =3D=3D 'function' || (objType =3D=3D 'object' &amp;&amp; =
obj !=3D=3D null)) {=0A=
    key =3D obj.$$hashKey =3D objType + ':' + (nextUidFn || nextUid)();=0A=
  } else {=0A=
    key =3D objType + ':' + obj;=0A=
  }=0A=
=0A=
  return key;=0A=
}=0A=
=0A=
/**=0A=
 * HashMap which can use objects as keys=0A=
 */=0A=
function HashMap(array, isolatedUid) {=0A=
  if (isolatedUid) {=0A=
    var uid =3D 0;=0A=
    this.nextUid =3D function() {=0A=
      return ++uid;=0A=
    };=0A=
  }=0A=
  forEach(array, this.put, this);=0A=
}=0A=
HashMap.prototype =3D {=0A=
  /**=0A=
   * Store key value pair=0A=
   * @param key key to store can be any type=0A=
   * @param value value to store can be any type=0A=
   */=0A=
  put: function(key, value) {=0A=
    this[hashKey(key, this.nextUid)] =3D value;=0A=
  },=0A=
=0A=
  /**=0A=
   * @param key=0A=
   * @returns {Object} the value for the key=0A=
   */=0A=
  get: function(key) {=0A=
    return this[hashKey(key, this.nextUid)];=0A=
  },=0A=
=0A=
  /**=0A=
   * Remove the key/value pair=0A=
   * @param key=0A=
   */=0A=
  remove: function(key) {=0A=
    var value =3D this[key =3D hashKey(key, this.nextUid)];=0A=
    delete this[key];=0A=
    return value;=0A=
  }=0A=
};=0A=
=0A=
/**=0A=
 * @ngdoc function=0A=
 * @module ng=0A=
 * @name angular.injector=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Creates an injector object that can be used for retrieving services =
as well as for=0A=
 * dependency injection (see {@link guide/di dependency injection}).=0A=
 *=0A=
=0A=
 * @param {Array.&lt;string|Function&gt;} modules A list of module =
functions or their aliases. See=0A=
 *        {@link angular.module}. The `ng` module must be explicitly =
added.=0A=
 * @returns {injector} Injector object. See {@link auto.$injector =
$injector}.=0A=
 *=0A=
 * @example=0A=
 * Typical usage=0A=
 * ```js=0A=
 *   // create an injector=0A=
 *   var $injector =3D angular.injector(['ng']);=0A=
 *=0A=
 *   // use the injector to kick off your application=0A=
 *   // use the type inference to auto inject arguments, or use implicit =
injection=0A=
 *   $injector.invoke(function($rootScope, $compile, $document) {=0A=
 *     $compile($document)($rootScope);=0A=
 *     $rootScope.$digest();=0A=
 *   });=0A=
 * ```=0A=
 *=0A=
 * Sometimes you want to get access to the injector of a currently =
running Angular app=0A=
 * from outside Angular. Perhaps, you want to inject and compile some =
markup after the=0A=
 * application has been bootstrapped. You can do this using the extra =
`injector()` added=0A=
 * to JQuery/jqLite elements. See {@link angular.element}.=0A=
 *=0A=
 * *This is fairly rare but could be the case if a third party library =
is injecting the=0A=
 * markup.*=0A=
 *=0A=
 * In the following example a new block of HTML containing a =
`ng-controller`=0A=
 * directive is added to the end of the document body by JQuery. We then =
compile and link=0A=
 * it into the current AngularJS scope.=0A=
 *=0A=
 * ```js=0A=
 * var $div =3D $('&lt;div =
ng-controller=3D"MyCtrl"&gt;{{content.label}}&lt;/div&gt;');=0A=
 * $(document.body).append($div);=0A=
 *=0A=
 * angular.element(document).injector().invoke(function($compile) {=0A=
 *   var scope =3D angular.element($div).scope();=0A=
 *   $compile($div)(scope);=0A=
 * });=0A=
 * ```=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc module=0A=
 * @name auto=0A=
 * @description=0A=
 *=0A=
 * Implicit module which gets automatically added to each {@link =
auto.$injector $injector}.=0A=
 */=0A=
=0A=
var FN_ARGS =3D /^function\s*[^\(]*\(\s*([^\)]*)\)/m;=0A=
var FN_ARG_SPLIT =3D /,/;=0A=
var FN_ARG =3D /^\s*(_?)(\S+?)\1\s*$/;=0A=
var STRIP_COMMENTS =3D /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;=0A=
var $injectorMinErr =3D minErr('$injector');=0A=
=0A=
function anonFn(fn) {=0A=
  // For anonymous functions, showing at the very least the function =
signature can help in=0A=
  // debugging.=0A=
  var fnText =3D fn.toString().replace(STRIP_COMMENTS, ''),=0A=
      args =3D fnText.match(FN_ARGS);=0A=
  if (args) {=0A=
    return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';=0A=
  }=0A=
  return 'fn';=0A=
}=0A=
=0A=
function annotate(fn, strictDi, name) {=0A=
  var $inject,=0A=
      fnText,=0A=
      argDecl,=0A=
      last;=0A=
=0A=
  if (typeof fn =3D=3D=3D 'function') {=0A=
    if (!($inject =3D fn.$inject)) {=0A=
      $inject =3D [];=0A=
      if (fn.length) {=0A=
        if (strictDi) {=0A=
          if (!isString(name) || !name) {=0A=
            name =3D fn.name || anonFn(fn);=0A=
          }=0A=
          throw $injectorMinErr('strictdi',=0A=
            '{0} is not using explicit annotation and cannot be invoked =
in strict mode', name);=0A=
        }=0A=
        fnText =3D fn.toString().replace(STRIP_COMMENTS, '');=0A=
        argDecl =3D fnText.match(FN_ARGS);=0A=
        forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {=0A=
          arg.replace(FN_ARG, function(all, underscore, name) {=0A=
            $inject.push(name);=0A=
          });=0A=
        });=0A=
      }=0A=
      fn.$inject =3D $inject;=0A=
    }=0A=
  } else if (isArray(fn)) {=0A=
    last =3D fn.length - 1;=0A=
    assertArgFn(fn[last], 'fn');=0A=
    $inject =3D fn.slice(0, last);=0A=
  } else {=0A=
    assertArgFn(fn, 'fn', true);=0A=
  }=0A=
  return $inject;=0A=
}=0A=
=0A=
///////////////////////////////////////=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $injector=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * `$injector` is used to retrieve object instances as defined by=0A=
 * {@link auto.$provide provider}, instantiate types, invoke methods,=0A=
 * and load modules.=0A=
 *=0A=
 * The following always holds true:=0A=
 *=0A=
 * ```js=0A=
 *   var $injector =3D angular.injector();=0A=
 *   expect($injector.get('$injector')).toBe($injector);=0A=
 *   expect($injector.invoke(function($injector) {=0A=
 *     return $injector;=0A=
 *   })).toBe($injector);=0A=
 * ```=0A=
 *=0A=
 * # Injection Function Annotation=0A=
 *=0A=
 * JavaScript does not have annotations, and annotations are needed for =
dependency injection. The=0A=
 * following are all valid ways of annotating function with injection =
arguments and are equivalent.=0A=
 *=0A=
 * ```js=0A=
 *   // inferred (only works if code not minified/obfuscated)=0A=
 *   $injector.invoke(function(serviceA){});=0A=
 *=0A=
 *   // annotated=0A=
 *   function explicit(serviceA) {};=0A=
 *   explicit.$inject =3D ['serviceA'];=0A=
 *   $injector.invoke(explicit);=0A=
 *=0A=
 *   // inline=0A=
 *   $injector.invoke(['serviceA', function(serviceA){}]);=0A=
 * ```=0A=
 *=0A=
 * ## Inference=0A=
 *=0A=
 * In JavaScript calling `toString()` on a function returns the function =
definition. The definition=0A=
 * can then be parsed and the function arguments can be extracted. =
*NOTE:* This does not work with=0A=
 * minification, and obfuscation tools since these tools change the =
argument names.=0A=
 *=0A=
 * ## `$inject` Annotation=0A=
 * By adding an `$inject` property onto a function the injection =
parameters can be specified.=0A=
 *=0A=
 * ## Inline=0A=
 * As an array of injection names, where the last item in the array is =
the function to call.=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $injector#get=0A=
 *=0A=
 * @description=0A=
 * Return an instance of the service.=0A=
 *=0A=
 * @param {string} name The name of the instance to retrieve.=0A=
 * @return {*} The instance.=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $injector#invoke=0A=
 *=0A=
 * @description=0A=
 * Invoke the method and supply the method arguments from the =
`$injector`.=0A=
 *=0A=
 * @param {!Function} fn The function to invoke. Function parameters are =
injected according to the=0A=
 *   {@link guide/di $inject Annotation} rules.=0A=
 * @param {Object=3D} self The `this` for the invoked method.=0A=
 * @param {Object=3D} locals Optional object. If preset then any =
argument names are read from this=0A=
 *                         object first, before the `$injector` is =
consulted.=0A=
 * @returns {*} the value returned by the invoked `fn` function.=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $injector#has=0A=
 *=0A=
 * @description=0A=
 * Allows the user to query if the particular service exists.=0A=
 *=0A=
 * @param {string} name Name of the service to query.=0A=
 * @returns {boolean} `true` if injector has given service.=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $injector#instantiate=0A=
 * @description=0A=
 * Create a new instance of JS type. The method takes a constructor =
function, invokes the new=0A=
 * operator, and supplies all of the arguments to the constructor =
function as specified by the=0A=
 * constructor annotation.=0A=
 *=0A=
 * @param {Function} Type Annotated constructor function.=0A=
 * @param {Object=3D} locals Optional object. If preset then any =
argument names are read from this=0A=
 * object first, before the `$injector` is consulted.=0A=
 * @returns {Object} new instance of `Type`.=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $injector#annotate=0A=
 *=0A=
 * @description=0A=
 * Returns an array of service names which the function is requesting =
for injection. This API is=0A=
 * used by the injector to determine which services need to be injected =
into the function when the=0A=
 * function is invoked. There are three ways in which the function can =
be annotated with the needed=0A=
 * dependencies.=0A=
 *=0A=
 * # Argument names=0A=
 *=0A=
 * The simplest form is to extract the dependencies from the arguments =
of the function. This is done=0A=
 * by converting the function into a string using `toString()` method =
and extracting the argument=0A=
 * names.=0A=
 * ```js=0A=
 *   // Given=0A=
 *   function MyController($scope, $route) {=0A=
 *     // ...=0A=
 *   }=0A=
 *=0A=
 *   // Then=0A=
 *   expect(injector.annotate(MyController)).toEqual(['$scope', =
'$route']);=0A=
 * ```=0A=
 *=0A=
 * This method does not work with code minification / obfuscation. For =
this reason the following=0A=
 * annotation strategies are supported.=0A=
 *=0A=
 * # The `$inject` property=0A=
 *=0A=
 * If a function has an `$inject` property and its value is an array of =
strings, then the strings=0A=
 * represent names of services to be injected into the function.=0A=
 * ```js=0A=
 *   // Given=0A=
 *   var MyController =3D function(obfuscatedScope, obfuscatedRoute) {=0A=
 *     // ...=0A=
 *   }=0A=
 *   // Define function dependencies=0A=
 *   MyController['$inject'] =3D ['$scope', '$route'];=0A=
 *=0A=
 *   // Then=0A=
 *   expect(injector.annotate(MyController)).toEqual(['$scope', =
'$route']);=0A=
 * ```=0A=
 *=0A=
 * # The array notation=0A=
 *=0A=
 * It is often desirable to inline Injected functions and that's when =
setting the `$inject` property=0A=
 * is very inconvenient. In these situations using the array notation to =
specify the dependencies in=0A=
 * a way that survives minification is a better choice:=0A=
 *=0A=
 * ```js=0A=
 *   // We wish to write this (not minification / obfuscation safe)=0A=
 *   injector.invoke(function($compile, $rootScope) {=0A=
 *     // ...=0A=
 *   });=0A=
 *=0A=
 *   // We are forced to write break inlining=0A=
 *   var tmpFn =3D function(obfuscatedCompile, obfuscatedRootScope) {=0A=
 *     // ...=0A=
 *   };=0A=
 *   tmpFn.$inject =3D ['$compile', '$rootScope'];=0A=
 *   injector.invoke(tmpFn);=0A=
 *=0A=
 *   // To better support inline function the inline annotation is =
supported=0A=
 *   injector.invoke(['$compile', '$rootScope', function(obfCompile, =
obfRootScope) {=0A=
 *     // ...=0A=
 *   }]);=0A=
 *=0A=
 *   // Therefore=0A=
 *   expect(injector.annotate(=0A=
 *      ['$compile', '$rootScope', function(obfus_$compile, =
obfus_$rootScope) {}])=0A=
 *    ).toEqual(['$compile', '$rootScope']);=0A=
 * ```=0A=
 *=0A=
 * @param {Function|Array.&lt;string|Function&gt;} fn Function for which =
dependent service names need to=0A=
 * be retrieved as described above.=0A=
 *=0A=
 * @returns {Array.&lt;string&gt;} The names of the services which the =
function requires.=0A=
 */=0A=
=0A=
=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $provide=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * The {@link auto.$provide $provide} service has a number of methods =
for registering components=0A=
 * with the {@link auto.$injector $injector}. Many of these functions =
are also exposed on=0A=
 * {@link angular.Module}.=0A=
 *=0A=
 * An Angular **service** is a singleton object created by a **service =
factory**.  These **service=0A=
 * factories** are functions which, in turn, are created by a **service =
provider**.=0A=
 * The **service providers** are constructor functions. When =
instantiated they must contain a=0A=
 * property called `$get`, which holds the **service factory** function.=0A=
 *=0A=
 * When you request a service, the {@link auto.$injector $injector} is =
responsible for finding the=0A=
 * correct **service provider**, instantiating it and then calling its =
`$get` **service factory**=0A=
 * function to get the instance of the **service**.=0A=
 *=0A=
 * Often services have no configuration options and there is no need to =
add methods to the service=0A=
 * provider.  The provider will be no more than a constructor function =
with a `$get` property. For=0A=
 * these cases the {@link auto.$provide $provide} service has additional =
helper methods to register=0A=
 * services without specifying a provider.=0A=
 *=0A=
 * * {@link auto.$provide#provider provider(provider)} - registers a =
**service provider** with the=0A=
 *     {@link auto.$injector $injector}=0A=
 * * {@link auto.$provide#constant constant(obj)} - registers a =
value/object that can be accessed by=0A=
 *     providers and services.=0A=
 * * {@link auto.$provide#value value(obj)} - registers a value/object =
that can only be accessed by=0A=
 *     services, not providers.=0A=
 * * {@link auto.$provide#factory factory(fn)} - registers a service =
**factory function**, `fn`,=0A=
 *     that will be wrapped in a **service provider** object, whose =
`$get` property will contain the=0A=
 *     given factory function.=0A=
 * * {@link auto.$provide#service service(class)} - registers a =
**constructor function**, `class`=0A=
 *     that will be wrapped in a **service provider** object, whose =
`$get` property will instantiate=0A=
 *      a new object using the given constructor function.=0A=
 *=0A=
 * See the individual methods for more information and examples.=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $provide#provider=0A=
 * @description=0A=
 *=0A=
 * Register a **provider function** with the {@link auto.$injector =
$injector}. Provider functions=0A=
 * are constructor functions, whose instances are responsible for =
"providing" a factory for a=0A=
 * service.=0A=
 *=0A=
 * Service provider names start with the name of the service they =
provide followed by `Provider`.=0A=
 * For example, the {@link ng.$log $log} service has a provider called=0A=
 * {@link ng.$logProvider $logProvider}.=0A=
 *=0A=
 * Service provider objects can have additional methods which allow =
configuration of the provider=0A=
 * and its service. Importantly, you can configure what kind of service =
is created by the `$get`=0A=
 * method, or how that service will act. For example, the {@link =
ng.$logProvider $logProvider} has a=0A=
 * method {@link ng.$logProvider#debugEnabled debugEnabled}=0A=
 * which lets you specify whether the {@link ng.$log $log} service will =
log debug messages to the=0A=
 * console or not.=0A=
 *=0A=
 * @param {string} name The name of the instance. NOTE: the provider =
will be available under `name +=0A=
                        'Provider'` key.=0A=
 * @param {(Object|function())} provider If the provider is:=0A=
 *=0A=
 *   - `Object`: then it should have a `$get` method. The `$get` method =
will be invoked using=0A=
 *     {@link auto.$injector#invoke $injector.invoke()} when an instance =
needs to be created.=0A=
 *   - `Constructor`: a new instance of the provider will be created =
using=0A=
 *     {@link auto.$injector#instantiate $injector.instantiate()}, then =
treated as `object`.=0A=
 *=0A=
 * @returns {Object} registered provider instance=0A=
=0A=
 * @example=0A=
 *=0A=
 * The following example shows how to create a simple event tracking =
service and register it using=0A=
 * {@link auto.$provide#provider $provide.provider()}.=0A=
 *=0A=
 * ```js=0A=
 *  // Define the eventTracker provider=0A=
 *  function EventTrackerProvider() {=0A=
 *    var trackingUrl =3D '/track';=0A=
 *=0A=
 *    // A provider method for configuring where the tracked events =
should been saved=0A=
 *    this.setTrackingUrl =3D function(url) {=0A=
 *      trackingUrl =3D url;=0A=
 *    };=0A=
 *=0A=
 *    // The service factory function=0A=
 *    this.$get =3D ['$http', function($http) {=0A=
 *      var trackedEvents =3D {};=0A=
 *      return {=0A=
 *        // Call this to track an event=0A=
 *        event: function(event) {=0A=
 *          var count =3D trackedEvents[event] || 0;=0A=
 *          count +=3D 1;=0A=
 *          trackedEvents[event] =3D count;=0A=
 *          return count;=0A=
 *        },=0A=
 *        // Call this to save the tracked events to the trackingUrl=0A=
 *        save: function() {=0A=
 *          $http.post(trackingUrl, trackedEvents);=0A=
 *        }=0A=
 *      };=0A=
 *    }];=0A=
 *  }=0A=
 *=0A=
 *  describe('eventTracker', function() {=0A=
 *    var postSpy;=0A=
 *=0A=
 *    beforeEach(module(function($provide) {=0A=
 *      // Register the eventTracker provider=0A=
 *      $provide.provider('eventTracker', EventTrackerProvider);=0A=
 *    }));=0A=
 *=0A=
 *    beforeEach(module(function(eventTrackerProvider) {=0A=
 *      // Configure eventTracker provider=0A=
 *      eventTrackerProvider.setTrackingUrl('/custom-track');=0A=
 *    }));=0A=
 *=0A=
 *    it('tracks events', inject(function(eventTracker) {=0A=
 *      expect(eventTracker.event('login')).toEqual(1);=0A=
 *      expect(eventTracker.event('login')).toEqual(2);=0A=
 *    }));=0A=
 *=0A=
 *    it('saves to the tracking url', inject(function(eventTracker, =
$http) {=0A=
 *      postSpy =3D spyOn($http, 'post');=0A=
 *      eventTracker.event('login');=0A=
 *      eventTracker.save();=0A=
 *      expect(postSpy).toHaveBeenCalled();=0A=
 *      expect(postSpy.mostRecentCall.args[0]).not.toEqual('/track');=0A=
 *      expect(postSpy.mostRecentCall.args[0]).toEqual('/custom-track');=0A=
 *      expect(postSpy.mostRecentCall.args[1]).toEqual({ 'login': 1 });=0A=
 *    }));=0A=
 *  });=0A=
 * ```=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $provide#factory=0A=
 * @description=0A=
 *=0A=
 * Register a **service factory**, which will be called to return the =
service instance.=0A=
 * This is short for registering a service where its provider consists =
of only a `$get` property,=0A=
 * which is the given service factory function.=0A=
 * You should use {@link auto.$provide#factory $provide.factory(getFn)} =
if you do not need to=0A=
 * configure your service in a provider.=0A=
 *=0A=
 * @param {string} name The name of the instance.=0A=
 * @param {function()} $getFn The $getFn for the instance creation. =
Internally this is a short hand=0A=
 *                            for `$provide.provider(name, {$get: =
$getFn})`.=0A=
 * @returns {Object} registered provider instance=0A=
 *=0A=
 * @example=0A=
 * Here is an example of registering a service=0A=
 * ```js=0A=
 *   $provide.factory('ping', ['$http', function($http) {=0A=
 *     return function ping() {=0A=
 *       return $http.send('/ping');=0A=
 *     };=0A=
 *   }]);=0A=
 * ```=0A=
 * You would then inject and use this service like this:=0A=
 * ```js=0A=
 *   someModule.controller('Ctrl', ['ping', function(ping) {=0A=
 *     ping();=0A=
 *   }]);=0A=
 * ```=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $provide#service=0A=
 * @description=0A=
 *=0A=
 * Register a **service constructor**, which will be invoked with `new` =
to create the service=0A=
 * instance.=0A=
 * This is short for registering a service where its provider's `$get` =
property is the service=0A=
 * constructor function that will be used to instantiate the service =
instance.=0A=
 *=0A=
 * You should use {@link auto.$provide#service $provide.service(class)} =
if you define your service=0A=
 * as a type/class.=0A=
 *=0A=
 * @param {string} name The name of the instance.=0A=
 * @param {Function} constructor A class (constructor function) that =
will be instantiated.=0A=
 * @returns {Object} registered provider instance=0A=
 *=0A=
 * @example=0A=
 * Here is an example of registering a service using=0A=
 * {@link auto.$provide#service $provide.service(class)}.=0A=
 * ```js=0A=
 *   var Ping =3D function($http) {=0A=
 *     this.$http =3D $http;=0A=
 *   };=0A=
 *=0A=
 *   Ping.$inject =3D ['$http'];=0A=
 *=0A=
 *   Ping.prototype.send =3D function() {=0A=
 *     return this.$http.get('/ping');=0A=
 *   };=0A=
 *   $provide.service('ping', Ping);=0A=
 * ```=0A=
 * You would then inject and use this service like this:=0A=
 * ```js=0A=
 *   someModule.controller('Ctrl', ['ping', function(ping) {=0A=
 *     ping.send();=0A=
 *   }]);=0A=
 * ```=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $provide#value=0A=
 * @description=0A=
 *=0A=
 * Register a **value service** with the {@link auto.$injector =
$injector}, such as a string, a=0A=
 * number, an array, an object or a function.  This is short for =
registering a service where its=0A=
 * provider's `$get` property is a factory function that takes no =
arguments and returns the **value=0A=
 * service**.=0A=
 *=0A=
 * Value services are similar to constant services, except that they =
cannot be injected into a=0A=
 * module configuration function (see {@link angular.Module#config}) but =
they can be overridden by=0A=
 * an Angular=0A=
 * {@link auto.$provide#decorator decorator}.=0A=
 *=0A=
 * @param {string} name The name of the instance.=0A=
 * @param {*} value The value.=0A=
 * @returns {Object} registered provider instance=0A=
 *=0A=
 * @example=0A=
 * Here are some examples of creating value services.=0A=
 * ```js=0A=
 *   $provide.value('ADMIN_USER', 'admin');=0A=
 *=0A=
 *   $provide.value('RoleLookup', { admin: 0, writer: 1, reader: 2 });=0A=
 *=0A=
 *   $provide.value('halfOf', function(value) {=0A=
 *     return value / 2;=0A=
 *   });=0A=
 * ```=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $provide#constant=0A=
 * @description=0A=
 *=0A=
 * Register a **constant service**, such as a string, a number, an =
array, an object or a function,=0A=
 * with the {@link auto.$injector $injector}. Unlike {@link =
auto.$provide#value value} it can be=0A=
 * injected into a module configuration function (see {@link =
angular.Module#config}) and it cannot=0A=
 * be overridden by an Angular {@link auto.$provide#decorator decorator}.=0A=
 *=0A=
 * @param {string} name The name of the constant.=0A=
 * @param {*} value The constant value.=0A=
 * @returns {Object} registered instance=0A=
 *=0A=
 * @example=0A=
 * Here a some examples of creating constants:=0A=
 * ```js=0A=
 *   $provide.constant('SHARD_HEIGHT', 306);=0A=
 *=0A=
 *   $provide.constant('MY_COLOURS', ['red', 'blue', 'grey']);=0A=
 *=0A=
 *   $provide.constant('double', function(value) {=0A=
 *     return value * 2;=0A=
 *   });=0A=
 * ```=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $provide#decorator=0A=
 * @description=0A=
 *=0A=
 * Register a **service decorator** with the {@link auto.$injector =
$injector}. A service decorator=0A=
 * intercepts the creation of a service, allowing it to override or =
modify the behaviour of the=0A=
 * service. The object returned by the decorator may be the original =
service, or a new service=0A=
 * object which replaces or wraps and delegates to the original service.=0A=
 *=0A=
 * @param {string} name The name of the service to decorate.=0A=
 * @param {function()} decorator This function will be invoked when the =
service needs to be=0A=
 *    instantiated and should return the decorated service instance. The =
function is called using=0A=
 *    the {@link auto.$injector#invoke injector.invoke} method and is =
therefore fully injectable.=0A=
 *    Local injection arguments:=0A=
 *=0A=
 *    * `$delegate` - The original service instance, which can be monkey =
patched, configured,=0A=
 *      decorated or delegated to.=0A=
 *=0A=
 * @example=0A=
 * Here we decorate the {@link ng.$log $log} service to convert warnings =
to errors by intercepting=0A=
 * calls to {@link ng.$log#error $log.warn()}.=0A=
 * ```js=0A=
 *   $provide.decorator('$log', ['$delegate', function($delegate) {=0A=
 *     $delegate.warn =3D $delegate.error;=0A=
 *     return $delegate;=0A=
 *   }]);=0A=
 * ```=0A=
 */=0A=
=0A=
=0A=
function createInjector(modulesToLoad, strictDi) {=0A=
  strictDi =3D (strictDi =3D=3D=3D true);=0A=
  var INSTANTIATING =3D {},=0A=
      providerSuffix =3D 'Provider',=0A=
      path =3D [],=0A=
      loadedModules =3D new HashMap([], true),=0A=
      providerCache =3D {=0A=
        $provide: {=0A=
            provider: supportObject(provider),=0A=
            factory: supportObject(factory),=0A=
            service: supportObject(service),=0A=
            value: supportObject(value),=0A=
            constant: supportObject(constant),=0A=
            decorator: decorator=0A=
          }=0A=
      },=0A=
      providerInjector =3D (providerCache.$injector =3D=0A=
          createInternalInjector(providerCache, function() {=0A=
            throw $injectorMinErr('unpr', "Unknown provider: {0}", =
path.join(' &lt;- '));=0A=
          })),=0A=
      instanceCache =3D {},=0A=
      instanceInjector =3D (instanceCache.$injector =3D=0A=
          createInternalInjector(instanceCache, function(servicename) {=0A=
            var provider =3D providerInjector.get(servicename + =
providerSuffix);=0A=
            return instanceInjector.invoke(provider.$get, provider, =
undefined, servicename);=0A=
          }));=0A=
=0A=
=0A=
  forEach(loadModules(modulesToLoad), function(fn) { =
instanceInjector.invoke(fn || noop); });=0A=
=0A=
  return instanceInjector;=0A=
=0A=
  ////////////////////////////////////=0A=
  // $provider=0A=
  ////////////////////////////////////=0A=
=0A=
  function supportObject(delegate) {=0A=
    return function(key, value) {=0A=
      if (isObject(key)) {=0A=
        forEach(key, reverseParams(delegate));=0A=
      } else {=0A=
        return delegate(key, value);=0A=
      }=0A=
    };=0A=
  }=0A=
=0A=
  function provider(name, provider_) {=0A=
    assertNotHasOwnProperty(name, 'service');=0A=
    if (isFunction(provider_) || isArray(provider_)) {=0A=
      provider_ =3D providerInjector.instantiate(provider_);=0A=
    }=0A=
    if (!provider_.$get) {=0A=
      throw $injectorMinErr('pget', "Provider '{0}' must define $get =
factory method.", name);=0A=
    }=0A=
    return providerCache[name + providerSuffix] =3D provider_;=0A=
  }=0A=
=0A=
  function enforceReturnValue(name, factory) {=0A=
    return function enforcedReturnValue() {=0A=
      var result =3D instanceInjector.invoke(factory, this, undefined, =
name);=0A=
      if (isUndefined(result)) {=0A=
        throw $injectorMinErr('undef', "Provider '{0}' must return a =
value from $get factory method.", name);=0A=
      }=0A=
      return result;=0A=
    };=0A=
  }=0A=
=0A=
  function factory(name, factoryFn, enforce) {=0A=
    return provider(name, {=0A=
      $get: enforce !=3D=3D false ? enforceReturnValue(name, factoryFn) =
: factoryFn=0A=
    });=0A=
  }=0A=
=0A=
  function service(name, constructor) {=0A=
    return factory(name, ['$injector', function($injector) {=0A=
      return $injector.instantiate(constructor);=0A=
    }]);=0A=
  }=0A=
=0A=
  function value(name, val) { return factory(name, valueFn(val), false); =
}=0A=
=0A=
  function constant(name, value) {=0A=
    assertNotHasOwnProperty(name, 'constant');=0A=
    providerCache[name] =3D value;=0A=
    instanceCache[name] =3D value;=0A=
  }=0A=
=0A=
  function decorator(serviceName, decorFn) {=0A=
    var origProvider =3D providerInjector.get(serviceName + =
providerSuffix),=0A=
        orig$get =3D origProvider.$get;=0A=
=0A=
    origProvider.$get =3D function() {=0A=
      var origInstance =3D instanceInjector.invoke(orig$get, =
origProvider);=0A=
      return instanceInjector.invoke(decorFn, null, {$delegate: =
origInstance});=0A=
    };=0A=
  }=0A=
=0A=
  ////////////////////////////////////=0A=
  // Module Loading=0A=
  ////////////////////////////////////=0A=
  function loadModules(modulesToLoad){=0A=
    var runBlocks =3D [], moduleFn;=0A=
    forEach(modulesToLoad, function(module) {=0A=
      if (loadedModules.get(module)) return;=0A=
      loadedModules.put(module, true);=0A=
=0A=
      function runInvokeQueue(queue) {=0A=
        var i, ii;=0A=
        for(i =3D 0, ii =3D queue.length; i &lt; ii; i++) {=0A=
          var invokeArgs =3D queue[i],=0A=
              provider =3D providerInjector.get(invokeArgs[0]);=0A=
=0A=
          provider[invokeArgs[1]].apply(provider, invokeArgs[2]);=0A=
        }=0A=
      }=0A=
=0A=
      try {=0A=
        if (isString(module)) {=0A=
          moduleFn =3D angularModule(module);=0A=
          runBlocks =3D =
runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBloc=
ks);=0A=
          runInvokeQueue(moduleFn._invokeQueue);=0A=
          runInvokeQueue(moduleFn._configBlocks);=0A=
        } else if (isFunction(module)) {=0A=
            runBlocks.push(providerInjector.invoke(module));=0A=
        } else if (isArray(module)) {=0A=
            runBlocks.push(providerInjector.invoke(module));=0A=
        } else {=0A=
          assertArgFn(module, 'module');=0A=
        }=0A=
      } catch (e) {=0A=
        if (isArray(module)) {=0A=
          module =3D module[module.length - 1];=0A=
        }=0A=
        if (e.message &amp;&amp; e.stack &amp;&amp; =
e.stack.indexOf(e.message) =3D=3D -1) {=0A=
          // Safari &amp; FF's stack traces don't contain error.message =
content=0A=
          // unlike those of Chrome and IE=0A=
          // So if stack doesn't contain message, we create a new string =
that contains both.=0A=
          // Since error.stack is read-only in Safari, I'm overriding e =
and not e.stack here.=0A=
          /* jshint -W022 */=0A=
          e =3D e.message + '\n' + e.stack;=0A=
        }=0A=
        throw $injectorMinErr('modulerr', "Failed to instantiate module =
{0} due to:\n{1}",=0A=
                  module, e.stack || e.message || e);=0A=
      }=0A=
    });=0A=
    return runBlocks;=0A=
  }=0A=
=0A=
  ////////////////////////////////////=0A=
  // internal Injector=0A=
  ////////////////////////////////////=0A=
=0A=
  function createInternalInjector(cache, factory) {=0A=
=0A=
    function getService(serviceName) {=0A=
      if (cache.hasOwnProperty(serviceName)) {=0A=
        if (cache[serviceName] =3D=3D=3D INSTANTIATING) {=0A=
          throw $injectorMinErr('cdep', 'Circular dependency found: {0}',=0A=
                    serviceName + ' &lt;- ' + path.join(' &lt;- '));=0A=
        }=0A=
        return cache[serviceName];=0A=
      } else {=0A=
        try {=0A=
          path.unshift(serviceName);=0A=
          cache[serviceName] =3D INSTANTIATING;=0A=
          return cache[serviceName] =3D factory(serviceName);=0A=
        } catch (err) {=0A=
          if (cache[serviceName] =3D=3D=3D INSTANTIATING) {=0A=
            delete cache[serviceName];=0A=
          }=0A=
          throw err;=0A=
        } finally {=0A=
          path.shift();=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    function invoke(fn, self, locals, serviceName) {=0A=
      if (typeof locals =3D=3D=3D 'string') {=0A=
        serviceName =3D locals;=0A=
        locals =3D null;=0A=
      }=0A=
=0A=
      var args =3D [],=0A=
          $inject =3D annotate(fn, strictDi, serviceName),=0A=
          length, i,=0A=
          key;=0A=
=0A=
      for(i =3D 0, length =3D $inject.length; i &lt; length; i++) {=0A=
        key =3D $inject[i];=0A=
        if (typeof key !=3D=3D 'string') {=0A=
          throw $injectorMinErr('itkn',=0A=
                  'Incorrect injection token! Expected service name as =
string, got {0}', key);=0A=
        }=0A=
        args.push(=0A=
          locals &amp;&amp; locals.hasOwnProperty(key)=0A=
          ? locals[key]=0A=
          : getService(key)=0A=
        );=0A=
      }=0A=
      if (isArray(fn)) {=0A=
        fn =3D fn[length];=0A=
      }=0A=
=0A=
      // http://jsperf.com/angularjs-invoke-apply-vs-switch=0A=
      // #5388=0A=
      return fn.apply(self, args);=0A=
    }=0A=
=0A=
    function instantiate(Type, locals, serviceName) {=0A=
      var Constructor =3D function() {},=0A=
          instance, returnedValue;=0A=
=0A=
      // Check if Type is annotated and use just the given function at =
n-1 as parameter=0A=
      // e.g. someModule.factory('greeter', ['$window', =
function(renamed$window) {}]);=0A=
      Constructor.prototype =3D (isArray(Type) ? Type[Type.length - 1] : =
Type).prototype;=0A=
      instance =3D new Constructor();=0A=
      returnedValue =3D invoke(Type, instance, locals, serviceName);=0A=
=0A=
      return isObject(returnedValue) || isFunction(returnedValue) ? =
returnedValue : instance;=0A=
    }=0A=
=0A=
    return {=0A=
      invoke: invoke,=0A=
      instantiate: instantiate,=0A=
      get: getService,=0A=
      annotate: annotate,=0A=
      has: function(name) {=0A=
        return providerCache.hasOwnProperty(name + providerSuffix) || =
cache.hasOwnProperty(name);=0A=
      }=0A=
    };=0A=
  }=0A=
}=0A=
=0A=
createInjector.$$annotate =3D annotate;=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $anchorScrollProvider=0A=
 *=0A=
 * @description=0A=
 * Use `$anchorScrollProvider` to disable automatic scrolling whenever=0A=
 * {@link ng.$location#hash $location.hash()} changes.=0A=
 */=0A=
function $AnchorScrollProvider() {=0A=
=0A=
  var autoScrollingEnabled =3D true;=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $anchorScrollProvider#disableAutoScrolling=0A=
   *=0A=
   * @description=0A=
   * By default, {@link ng.$anchorScroll $anchorScroll()} will =
automatically will detect changes to=0A=
   * {@link ng.$location#hash $location.hash()} and scroll to the =
element matching the new hash.&lt;br /&gt;=0A=
   * Use this method to disable automatic scrolling.=0A=
   *=0A=
   * If automatic scrolling is disabled, one must explicitly call=0A=
   * {@link ng.$anchorScroll $anchorScroll()} in order to scroll to the =
element related to the=0A=
   * current hash.=0A=
   */=0A=
  this.disableAutoScrolling =3D function() {=0A=
    autoScrollingEnabled =3D false;=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc service=0A=
   * @name $anchorScroll=0A=
   * @kind function=0A=
   * @requires $window=0A=
   * @requires $location=0A=
   * @requires $rootScope=0A=
   *=0A=
   * @description=0A=
   * When called, it checks the current value of {@link =
ng.$location#hash $location.hash()} and=0A=
   * scrolls to the related element, according to the rules specified in =
the=0A=
   * [Html5 =
spec](http://dev.w3.org/html5/spec/Overview.html#the-indicated-part-of-th=
e-document).=0A=
   *=0A=
   * It also watches the {@link ng.$location#hash $location.hash()} and =
automatically scrolls to=0A=
   * match any anchor whenever it changes. This can be disabled by =
calling=0A=
   * {@link ng.$anchorScrollProvider#disableAutoScrolling =
$anchorScrollProvider.disableAutoScrolling()}.=0A=
   *=0A=
   * Additionally, you can use its {@link ng.$anchorScroll#yOffset =
yOffset} property to specify a=0A=
   * vertical scroll-offset (either fixed or dynamic).=0A=
   *=0A=
   * @property {(number|function|jqLite)} yOffset=0A=
   * If set, specifies a vertical scroll-offset. This is often useful =
when there are fixed=0A=
   * positioned elements at the top of the page, such as navbars, =
headers etc.=0A=
   *=0A=
   * `yOffset` can be specified in various ways:=0A=
   * - **number**: A fixed number of pixels to be used as offset.&lt;br =
/&gt;&lt;br /&gt;=0A=
   * - **function**: A getter function called everytime =
`$anchorScroll()` is executed. Must return=0A=
   *   a number representing the offset (in pixels).&lt;br /&gt;&lt;br =
/&gt;=0A=
   * - **jqLite**: A jqLite/jQuery element to be used for specifying the =
offset. The distance from=0A=
   *   the top of the page to the element's bottom will be used as =
offset.&lt;br /&gt;=0A=
   *   **Note**: The element will be taken into account only as long as =
its `position` is set to=0A=
   *   `fixed`. This option is useful, when dealing with responsive =
navbars/headers that adjust=0A=
   *   their height and/or positioning according to the viewport's size.=0A=
   *=0A=
   * &lt;br /&gt;=0A=
   * &lt;div class=3D"alert alert-warning"&gt;=0A=
   * In order for `yOffset` to work properly, scrolling should take =
place on the document's root and=0A=
   * not some child element.=0A=
   * &lt;/div&gt;=0A=
   *=0A=
   * @example=0A=
     &lt;example module=3D"anchorScrollExample"&gt;=0A=
       &lt;file name=3D"todoList.html"&gt;=0A=
         &lt;div id=3D"scrollArea" ng-controller=3D"ScrollController"&gt;=0A=
           &lt;a ng-click=3D"gotoBottom()"&gt;Go to bottom&lt;/a&gt;=0A=
           &lt;a id=3D"bottom"&gt;&lt;/a&gt; You're at the bottom!=0A=
         &lt;/div&gt;=0A=
       &lt;/file&gt;=0A=
       &lt;file name=3D"script.js"&gt;=0A=
         angular.module('anchorScrollExample', [])=0A=
           .controller('ScrollController', ['$scope', '$location', =
'$anchorScroll',=0A=
             function ($scope, $location, $anchorScroll) {=0A=
               $scope.gotoBottom =3D function() {=0A=
                 // set the location.hash to the id of=0A=
                 // the element you wish to scroll to.=0A=
                 $location.hash('bottom');=0A=
=0A=
                 // call $anchorScroll()=0A=
                 $anchorScroll();=0A=
               };=0A=
             }]);=0A=
       &lt;/file&gt;=0A=
       &lt;file name=3D"style.css"&gt;=0A=
         #scrollArea {=0A=
           height: 280px;=0A=
           overflow: auto;=0A=
         }=0A=
=0A=
         #bottom {=0A=
           display: block;=0A=
           margin-top: 2000px;=0A=
         }=0A=
       &lt;/file&gt;=0A=
     &lt;/example&gt;=0A=
   *=0A=
   * &lt;hr /&gt;=0A=
   * The example below illustrates the use of a vertical scroll-offset =
(specified as a fixed value).=0A=
   * See {@link ng.$anchorScroll#yOffset $anchorScroll.yOffset} for more =
details.=0A=
   *=0A=
   * @example=0A=
     &lt;example module=3D"anchorScrollOffsetExample"&gt;=0A=
       &lt;file name=3D"todoList.html"&gt;=0A=
         &lt;div class=3D"fixed-header" ng-controller=3D"headerCtrl"&gt;=0A=
           &lt;a href=3D"" ng-click=3D"gotoAnchor(x)" ng-repeat=3D"x in =
[1,2,3,4,5]"&gt;=0A=
             Go to anchor {{x}}=0A=
           &lt;/a&gt;=0A=
         &lt;/div&gt;=0A=
         &lt;div id=3D"anchor{{x}}" class=3D"anchor" ng-repeat=3D"x in =
[1,2,3,4,5]"&gt;=0A=
           Anchor {{x}} of 5=0A=
         &lt;/div&gt;=0A=
       &lt;/file&gt;=0A=
       &lt;file name=3D"script.js"&gt;=0A=
         angular.module('anchorScrollOffsetExample', [])=0A=
           .run(['$anchorScroll', function($anchorScroll) {=0A=
             $anchorScroll.yOffset =3D 50;   // always scroll by 50 =
extra pixels=0A=
           }])=0A=
           .controller('headerCtrl', ['$anchorScroll', '$location', =
'$scope',=0A=
             function ($anchorScroll, $location, $scope) {=0A=
               $scope.gotoAnchor =3D function(x) {=0A=
                 var newHash =3D 'anchor' + x;=0A=
                 if ($location.hash() !=3D=3D newHash) {=0A=
                   // set the $location.hash to `newHash` and=0A=
                   // $anchorScroll will automatically scroll to it=0A=
                   $location.hash('anchor' + x);=0A=
                 } else {=0A=
                   // call $anchorScroll() explicitly,=0A=
                   // since $location.hash hasn't changed=0A=
                   $anchorScroll();=0A=
                 }=0A=
               };=0A=
             }=0A=
           ]);=0A=
       &lt;/file&gt;=0A=
       &lt;file name=3D"style.css"&gt;=0A=
         body {=0A=
           padding-top: 50px;=0A=
         }=0A=
=0A=
         .anchor {=0A=
           border: 2px dashed DarkOrchid;=0A=
           padding: 10px 10px 200px 10px;=0A=
         }=0A=
=0A=
         .fixed-header {=0A=
           background-color: rgba(0, 0, 0, 0.2);=0A=
           height: 50px;=0A=
           position: fixed;=0A=
           top: 0; left: 0; right: 0;=0A=
         }=0A=
=0A=
         .fixed-header &gt; a {=0A=
           display: inline-block;=0A=
           margin: 5px 15px;=0A=
         }=0A=
       &lt;/file&gt;=0A=
     &lt;/example&gt;=0A=
   */=0A=
  this.$get =3D ['$window', '$location', '$rootScope', function($window, =
$location, $rootScope) {=0A=
    var document =3D $window.document;=0A=
    var scrollScheduled =3D false;=0A=
=0A=
    // Helper function to get first anchor from a NodeList=0A=
    // (using `Array#some()` instead of `angular#forEach()` since it's =
more performant=0A=
    //  and working in all supported browsers.)=0A=
    function getFirstAnchor(list) {=0A=
      var result =3D null;=0A=
      Array.prototype.some.call(list, function(element) {=0A=
        if (nodeName_(element) =3D=3D=3D 'a') {=0A=
          result =3D element;=0A=
          return true;=0A=
        }=0A=
      });=0A=
      return result;=0A=
    }=0A=
=0A=
    function getYOffset() {=0A=
=0A=
      var offset =3D scroll.yOffset;=0A=
=0A=
      if (isFunction(offset)) {=0A=
        offset =3D offset();=0A=
      } else if (isElement(offset)) {=0A=
        var elem =3D offset[0];=0A=
        var style =3D $window.getComputedStyle(elem);=0A=
        if (style.position !=3D=3D 'fixed') {=0A=
          offset =3D 0;=0A=
        } else {=0A=
          offset =3D elem.getBoundingClientRect().bottom;=0A=
        }=0A=
      } else if (!isNumber(offset)) {=0A=
        offset =3D 0;=0A=
      }=0A=
=0A=
      return offset;=0A=
    }=0A=
=0A=
    function scrollTo(elem) {=0A=
      if (elem) {=0A=
        elem.scrollIntoView();=0A=
=0A=
        var offset =3D getYOffset();=0A=
=0A=
        if (offset) {=0A=
          // `offset` is the number of pixels we should scroll UP in =
order to align `elem` properly.=0A=
          // This is true ONLY if the call to `elem.scrollIntoView()` =
initially aligns `elem` at the=0A=
          // top of the viewport.=0A=
          //=0A=
          // IF the number of pixels from the top of `elem` to the end =
of the page's content is less=0A=
          // than the height of the viewport, then =
`elem.scrollIntoView()` will align the `elem` some=0A=
          // way down the page.=0A=
          //=0A=
          // This is often the case for elements near the bottom of the =
page.=0A=
          //=0A=
          // In such cases we do not need to scroll the whole `offset` =
up, just the difference between=0A=
          // the top of the element and the offset, which is enough to =
align the top of `elem` at the=0A=
          // desired position.=0A=
          var elemTop =3D elem.getBoundingClientRect().top;=0A=
          $window.scrollBy(0, elemTop - offset);=0A=
        }=0A=
      } else {=0A=
        $window.scrollTo(0, 0);=0A=
      }=0A=
    }=0A=
=0A=
    function scroll() {=0A=
      var hash =3D $location.hash(), elm;=0A=
=0A=
      // empty hash, scroll to the top of the page=0A=
      if (!hash) scrollTo(null);=0A=
=0A=
      // element with given id=0A=
      else if ((elm =3D document.getElementById(hash))) scrollTo(elm);=0A=
=0A=
      // first anchor with given name :-D=0A=
      else if ((elm =3D =
getFirstAnchor(document.getElementsByName(hash)))) scrollTo(elm);=0A=
=0A=
      // no element and hash =3D=3D 'top', scroll to the top of the page=0A=
      else if (hash =3D=3D=3D 'top') scrollTo(null);=0A=
    }=0A=
=0A=
    // does not scroll when user clicks on anchor link that is currently =
on=0A=
    // (no url change, no $location.hash() change), browser native does =
scroll=0A=
    if (autoScrollingEnabled) {=0A=
      $rootScope.$watch(function autoScrollWatch() {return =
$location.hash();},=0A=
        function autoScrollWatchAction(newVal, oldVal) {=0A=
          // skip the initial scroll if $location.hash is empty=0A=
          if (newVal =3D=3D=3D oldVal &amp;&amp; newVal =3D=3D=3D '') =
return;=0A=
=0A=
          jqLiteDocumentLoaded(function() {=0A=
            $rootScope.$evalAsync(scroll);=0A=
          });=0A=
        });=0A=
    }=0A=
=0A=
    return scroll;=0A=
  }];=0A=
}=0A=
=0A=
var $animateMinErr =3D minErr('$animate');=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $animateProvider=0A=
 *=0A=
 * @description=0A=
 * Default implementation of $animate that doesn't perform any =
animations, instead just=0A=
 * synchronously performs DOM=0A=
 * updates and calls done() callbacks.=0A=
 *=0A=
 * In order to enable animations the ngAnimate module has to be loaded.=0A=
 *=0A=
 * To see the functional implementation check out =
src/ngAnimate/animate.js=0A=
 */=0A=
var $AnimateProvider =3D ['$provide', function($provide) {=0A=
=0A=
=0A=
  this.$$selectors =3D {};=0A=
=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $animateProvider#register=0A=
   *=0A=
   * @description=0A=
   * Registers a new injectable animation factory function. The factory =
function produces the=0A=
   * animation object which contains callback functions for each event =
that is expected to be=0A=
   * animated.=0A=
   *=0A=
   *   * `eventFn`: `function(Element, doneFunction)` The element to =
animate, the `doneFunction`=0A=
   *   must be called once the element animation is complete. If a =
function is returned then the=0A=
   *   animation service will use this function to cancel the animation =
whenever a cancel event is=0A=
   *   triggered.=0A=
   *=0A=
   *=0A=
   * ```js=0A=
   *   return {=0A=
     *     eventFn : function(element, done) {=0A=
     *       //code to run the animation=0A=
     *       //once complete, then run done()=0A=
     *       return function cancellationFunction() {=0A=
     *         //code to cancel the animation=0A=
     *       }=0A=
     *     }=0A=
     *   }=0A=
   * ```=0A=
   *=0A=
   * @param {string} name The name of the animation.=0A=
   * @param {Function} factory The factory function that will be =
executed to return the animation=0A=
   *                           object.=0A=
   */=0A=
  this.register =3D function(name, factory) {=0A=
    var key =3D name + '-animation';=0A=
    if (name &amp;&amp; name.charAt(0) !=3D '.') throw =
$animateMinErr('notcsel',=0A=
        "Expecting class selector starting with '.' got '{0}'.", name);=0A=
    this.$$selectors[name.substr(1)] =3D key;=0A=
    $provide.factory(key, factory);=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $animateProvider#classNameFilter=0A=
   *=0A=
   * @description=0A=
   * Sets and/or returns the CSS class regular expression that is =
checked when performing=0A=
   * an animation. Upon bootstrap the classNameFilter value is not set =
at all and will=0A=
   * therefore enable $animate to attempt to perform an animation on any =
element.=0A=
   * When setting the classNameFilter value, animations will only be =
performed on elements=0A=
   * that successfully match the filter expression. This in turn can =
boost performance=0A=
   * for low-powered devices as well as applications containing a lot of =
structural operations.=0A=
   * @param {RegExp=3D} expression The className expression which will =
be checked against all animations=0A=
   * @return {RegExp} The current CSS className expression value. If =
null then there is no expression value=0A=
   */=0A=
  this.classNameFilter =3D function(expression) {=0A=
    if(arguments.length =3D=3D=3D 1) {=0A=
      this.$$classNameFilter =3D (expression instanceof RegExp) ? =
expression : null;=0A=
    }=0A=
    return this.$$classNameFilter;=0A=
  };=0A=
=0A=
  this.$get =3D ['$$q', '$$asyncCallback', '$rootScope', function($$q, =
$$asyncCallback, $rootScope) {=0A=
=0A=
    var currentDefer;=0A=
=0A=
    function runAnimationPostDigest(fn) {=0A=
      var cancelFn, defer =3D $$q.defer();=0A=
      defer.promise.$$cancelFn =3D function ngAnimateMaybeCancel() {=0A=
        cancelFn &amp;&amp; cancelFn();=0A=
      };=0A=
=0A=
      $rootScope.$$postDigest(function ngAnimatePostDigest() {=0A=
        cancelFn =3D fn(function ngAnimateNotifyComplete() {=0A=
          defer.resolve();=0A=
        });=0A=
      });=0A=
=0A=
      return defer.promise;=0A=
    }=0A=
=0A=
    function resolveElementClasses(element, classes) {=0A=
      var toAdd =3D [], toRemove =3D [];=0A=
=0A=
      var hasClasses =3D createMap();=0A=
      forEach((element.attr('class') || '').split(/\s+/), =
function(className) {=0A=
        hasClasses[className] =3D true;=0A=
      });=0A=
=0A=
      forEach(classes, function(status, className) {=0A=
        var hasClass =3D hasClasses[className];=0A=
=0A=
        // If the most recent class manipulation (via $animate) was to =
remove the class, and the=0A=
        // element currently has the class, the class is scheduled for =
removal. Otherwise, if=0A=
        // the most recent class manipulation (via $animate) was to add =
the class, and the=0A=
        // element does not currently have the class, the class is =
scheduled to be added.=0A=
        if (status =3D=3D=3D false &amp;&amp; hasClass) {=0A=
          toRemove.push(className);=0A=
        } else if (status =3D=3D=3D true &amp;&amp; !hasClass) {=0A=
          toAdd.push(className);=0A=
        }=0A=
      });=0A=
=0A=
      return (toAdd.length + toRemove.length) &gt; 0 &amp;&amp;=0A=
        [toAdd.length ? toAdd : null, toRemove.length ? toRemove : null];=0A=
    }=0A=
=0A=
    function cachedClassManipulation(cache, classes, op) {=0A=
      for (var i=3D0, ii =3D classes.length; i &lt; ii; ++i) {=0A=
        var className =3D classes[i];=0A=
        cache[className] =3D op;=0A=
      }=0A=
    }=0A=
=0A=
    function asyncPromise() {=0A=
      // only serve one instance of a promise in order to save CPU cycles=0A=
      if (!currentDefer) {=0A=
        currentDefer =3D $$q.defer();=0A=
        $$asyncCallback(function() {=0A=
          currentDefer.resolve();=0A=
          currentDefer =3D null;=0A=
        });=0A=
      }=0A=
      return currentDefer.promise;=0A=
    }=0A=
=0A=
    function applyStyles(element, options) {=0A=
      if (angular.isObject(options)) {=0A=
        var styles =3D extend(options.from || {}, options.to || {});=0A=
        element.css(styles);=0A=
      }=0A=
    }=0A=
=0A=
    /**=0A=
     *=0A=
     * @ngdoc service=0A=
     * @name $animate=0A=
     * @description The $animate service provides rudimentary DOM =
manipulation functions to=0A=
     * insert, remove and move elements within the DOM, as well as =
adding and removing classes.=0A=
     * This service is the core service used by the ngAnimate $animator =
service which provides=0A=
     * high-level animation hooks for CSS and JavaScript.=0A=
     *=0A=
     * $animate is available in the AngularJS core, however, the =
ngAnimate module must be included=0A=
     * to enable full out animation support. Otherwise, $animate will =
only perform simple DOM=0A=
     * manipulation operations.=0A=
     *=0A=
     * To learn more about enabling animation support, click here to =
visit the {@link ngAnimate=0A=
     * ngAnimate module page} as well as the {@link ngAnimate.$animate =
ngAnimate $animate service=0A=
     * page}.=0A=
     */=0A=
    return {=0A=
      animate : function(element, from, to) {=0A=
        applyStyles(element, { from: from, to: to });=0A=
        return asyncPromise();=0A=
      },=0A=
=0A=
      /**=0A=
       *=0A=
       * @ngdoc method=0A=
       * @name $animate#enter=0A=
       * @kind function=0A=
       * @description Inserts the element into the DOM either after the =
`after` element or=0A=
       * as the first child within the `parent` element. When the =
function is called a promise=0A=
       * is returned that will be resolved at a later time.=0A=
       * @param {DOMElement} element the element which will be inserted =
into the DOM=0A=
       * @param {DOMElement} parent the parent element which will append =
the element as=0A=
       *   a child (if the after element is not present)=0A=
       * @param {DOMElement} after the sibling element which will append =
the element=0A=
       *   after itself=0A=
       * @param {object=3D} options an optional collection of styles =
that will be applied to the element.=0A=
       * @return {Promise} the animation callback promise=0A=
       */=0A=
      enter : function(element, parent, after, options) {=0A=
        applyStyles(element, options);=0A=
        after ? after.after(element)=0A=
              : parent.prepend(element);=0A=
        return asyncPromise();=0A=
      },=0A=
=0A=
      /**=0A=
       *=0A=
       * @ngdoc method=0A=
       * @name $animate#leave=0A=
       * @kind function=0A=
       * @description Removes the element from the DOM. When the =
function is called a promise=0A=
       * is returned that will be resolved at a later time.=0A=
       * @param {DOMElement} element the element which will be removed =
from the DOM=0A=
       * @param {object=3D} options an optional collection of options =
that will be applied to the element.=0A=
       * @return {Promise} the animation callback promise=0A=
       */=0A=
      leave : function(element, options) {=0A=
        element.remove();=0A=
        return asyncPromise();=0A=
      },=0A=
=0A=
      /**=0A=
       *=0A=
       * @ngdoc method=0A=
       * @name $animate#move=0A=
       * @kind function=0A=
       * @description Moves the position of the provided element within =
the DOM to be placed=0A=
       * either after the `after` element or inside of the `parent` =
element. When the function=0A=
       * is called a promise is returned that will be resolved at a =
later time.=0A=
       *=0A=
       * @param {DOMElement} element the element which will be moved =
around within the=0A=
       *   DOM=0A=
       * @param {DOMElement} parent the parent element where the element =
will be=0A=
       *   inserted into (if the after element is not present)=0A=
       * @param {DOMElement} after the sibling element where the element =
will be=0A=
       *   positioned next to=0A=
       * @param {object=3D} options an optional collection of options =
that will be applied to the element.=0A=
       * @return {Promise} the animation callback promise=0A=
       */=0A=
      move : function(element, parent, after, options) {=0A=
        // Do not remove element before insert. Removing will cause data =
associated with the=0A=
        // element to be dropped. Insert will implicitly do the remove.=0A=
        return this.enter(element, parent, after, options);=0A=
      },=0A=
=0A=
      /**=0A=
       *=0A=
       * @ngdoc method=0A=
       * @name $animate#addClass=0A=
       * @kind function=0A=
       * @description Adds the provided className CSS class value to the =
provided element.=0A=
       * When the function is called a promise is returned that will be =
resolved at a later time.=0A=
       * @param {DOMElement} element the element which will have the =
className value=0A=
       *   added to it=0A=
       * @param {string} className the CSS class which will be added to =
the element=0A=
       * @param {object=3D} options an optional collection of options =
that will be applied to the element.=0A=
       * @return {Promise} the animation callback promise=0A=
       */=0A=
      addClass : function(element, className, options) {=0A=
        return this.setClass(element, className, [], options);=0A=
      },=0A=
=0A=
      $$addClassImmediately : function(element, className, options) {=0A=
        element =3D jqLite(element);=0A=
        className =3D !isString(className)=0A=
                        ? (isArray(className) ? className.join(' ') : '')=0A=
                        : className;=0A=
        forEach(element, function (element) {=0A=
          jqLiteAddClass(element, className);=0A=
        });=0A=
        applyStyles(element, options);=0A=
        return asyncPromise();=0A=
      },=0A=
=0A=
      /**=0A=
       *=0A=
       * @ngdoc method=0A=
       * @name $animate#removeClass=0A=
       * @kind function=0A=
       * @description Removes the provided className CSS class value =
from the provided element.=0A=
       * When the function is called a promise is returned that will be =
resolved at a later time.=0A=
       * @param {DOMElement} element the element which will have the =
className value=0A=
       *   removed from it=0A=
       * @param {string} className the CSS class which will be removed =
from the element=0A=
       * @param {object=3D} options an optional collection of options =
that will be applied to the element.=0A=
       * @return {Promise} the animation callback promise=0A=
       */=0A=
      removeClass : function(element, className, options) {=0A=
        return this.setClass(element, [], className, options);=0A=
      },=0A=
=0A=
      $$removeClassImmediately : function(element, className, options) {=0A=
        element =3D jqLite(element);=0A=
        className =3D !isString(className)=0A=
                        ? (isArray(className) ? className.join(' ') : '')=0A=
                        : className;=0A=
        forEach(element, function (element) {=0A=
          jqLiteRemoveClass(element, className);=0A=
        });=0A=
        applyStyles(element, options);=0A=
        return asyncPromise();=0A=
      },=0A=
=0A=
      /**=0A=
       *=0A=
       * @ngdoc method=0A=
       * @name $animate#setClass=0A=
       * @kind function=0A=
       * @description Adds and/or removes the given CSS classes to and =
from the element.=0A=
       * When the function is called a promise is returned that will be =
resolved at a later time.=0A=
       * @param {DOMElement} element the element which will have its CSS =
classes changed=0A=
       *   removed from it=0A=
       * @param {string} add the CSS classes which will be added to the =
element=0A=
       * @param {string} remove the CSS class which will be removed from =
the element=0A=
       * @param {object=3D} options an optional collection of options =
that will be applied to the element.=0A=
       * @return {Promise} the animation callback promise=0A=
       */=0A=
      setClass : function(element, add, remove, options) {=0A=
        var self =3D this;=0A=
        var STORAGE_KEY =3D '$$animateClasses';=0A=
        var createdCache =3D false;=0A=
        element =3D jqLite(element);=0A=
=0A=
        var cache =3D element.data(STORAGE_KEY);=0A=
        if (!cache) {=0A=
          cache =3D {=0A=
            classes: {},=0A=
            options : options=0A=
          };=0A=
          createdCache =3D true;=0A=
        } else if (options &amp;&amp; cache.options) {=0A=
          cache.options =3D angular.extend(cache.options || {}, options);=0A=
        }=0A=
=0A=
        var classes =3D cache.classes;=0A=
=0A=
        add =3D isArray(add) ? add : add.split(' ');=0A=
        remove =3D isArray(remove) ? remove : remove.split(' ');=0A=
        cachedClassManipulation(classes, add, true);=0A=
        cachedClassManipulation(classes, remove, false);=0A=
=0A=
        if (createdCache) {=0A=
          cache.promise =3D runAnimationPostDigest(function(done) {=0A=
            var cache =3D element.data(STORAGE_KEY);=0A=
            element.removeData(STORAGE_KEY);=0A=
=0A=
            // in the event that the element is removed before postDigest=0A=
            // is run then the cache will be undefined and there will be=0A=
            // no need anymore to add or remove and of the element =
classes=0A=
            if (cache) {=0A=
              var classes =3D resolveElementClasses(element, =
cache.classes);=0A=
              if (classes) {=0A=
                self.$$setClassImmediately(element, classes[0], =
classes[1], cache.options);=0A=
              }=0A=
            }=0A=
=0A=
            done();=0A=
          });=0A=
          element.data(STORAGE_KEY, cache);=0A=
        }=0A=
=0A=
        return cache.promise;=0A=
      },=0A=
=0A=
      $$setClassImmediately : function(element, add, remove, options) {=0A=
        add &amp;&amp; this.$$addClassImmediately(element, add);=0A=
        remove &amp;&amp; this.$$removeClassImmediately(element, remove);=0A=
        applyStyles(element, options);=0A=
        return asyncPromise();=0A=
      },=0A=
=0A=
      enabled : noop,=0A=
      cancel : noop=0A=
    };=0A=
  }];=0A=
}];=0A=
=0A=
function $$AsyncCallbackProvider(){=0A=
  this.$get =3D ['$$rAF', '$timeout', function($$rAF, $timeout) {=0A=
    return $$rAF.supported=0A=
      ? function(fn) { return $$rAF(fn); }=0A=
      : function(fn) {=0A=
        return $timeout(fn, 0, false);=0A=
      };=0A=
  }];=0A=
}=0A=
=0A=
/* global stripHash: true */=0A=
=0A=
/**=0A=
 * ! This is a private undocumented service !=0A=
 *=0A=
 * @name $browser=0A=
 * @requires $log=0A=
 * @description=0A=
 * This object has two goals:=0A=
 *=0A=
 * - hide all the global state in the browser caused by the window object=0A=
 * - abstract away all the browser specific features and inconsistencies=0A=
 *=0A=
 * For tests we provide {@link ngMock.$browser mock implementation} of =
the `$browser`=0A=
 * service, which can be used for convenient testing of the application =
without the interaction with=0A=
 * the real browser apis.=0A=
 */=0A=
/**=0A=
 * @param {object} window The global window object.=0A=
 * @param {object} document jQuery wrapped document.=0A=
 * @param {function()} XHR XMLHttpRequest constructor.=0A=
 * @param {object} $log console.log or an object with the same interface.=0A=
 * @param {object} $sniffer $sniffer service=0A=
 */=0A=
function Browser(window, document, $log, $sniffer) {=0A=
  var self =3D this,=0A=
      rawDocument =3D document[0],=0A=
      location =3D window.location,=0A=
      history =3D window.history,=0A=
      setTimeout =3D window.setTimeout,=0A=
      clearTimeout =3D window.clearTimeout,=0A=
      pendingDeferIds =3D {};=0A=
=0A=
  self.isMock =3D false;=0A=
=0A=
  var outstandingRequestCount =3D 0;=0A=
  var outstandingRequestCallbacks =3D [];=0A=
=0A=
  // TODO(vojta): remove this temporary api=0A=
  self.$$completeOutstandingRequest =3D completeOutstandingRequest;=0A=
  self.$$incOutstandingRequestCount =3D function() { =
outstandingRequestCount++; };=0A=
=0A=
  /**=0A=
   * Executes the `fn` function(supports currying) and decrements the =
`outstandingRequestCallbacks`=0A=
   * counter. If the counter reaches 0, all the =
`outstandingRequestCallbacks` are executed.=0A=
   */=0A=
  function completeOutstandingRequest(fn) {=0A=
    try {=0A=
      fn.apply(null, sliceArgs(arguments, 1));=0A=
    } finally {=0A=
      outstandingRequestCount--;=0A=
      if (outstandingRequestCount =3D=3D=3D 0) {=0A=
        while(outstandingRequestCallbacks.length) {=0A=
          try {=0A=
            outstandingRequestCallbacks.pop()();=0A=
          } catch (e) {=0A=
            $log.error(e);=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
  }=0A=
=0A=
  /**=0A=
   * @private=0A=
   * Note: this method is used only by scenario runner=0A=
   * TODO(vojta): prefix this method with $$ ?=0A=
   * @param {function()} callback Function that will be called when no =
outstanding request=0A=
   */=0A=
  self.notifyWhenNoOutstandingRequests =3D function(callback) {=0A=
    // force browser to execute all pollFns - this is needed so that =
cookies and other pollers fire=0A=
    // at some deterministic time in respect to the test runner's =
actions. Leaving things up to the=0A=
    // regular poller would result in flaky tests.=0A=
    forEach(pollFns, function(pollFn){ pollFn(); });=0A=
=0A=
    if (outstandingRequestCount =3D=3D=3D 0) {=0A=
      callback();=0A=
    } else {=0A=
      outstandingRequestCallbacks.push(callback);=0A=
    }=0A=
  };=0A=
=0A=
  //////////////////////////////////////////////////////////////=0A=
  // Poll Watcher API=0A=
  //////////////////////////////////////////////////////////////=0A=
  var pollFns =3D [],=0A=
      pollTimeout;=0A=
=0A=
  /**=0A=
   * @name $browser#addPollFn=0A=
   *=0A=
   * @param {function()} fn Poll function to add=0A=
   *=0A=
   * @description=0A=
   * Adds a function to the list of functions that poller periodically =
executes,=0A=
   * and starts polling if not started yet.=0A=
   *=0A=
   * @returns {function()} the added function=0A=
   */=0A=
  self.addPollFn =3D function(fn) {=0A=
    if (isUndefined(pollTimeout)) startPoller(100, setTimeout);=0A=
    pollFns.push(fn);=0A=
    return fn;=0A=
  };=0A=
=0A=
  /**=0A=
   * @param {number} interval How often should browser call poll =
functions (ms)=0A=
   * @param {function()} setTimeout Reference to a real or fake =
`setTimeout` function.=0A=
   *=0A=
   * @description=0A=
   * Configures the poller to run in the specified intervals, using the =
specified=0A=
   * setTimeout fn and kicks it off.=0A=
   */=0A=
  function startPoller(interval, setTimeout) {=0A=
    (function check() {=0A=
      forEach(pollFns, function(pollFn){ pollFn(); });=0A=
      pollTimeout =3D setTimeout(check, interval);=0A=
    })();=0A=
  }=0A=
=0A=
  //////////////////////////////////////////////////////////////=0A=
  // URL API=0A=
  //////////////////////////////////////////////////////////////=0A=
=0A=
  var cachedState, lastHistoryState,=0A=
      lastBrowserUrl =3D location.href,=0A=
      baseElement =3D document.find('base'),=0A=
      reloadLocation =3D null;=0A=
=0A=
  cacheState();=0A=
  lastHistoryState =3D cachedState;=0A=
=0A=
  /**=0A=
   * @name $browser#url=0A=
   *=0A=
   * @description=0A=
   * GETTER:=0A=
   * Without any argument, this method just returns current value of =
location.href.=0A=
   *=0A=
   * SETTER:=0A=
   * With at least one argument, this method sets url to new value.=0A=
   * If html5 history api supported, pushState/replaceState is used, =
otherwise=0A=
   * location.href/location.replace is used.=0A=
   * Returns its own instance to allow chaining=0A=
   *=0A=
   * NOTE: this api is intended for use only by the $location service. =
Please use the=0A=
   * {@link ng.$location $location service} to change url.=0A=
   *=0A=
   * @param {string} url New url (when used as setter)=0A=
   * @param {boolean=3D} replace Should new url replace current history =
record?=0A=
   * @param {object=3D} state object to use with pushState/replaceState=0A=
   */=0A=
  self.url =3D function(url, replace, state) {=0A=
    // In modern browsers `history.state` is `null` by default; treating =
it separately=0A=
    // from `undefined` would cause `$browser.url('/foo')` to change =
`history.state`=0A=
    // to undefined via `pushState`. Instead, let's change `undefined` =
to `null` here.=0A=
    if (isUndefined(state)) {=0A=
      state =3D null;=0A=
    }=0A=
=0A=
    // Android Browser BFCache causes location, history reference to =
become stale.=0A=
    if (location !=3D=3D window.location) location =3D window.location;=0A=
    if (history !=3D=3D window.history) history =3D window.history;=0A=
=0A=
    // setter=0A=
    if (url) {=0A=
      var sameState =3D lastHistoryState =3D=3D=3D state;=0A=
=0A=
      // Don't change anything if previous and current URLs and states =
match. This also prevents=0A=
      // IE&lt;10 from getting into redirect loop when in =
LocationHashbangInHtml5Url mode.=0A=
      // See https://github.com/angular/angular.js/commit/ffb2701=0A=
      if (lastBrowserUrl =3D=3D=3D url &amp;&amp; (!$sniffer.history || =
sameState)) {=0A=
        return;=0A=
      }=0A=
      var sameBase =3D lastBrowserUrl &amp;&amp; =
stripHash(lastBrowserUrl) =3D=3D=3D stripHash(url);=0A=
      lastBrowserUrl =3D url;=0A=
      lastHistoryState =3D state;=0A=
      // Don't use history API if only the hash changed=0A=
      // due to a bug in IE10/IE11 which leads=0A=
      // to not firing a `hashchange` nor `popstate` event=0A=
      // in some cases (see #9143).=0A=
      if ($sniffer.history &amp;&amp; (!sameBase || !sameState)) {=0A=
        history[replace ? 'replaceState' : 'pushState'](state, '', url);=0A=
        cacheState();=0A=
        // Do the assignment again so that those two variables are =
referentially identical.=0A=
        lastHistoryState =3D cachedState;=0A=
      } else {=0A=
        if (!sameBase) {=0A=
          reloadLocation =3D url;=0A=
        }=0A=
        if (replace) {=0A=
          location.replace(url);=0A=
        } else {=0A=
          location.href =3D url;=0A=
        }=0A=
      }=0A=
      return self;=0A=
    // getter=0A=
    } else {=0A=
      // - reloadLocation is needed as browsers don't allow to read out=0A=
      //   the new location.href if a reload happened.=0A=
      // - the replacement is a workaround for =
https://bugzilla.mozilla.org/show_bug.cgi?id=3D407172=0A=
      return reloadLocation || location.href.replace(/%27/g,"'");=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * @name $browser#state=0A=
   *=0A=
   * @description=0A=
   * This method is a getter.=0A=
   *=0A=
   * Return history.state or null if history.state is undefined.=0A=
   *=0A=
   * @returns {object} state=0A=
   */=0A=
  self.state =3D function() {=0A=
    return cachedState;=0A=
  };=0A=
=0A=
  var urlChangeListeners =3D [],=0A=
      urlChangeInit =3D false;=0A=
=0A=
  function cacheStateAndFireUrlChange() {=0A=
    cacheState();=0A=
    fireUrlChange();=0A=
  }=0A=
=0A=
  // This variable should be used *only* inside the cacheState function.=0A=
  var lastCachedState =3D null;=0A=
  function cacheState() {=0A=
    // This should be the only place in $browser where `history.state` =
is read.=0A=
    cachedState =3D window.history.state;=0A=
    cachedState =3D isUndefined(cachedState) ? null : cachedState;=0A=
=0A=
    // Prevent callbacks fo fire twice if both hashchange &amp; popstate =
were fired.=0A=
    if (equals(cachedState, lastCachedState)) {=0A=
      cachedState =3D lastCachedState;=0A=
    }=0A=
    lastCachedState =3D cachedState;=0A=
  }=0A=
=0A=
  function fireUrlChange() {=0A=
    if (lastBrowserUrl =3D=3D=3D self.url() &amp;&amp; lastHistoryState =
=3D=3D=3D cachedState) {=0A=
      return;=0A=
    }=0A=
=0A=
    lastBrowserUrl =3D self.url();=0A=
    lastHistoryState =3D cachedState;=0A=
    forEach(urlChangeListeners, function(listener) {=0A=
      listener(self.url(), cachedState);=0A=
    });=0A=
  }=0A=
=0A=
  /**=0A=
   * @name $browser#onUrlChange=0A=
   *=0A=
   * @description=0A=
   * Register callback function that will be called, when url changes.=0A=
   *=0A=
   * It's only called when the url is changed from outside of angular:=0A=
   * - user types different url into address bar=0A=
   * - user clicks on history (forward/back) button=0A=
   * - user clicks on a link=0A=
   *=0A=
   * It's not called when url is changed by $browser.url() method=0A=
   *=0A=
   * The listener gets called with new url as parameter.=0A=
   *=0A=
   * NOTE: this api is intended for use only by the $location service. =
Please use the=0A=
   * {@link ng.$location $location service} to monitor url changes in =
angular apps.=0A=
   *=0A=
   * @param {function(string)} listener Listener function to be called =
when url changes.=0A=
   * @return {function(string)} Returns the registered listener fn - =
handy if the fn is anonymous.=0A=
   */=0A=
  self.onUrlChange =3D function(callback) {=0A=
    // TODO(vojta): refactor to use node's syntax for events=0A=
    if (!urlChangeInit) {=0A=
      // We listen on both (hashchange/popstate) when available, as some =
browsers (e.g. Opera)=0A=
      // don't fire popstate when user change the address bar and don't =
fire hashchange when url=0A=
      // changed by push/replaceState=0A=
=0A=
      // html5 history api - popstate event=0A=
      if ($sniffer.history) jqLite(window).on('popstate', =
cacheStateAndFireUrlChange);=0A=
      // hashchange event=0A=
      jqLite(window).on('hashchange', cacheStateAndFireUrlChange);=0A=
=0A=
      urlChangeInit =3D true;=0A=
    }=0A=
=0A=
    urlChangeListeners.push(callback);=0A=
    return callback;=0A=
  };=0A=
=0A=
  /**=0A=
   * Checks whether the url has changed outside of Angular.=0A=
   * Needs to be exported to be able to check for changes that have been =
done in sync,=0A=
   * as hashchange/popstate events fire in async.=0A=
   */=0A=
  self.$$checkUrlChange =3D fireUrlChange;=0A=
=0A=
  //////////////////////////////////////////////////////////////=0A=
  // Misc API=0A=
  //////////////////////////////////////////////////////////////=0A=
=0A=
  /**=0A=
   * @name $browser#baseHref=0A=
   *=0A=
   * @description=0A=
   * Returns current &lt;base href&gt;=0A=
   * (always relative - without domain)=0A=
   *=0A=
   * @returns {string} The current base href=0A=
   */=0A=
  self.baseHref =3D function() {=0A=
    var href =3D baseElement.attr('href');=0A=
    return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, '') : '';=0A=
  };=0A=
=0A=
  //////////////////////////////////////////////////////////////=0A=
  // Cookies API=0A=
  //////////////////////////////////////////////////////////////=0A=
  var lastCookies =3D {};=0A=
  var lastCookieString =3D '';=0A=
  var cookiePath =3D self.baseHref();=0A=
=0A=
  function safeDecodeURIComponent(str) {=0A=
    try {=0A=
      return decodeURIComponent(str);=0A=
    } catch (e) {=0A=
      return str;=0A=
    }=0A=
  }=0A=
=0A=
  /**=0A=
   * @name $browser#cookies=0A=
   *=0A=
   * @param {string=3D} name Cookie name=0A=
   * @param {string=3D} value Cookie value=0A=
   *=0A=
   * @description=0A=
   * The cookies method provides a 'private' low level access to browser =
cookies.=0A=
   * It is not meant to be used directly, use the $cookie service =
instead.=0A=
   *=0A=
   * The return values vary depending on the arguments that the method =
was called with as follows:=0A=
   *=0A=
   * - cookies() -&gt; hash of all cookies, this is NOT a copy of the =
internal state, so do not modify=0A=
   *   it=0A=
   * - cookies(name, value) -&gt; set name to value, if value is =
undefined delete the cookie=0A=
   * - cookies(name) -&gt; the same as (name, undefined) =3D=3D DELETES =
(no one calls it right now that=0A=
   *   way)=0A=
   *=0A=
   * @returns {Object} Hash of all cookies (if called without any =
parameter)=0A=
   */=0A=
  self.cookies =3D function(name, value) {=0A=
    var cookieLength, cookieArray, cookie, i, index;=0A=
=0A=
    if (name) {=0A=
      if (value =3D=3D=3D undefined) {=0A=
        rawDocument.cookie =3D encodeURIComponent(name) + "=3D;path=3D" =
+ cookiePath +=0A=
                                ";expires=3DThu, 01 Jan 1970 00:00:00 =
GMT";=0A=
      } else {=0A=
        if (isString(value)) {=0A=
          cookieLength =3D (rawDocument.cookie =3D =
encodeURIComponent(name) + '=3D' + encodeURIComponent(value) +=0A=
                                ';path=3D' + cookiePath).length + 1;=0A=
=0A=
          // per http://www.ietf.org/rfc/rfc2109.txt browser must allow =
at minimum:=0A=
          // - 300 cookies=0A=
          // - 20 cookies per unique domain=0A=
          // - 4096 bytes per cookie=0A=
          if (cookieLength &gt; 4096) {=0A=
            $log.warn("Cookie '"+ name +=0A=
              "' possibly not set or overflowed because it was too large =
("+=0A=
              cookieLength + " &gt; 4096 bytes)!");=0A=
          }=0A=
        }=0A=
      }=0A=
    } else {=0A=
      if (rawDocument.cookie !=3D=3D lastCookieString) {=0A=
        lastCookieString =3D rawDocument.cookie;=0A=
        cookieArray =3D lastCookieString.split("; ");=0A=
        lastCookies =3D {};=0A=
=0A=
        for (i =3D 0; i &lt; cookieArray.length; i++) {=0A=
          cookie =3D cookieArray[i];=0A=
          index =3D cookie.indexOf('=3D');=0A=
          if (index &gt; 0) { //ignore nameless cookies=0A=
            name =3D safeDecodeURIComponent(cookie.substring(0, index));=0A=
            // the first value that is seen for a cookie is the most=0A=
            // specific one.  values for the same cookie name that=0A=
            // follow are for less specific paths.=0A=
            if (lastCookies[name] =3D=3D=3D undefined) {=0A=
              lastCookies[name] =3D =
safeDecodeURIComponent(cookie.substring(index + 1));=0A=
            }=0A=
          }=0A=
        }=0A=
      }=0A=
      return lastCookies;=0A=
    }=0A=
  };=0A=
=0A=
=0A=
  /**=0A=
   * @name $browser#defer=0A=
   * @param {function()} fn A function, who's execution should be =
deferred.=0A=
   * @param {number=3D} [delay=3D0] of milliseconds to defer the =
function execution.=0A=
   * @returns {*} DeferId that can be used to cancel the task via =
`$browser.defer.cancel()`.=0A=
   *=0A=
   * @description=0A=
   * Executes a fn asynchronously via `setTimeout(fn, delay)`.=0A=
   *=0A=
   * Unlike when calling `setTimeout` directly, in test this function is =
mocked and instead of using=0A=
   * `setTimeout` in tests, the fns are queued in an array, which can be =
programmatically flushed=0A=
   * via `$browser.defer.flush()`.=0A=
   *=0A=
   */=0A=
  self.defer =3D function(fn, delay) {=0A=
    var timeoutId;=0A=
    outstandingRequestCount++;=0A=
    timeoutId =3D setTimeout(function() {=0A=
      delete pendingDeferIds[timeoutId];=0A=
      completeOutstandingRequest(fn);=0A=
    }, delay || 0);=0A=
    pendingDeferIds[timeoutId] =3D true;=0A=
    return timeoutId;=0A=
  };=0A=
=0A=
=0A=
  /**=0A=
   * @name $browser#defer.cancel=0A=
   *=0A=
   * @description=0A=
   * Cancels a deferred task identified with `deferId`.=0A=
   *=0A=
   * @param {*} deferId Token returned by the `$browser.defer` function.=0A=
   * @returns {boolean} Returns `true` if the task hasn't executed yet =
and was successfully=0A=
   *                    canceled.=0A=
   */=0A=
  self.defer.cancel =3D function(deferId) {=0A=
    if (pendingDeferIds[deferId]) {=0A=
      delete pendingDeferIds[deferId];=0A=
      clearTimeout(deferId);=0A=
      completeOutstandingRequest(noop);=0A=
      return true;=0A=
    }=0A=
    return false;=0A=
  };=0A=
=0A=
}=0A=
=0A=
function $BrowserProvider(){=0A=
  this.$get =3D ['$window', '$log', '$sniffer', '$document',=0A=
      function( $window,   $log,   $sniffer,   $document){=0A=
        return new Browser($window, $document, $log, $sniffer);=0A=
      }];=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $cacheFactory=0A=
 *=0A=
 * @description=0A=
 * Factory that constructs {@link $cacheFactory.Cache Cache} objects and =
gives access to=0A=
 * them.=0A=
 *=0A=
 * ```js=0A=
 *=0A=
 *  var cache =3D $cacheFactory('cacheId');=0A=
 *  expect($cacheFactory.get('cacheId')).toBe(cache);=0A=
 *  expect($cacheFactory.get('noSuchCacheId')).not.toBeDefined();=0A=
 *=0A=
 *  cache.put("key", "value");=0A=
 *  cache.put("another key", "another value");=0A=
 *=0A=
 *  // We've specified no options on creation=0A=
 *  expect(cache.info()).toEqual({id: 'cacheId', size: 2});=0A=
 *=0A=
 * ```=0A=
 *=0A=
 *=0A=
 * @param {string} cacheId Name or id of the newly created cache.=0A=
 * @param {object=3D} options Options object that specifies the cache =
behavior. Properties:=0A=
 *=0A=
 *   - `{number=3D}` `capacity` =E2=80&#65533; turns the cache into LRU =
cache.=0A=
 *=0A=
 * @returns {object} Newly created cache object with the following set =
of methods:=0A=
 *=0A=
 * - `{object}` `info()` =E2=80&#65533; Returns id, size, and options of =
cache.=0A=
 * - `{{*}}` `put({string} key, {*} value)` =E2=80&#65533; Puts a new =
key-value pair into the cache and returns=0A=
 *   it.=0A=
 * - `{{*}}` `get({string} key)` =E2=80&#65533; Returns cached value for =
`key` or undefined for cache miss.=0A=
 * - `{void}` `remove({string} key)` =E2=80&#65533; Removes a key-value =
pair from the cache.=0A=
 * - `{void}` `removeAll()` =E2=80&#65533; Removes all cached values.=0A=
 * - `{void}` `destroy()` =E2=80&#65533; Removes references to this =
cache from $cacheFactory.=0A=
 *=0A=
 * @example=0A=
   &lt;example module=3D"cacheExampleApp"&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
       &lt;div ng-controller=3D"CacheController"&gt;=0A=
         &lt;input ng-model=3D"newCacheKey" placeholder=3D"Key"&gt;=0A=
         &lt;input ng-model=3D"newCacheValue" placeholder=3D"Value"&gt;=0A=
         &lt;button ng-click=3D"put(newCacheKey, =
newCacheValue)"&gt;Cache&lt;/button&gt;=0A=
=0A=
         &lt;p ng-if=3D"keys.length"&gt;Cached Values&lt;/p&gt;=0A=
         &lt;div ng-repeat=3D"key in keys"&gt;=0A=
           &lt;span ng-bind=3D"key"&gt;&lt;/span&gt;=0A=
           &lt;span&gt;: &lt;/span&gt;=0A=
           &lt;b ng-bind=3D"cache.get(key)"&gt;&lt;/b&gt;=0A=
         &lt;/div&gt;=0A=
=0A=
         &lt;p&gt;Cache Info&lt;/p&gt;=0A=
         &lt;div ng-repeat=3D"(key, value) in cache.info()"&gt;=0A=
           &lt;span ng-bind=3D"key"&gt;&lt;/span&gt;=0A=
           &lt;span&gt;: &lt;/span&gt;=0A=
           &lt;b ng-bind=3D"value"&gt;&lt;/b&gt;=0A=
         &lt;/div&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"script.js"&gt;=0A=
       angular.module('cacheExampleApp', []).=0A=
         controller('CacheController', ['$scope', '$cacheFactory', =
function($scope, $cacheFactory) {=0A=
           $scope.keys =3D [];=0A=
           $scope.cache =3D $cacheFactory('cacheId');=0A=
           $scope.put =3D function(key, value) {=0A=
             if ($scope.cache.get(key) =3D=3D=3D undefined) {=0A=
               $scope.keys.push(key);=0A=
             }=0A=
             $scope.cache.put(key, value =3D=3D=3D undefined ? null : =
value);=0A=
           };=0A=
         }]);=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"style.css"&gt;=0A=
       p {=0A=
         margin: 10px 0 3px;=0A=
       }=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
function $CacheFactoryProvider() {=0A=
=0A=
  this.$get =3D function() {=0A=
    var caches =3D {};=0A=
=0A=
    function cacheFactory(cacheId, options) {=0A=
      if (cacheId in caches) {=0A=
        throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already =
taken!", cacheId);=0A=
      }=0A=
=0A=
      var size =3D 0,=0A=
          stats =3D extend({}, options, {id: cacheId}),=0A=
          data =3D {},=0A=
          capacity =3D (options &amp;&amp; options.capacity) || =
Number.MAX_VALUE,=0A=
          lruHash =3D {},=0A=
          freshEnd =3D null,=0A=
          staleEnd =3D null;=0A=
=0A=
      /**=0A=
       * @ngdoc type=0A=
       * @name $cacheFactory.Cache=0A=
       *=0A=
       * @description=0A=
       * A cache object used to store and retrieve data, primarily used =
by=0A=
       * {@link $http $http} and the {@link ng.directive:script script} =
directive to cache=0A=
       * templates and other data.=0A=
       *=0A=
       * ```js=0A=
       *  angular.module('superCache')=0A=
       *    .factory('superCache', ['$cacheFactory', =
function($cacheFactory) {=0A=
       *      return $cacheFactory('super-cache');=0A=
       *    }]);=0A=
       * ```=0A=
       *=0A=
       * Example test:=0A=
       *=0A=
       * ```js=0A=
       *  it('should behave like a cache', inject(function(superCache) {=0A=
       *    superCache.put('key', 'value');=0A=
       *    superCache.put('another key', 'another value');=0A=
       *=0A=
       *    expect(superCache.info()).toEqual({=0A=
       *      id: 'super-cache',=0A=
       *      size: 2=0A=
       *    });=0A=
       *=0A=
       *    superCache.remove('another key');=0A=
       *    expect(superCache.get('another key')).toBeUndefined();=0A=
       *=0A=
       *    superCache.removeAll();=0A=
       *    expect(superCache.info()).toEqual({=0A=
       *      id: 'super-cache',=0A=
       *      size: 0=0A=
       *    });=0A=
       *  }));=0A=
       * ```=0A=
       */=0A=
      return caches[cacheId] =3D {=0A=
=0A=
        /**=0A=
         * @ngdoc method=0A=
         * @name $cacheFactory.Cache#put=0A=
         * @kind function=0A=
         *=0A=
         * @description=0A=
         * Inserts a named entry into the {@link $cacheFactory.Cache =
Cache} object to be=0A=
         * retrieved later, and incrementing the size of the cache if =
the key was not already=0A=
         * present in the cache. If behaving like an LRU cache, it will =
also remove stale=0A=
         * entries from the set.=0A=
         *=0A=
         * It will not insert undefined values into the cache.=0A=
         *=0A=
         * @param {string} key the key under which the cached data is =
stored.=0A=
         * @param {*} value the value to store alongside the key. If it =
is undefined, the key=0A=
         *    will not be stored.=0A=
         * @returns {*} the value stored.=0A=
         */=0A=
        put: function(key, value) {=0A=
          if (capacity &lt; Number.MAX_VALUE) {=0A=
            var lruEntry =3D lruHash[key] || (lruHash[key] =3D {key: =
key});=0A=
=0A=
            refresh(lruEntry);=0A=
          }=0A=
=0A=
          if (isUndefined(value)) return;=0A=
          if (!(key in data)) size++;=0A=
          data[key] =3D value;=0A=
=0A=
          if (size &gt; capacity) {=0A=
            this.remove(staleEnd.key);=0A=
          }=0A=
=0A=
          return value;=0A=
        },=0A=
=0A=
        /**=0A=
         * @ngdoc method=0A=
         * @name $cacheFactory.Cache#get=0A=
         * @kind function=0A=
         *=0A=
         * @description=0A=
         * Retrieves named data stored in the {@link $cacheFactory.Cache =
Cache} object.=0A=
         *=0A=
         * @param {string} key the key of the data to be retrieved=0A=
         * @returns {*} the value stored.=0A=
         */=0A=
        get: function(key) {=0A=
          if (capacity &lt; Number.MAX_VALUE) {=0A=
            var lruEntry =3D lruHash[key];=0A=
=0A=
            if (!lruEntry) return;=0A=
=0A=
            refresh(lruEntry);=0A=
          }=0A=
=0A=
          return data[key];=0A=
        },=0A=
=0A=
=0A=
        /**=0A=
         * @ngdoc method=0A=
         * @name $cacheFactory.Cache#remove=0A=
         * @kind function=0A=
         *=0A=
         * @description=0A=
         * Removes an entry from the {@link $cacheFactory.Cache Cache} =
object.=0A=
         *=0A=
         * @param {string} key the key of the entry to be removed=0A=
         */=0A=
        remove: function(key) {=0A=
          if (capacity &lt; Number.MAX_VALUE) {=0A=
            var lruEntry =3D lruHash[key];=0A=
=0A=
            if (!lruEntry) return;=0A=
=0A=
            if (lruEntry =3D=3D freshEnd) freshEnd =3D lruEntry.p;=0A=
            if (lruEntry =3D=3D staleEnd) staleEnd =3D lruEntry.n;=0A=
            link(lruEntry.n,lruEntry.p);=0A=
=0A=
            delete lruHash[key];=0A=
          }=0A=
=0A=
          delete data[key];=0A=
          size--;=0A=
        },=0A=
=0A=
=0A=
        /**=0A=
         * @ngdoc method=0A=
         * @name $cacheFactory.Cache#removeAll=0A=
         * @kind function=0A=
         *=0A=
         * @description=0A=
         * Clears the cache object of any entries.=0A=
         */=0A=
        removeAll: function() {=0A=
          data =3D {};=0A=
          size =3D 0;=0A=
          lruHash =3D {};=0A=
          freshEnd =3D staleEnd =3D null;=0A=
        },=0A=
=0A=
=0A=
        /**=0A=
         * @ngdoc method=0A=
         * @name $cacheFactory.Cache#destroy=0A=
         * @kind function=0A=
         *=0A=
         * @description=0A=
         * Destroys the {@link $cacheFactory.Cache Cache} object =
entirely,=0A=
         * removing it from the {@link $cacheFactory $cacheFactory} set.=0A=
         */=0A=
        destroy: function() {=0A=
          data =3D null;=0A=
          stats =3D null;=0A=
          lruHash =3D null;=0A=
          delete caches[cacheId];=0A=
        },=0A=
=0A=
=0A=
        /**=0A=
         * @ngdoc method=0A=
         * @name $cacheFactory.Cache#info=0A=
         * @kind function=0A=
         *=0A=
         * @description=0A=
         * Retrieve information regarding a particular {@link =
$cacheFactory.Cache Cache}.=0A=
         *=0A=
         * @returns {object} an object with the following properties:=0A=
         *   &lt;ul&gt;=0A=
         *     &lt;li&gt;**id**: the id of the cache instance&lt;/li&gt;=0A=
         *     &lt;li&gt;**size**: the number of entries kept in the =
cache instance&lt;/li&gt;=0A=
         *     &lt;li&gt;**...**: any additional properties from the =
options object when creating the=0A=
         *       cache.&lt;/li&gt;=0A=
         *   &lt;/ul&gt;=0A=
         */=0A=
        info: function() {=0A=
          return extend({}, stats, {size: size});=0A=
        }=0A=
      };=0A=
=0A=
=0A=
      /**=0A=
       * makes the `entry` the freshEnd of the LRU linked list=0A=
       */=0A=
      function refresh(entry) {=0A=
        if (entry !=3D freshEnd) {=0A=
          if (!staleEnd) {=0A=
            staleEnd =3D entry;=0A=
          } else if (staleEnd =3D=3D entry) {=0A=
            staleEnd =3D entry.n;=0A=
          }=0A=
=0A=
          link(entry.n, entry.p);=0A=
          link(entry, freshEnd);=0A=
          freshEnd =3D entry;=0A=
          freshEnd.n =3D null;=0A=
        }=0A=
      }=0A=
=0A=
=0A=
      /**=0A=
       * bidirectionally links two entries of the LRU linked list=0A=
       */=0A=
      function link(nextEntry, prevEntry) {=0A=
        if (nextEntry !=3D prevEntry) {=0A=
          if (nextEntry) nextEntry.p =3D prevEntry; //p stands for =
previous, 'prev' didn't minify=0A=
          if (prevEntry) prevEntry.n =3D nextEntry; //n stands for next, =
'next' didn't minify=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $cacheFactory#info=0A=
   *=0A=
   * @description=0A=
   * Get information about all the caches that have been created=0A=
   *=0A=
   * @returns {Object} - key-value map of `cacheId` to the result of =
calling `cache#info`=0A=
   */=0A=
    cacheFactory.info =3D function() {=0A=
      var info =3D {};=0A=
      forEach(caches, function(cache, cacheId) {=0A=
        info[cacheId] =3D cache.info();=0A=
      });=0A=
      return info;=0A=
    };=0A=
=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $cacheFactory#get=0A=
   *=0A=
   * @description=0A=
   * Get access to a cache object by the `cacheId` used when it was =
created.=0A=
   *=0A=
   * @param {string} cacheId Name or id of a cache to access.=0A=
   * @returns {object} Cache object identified by the cacheId or =
undefined if no such cache.=0A=
   */=0A=
    cacheFactory.get =3D function(cacheId) {=0A=
      return caches[cacheId];=0A=
    };=0A=
=0A=
=0A=
    return cacheFactory;=0A=
  };=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $templateCache=0A=
 *=0A=
 * @description=0A=
 * The first time a template is used, it is loaded in the template cache =
for quick retrieval. You=0A=
 * can load templates directly into the cache in a `script` tag, or by =
consuming the=0A=
 * `$templateCache` service directly.=0A=
 *=0A=
 * Adding via the `script` tag:=0A=
 *=0A=
 * ```html=0A=
 *   &lt;script type=3D"text/ng-template" id=3D"templateId.html"&gt;=0A=
 *     &lt;p&gt;This is the content of the template&lt;/p&gt;=0A=
 *   &lt;/script&gt;=0A=
 * ```=0A=
 *=0A=
 * **Note:** the `script` tag containing the template does not need to =
be included in the `head` of=0A=
 * the document, but it must be below the `ng-app` definition.=0A=
 *=0A=
 * Adding via the $templateCache service:=0A=
 *=0A=
 * ```js=0A=
 * var myApp =3D angular.module('myApp', []);=0A=
 * myApp.run(function($templateCache) {=0A=
 *   $templateCache.put('templateId.html', 'This is the content of the =
template');=0A=
 * });=0A=
 * ```=0A=
 *=0A=
 * To retrieve the template later, simply use it in your HTML:=0A=
 * ```html=0A=
 * &lt;div ng-include=3D" 'templateId.html' "&gt;&lt;/div&gt;=0A=
 * ```=0A=
 *=0A=
 * or get it via Javascript:=0A=
 * ```js=0A=
 * $templateCache.get('templateId.html')=0A=
 * ```=0A=
 *=0A=
 * See {@link ng.$cacheFactory $cacheFactory}.=0A=
 *=0A=
 */=0A=
function $TemplateCacheProvider() {=0A=
  this.$get =3D ['$cacheFactory', function($cacheFactory) {=0A=
    return $cacheFactory('templates');=0A=
  }];=0A=
}=0A=
=0A=
/* ! VARIABLE/FUNCTION NAMING CONVENTIONS THAT APPLY TO THIS FILE!=0A=
 *=0A=
 * DOM-related variables:=0A=
 *=0A=
 * - "node" - DOM Node=0A=
 * - "element" - DOM Element or Node=0A=
 * - "$node" or "$element" - jqLite-wrapped node or element=0A=
 *=0A=
 *=0A=
 * Compiler related stuff:=0A=
 *=0A=
 * - "linkFn" - linking fn of a single directive=0A=
 * - "nodeLinkFn" - function that aggregates all linking fns for a =
particular node=0A=
 * - "childLinkFn" -  function that aggregates all linking fns for child =
nodes of a particular node=0A=
 * - "compositeLinkFn" - function that aggregates all linking fns for a =
compilation root (nodeList)=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $compile=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Compiles an HTML string or DOM into a template and produces a =
template function, which=0A=
 * can then be used to link {@link ng.$rootScope.Scope `scope`} and the =
template together.=0A=
 *=0A=
 * The compilation is a process of walking the DOM tree and matching DOM =
elements to=0A=
 * {@link ng.$compileProvider#directive directives}.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * **Note:** This document is an in-depth reference of all directive =
options.=0A=
 * For a gentle introduction to directives with examples of common use =
cases,=0A=
 * see the {@link guide/directive directive guide}.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * ## Comprehensive Directive API=0A=
 *=0A=
 * There are many different options for a directive.=0A=
 *=0A=
 * The difference resides in the return value of the factory function.=0A=
 * You can either return a "Directive Definition Object" (see below) =
that defines the directive properties,=0A=
 * or just the `postLink` function (all other properties will have the =
default values).=0A=
 *=0A=
 * &lt;div class=3D"alert alert-success"&gt;=0A=
 * **Best Practice:** It's recommended to use the "directive definition =
object" form.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * Here's an example directive declared with a Directive Definition =
Object:=0A=
 *=0A=
 * ```js=0A=
 *   var myModule =3D angular.module(...);=0A=
 *=0A=
 *   myModule.directive('directiveName', function factory(injectables) {=0A=
 *     var directiveDefinitionObject =3D {=0A=
 *       priority: 0,=0A=
 *       template: '&lt;div&gt;&lt;/div&gt;', // or // =
function(tElement, tAttrs) { ... },=0A=
 *       // or=0A=
 *       // templateUrl: 'directive.html', // or // function(tElement, =
tAttrs) { ... },=0A=
 *       transclude: false,=0A=
 *       restrict: 'A',=0A=
 *       templateNamespace: 'html',=0A=
 *       scope: false,=0A=
 *       controller: function($scope, $element, $attrs, $transclude, =
otherInjectables) { ... },=0A=
 *       controllerAs: 'stringAlias',=0A=
 *       require: 'siblingDirectiveName', // or // =
['^parentDirectiveName', '?optionalDirectiveName', '?^optionalParent'],=0A=
 *       compile: function compile(tElement, tAttrs, transclude) {=0A=
 *         return {=0A=
 *           pre: function preLink(scope, iElement, iAttrs, controller) =
{ ... },=0A=
 *           post: function postLink(scope, iElement, iAttrs, =
controller) { ... }=0A=
 *         }=0A=
 *         // or=0A=
 *         // return function postLink( ... ) { ... }=0A=
 *       },=0A=
 *       // or=0A=
 *       // link: {=0A=
 *       //  pre: function preLink(scope, iElement, iAttrs, controller) =
{ ... },=0A=
 *       //  post: function postLink(scope, iElement, iAttrs, =
controller) { ... }=0A=
 *       // }=0A=
 *       // or=0A=
 *       // link: function postLink( ... ) { ... }=0A=
 *     };=0A=
 *     return directiveDefinitionObject;=0A=
 *   });=0A=
 * ```=0A=
 *=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * **Note:** Any unspecified options will use the default value. You can =
see the default values below.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * Therefore the above can be simplified as:=0A=
 *=0A=
 * ```js=0A=
 *   var myModule =3D angular.module(...);=0A=
 *=0A=
 *   myModule.directive('directiveName', function factory(injectables) {=0A=
 *     var directiveDefinitionObject =3D {=0A=
 *       link: function postLink(scope, iElement, iAttrs) { ... }=0A=
 *     };=0A=
 *     return directiveDefinitionObject;=0A=
 *     // or=0A=
 *     // return function postLink(scope, iElement, iAttrs) { ... }=0A=
 *   });=0A=
 * ```=0A=
 *=0A=
 *=0A=
 *=0A=
 * ### Directive Definition Object=0A=
 *=0A=
 * The directive definition object provides instructions to the {@link =
ng.$compile=0A=
 * compiler}. The attributes are:=0A=
 *=0A=
 * #### `multiElement`=0A=
 * When this property is set to true, the HTML compiler will collect DOM =
nodes between=0A=
 * nodes with the attributes `directive-name-start` and =
`directive-name-end`, and group them=0A=
 * together as the directive elements. It is recomended that this =
feature be used on directives=0A=
 * which are not strictly behavioural (such as {@link ngClick}), and =
which=0A=
 * do not manipulate or replace child nodes (such as {@link ngInclude}).=0A=
 *=0A=
 * #### `priority`=0A=
 * When there are multiple directives defined on a single DOM element, =
sometimes it=0A=
 * is necessary to specify the order in which the directives are =
applied. The `priority` is used=0A=
 * to sort the directives before their `compile` functions get called. =
Priority is defined as a=0A=
 * number. Directives with greater numerical `priority` are compiled =
first. Pre-link functions=0A=
 * are also run in priority order, but post-link functions are run in =
reverse order. The order=0A=
 * of directives with the same priority is undefined. The default =
priority is `0`.=0A=
 *=0A=
 * #### `terminal`=0A=
 * If set to true then the current `priority` will be the last set of =
directives=0A=
 * which will execute (any directives at the current priority will still =
execute=0A=
 * as the order of execution on same `priority` is undefined). Note that =
expressions=0A=
 * and other directives used in the directive's template will also be =
excluded from execution.=0A=
 *=0A=
 * #### `scope`=0A=
 * **If set to `true`,** then a new scope will be created for this =
directive. If multiple directives on the=0A=
 * same element request a new scope, only one new scope is created. The =
new scope rule does not=0A=
 * apply for the root of the template since the root of the template =
always gets a new scope.=0A=
 *=0A=
 * **If set to `{}` (object hash),** then a new "isolate" scope is =
created. The 'isolate' scope differs from=0A=
 * normal scope in that it does not prototypically inherit from the =
parent scope. This is useful=0A=
 * when creating reusable components, which should not accidentally read =
or modify data in the=0A=
 * parent scope.=0A=
 *=0A=
 * The 'isolate' scope takes an object hash which defines a set of local =
scope properties=0A=
 * derived from the parent scope. These local properties are useful for =
aliasing values for=0A=
 * templates. Locals definition is a hash of local scope property to its =
source:=0A=
 *=0A=
 * * `@` or `@attr` - bind a local scope property to the value of DOM =
attribute. The result is=0A=
 *   always a string since DOM attributes are strings. If no `attr` name =
is specified  then the=0A=
 *   attribute name is assumed to be the same as the local name.=0A=
 *   Given `&lt;widget my-attr=3D"hello {{name}}"&gt;` and widget =
definition=0A=
 *   of `scope: { localName:'@myAttr' }`, then widget scope property =
`localName` will reflect=0A=
 *   the interpolated value of `hello {{name}}`. As the `name` attribute =
changes so will the=0A=
 *   `localName` property on the widget scope. The `name` is read from =
the parent scope (not=0A=
 *   component scope).=0A=
 *=0A=
 * * `=3D` or `=3Dattr` - set up bi-directional binding between a local =
scope property and the=0A=
 *   parent scope property of name defined via the value of the `attr` =
attribute. If no `attr`=0A=
 *   name is specified then the attribute name is assumed to be the same =
as the local name.=0A=
 *   Given `&lt;widget my-attr=3D"parentModel"&gt;` and widget =
definition of=0A=
 *   `scope: { localModel:'=3DmyAttr' }`, then widget scope property =
`localModel` will reflect the=0A=
 *   value of `parentModel` on the parent scope. Any changes to =
`parentModel` will be reflected=0A=
 *   in `localModel` and any changes in `localModel` will reflect in =
`parentModel`. If the parent=0A=
 *   scope property doesn't exist, it will throw a =
NON_ASSIGNABLE_MODEL_EXPRESSION exception. You=0A=
 *   can avoid this behavior using `=3D?` or `=3D?attr` in order to flag =
the property as optional.=0A=
 *=0A=
 * * `&amp;` or `&amp;attr` - provides a way to execute an expression in =
the context of the parent scope.=0A=
 *   If no `attr` name is specified then the attribute name is assumed =
to be the same as the=0A=
 *   local name. Given `&lt;widget my-attr=3D"count =3D count + =
value"&gt;` and widget definition of=0A=
 *   `scope: { localFn:'&amp;myAttr' }`, then isolate scope property =
`localFn` will point to=0A=
 *   a function wrapper for the `count =3D count + value` expression. =
Often it's desirable to=0A=
 *   pass data from the isolated scope via an expression to the parent =
scope, this can be=0A=
 *   done by passing a map of local variable names and values into the =
expression wrapper fn.=0A=
 *   For example, if the expression is `increment(amount)` then we can =
specify the amount value=0A=
 *   by calling the `localFn` as `localFn({amount: 22})`.=0A=
 *=0A=
 *=0A=
 * #### `bindToController`=0A=
 * When an isolate scope is used for a component (see above), and =
`controllerAs` is used, `bindToController` will=0A=
 * allow a component to have its properties bound to the controller, =
rather than to scope. When the controller=0A=
 * is instantiated, the initial values of the isolate scope bindings are =
already available.=0A=
 *=0A=
 * #### `controller`=0A=
 * Controller constructor function. The controller is instantiated =
before the=0A=
 * pre-linking phase and it is shared with other directives (see=0A=
 * `require` attribute). This allows the directives to communicate with =
each other and augment=0A=
 * each other's behavior. The controller is injectable (and supports =
bracket notation) with the following locals:=0A=
 *=0A=
 * * `$scope` - Current scope associated with the element=0A=
 * * `$element` - Current element=0A=
 * * `$attrs` - Current attributes object for the element=0A=
 * * `$transclude` - A transclude linking function pre-bound to the =
correct transclusion scope:=0A=
 *   `function([scope], cloneLinkingFn, futureParentElement)`.=0A=
 *    * `scope`: optional argument to override the scope.=0A=
 *    * `cloneLinkingFn`: optional argument to create clones of the =
original transcluded content.=0A=
 *    * `futureParentElement`:=0A=
 *        * defines the parent to which the `cloneLinkingFn` will add =
the cloned elements.=0A=
 *        * default: `$element.parent()` resp. `$element` for =
`transclude:'element'` resp. `transclude:true`.=0A=
 *        * only needed for transcludes that are allowed to contain non =
html elements (e.g. SVG elements)=0A=
 *          and when the `cloneLinkinFn` is passed,=0A=
 *          as those elements need to created and cloned in a special =
way when they are defined outside their=0A=
 *          usual containers (e.g. like `&lt;svg&gt;`).=0A=
 *        * See also the `directive.templateNamespace` property.=0A=
 *=0A=
 *=0A=
 * #### `require`=0A=
 * Require another directive and inject its controller as the fourth =
argument to the linking function. The=0A=
 * `require` takes a string name (or array of strings) of the =
directive(s) to pass in. If an array is used, the=0A=
 * injected argument will be an array in corresponding order. If no such =
directive can be=0A=
 * found, or if the directive does not have a controller, then an error =
is raised. The name can be prefixed with:=0A=
 *=0A=
 * * (no prefix) - Locate the required controller on the current =
element. Throw an error if not found.=0A=
 * * `?` - Attempt to locate the required controller or pass `null` to =
the `link` fn if not found.=0A=
 * * `^` - Locate the required controller by searching the element and =
its parents. Throw an error if not found.=0A=
 * * `^^` - Locate the required controller by searching the element's =
parents. Throw an error if not found.=0A=
 * * `?^` - Attempt to locate the required controller by searching the =
element and its parents or pass=0A=
 *   `null` to the `link` fn if not found.=0A=
 * * `?^^` - Attempt to locate the required controller by searching the =
element's parents, or pass=0A=
 *   `null` to the `link` fn if not found.=0A=
 *=0A=
 *=0A=
 * #### `controllerAs`=0A=
 * Controller alias at the directive scope. An alias for the controller =
so it=0A=
 * can be referenced at the directive template. The directive needs to =
define a scope for this=0A=
 * configuration to be used. Useful in the case when directive is used =
as component.=0A=
 *=0A=
 *=0A=
 * #### `restrict`=0A=
 * String of subset of `EACM` which restricts the directive to a =
specific directive=0A=
 * declaration style. If omitted, the defaults (elements and attributes) =
are used.=0A=
 *=0A=
 * * `E` - Element name (default): =
`&lt;my-directive&gt;&lt;/my-directive&gt;`=0A=
 * * `A` - Attribute (default): `&lt;div =
my-directive=3D"exp"&gt;&lt;/div&gt;`=0A=
 * * `C` - Class: `&lt;div class=3D"my-directive: exp;"&gt;&lt;/div&gt;`=0A=
 * * `M` - Comment: `&lt;!-- directive: my-directive exp --&gt;`=0A=
 *=0A=
 *=0A=
 * #### `templateNamespace`=0A=
 * String representing the document type used by the markup in the =
template.=0A=
 * AngularJS needs this information as those elements need to be created =
and cloned=0A=
 * in a special way when they are defined outside their usual containers =
like `&lt;svg&gt;` and `&lt;math&gt;`.=0A=
 *=0A=
 * * `html` - All root nodes in the template are HTML. Root nodes may =
also be=0A=
 *   top-level elements such as `&lt;svg&gt;` or `&lt;math&gt;`.=0A=
 * * `svg` - The root nodes in the template are SVG elements (excluding =
`&lt;math&gt;`).=0A=
 * * `math` - The root nodes in the template are MathML elements =
(excluding `&lt;svg&gt;`).=0A=
 *=0A=
 * If no `templateNamespace` is specified, then the namespace is =
considered to be `html`.=0A=
 *=0A=
 * #### `template`=0A=
 * HTML markup that may:=0A=
 * * Replace the contents of the directive's element (default).=0A=
 * * Replace the directive's element itself (if `replace` is true - =
DEPRECATED).=0A=
 * * Wrap the contents of the directive's element (if `transclude` is =
true).=0A=
 *=0A=
 * Value may be:=0A=
 *=0A=
 * * A string. For example `&lt;div =
red-on-hover&gt;{{delete_str}}&lt;/div&gt;`.=0A=
 * * A function which takes two arguments `tElement` and `tAttrs` =
(described in the `compile`=0A=
 *   function api below) and returns a string value.=0A=
 *=0A=
 *=0A=
 * #### `templateUrl`=0A=
 * This is similar to `template` but the template is loaded from the =
specified URL, asynchronously.=0A=
 *=0A=
 * Because template loading is asynchronous the compiler will suspend =
compilation of directives on that element=0A=
 * for later when the template has been resolved.  In the meantime it =
will continue to compile and link=0A=
 * sibling and parent elements as though this element had not contained =
any directives.=0A=
 *=0A=
 * The compiler does not suspend the entire compilation to wait for =
templates to be loaded because this=0A=
 * would result in the whole app "stalling" until all templates are =
loaded asynchronously - even in the=0A=
 * case when only one deeply nested directive has `templateUrl`.=0A=
 *=0A=
 * Template loading is asynchronous even if the template has been =
preloaded into the {@link $templateCache}=0A=
 *=0A=
 * You can specify `templateUrl` as a string representing the URL or as =
a function which takes two=0A=
 * arguments `tElement` and `tAttrs` (described in the `compile` =
function api below) and returns=0A=
 * a string value representing the url.  In either case, the template =
URL is passed through {@link=0A=
 * $sce#getTrustedResourceUrl $sce.getTrustedResourceUrl}.=0A=
 *=0A=
 *=0A=
 * #### `replace` ([*DEPRECATED*!], will be removed in next major =
release - i.e. v2.0)=0A=
 * specify what the template should replace. Defaults to `false`.=0A=
 *=0A=
 * * `true` - the template will replace the directive's element.=0A=
 * * `false` - the template will replace the contents of the directive's =
element.=0A=
 *=0A=
 * The replacement process migrates all of the attributes / classes from =
the old element to the new=0A=
 * one. See the {@link guide/directive#template-expanding-directive=0A=
 * Directives Guide} for an example.=0A=
 *=0A=
 * There are very few scenarios where element replacement is required =
for the application function,=0A=
 * the main one being reusable custom components that are used within =
SVG contexts=0A=
 * (because SVG doesn't work with custom elements in the DOM tree).=0A=
 *=0A=
 * #### `transclude`=0A=
 * Extract the contents of the element where the directive appears and =
make it available to the directive.=0A=
 * The contents are compiled and provided to the directive as a =
**transclusion function**. See the=0A=
 * {@link $compile#transclusion Transclusion} section below.=0A=
 *=0A=
 * There are two kinds of transclusion depending upon whether you want =
to transclude just the contents of the=0A=
 * directive's element or the entire element:=0A=
 *=0A=
 * * `true` - transclude the content (i.e. the child nodes) of the =
directive's element.=0A=
 * * `'element'` - transclude the whole of the directive's element =
including any directives on this=0A=
 *   element that defined at a lower priority than this directive. When =
used, the `template`=0A=
 *   property is ignored.=0A=
 *=0A=
 *=0A=
 * #### `compile`=0A=
 *=0A=
 * ```js=0A=
 *   function compile(tElement, tAttrs, transclude) { ... }=0A=
 * ```=0A=
 *=0A=
 * The compile function deals with transforming the template DOM. Since =
most directives do not do=0A=
 * template transformation, it is not used often. The compile function =
takes the following arguments:=0A=
 *=0A=
 *   * `tElement` - template element - The element where the directive =
has been declared. It is=0A=
 *     safe to do template transformation on the element and child =
elements only.=0A=
 *=0A=
 *   * `tAttrs` - template attributes - Normalized list of attributes =
declared on this element shared=0A=
 *     between all directive compile functions.=0A=
 *=0A=
 *   * `transclude` -  [*DEPRECATED*!] A transclude linking function: =
`function(scope, cloneLinkingFn)`=0A=
 *=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * **Note:** The template instance and the link instance may be =
different objects if the template has=0A=
 * been cloned. For this reason it is **not** safe to do anything other =
than DOM transformations that=0A=
 * apply to all cloned DOM nodes within the compile function. =
Specifically, DOM listener registration=0A=
 * should be done in a linking function rather than in a compile =
function.=0A=
 * &lt;/div&gt;=0A=
=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * **Note:** The compile function cannot handle directives that =
recursively use themselves in their=0A=
 * own templates or compile functions. Compiling these directives =
results in an infinite loop and a=0A=
 * stack overflow errors.=0A=
 *=0A=
 * This can be avoided by manually using $compile in the postLink =
function to imperatively compile=0A=
 * a directive's template instead of relying on automatic template =
compilation via `template` or=0A=
 * `templateUrl` declaration or manual compilation inside the compile =
function.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * &lt;div class=3D"alert alert-error"&gt;=0A=
 * **Note:** The `transclude` function that is passed to the compile =
function is deprecated, as it=0A=
 *   e.g. does not know about the right outer scope. Please use the =
transclude function that is passed=0A=
 *   to the link function instead.=0A=
 * &lt;/div&gt;=0A=
=0A=
 * A compile function can have a return value which can be either a =
function or an object.=0A=
 *=0A=
 * * returning a (post-link) function - is equivalent to registering the =
linking function via the=0A=
 *   `link` property of the config object when the compile function is =
empty.=0A=
 *=0A=
 * * returning an object with function(s) registered via `pre` and =
`post` properties - allows you to=0A=
 *   control when a linking function should be called during the linking =
phase. See info about=0A=
 *   pre-linking and post-linking functions below.=0A=
 *=0A=
 *=0A=
 * #### `link`=0A=
 * This property is used only if the `compile` property is not defined.=0A=
 *=0A=
 * ```js=0A=
 *   function link(scope, iElement, iAttrs, controller, transcludeFn) { =
... }=0A=
 * ```=0A=
 *=0A=
 * The link function is responsible for registering DOM listeners as =
well as updating the DOM. It is=0A=
 * executed after the template has been cloned. This is where most of =
the directive logic will be=0A=
 * put.=0A=
 *=0A=
 *   * `scope` - {@link ng.$rootScope.Scope Scope} - The scope to be =
used by the=0A=
 *     directive for registering {@link ng.$rootScope.Scope#$watch =
watches}.=0A=
 *=0A=
 *   * `iElement` - instance element - The element where the directive =
is to be used. It is safe to=0A=
 *     manipulate the children of the element only in `postLink` =
function since the children have=0A=
 *     already been linked.=0A=
 *=0A=
 *   * `iAttrs` - instance attributes - Normalized list of attributes =
declared on this element shared=0A=
 *     between all directive linking functions.=0A=
 *=0A=
 *   * `controller` - a controller instance - A controller instance if =
at least one directive on the=0A=
 *     element defines a controller. The controller is shared among all =
the directives, which allows=0A=
 *     the directives to use the controllers as a communication channel.=0A=
 *=0A=
 *   * `transcludeFn` - A transclude linking function pre-bound to the =
correct transclusion scope.=0A=
 *     This is the same as the `$transclude`=0A=
 *     parameter of directive controllers, see there for details.=0A=
 *     `function([scope], cloneLinkingFn, futureParentElement)`.=0A=
 *=0A=
 * #### Pre-linking function=0A=
 *=0A=
 * Executed before the child elements are linked. Not safe to do DOM =
transformation since the=0A=
 * compiler linking function will fail to locate the correct elements =
for linking.=0A=
 *=0A=
 * #### Post-linking function=0A=
 *=0A=
 * Executed after the child elements are linked.=0A=
 *=0A=
 * Note that child elements that contain `templateUrl` directives will =
not have been compiled=0A=
 * and linked since they are waiting for their template to load =
asynchronously and their own=0A=
 * compilation and linking has been suspended until that occurs.=0A=
 *=0A=
 * It is safe to do DOM transformation in the post-linking function on =
elements that are not waiting=0A=
 * for their async templates to be resolved.=0A=
 *=0A=
 *=0A=
 * ### Transclusion=0A=
 *=0A=
 * Transclusion is the process of extracting a collection of DOM element =
from one part of the DOM and=0A=
 * copying them to another part of the DOM, while maintaining their =
connection to the original AngularJS=0A=
 * scope from where they were taken.=0A=
 *=0A=
 * Transclusion is used (often with {@link ngTransclude}) to insert the=0A=
 * original contents of a directive's element into a specified place in =
the template of the directive.=0A=
 * The benefit of transclusion, over simply moving the DOM elements =
manually, is that the transcluded=0A=
 * content has access to the properties on the scope from which it was =
taken, even if the directive=0A=
 * has isolated scope.=0A=
 * See the {@link =
guide/directive#creating-a-directive-that-wraps-other-elements =
Directives Guide}.=0A=
 *=0A=
 * This makes it possible for the widget to have private state for its =
template, while the transcluded=0A=
 * content has access to its originating scope.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * **Note:** When testing an element transclude directive you must not =
place the directive at the root of the=0A=
 * DOM fragment that is being compiled. See {@link =
guide/unit-testing#testing-transclusion-directives=0A=
 * Testing Transclusion Directives}.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * #### Transclusion Functions=0A=
 *=0A=
 * When a directive requests transclusion, the compiler extracts its =
contents and provides a **transclusion=0A=
 * function** to the directive's `link` function and `controller`. This =
transclusion function is a special=0A=
 * **linking function** that will return the compiled contents linked to =
a new transclusion scope.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-info"&gt;=0A=
 * If you are just using {@link ngTransclude} then you don't need to =
worry about this function, since=0A=
 * ngTransclude will deal with it for us.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * If you want to manually control the insertion and removal of the =
transcluded content in your directive=0A=
 * then you must use this transclude function. When you call a =
transclude function it returns a a jqLite/JQuery=0A=
 * object that contains the compiled DOM, which is linked to the correct =
transclusion scope.=0A=
 *=0A=
 * When you call a transclusion function you can pass in a **clone =
attach function**. This function accepts=0A=
 * two parameters, `function(clone, scope) { ... }`, where the `clone` =
is a fresh compiled copy of your transcluded=0A=
 * content and the `scope` is the newly created transclusion scope, to =
which the clone is bound.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-info"&gt;=0A=
 * **Best Practice**: Always provide a `cloneFn` (clone attach function) =
when you call a translude function=0A=
 * since you then get a fresh clone of the original DOM and also have =
access to the new transclusion scope.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * It is normal practice to attach your transcluded content (`clone`) to =
the DOM inside your **clone=0A=
 * attach function**:=0A=
 *=0A=
 * ```js=0A=
 * var transcludedContent, transclusionScope;=0A=
 *=0A=
 * $transclude(function(clone, scope) {=0A=
 *   element.append(clone);=0A=
 *   transcludedContent =3D clone;=0A=
 *   transclusionScope =3D scope;=0A=
 * });=0A=
 * ```=0A=
 *=0A=
 * Later, if you want to remove the transcluded content from your DOM =
then you should also destroy the=0A=
 * associated transclusion scope:=0A=
 *=0A=
 * ```js=0A=
 * transcludedContent.remove();=0A=
 * transclusionScope.$destroy();=0A=
 * ```=0A=
 *=0A=
 * &lt;div class=3D"alert alert-info"&gt;=0A=
 * **Best Practice**: if you intend to add and remove transcluded =
content manually in your directive=0A=
 * (by calling the transclude function to get the DOM and and calling =
`element.remove()` to remove it),=0A=
 * then you are also responsible for calling `$destroy` on the =
transclusion scope.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * The built-in DOM manipulation directives, such as {@link ngIf}, =
{@link ngSwitch} and {@link ngRepeat}=0A=
 * automatically destroy their transluded clones as necessary so you do =
not need to worry about this if=0A=
 * you are simply using {@link ngTransclude} to inject the transclusion =
into your directive.=0A=
 *=0A=
 *=0A=
 * #### Transclusion Scopes=0A=
 *=0A=
 * When you call a transclude function it returns a DOM fragment that is =
pre-bound to a **transclusion=0A=
 * scope**. This scope is special, in that it is a child of the =
directive's scope (and so gets destroyed=0A=
 * when the directive's scope gets destroyed) but it inherits the =
properties of the scope from which it=0A=
 * was taken.=0A=
 *=0A=
 * For example consider a directive that uses transclusion and isolated =
scope. The DOM hierarchy might look=0A=
 * like this:=0A=
 *=0A=
 * ```html=0A=
 * &lt;div ng-app&gt;=0A=
 *   &lt;div isolate&gt;=0A=
 *     &lt;div transclusion&gt;=0A=
 *     &lt;/div&gt;=0A=
 *   &lt;/div&gt;=0A=
 * &lt;/div&gt;=0A=
 * ```=0A=
 *=0A=
 * The `$parent` scope hierarchy will look like this:=0A=
 *=0A=
 * ```=0A=
 * - $rootScope=0A=
 *   - isolate=0A=
 *     - transclusion=0A=
 * ```=0A=
 *=0A=
 * but the scopes will inherit prototypically from different scopes to =
their `$parent`.=0A=
 *=0A=
 * ```=0A=
 * - $rootScope=0A=
 *   - transclusion=0A=
 * - isolate=0A=
 * ```=0A=
 *=0A=
 *=0A=
 * ### Attributes=0A=
 *=0A=
 * The {@link ng.$compile.directive.Attributes Attributes} object - =
passed as a parameter in the=0A=
 * `link()` or `compile()` functions. It has a variety of uses.=0A=
 *=0A=
 * accessing *Normalized attribute names:*=0A=
 * Directives like 'ngBind' can be expressed in many ways: 'ng:bind', =
`data-ng-bind`, or 'x-ng-bind'.=0A=
 * the attributes object allows for normalized access to=0A=
 *   the attributes.=0A=
 *=0A=
 * * *Directive inter-communication:* All directives share the same =
instance of the attributes=0A=
 *   object which allows the directives to use the attributes object as =
inter directive=0A=
 *   communication.=0A=
 *=0A=
 * * *Supports interpolation:* Interpolation attributes are assigned to =
the attribute object=0A=
 *   allowing other directives to read the interpolated value.=0A=
 *=0A=
 * * *Observing interpolated attributes:* Use `$observe` to observe the =
value changes of attributes=0A=
 *   that contain interpolation (e.g. `src=3D"{{bar}}"`). Not only is =
this very efficient but it's also=0A=
 *   the only way to easily get the actual value because during the =
linking phase the interpolation=0A=
 *   hasn't been evaluated yet and so the value is at this time set to =
`undefined`.=0A=
 *=0A=
 * ```js=0A=
 * function linkingFn(scope, elm, attrs, ctrl) {=0A=
 *   // get the attribute value=0A=
 *   console.log(attrs.ngModel);=0A=
 *=0A=
 *   // change the attribute=0A=
 *   attrs.$set('ngModel', 'new value');=0A=
 *=0A=
 *   // observe changes to interpolated attribute=0A=
 *   attrs.$observe('ngModel', function(value) {=0A=
 *     console.log('ngModel has changed value to ' + value);=0A=
 *   });=0A=
 * }=0A=
 * ```=0A=
 *=0A=
 * ## Example=0A=
 *=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * **Note**: Typically directives are registered with =
`module.directive`. The example below is=0A=
 * to illustrate how `$compile` works.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 &lt;example module=3D"compileExample"&gt;=0A=
   &lt;file name=3D"todoList.html"&gt;=0A=
    &lt;script&gt;=0A=
      angular.module('compileExample', [], function($compileProvider) {=0A=
        // configure new 'compile' directive by passing a directive=0A=
        // factory function. The factory function injects the '$compile'=0A=
        $compileProvider.directive('compile', function($compile) {=0A=
          // directive factory creates a link function=0A=
          return function(scope, element, attrs) {=0A=
            scope.$watch(=0A=
              function(scope) {=0A=
                 // watch the 'compile' expression for changes=0A=
                return scope.$eval(attrs.compile);=0A=
              },=0A=
              function(value) {=0A=
                // when the 'compile' expression changes=0A=
                // assign it into the current DOM=0A=
                element.html(value);=0A=
=0A=
                // compile the new DOM and link it to the current=0A=
                // scope.=0A=
                // NOTE: we only compile .childNodes so that=0A=
                // we don't get into infinite loop compiling ourselves=0A=
                $compile(element.contents())(scope);=0A=
              }=0A=
            );=0A=
          };=0A=
        });=0A=
      })=0A=
      .controller('GreeterController', ['$scope', function($scope) {=0A=
        $scope.name =3D 'Angular';=0A=
        $scope.html =3D 'Hello {{name}}';=0A=
      }]);=0A=
    &lt;/script&gt;=0A=
    &lt;div ng-controller=3D"GreeterController"&gt;=0A=
      &lt;input ng-model=3D"name"&gt; &lt;br&gt;=0A=
      &lt;textarea ng-model=3D"html"&gt;&lt;/textarea&gt; &lt;br&gt;=0A=
      &lt;div compile=3D"html"&gt;&lt;/div&gt;=0A=
    &lt;/div&gt;=0A=
   &lt;/file&gt;=0A=
   &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
     it('should auto compile', function() {=0A=
       var textarea =3D $('textarea');=0A=
       var output =3D $('div[compile]');=0A=
       // The initial state reads 'Hello Angular'.=0A=
       expect(output.getText()).toBe('Hello Angular');=0A=
       textarea.clear();=0A=
       textarea.sendKeys('{{name}}!');=0A=
       expect(output.getText()).toBe('Angular!');=0A=
     });=0A=
   &lt;/file&gt;=0A=
 &lt;/example&gt;=0A=
=0A=
 *=0A=
 *=0A=
 * @param {string|DOMElement} element Element or HTML string to compile =
into a template function.=0A=
 * @param {function(angular.Scope, cloneAttachFn=3D)} transclude =
function available to directives.=0A=
 * @param {number} maxPriority only apply directives lower than given =
priority (Only effects the=0A=
 *                 root element(s), not their children)=0A=
 * @returns {function(scope, cloneAttachFn=3D)} a link function which is =
used to bind template=0A=
 * (a DOM element/tree) to a scope. Where:=0A=
 *=0A=
 *  * `scope` - A {@link ng.$rootScope.Scope Scope} to bind to.=0A=
 *  * `cloneAttachFn` - If `cloneAttachFn` is provided, then the link =
function will clone the=0A=
 *  `template` and call the `cloneAttachFn` function allowing the caller =
to attach the=0A=
 *  cloned elements to the DOM document at the appropriate place. The =
`cloneAttachFn` is=0A=
 *  called as: &lt;br&gt; `cloneAttachFn(clonedElement, scope)` where:=0A=
 *=0A=
 *      * `clonedElement` - is a clone of the original `element` passed =
into the compiler.=0A=
 *      * `scope` - is the current scope with which the linking function =
is working with.=0A=
 *=0A=
 * Calling the linking function returns the element of the template. It =
is either the original=0A=
 * element passed in, or the clone of the element if the `cloneAttachFn` =
is provided.=0A=
 *=0A=
 * After linking the view is not updated until after a call to $digest =
which typically is done by=0A=
 * Angular automatically.=0A=
 *=0A=
 * If you need access to the bound view, there are two ways to do it:=0A=
 *=0A=
 * - If you are not asking the linking function to clone the template, =
create the DOM element(s)=0A=
 *   before you send them to the compiler and keep this reference around.=0A=
 *   ```js=0A=
 *     var element =3D $compile('&lt;p&gt;{{total}}&lt;/p&gt;')(scope);=0A=
 *   ```=0A=
 *=0A=
 * - if on the other hand, you need the element to be cloned, the view =
reference from the original=0A=
 *   example would not point to the clone, but rather to the original =
template that was cloned. In=0A=
 *   this case, you can access the clone via the cloneAttachFn:=0A=
 *   ```js=0A=
 *     var templateElement =3D =
angular.element('&lt;p&gt;{{total}}&lt;/p&gt;'),=0A=
 *         scope =3D ....;=0A=
 *=0A=
 *     var clonedElement =3D $compile(templateElement)(scope, =
function(clonedElement, scope) {=0A=
 *       //attach the clone to DOM document at the right place=0A=
 *     });=0A=
 *=0A=
 *     //now we have reference to the cloned DOM via `clonedElement`=0A=
 *   ```=0A=
 *=0A=
 *=0A=
 * For information on how the compiler works, see the=0A=
 * {@link guide/compiler Angular HTML Compiler} section of the Developer =
Guide.=0A=
 */=0A=
=0A=
var $compileMinErr =3D minErr('$compile');=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $compileProvider=0A=
 *=0A=
 * @description=0A=
 */=0A=
$CompileProvider.$inject =3D ['$provide', '$$sanitizeUriProvider'];=0A=
function $CompileProvider($provide, $$sanitizeUriProvider) {=0A=
  var hasDirectives =3D {},=0A=
      Suffix =3D 'Directive',=0A=
      COMMENT_DIRECTIVE_REGEXP =3D =
/^\s*directive\:\s*([\d\w_\-]+)\s+(.*)$/,=0A=
      CLASS_DIRECTIVE_REGEXP =3D /(([\d\w_\-]+)(?:\:([^;]+))?;?)/,=0A=
      ALL_OR_NOTHING_ATTRS =3D makeMap('ngSrc,ngSrcset,src,srcset'),=0A=
      REQUIRE_PREFIX_REGEXP =3D /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;=0A=
=0A=
  // Ref: =
http://developers.whatwg.org/webappapis.html#event-handler-idl-attributes=0A=
  // The assumption is that future DOM event attribute names will begin =
with=0A=
  // 'on' and be composed of only English letters.=0A=
  var EVENT_HANDLER_ATTR_REGEXP =3D /^(on[a-z]+|formaction)$/;=0A=
=0A=
  function parseIsolateBindings(scope, directiveName) {=0A=
    var LOCAL_REGEXP =3D /^\s*([@=3D&amp;])(\??)\s*(\w*)\s*$/;=0A=
=0A=
    var bindings =3D {};=0A=
=0A=
    forEach(scope, function(definition, scopeName) {=0A=
      var match =3D definition.match(LOCAL_REGEXP);=0A=
=0A=
      if (!match) {=0A=
        throw $compileMinErr('iscp',=0A=
            "Invalid isolate scope definition for directive '{0}'." +=0A=
            " Definition: {... {1}: '{2}' ...}",=0A=
            directiveName, scopeName, definition);=0A=
      }=0A=
=0A=
      bindings[scopeName] =3D {=0A=
        attrName: match[3] || scopeName,=0A=
        mode: match[1],=0A=
        optional: match[2] =3D=3D=3D '?'=0A=
      };=0A=
    });=0A=
=0A=
    return bindings;=0A=
  }=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $compileProvider#directive=0A=
   * @kind function=0A=
   *=0A=
   * @description=0A=
   * Register a new directive with the compiler.=0A=
   *=0A=
   * @param {string|Object} name Name of the directive in camel-case =
(i.e. &lt;code&gt;ngBind&lt;/code&gt; which=0A=
   *    will match as &lt;code&gt;ng-bind&lt;/code&gt;), or an object =
map of directives where the keys are the=0A=
   *    names and the values are the factories.=0A=
   * @param {Function|Array} directiveFactory An injectable directive =
factory function. See=0A=
   *    {@link guide/directive} for more info.=0A=
   * @returns {ng.$compileProvider} Self for chaining.=0A=
   */=0A=
   this.directive =3D function registerDirective(name, directiveFactory) =
{=0A=
    assertNotHasOwnProperty(name, 'directive');=0A=
    if (isString(name)) {=0A=
      assertArg(directiveFactory, 'directiveFactory');=0A=
      if (!hasDirectives.hasOwnProperty(name)) {=0A=
        hasDirectives[name] =3D [];=0A=
        $provide.factory(name + Suffix, ['$injector', =
'$exceptionHandler',=0A=
          function($injector, $exceptionHandler) {=0A=
            var directives =3D [];=0A=
            forEach(hasDirectives[name], function(directiveFactory, =
index) {=0A=
              try {=0A=
                var directive =3D $injector.invoke(directiveFactory);=0A=
                if (isFunction(directive)) {=0A=
                  directive =3D { compile: valueFn(directive) };=0A=
                } else if (!directive.compile &amp;&amp; directive.link) =
{=0A=
                  directive.compile =3D valueFn(directive.link);=0A=
                }=0A=
                directive.priority =3D directive.priority || 0;=0A=
                directive.index =3D index;=0A=
                directive.name =3D directive.name || name;=0A=
                directive.require =3D directive.require || =
(directive.controller &amp;&amp; directive.name);=0A=
                directive.restrict =3D directive.restrict || 'EA';=0A=
                if (isObject(directive.scope)) {=0A=
                  directive.$$isolateBindings =3D =
parseIsolateBindings(directive.scope, directive.name);=0A=
                }=0A=
                directives.push(directive);=0A=
              } catch (e) {=0A=
                $exceptionHandler(e);=0A=
              }=0A=
            });=0A=
            return directives;=0A=
          }]);=0A=
      }=0A=
      hasDirectives[name].push(directiveFactory);=0A=
    } else {=0A=
      forEach(name, reverseParams(registerDirective));=0A=
    }=0A=
    return this;=0A=
  };=0A=
=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $compileProvider#aHrefSanitizationWhitelist=0A=
   * @kind function=0A=
   *=0A=
   * @description=0A=
   * Retrieves or overrides the default regular expression that is used =
for whitelisting of safe=0A=
   * urls during a[href] sanitization.=0A=
   *=0A=
   * The sanitization is a security measure aimed at prevent XSS attacks =
via html links.=0A=
   *=0A=
   * Any url about to be assigned to a[href] via data-binding is first =
normalized and turned into=0A=
   * an absolute url. Afterwards, the url is matched against the =
`aHrefSanitizationWhitelist`=0A=
   * regular expression. If a match is found, the original url is =
written into the dom. Otherwise,=0A=
   * the absolute url is prefixed with `'unsafe:'` string and only then =
is it written into the DOM.=0A=
   *=0A=
   * @param {RegExp=3D} regexp New regexp to whitelist urls with.=0A=
   * @returns {RegExp|ng.$compileProvider} Current RegExp if called =
without value or self for=0A=
   *    chaining otherwise.=0A=
   */=0A=
  this.aHrefSanitizationWhitelist =3D function(regexp) {=0A=
    if (isDefined(regexp)) {=0A=
      $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);=0A=
      return this;=0A=
    } else {=0A=
      return $$sanitizeUriProvider.aHrefSanitizationWhitelist();=0A=
    }=0A=
  };=0A=
=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $compileProvider#imgSrcSanitizationWhitelist=0A=
   * @kind function=0A=
   *=0A=
   * @description=0A=
   * Retrieves or overrides the default regular expression that is used =
for whitelisting of safe=0A=
   * urls during img[src] sanitization.=0A=
   *=0A=
   * The sanitization is a security measure aimed at prevent XSS attacks =
via html links.=0A=
   *=0A=
   * Any url about to be assigned to img[src] via data-binding is first =
normalized and turned into=0A=
   * an absolute url. Afterwards, the url is matched against the =
`imgSrcSanitizationWhitelist`=0A=
   * regular expression. If a match is found, the original url is =
written into the dom. Otherwise,=0A=
   * the absolute url is prefixed with `'unsafe:'` string and only then =
is it written into the DOM.=0A=
   *=0A=
   * @param {RegExp=3D} regexp New regexp to whitelist urls with.=0A=
   * @returns {RegExp|ng.$compileProvider} Current RegExp if called =
without value or self for=0A=
   *    chaining otherwise.=0A=
   */=0A=
  this.imgSrcSanitizationWhitelist =3D function(regexp) {=0A=
    if (isDefined(regexp)) {=0A=
      $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);=0A=
      return this;=0A=
    } else {=0A=
      return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name  $compileProvider#debugInfoEnabled=0A=
   *=0A=
   * @param {boolean=3D} enabled update the debugInfoEnabled state if =
provided, otherwise just return the=0A=
   * current debugInfoEnabled state=0A=
   * @returns {*} current value if used as getter or itself (chaining) =
if used as setter=0A=
   *=0A=
   * @kind function=0A=
   *=0A=
   * @description=0A=
   * Call this method to enable/disable various debug runtime =
information in the compiler such as adding=0A=
   * binding information and a reference to the current scope on to DOM =
elements.=0A=
   * If enabled, the compiler will add the following to DOM elements =
that have been bound to the scope=0A=
   * * `ng-binding` CSS class=0A=
   * * `$binding` data property containing an array of the binding =
expressions=0A=
   *=0A=
   * You may want to use this in production for a significant =
performance boost. See=0A=
   * {@link guide/production#disabling-debug-data Disabling Debug Data} =
for more.=0A=
   *=0A=
   * The default value is true.=0A=
   */=0A=
  var debugInfoEnabled =3D true;=0A=
  this.debugInfoEnabled =3D function(enabled) {=0A=
    if(isDefined(enabled)) {=0A=
      debugInfoEnabled =3D enabled;=0A=
      return this;=0A=
    }=0A=
    return debugInfoEnabled;=0A=
  };=0A=
=0A=
  this.$get =3D [=0A=
            '$injector', '$interpolate', '$exceptionHandler', =
'$templateRequest', '$parse',=0A=
            '$controller', '$rootScope', '$document', '$sce', =
'$animate', '$$sanitizeUri',=0A=
    function($injector,   $interpolate,   $exceptionHandler,   =
$templateRequest,   $parse,=0A=
             $controller,   $rootScope,   $document,   $sce,   $animate, =
  $$sanitizeUri) {=0A=
=0A=
    var Attributes =3D function(element, attributesToCopy) {=0A=
      if (attributesToCopy) {=0A=
        var keys =3D Object.keys(attributesToCopy);=0A=
        var i, l, key;=0A=
=0A=
        for (i =3D 0, l =3D keys.length; i &lt; l; i++) {=0A=
          key =3D keys[i];=0A=
          this[key] =3D attributesToCopy[key];=0A=
        }=0A=
      } else {=0A=
        this.$attr =3D {};=0A=
      }=0A=
=0A=
      this.$$element =3D element;=0A=
    };=0A=
=0A=
    Attributes.prototype =3D {=0A=
      $normalize: directiveNormalize,=0A=
=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $compile.directive.Attributes#$addClass=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Adds the CSS class value specified by the classVal parameter to =
the element. If animations=0A=
       * are enabled then an animation will be triggered for the class =
addition.=0A=
       *=0A=
       * @param {string} classVal The className value that will be added =
to the element=0A=
       */=0A=
      $addClass : function(classVal) {=0A=
        if(classVal &amp;&amp; classVal.length &gt; 0) {=0A=
          $animate.addClass(this.$$element, classVal);=0A=
        }=0A=
      },=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $compile.directive.Attributes#$removeClass=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Removes the CSS class value specified by the classVal parameter =
from the element. If=0A=
       * animations are enabled then an animation will be triggered for =
the class removal.=0A=
       *=0A=
       * @param {string} classVal The className value that will be =
removed from the element=0A=
       */=0A=
      $removeClass : function(classVal) {=0A=
        if(classVal &amp;&amp; classVal.length &gt; 0) {=0A=
          $animate.removeClass(this.$$element, classVal);=0A=
        }=0A=
      },=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $compile.directive.Attributes#$updateClass=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Adds and removes the appropriate CSS class values to the =
element based on the difference=0A=
       * between the new and old CSS class values (specified as =
newClasses and oldClasses).=0A=
       *=0A=
       * @param {string} newClasses The current CSS className value=0A=
       * @param {string} oldClasses The former CSS className value=0A=
       */=0A=
      $updateClass : function(newClasses, oldClasses) {=0A=
        var toAdd =3D tokenDifference(newClasses, oldClasses);=0A=
        if (toAdd &amp;&amp; toAdd.length) {=0A=
          $animate.addClass(this.$$element, toAdd);=0A=
        }=0A=
=0A=
        var toRemove =3D tokenDifference(oldClasses, newClasses);=0A=
        if (toRemove &amp;&amp; toRemove.length) {=0A=
          $animate.removeClass(this.$$element, toRemove);=0A=
        }=0A=
      },=0A=
=0A=
      /**=0A=
       * Set a normalized attribute on the element in a way such that =
all directives=0A=
       * can share the attribute. This function properly handles boolean =
attributes.=0A=
       * @param {string} key Normalized key. (ie ngAttribute)=0A=
       * @param {string|boolean} value The value to set. If `null` =
attribute will be deleted.=0A=
       * @param {boolean=3D} writeAttr If false, does not write the =
value to DOM element attribute.=0A=
       *     Defaults to true.=0A=
       * @param {string=3D} attrName Optional none normalized name. =
Defaults to key.=0A=
       */=0A=
      $set: function(key, value, writeAttr, attrName) {=0A=
        // TODO: decide whether or not to throw an error if "class"=0A=
        //is set through this function since it may cause $updateClass to=0A=
        //become unstable.=0A=
=0A=
        var node =3D this.$$element[0],=0A=
            booleanKey =3D getBooleanAttrName(node, key),=0A=
            aliasedKey =3D getAliasedAttrName(node, key),=0A=
            observer =3D key,=0A=
            normalizedVal,=0A=
            nodeName;=0A=
=0A=
        if (booleanKey) {=0A=
          this.$$element.prop(key, value);=0A=
          attrName =3D booleanKey;=0A=
        } else if(aliasedKey) {=0A=
          this[aliasedKey] =3D value;=0A=
          observer =3D aliasedKey;=0A=
        }=0A=
=0A=
        this[key] =3D value;=0A=
=0A=
        // translate normalized key to actual key=0A=
        if (attrName) {=0A=
          this.$attr[key] =3D attrName;=0A=
        } else {=0A=
          attrName =3D this.$attr[key];=0A=
          if (!attrName) {=0A=
            this.$attr[key] =3D attrName =3D snake_case(key, '-');=0A=
          }=0A=
        }=0A=
=0A=
        nodeName =3D nodeName_(this.$$element);=0A=
=0A=
        if ((nodeName =3D=3D=3D 'a' &amp;&amp; key =3D=3D=3D 'href') ||=0A=
            (nodeName =3D=3D=3D 'img' &amp;&amp; key =3D=3D=3D 'src')) {=0A=
          // sanitize a[href] and img[src] values=0A=
          this[key] =3D value =3D $$sanitizeUri(value, key =3D=3D=3D =
'src');=0A=
        } else if (nodeName =3D=3D=3D 'img' &amp;&amp; key =3D=3D=3D =
'srcset') {=0A=
          // sanitize img[srcset] values=0A=
          var result =3D "";=0A=
=0A=
          // first check if there are spaces because it's not the same =
pattern=0A=
          var trimmedSrcset =3D trim(value);=0A=
          //                (   999x   ,|   999w   ,|   ,|,   )=0A=
          var srcPattern =3D /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;=0A=
          var pattern =3D /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;=0A=
=0A=
          // split srcset into tuple of uri and descriptor except for =
the last item=0A=
          var rawUris =3D trimmedSrcset.split(pattern);=0A=
=0A=
          // for each tuples=0A=
          var nbrUrisWith2parts =3D Math.floor(rawUris.length / 2);=0A=
          for (var i=3D0; i&lt;nbrUrisWith2parts; i++) {=0A=
            var innerIdx =3D i*2;=0A=
            // sanitize the uri=0A=
            result +=3D $$sanitizeUri(trim( rawUris[innerIdx]), true);=0A=
            // add the descriptor=0A=
            result +=3D ( " " + trim(rawUris[innerIdx+1]));=0A=
          }=0A=
=0A=
          // split the last item into uri and descriptor=0A=
          var lastTuple =3D trim(rawUris[i*2]).split(/\s/);=0A=
=0A=
          // sanitize the last uri=0A=
          result +=3D $$sanitizeUri(trim(lastTuple[0]), true);=0A=
=0A=
          // and add the last descriptor if any=0A=
          if( lastTuple.length =3D=3D=3D 2) {=0A=
            result +=3D (" " + trim(lastTuple[1]));=0A=
          }=0A=
          this[key] =3D value =3D result;=0A=
        }=0A=
=0A=
        if (writeAttr !=3D=3D false) {=0A=
          if (value =3D=3D=3D null || value =3D=3D=3D undefined) {=0A=
            this.$$element.removeAttr(attrName);=0A=
          } else {=0A=
            this.$$element.attr(attrName, value);=0A=
          }=0A=
        }=0A=
=0A=
        // fire observers=0A=
        var $$observers =3D this.$$observers;=0A=
        $$observers &amp;&amp; forEach($$observers[observer], =
function(fn) {=0A=
          try {=0A=
            fn(value);=0A=
          } catch (e) {=0A=
            $exceptionHandler(e);=0A=
          }=0A=
        });=0A=
      },=0A=
=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $compile.directive.Attributes#$observe=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Observes an interpolated attribute.=0A=
       *=0A=
       * The observer function will be invoked once during the next =
`$digest` following=0A=
       * compilation. The observer is then invoked whenever the =
interpolated value=0A=
       * changes.=0A=
       *=0A=
       * @param {string} key Normalized key. (ie ngAttribute) .=0A=
       * @param {function(interpolatedValue)} fn Function that will be =
called whenever=0A=
                the interpolated value of the attribute changes.=0A=
       *        See the {@link =
guide/directive#text-and-attribute-bindings Directives} guide for more =
info.=0A=
       * @returns {function()} Returns a deregistration function for =
this observer.=0A=
       */=0A=
      $observe: function(key, fn) {=0A=
        var attrs =3D this,=0A=
            $$observers =3D (attrs.$$observers || (attrs.$$observers =3D =
createMap())),=0A=
            listeners =3D ($$observers[key] || ($$observers[key] =3D =
[]));=0A=
=0A=
        listeners.push(fn);=0A=
        $rootScope.$evalAsync(function() {=0A=
          if (!listeners.$$inter) {=0A=
            // no one registered attribute interpolation function, so =
lets call it manually=0A=
            fn(attrs[key]);=0A=
          }=0A=
        });=0A=
=0A=
        return function() {=0A=
          arrayRemove(listeners, fn);=0A=
        };=0A=
      }=0A=
    };=0A=
=0A=
=0A=
    function safeAddClass($element, className) {=0A=
      try {=0A=
        $element.addClass(className);=0A=
      } catch(e) {=0A=
        // ignore, since it means that we are trying to set class on=0A=
        // SVG element, where class name is read-only.=0A=
      }=0A=
    }=0A=
=0A=
=0A=
    var startSymbol =3D $interpolate.startSymbol(),=0A=
        endSymbol =3D $interpolate.endSymbol(),=0A=
        denormalizeTemplate =3D (startSymbol =3D=3D '{{' || endSymbol  =
=3D=3D '}}')=0A=
            ? identity=0A=
            : function denormalizeTemplate(template) {=0A=
              return template.replace(/\{\{/g, =
startSymbol).replace(/}}/g, endSymbol);=0A=
        },=0A=
        NG_ATTR_BINDING =3D /^ngAttr[A-Z]/;=0A=
=0A=
    compile.$$addBindingInfo =3D debugInfoEnabled ? function =
$$addBindingInfo($element, binding) {=0A=
      var bindings =3D $element.data('$binding') || [];=0A=
=0A=
      if (isArray(binding)) {=0A=
        bindings =3D bindings.concat(binding);=0A=
      } else {=0A=
        bindings.push(binding);=0A=
      }=0A=
=0A=
      $element.data('$binding', bindings);=0A=
    } : noop;=0A=
=0A=
    compile.$$addBindingClass =3D debugInfoEnabled ? function =
$$addBindingClass($element) {=0A=
      safeAddClass($element, 'ng-binding');=0A=
    } : noop;=0A=
=0A=
    compile.$$addScopeInfo =3D debugInfoEnabled ? function =
$$addScopeInfo($element, scope, isolated, noTemplate) {=0A=
      var dataName =3D isolated ? (noTemplate ? =
'$isolateScopeNoTemplate' : '$isolateScope') : '$scope';=0A=
      $element.data(dataName, scope);=0A=
    } : noop;=0A=
=0A=
    compile.$$addScopeClass =3D debugInfoEnabled ? function =
$$addScopeClass($element, isolated) {=0A=
      safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');=0A=
    } : noop;=0A=
=0A=
    return compile;=0A=
=0A=
    =
//=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=0A=
=0A=
    function compile($compileNodes, transcludeFn, maxPriority, =
ignoreDirective,=0A=
                        previousCompileContext) {=0A=
      if (!($compileNodes instanceof jqLite)) {=0A=
        // jquery always rewraps, whereas we need to preserve the =
original selector so that we can=0A=
        // modify it.=0A=
        $compileNodes =3D jqLite($compileNodes);=0A=
      }=0A=
      // We can not compile top level text elements since text nodes can =
be merged and we will=0A=
      // not be able to attach scope data to them, so we will wrap them =
in &lt;span&gt;=0A=
      forEach($compileNodes, function(node, index){=0A=
        if (node.nodeType =3D=3D NODE_TYPE_TEXT &amp;&amp; =
node.nodeValue.match(/\S+/) /* non-empty */ ) {=0A=
          $compileNodes[index] =3D =
jqLite(node).wrap('&lt;span&gt;&lt;/span&gt;').parent()[0];=0A=
        }=0A=
      });=0A=
      var compositeLinkFn =3D=0A=
              compileNodes($compileNodes, transcludeFn, $compileNodes,=0A=
                           maxPriority, ignoreDirective, =
previousCompileContext);=0A=
      compile.$$addScopeClass($compileNodes);=0A=
      var namespace =3D null;=0A=
      return function publicLinkFn(scope, cloneConnectFn, =
transcludeControllers, parentBoundTranscludeFn, futureParentElement){=0A=
        assertArg(scope, 'scope');=0A=
        if (!namespace) {=0A=
          namespace =3D =
detectNamespaceForChildElements(futureParentElement);=0A=
        }=0A=
        var $linkNode;=0A=
        if (namespace !=3D=3D 'html') {=0A=
          // When using a directive with replace:true and templateUrl =
the $compileNodes=0A=
          // (or a child element inside of them)=0A=
          // might change, so we need to recreate the namespace adapted =
compileNodes=0A=
          // for call to the link function.=0A=
          // Note: This will already clone the nodes...=0A=
          $linkNode =3D jqLite(=0A=
            wrapTemplate(namespace, =
jqLite('&lt;div&gt;').append($compileNodes).html())=0A=
          );=0A=
        } else if (cloneConnectFn) {=0A=
          // important!!: we must call our jqLite.clone() since the =
jQuery one is trying to be smart=0A=
          // and sometimes changes the structure of the DOM.=0A=
          $linkNode =3D JQLitePrototype.clone.call($compileNodes);=0A=
        } else {=0A=
          $linkNode =3D $compileNodes;=0A=
        }=0A=
=0A=
        if (transcludeControllers) {=0A=
          for (var controllerName in transcludeControllers) {=0A=
            $linkNode.data('$' + controllerName + 'Controller', =
transcludeControllers[controllerName].instance);=0A=
          }=0A=
        }=0A=
=0A=
        compile.$$addScopeInfo($linkNode, scope);=0A=
=0A=
        if (cloneConnectFn) cloneConnectFn($linkNode, scope);=0A=
        if (compositeLinkFn) compositeLinkFn(scope, $linkNode, =
$linkNode, parentBoundTranscludeFn);=0A=
        return $linkNode;=0A=
      };=0A=
    }=0A=
=0A=
    function detectNamespaceForChildElements(parentElement) {=0A=
      // TODO: Make this detect MathML as well...=0A=
      var node =3D parentElement &amp;&amp; parentElement[0];=0A=
      if (!node) {=0A=
        return 'html';=0A=
      } else {=0A=
        return nodeName_(node) !=3D=3D 'foreignobject' &amp;&amp; =
node.toString().match(/SVG/) ? 'svg': 'html';=0A=
      }=0A=
    }=0A=
=0A=
    /**=0A=
     * Compile function matches each node in nodeList against the =
directives. Once all directives=0A=
     * for a particular node are collected their compile functions are =
executed. The compile=0A=
     * functions return values - the linking functions - are combined =
into a composite linking=0A=
     * function, which is the a linking function for the node.=0A=
     *=0A=
     * @param {NodeList} nodeList an array of nodes or NodeList to =
compile=0A=
     * @param {function(angular.Scope, cloneAttachFn=3D)} transcludeFn A =
linking function, where the=0A=
     *        scope argument is auto-generated to the new child of the =
transcluded parent scope.=0A=
     * @param {DOMElement=3D} $rootElement If the nodeList is the root =
of the compilation tree then=0A=
     *        the rootElement must be set the jqLite collection of the =
compile root. This is=0A=
     *        needed so that the jqLite collection items can be replaced =
with widgets.=0A=
     * @param {number=3D} maxPriority Max directive priority.=0A=
     * @returns {Function} A composite linking function of all of the =
matched directives or null.=0A=
     */=0A=
    function compileNodes(nodeList, transcludeFn, $rootElement, =
maxPriority, ignoreDirective,=0A=
                            previousCompileContext) {=0A=
      var linkFns =3D [],=0A=
          attrs, directives, nodeLinkFn, childNodes, childLinkFn, =
linkFnFound, nodeLinkFnFound;=0A=
=0A=
      for (var i =3D 0; i &lt; nodeList.length; i++) {=0A=
        attrs =3D new Attributes();=0A=
=0A=
        // we must always refer to nodeList[i] since the nodes can be =
replaced underneath us.=0A=
        directives =3D collectDirectives(nodeList[i], [], attrs, i =
=3D=3D=3D 0 ? maxPriority : undefined,=0A=
                                        ignoreDirective);=0A=
=0A=
        nodeLinkFn =3D (directives.length)=0A=
            ? applyDirectivesToNode(directives, nodeList[i], attrs, =
transcludeFn, $rootElement,=0A=
                                      null, [], [], =
previousCompileContext)=0A=
            : null;=0A=
=0A=
        if (nodeLinkFn &amp;&amp; nodeLinkFn.scope) {=0A=
          compile.$$addScopeClass(attrs.$$element);=0A=
        }=0A=
=0A=
        childLinkFn =3D (nodeLinkFn &amp;&amp; nodeLinkFn.terminal ||=0A=
                      !(childNodes =3D nodeList[i].childNodes) ||=0A=
                      !childNodes.length)=0A=
            ? null=0A=
            : compileNodes(childNodes,=0A=
                 nodeLinkFn ? (=0A=
                  (nodeLinkFn.transcludeOnThisElement || =
!nodeLinkFn.templateOnThisElement)=0A=
                     &amp;&amp; nodeLinkFn.transclude) : transcludeFn);=0A=
=0A=
        if (nodeLinkFn || childLinkFn) {=0A=
          linkFns.push(i, nodeLinkFn, childLinkFn);=0A=
          linkFnFound =3D true;=0A=
          nodeLinkFnFound =3D nodeLinkFnFound || nodeLinkFn;=0A=
        }=0A=
=0A=
        //use the previous context only for the first element in the =
virtual group=0A=
        previousCompileContext =3D null;=0A=
      }=0A=
=0A=
      // return a linking function if we have found anything, null =
otherwise=0A=
      return linkFnFound ? compositeLinkFn : null;=0A=
=0A=
      function compositeLinkFn(scope, nodeList, $rootElement, =
parentBoundTranscludeFn) {=0A=
        var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, =
childBoundTranscludeFn;=0A=
        var stableNodeList;=0A=
=0A=
=0A=
        if (nodeLinkFnFound) {=0A=
          // copy nodeList so that if a nodeLinkFn removes or adds an =
element at this DOM level our=0A=
          // offsets don't get screwed up=0A=
          var nodeListLength =3D nodeList.length;=0A=
          stableNodeList =3D new Array(nodeListLength);=0A=
=0A=
          // create a sparse array by only copying the elements which =
have a linkFn=0A=
          for (i =3D 0; i &lt; linkFns.length; i+=3D3) {=0A=
            idx =3D linkFns[i];=0A=
            stableNodeList[idx] =3D nodeList[idx];=0A=
          }=0A=
        } else {=0A=
          stableNodeList =3D nodeList;=0A=
        }=0A=
=0A=
        for(i =3D 0, ii =3D linkFns.length; i &lt; ii;) {=0A=
          node =3D stableNodeList[linkFns[i++]];=0A=
          nodeLinkFn =3D linkFns[i++];=0A=
          childLinkFn =3D linkFns[i++];=0A=
=0A=
          if (nodeLinkFn) {=0A=
            if (nodeLinkFn.scope) {=0A=
              childScope =3D scope.$new();=0A=
              compile.$$addScopeInfo(jqLite(node), childScope);=0A=
            } else {=0A=
              childScope =3D scope;=0A=
            }=0A=
=0A=
            if ( nodeLinkFn.transcludeOnThisElement ) {=0A=
              childBoundTranscludeFn =3D createBoundTranscludeFn(=0A=
                  scope, nodeLinkFn.transclude, parentBoundTranscludeFn,=0A=
                  nodeLinkFn.elementTranscludeOnThisElement);=0A=
=0A=
            } else if (!nodeLinkFn.templateOnThisElement &amp;&amp; =
parentBoundTranscludeFn) {=0A=
              childBoundTranscludeFn =3D parentBoundTranscludeFn;=0A=
=0A=
            } else if (!parentBoundTranscludeFn &amp;&amp; transcludeFn) =
{=0A=
              childBoundTranscludeFn =3D createBoundTranscludeFn(scope, =
transcludeFn);=0A=
=0A=
            } else {=0A=
              childBoundTranscludeFn =3D null;=0A=
            }=0A=
=0A=
            nodeLinkFn(childLinkFn, childScope, node, $rootElement, =
childBoundTranscludeFn);=0A=
=0A=
          } else if (childLinkFn) {=0A=
            childLinkFn(scope, node.childNodes, undefined, =
parentBoundTranscludeFn);=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    function createBoundTranscludeFn(scope, transcludeFn, =
previousBoundTranscludeFn, elementTransclusion) {=0A=
=0A=
      var boundTranscludeFn =3D function(transcludedScope, cloneFn, =
controllers, futureParentElement, containingScope) {=0A=
=0A=
        if (!transcludedScope) {=0A=
          transcludedScope =3D scope.$new(false, containingScope);=0A=
          transcludedScope.$$transcluded =3D true;=0A=
        }=0A=
=0A=
        return transcludeFn(transcludedScope, cloneFn, controllers, =
previousBoundTranscludeFn, futureParentElement);=0A=
      };=0A=
=0A=
      return boundTranscludeFn;=0A=
    }=0A=
=0A=
    /**=0A=
     * Looks for directives on the given node and adds them to the =
directive collection which is=0A=
     * sorted.=0A=
     *=0A=
     * @param node Node to search.=0A=
     * @param directives An array to which the directives are added to. =
This array is sorted before=0A=
     *        the function returns.=0A=
     * @param attrs The shared attrs object which is used to populate =
the normalized attributes.=0A=
     * @param {number=3D} maxPriority Max directive priority.=0A=
     */=0A=
    function collectDirectives(node, directives, attrs, maxPriority, =
ignoreDirective) {=0A=
      var nodeType =3D node.nodeType,=0A=
          attrsMap =3D attrs.$attr,=0A=
          match,=0A=
          className;=0A=
=0A=
      switch(nodeType) {=0A=
        case NODE_TYPE_ELEMENT: /* Element */=0A=
          // use the node name: &lt;directive&gt;=0A=
          addDirective(directives,=0A=
              directiveNormalize(nodeName_(node)), 'E', maxPriority, =
ignoreDirective);=0A=
=0A=
          // iterate over the attributes=0A=
          for (var attr, name, nName, ngAttrName, value, isNgAttr, =
nAttrs =3D node.attributes,=0A=
                   j =3D 0, jj =3D nAttrs &amp;&amp; nAttrs.length; j =
&lt; jj; j++) {=0A=
            var attrStartName =3D false;=0A=
            var attrEndName =3D false;=0A=
=0A=
            attr =3D nAttrs[j];=0A=
            name =3D attr.name;=0A=
            value =3D trim(attr.value);=0A=
=0A=
            // support ngAttr attribute binding=0A=
            ngAttrName =3D directiveNormalize(name);=0A=
            if (isNgAttr =3D NG_ATTR_BINDING.test(ngAttrName)) {=0A=
              name =3D snake_case(ngAttrName.substr(6), '-');=0A=
            }=0A=
=0A=
            var directiveNName =3D ngAttrName.replace(/(Start|End)$/, =
'');=0A=
            if (directiveIsMultiElement(directiveNName)) {=0A=
              if (ngAttrName =3D=3D=3D directiveNName + 'Start') {=0A=
                attrStartName =3D name;=0A=
                attrEndName =3D name.substr(0, name.length - 5) + 'end';=0A=
                name =3D name.substr(0, name.length - 6);=0A=
              }=0A=
            }=0A=
=0A=
            nName =3D directiveNormalize(name.toLowerCase());=0A=
            attrsMap[nName] =3D name;=0A=
            if (isNgAttr || !attrs.hasOwnProperty(nName)) {=0A=
                attrs[nName] =3D value;=0A=
                if (getBooleanAttrName(node, nName)) {=0A=
                  attrs[nName] =3D true; // presence means true=0A=
                }=0A=
            }=0A=
            addAttrInterpolateDirective(node, directives, value, nName, =
isNgAttr);=0A=
            addDirective(directives, nName, 'A', maxPriority, =
ignoreDirective, attrStartName,=0A=
                          attrEndName);=0A=
          }=0A=
=0A=
          // use class as directive=0A=
          className =3D node.className;=0A=
          if (isString(className) &amp;&amp; className !=3D=3D '') {=0A=
            while (match =3D CLASS_DIRECTIVE_REGEXP.exec(className)) {=0A=
              nName =3D directiveNormalize(match[2]);=0A=
              if (addDirective(directives, nName, 'C', maxPriority, =
ignoreDirective)) {=0A=
                attrs[nName] =3D trim(match[3]);=0A=
              }=0A=
              className =3D className.substr(match.index + =
match[0].length);=0A=
            }=0A=
          }=0A=
          break;=0A=
        case NODE_TYPE_TEXT: /* Text Node */=0A=
          addTextInterpolateDirective(directives, node.nodeValue);=0A=
          break;=0A=
        case NODE_TYPE_COMMENT: /* Comment */=0A=
          try {=0A=
            match =3D COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);=0A=
            if (match) {=0A=
              nName =3D directiveNormalize(match[1]);=0A=
              if (addDirective(directives, nName, 'M', maxPriority, =
ignoreDirective)) {=0A=
                attrs[nName] =3D trim(match[2]);=0A=
              }=0A=
            }=0A=
          } catch (e) {=0A=
            // turns out that under some circumstances IE9 throws errors =
when one attempts to read=0A=
            // comment's node value.=0A=
            // Just ignore it and continue. (Can't seem to reproduce in =
test case.)=0A=
          }=0A=
          break;=0A=
      }=0A=
=0A=
      directives.sort(byPriority);=0A=
      return directives;=0A=
    }=0A=
=0A=
    /**=0A=
     * Given a node with an directive-start it collects all of the =
siblings until it finds=0A=
     * directive-end.=0A=
     * @param node=0A=
     * @param attrStart=0A=
     * @param attrEnd=0A=
     * @returns {*}=0A=
     */=0A=
    function groupScan(node, attrStart, attrEnd) {=0A=
      var nodes =3D [];=0A=
      var depth =3D 0;=0A=
      if (attrStart &amp;&amp; node.hasAttribute &amp;&amp; =
node.hasAttribute(attrStart)) {=0A=
        var startNode =3D node;=0A=
        do {=0A=
          if (!node) {=0A=
            throw $compileMinErr('uterdir',=0A=
                      "Unterminated attribute, found '{0}' but no =
matching '{1}' found.",=0A=
                      attrStart, attrEnd);=0A=
          }=0A=
          if (node.nodeType =3D=3D NODE_TYPE_ELEMENT) {=0A=
            if (node.hasAttribute(attrStart)) depth++;=0A=
            if (node.hasAttribute(attrEnd)) depth--;=0A=
          }=0A=
          nodes.push(node);=0A=
          node =3D node.nextSibling;=0A=
        } while (depth &gt; 0);=0A=
      } else {=0A=
        nodes.push(node);=0A=
      }=0A=
=0A=
      return jqLite(nodes);=0A=
    }=0A=
=0A=
    /**=0A=
     * Wrapper for linking function which converts normal linking =
function into a grouped=0A=
     * linking function.=0A=
     * @param linkFn=0A=
     * @param attrStart=0A=
     * @param attrEnd=0A=
     * @returns {Function}=0A=
     */=0A=
    function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {=0A=
      return function(scope, element, attrs, controllers, transcludeFn) {=0A=
        element =3D groupScan(element[0], attrStart, attrEnd);=0A=
        return linkFn(scope, element, attrs, controllers, transcludeFn);=0A=
      };=0A=
    }=0A=
=0A=
    /**=0A=
     * Once the directives have been collected, their compile functions =
are executed. This method=0A=
     * is responsible for inlining directive templates as well as =
terminating the application=0A=
     * of the directives if the terminal directive has been reached.=0A=
     *=0A=
     * @param {Array} directives Array of collected directives to =
execute their compile function.=0A=
     *        this needs to be pre-sorted by priority order.=0A=
     * @param {Node} compileNode The raw DOM node to apply the compile =
functions to=0A=
     * @param {Object} templateAttrs The shared attribute function=0A=
     * @param {function(angular.Scope, cloneAttachFn=3D)} transcludeFn A =
linking function, where the=0A=
     *                                                  scope argument =
is auto-generated to the new=0A=
     *                                                  child of the =
transcluded parent scope.=0A=
     * @param {JQLite} jqCollection If we are working on the root of the =
compile tree then this=0A=
     *                              argument has the root jqLite array =
so that we can replace nodes=0A=
     *                              on it.=0A=
     * @param {Object=3D} originalReplaceDirective An optional directive =
that will be ignored when=0A=
     *                                           compiling the =
transclusion.=0A=
     * @param {Array.&lt;Function&gt;} preLinkFns=0A=
     * @param {Array.&lt;Function&gt;} postLinkFns=0A=
     * @param {Object} previousCompileContext Context used for previous =
compilation of the current=0A=
     *                                        node=0A=
     * @returns {Function} linkFn=0A=
     */=0A=
    function applyDirectivesToNode(directives, compileNode, =
templateAttrs, transcludeFn,=0A=
                                   jqCollection, =
originalReplaceDirective, preLinkFns, postLinkFns,=0A=
                                   previousCompileContext) {=0A=
      previousCompileContext =3D previousCompileContext || {};=0A=
=0A=
      var terminalPriority =3D -Number.MAX_VALUE,=0A=
          newScopeDirective,=0A=
          controllerDirectives =3D =
previousCompileContext.controllerDirectives,=0A=
          controllers,=0A=
          newIsolateScopeDirective =3D =
previousCompileContext.newIsolateScopeDirective,=0A=
          templateDirective =3D previousCompileContext.templateDirective,=0A=
          nonTlbTranscludeDirective =3D =
previousCompileContext.nonTlbTranscludeDirective,=0A=
          hasTranscludeDirective =3D false,=0A=
          hasTemplate =3D false,=0A=
          hasElementTranscludeDirective =3D =
previousCompileContext.hasElementTranscludeDirective,=0A=
          $compileNode =3D templateAttrs.$$element =3D =
jqLite(compileNode),=0A=
          directive,=0A=
          directiveName,=0A=
          $template,=0A=
          replaceDirective =3D originalReplaceDirective,=0A=
          childTranscludeFn =3D transcludeFn,=0A=
          linkFn,=0A=
          directiveValue;=0A=
=0A=
      // executes all directives on the current element=0A=
      for(var i =3D 0, ii =3D directives.length; i &lt; ii; i++) {=0A=
        directive =3D directives[i];=0A=
        var attrStart =3D directive.$$start;=0A=
        var attrEnd =3D directive.$$end;=0A=
=0A=
        // collect multiblock sections=0A=
        if (attrStart) {=0A=
          $compileNode =3D groupScan(compileNode, attrStart, attrEnd);=0A=
        }=0A=
        $template =3D undefined;=0A=
=0A=
        if (terminalPriority &gt; directive.priority) {=0A=
          break; // prevent further processing of directives=0A=
        }=0A=
=0A=
        if (directiveValue =3D directive.scope) {=0A=
=0A=
          // skip the check for directives with async templates, we'll =
check the derived sync=0A=
          // directive when the template arrives=0A=
          if (!directive.templateUrl) {=0A=
            if (isObject(directiveValue)) {=0A=
              // This directive is trying to add an isolated scope.=0A=
              // Check that there is no scope of any kind already=0A=
              assertNoDuplicate('new/isolated scope', =
newIsolateScopeDirective || newScopeDirective,=0A=
                                directive, $compileNode);=0A=
              newIsolateScopeDirective =3D directive;=0A=
            } else {=0A=
              // This directive is trying to add a child scope.=0A=
              // Check that there is no isolated scope already=0A=
              assertNoDuplicate('new/isolated scope', =
newIsolateScopeDirective, directive,=0A=
                                $compileNode);=0A=
            }=0A=
          }=0A=
=0A=
          newScopeDirective =3D newScopeDirective || directive;=0A=
        }=0A=
=0A=
        directiveName =3D directive.name;=0A=
=0A=
        if (!directive.templateUrl &amp;&amp; directive.controller) {=0A=
          directiveValue =3D directive.controller;=0A=
          controllerDirectives =3D controllerDirectives || {};=0A=
          assertNoDuplicate("'" + directiveName + "' controller",=0A=
              controllerDirectives[directiveName], directive, =
$compileNode);=0A=
          controllerDirectives[directiveName] =3D directive;=0A=
        }=0A=
=0A=
        if (directiveValue =3D directive.transclude) {=0A=
          hasTranscludeDirective =3D true;=0A=
=0A=
          // Special case ngIf and ngRepeat so that we don't complain =
about duplicate transclusion.=0A=
          // This option should only be used by directives that know how =
to safely handle element transclusion,=0A=
          // where the transcluded nodes are added or replaced after =
linking.=0A=
          if (!directive.$$tlb) {=0A=
            assertNoDuplicate('transclusion', nonTlbTranscludeDirective, =
directive, $compileNode);=0A=
            nonTlbTranscludeDirective =3D directive;=0A=
          }=0A=
=0A=
          if (directiveValue =3D=3D 'element') {=0A=
            hasElementTranscludeDirective =3D true;=0A=
            terminalPriority =3D directive.priority;=0A=
            $template =3D $compileNode;=0A=
            $compileNode =3D templateAttrs.$$element =3D=0A=
                jqLite(document.createComment(' ' + directiveName + ': ' =
+=0A=
                                              =
templateAttrs[directiveName] + ' '));=0A=
            compileNode =3D $compileNode[0];=0A=
            replaceWith(jqCollection, sliceArgs($template), compileNode);=0A=
=0A=
            childTranscludeFn =3D compile($template, transcludeFn, =
terminalPriority,=0A=
                                        replaceDirective &amp;&amp; =
replaceDirective.name, {=0A=
                                          // Don't pass in:=0A=
                                          // - controllerDirectives - =
otherwise we'll create duplicates controllers=0A=
                                          // - newIsolateScopeDirective =
or templateDirective - combining templates with=0A=
                                          //   element transclusion =
doesn't make sense.=0A=
                                          //=0A=
                                          // We need only =
nonTlbTranscludeDirective so that we prevent putting transclusion=0A=
                                          // on the same element more =
than once.=0A=
                                          nonTlbTranscludeDirective: =
nonTlbTranscludeDirective=0A=
                                        });=0A=
          } else {=0A=
            $template =3D jqLite(jqLiteClone(compileNode)).contents();=0A=
            $compileNode.empty(); // clear contents=0A=
            childTranscludeFn =3D compile($template, transcludeFn);=0A=
          }=0A=
        }=0A=
=0A=
        if (directive.template) {=0A=
          hasTemplate =3D true;=0A=
          assertNoDuplicate('template', templateDirective, directive, =
$compileNode);=0A=
          templateDirective =3D directive;=0A=
=0A=
          directiveValue =3D (isFunction(directive.template))=0A=
              ? directive.template($compileNode, templateAttrs)=0A=
              : directive.template;=0A=
=0A=
          directiveValue =3D denormalizeTemplate(directiveValue);=0A=
=0A=
          if (directive.replace) {=0A=
            replaceDirective =3D directive;=0A=
            if (jqLiteIsTextNode(directiveValue)) {=0A=
              $template =3D [];=0A=
            } else {=0A=
              $template =3D =
removeComments(wrapTemplate(directive.templateNamespace, =
trim(directiveValue)));=0A=
            }=0A=
            compileNode =3D $template[0];=0A=
=0A=
            if ($template.length !=3D 1 || compileNode.nodeType !=3D=3D =
NODE_TYPE_ELEMENT) {=0A=
              throw $compileMinErr('tplrt',=0A=
                  "Template for directive '{0}' must have exactly one =
root element. {1}",=0A=
                  directiveName, '');=0A=
            }=0A=
=0A=
            replaceWith(jqCollection, $compileNode, compileNode);=0A=
=0A=
            var newTemplateAttrs =3D {$attr: {}};=0A=
=0A=
            // combine directives from the original node and from the =
template:=0A=
            // - take the array of directives for this element=0A=
            // - split it into two parts, those that already applied =
(processed) and those that weren't (unprocessed)=0A=
            // - collect directives from the template and sort them by =
priority=0A=
            // - combine directives as: processed + template + =
unprocessed=0A=
            var templateDirectives =3D collectDirectives(compileNode, =
[], newTemplateAttrs);=0A=
            var unprocessedDirectives =3D directives.splice(i + 1, =
directives.length - (i + 1));=0A=
=0A=
            if (newIsolateScopeDirective) {=0A=
              markDirectivesAsIsolate(templateDirectives);=0A=
            }=0A=
            directives =3D =
directives.concat(templateDirectives).concat(unprocessedDirectives);=0A=
            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);=0A=
=0A=
            ii =3D directives.length;=0A=
          } else {=0A=
            $compileNode.html(directiveValue);=0A=
          }=0A=
        }=0A=
=0A=
        if (directive.templateUrl) {=0A=
          hasTemplate =3D true;=0A=
          assertNoDuplicate('template', templateDirective, directive, =
$compileNode);=0A=
          templateDirective =3D directive;=0A=
=0A=
          if (directive.replace) {=0A=
            replaceDirective =3D directive;=0A=
          }=0A=
=0A=
          nodeLinkFn =3D compileTemplateUrl(directives.splice(i, =
directives.length - i), $compileNode,=0A=
              templateAttrs, jqCollection, hasTranscludeDirective =
&amp;&amp; childTranscludeFn, preLinkFns, postLinkFns, {=0A=
                controllerDirectives: controllerDirectives,=0A=
                newIsolateScopeDirective: newIsolateScopeDirective,=0A=
                templateDirective: templateDirective,=0A=
                nonTlbTranscludeDirective: nonTlbTranscludeDirective=0A=
              });=0A=
          ii =3D directives.length;=0A=
        } else if (directive.compile) {=0A=
          try {=0A=
            linkFn =3D directive.compile($compileNode, templateAttrs, =
childTranscludeFn);=0A=
            if (isFunction(linkFn)) {=0A=
              addLinkFns(null, linkFn, attrStart, attrEnd);=0A=
            } else if (linkFn) {=0A=
              addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);=0A=
            }=0A=
          } catch (e) {=0A=
            $exceptionHandler(e, startingTag($compileNode));=0A=
          }=0A=
        }=0A=
=0A=
        if (directive.terminal) {=0A=
          nodeLinkFn.terminal =3D true;=0A=
          terminalPriority =3D Math.max(terminalPriority, =
directive.priority);=0A=
        }=0A=
=0A=
      }=0A=
=0A=
      nodeLinkFn.scope =3D newScopeDirective &amp;&amp; =
newScopeDirective.scope =3D=3D=3D true;=0A=
      nodeLinkFn.transcludeOnThisElement =3D hasTranscludeDirective;=0A=
      nodeLinkFn.elementTranscludeOnThisElement =3D =
hasElementTranscludeDirective;=0A=
      nodeLinkFn.templateOnThisElement =3D hasTemplate;=0A=
      nodeLinkFn.transclude =3D childTranscludeFn;=0A=
=0A=
      previousCompileContext.hasElementTranscludeDirective =3D =
hasElementTranscludeDirective;=0A=
=0A=
      // might be normal or delayed nodeLinkFn depending on if =
templateUrl is present=0A=
      return nodeLinkFn;=0A=
=0A=
      ////////////////////=0A=
=0A=
      function addLinkFns(pre, post, attrStart, attrEnd) {=0A=
        if (pre) {=0A=
          if (attrStart) pre =3D groupElementsLinkFnWrapper(pre, =
attrStart, attrEnd);=0A=
          pre.require =3D directive.require;=0A=
          pre.directiveName =3D directiveName;=0A=
          if (newIsolateScopeDirective =3D=3D=3D directive || =
directive.$$isolateScope) {=0A=
            pre =3D cloneAndAnnotateFn(pre, {isolateScope: true});=0A=
          }=0A=
          preLinkFns.push(pre);=0A=
        }=0A=
        if (post) {=0A=
          if (attrStart) post =3D groupElementsLinkFnWrapper(post, =
attrStart, attrEnd);=0A=
          post.require =3D directive.require;=0A=
          post.directiveName =3D directiveName;=0A=
          if (newIsolateScopeDirective =3D=3D=3D directive || =
directive.$$isolateScope) {=0A=
            post =3D cloneAndAnnotateFn(post, {isolateScope: true});=0A=
          }=0A=
          postLinkFns.push(post);=0A=
        }=0A=
      }=0A=
=0A=
=0A=
      function getControllers(directiveName, require, $element, =
elementControllers) {=0A=
        var value, retrievalMethod =3D 'data', optional =3D false;=0A=
        var $searchElement =3D $element;=0A=
        var match;=0A=
        if (isString(require)) {=0A=
          match =3D require.match(REQUIRE_PREFIX_REGEXP);=0A=
          require =3D require.substring(match[0].length);=0A=
=0A=
          if (match[3]) {=0A=
            if (match[1]) match[3] =3D null;=0A=
            else match[1] =3D match[3];=0A=
          }=0A=
          if (match[1] =3D=3D=3D '^') {=0A=
            retrievalMethod =3D 'inheritedData';=0A=
          } else if (match[1] =3D=3D=3D '^^') {=0A=
            retrievalMethod =3D 'inheritedData';=0A=
            $searchElement =3D $element.parent();=0A=
          }=0A=
          if (match[2] =3D=3D=3D '?') {=0A=
            optional =3D true;=0A=
          }=0A=
=0A=
          value =3D null;=0A=
=0A=
          if (elementControllers &amp;&amp; retrievalMethod =3D=3D=3D =
'data') {=0A=
            if (value =3D elementControllers[require]) {=0A=
              value =3D value.instance;=0A=
            }=0A=
          }=0A=
          value =3D value || $searchElement[retrievalMethod]('$' + =
require + 'Controller');=0A=
=0A=
          if (!value &amp;&amp; !optional) {=0A=
            throw $compileMinErr('ctreq',=0A=
                "Controller '{0}', required by directive '{1}', can't be =
found!",=0A=
                require, directiveName);=0A=
          }=0A=
          return value;=0A=
        } else if (isArray(require)) {=0A=
          value =3D [];=0A=
          forEach(require, function(require) {=0A=
            value.push(getControllers(directiveName, require, $element, =
elementControllers));=0A=
          });=0A=
        }=0A=
        return value;=0A=
      }=0A=
=0A=
=0A=
      function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, =
boundTranscludeFn) {=0A=
        var i, ii, linkFn, controller, isolateScope, elementControllers, =
transcludeFn, $element,=0A=
            attrs;=0A=
=0A=
        if (compileNode =3D=3D=3D linkNode) {=0A=
          attrs =3D templateAttrs;=0A=
          $element =3D templateAttrs.$$element;=0A=
        } else {=0A=
          $element =3D jqLite(linkNode);=0A=
          attrs =3D new Attributes($element, templateAttrs);=0A=
        }=0A=
=0A=
        if (newIsolateScopeDirective) {=0A=
          isolateScope =3D scope.$new(true);=0A=
        }=0A=
=0A=
        transcludeFn =3D boundTranscludeFn &amp;&amp; =
controllersBoundTransclude;=0A=
        if (controllerDirectives) {=0A=
          // TODO: merge `controllers` and `elementControllers` into =
single object.=0A=
          controllers =3D {};=0A=
          elementControllers =3D {};=0A=
          forEach(controllerDirectives, function(directive) {=0A=
            var locals =3D {=0A=
              $scope: directive =3D=3D=3D newIsolateScopeDirective || =
directive.$$isolateScope ? isolateScope : scope,=0A=
              $element: $element,=0A=
              $attrs: attrs,=0A=
              $transclude: transcludeFn=0A=
            }, controllerInstance;=0A=
=0A=
            controller =3D directive.controller;=0A=
            if (controller =3D=3D '@') {=0A=
              controller =3D attrs[directive.name];=0A=
            }=0A=
=0A=
            controllerInstance =3D $controller(controller, locals, true, =
directive.controllerAs);=0A=
=0A=
            // For directives with element transclusion the element is a =
comment,=0A=
            // but jQuery .data doesn't support attaching data to =
comment nodes as it's hard to=0A=
            // clean up (http://bugs.jquery.com/ticket/8335).=0A=
            // Instead, we save the controllers for the element in a =
local hash and attach to .data=0A=
            // later, once we have the actual element.=0A=
            elementControllers[directive.name] =3D controllerInstance;=0A=
            if (!hasElementTranscludeDirective) {=0A=
              $element.data('$' + directive.name + 'Controller', =
controllerInstance.instance);=0A=
            }=0A=
=0A=
            controllers[directive.name] =3D controllerInstance;=0A=
          });=0A=
        }=0A=
=0A=
        if (newIsolateScopeDirective) {=0A=
          var LOCAL_REGEXP =3D /^\s*([@=3D&amp;])(\??)\s*(\w*)\s*$/;=0A=
=0A=
          compile.$$addScopeInfo($element, isolateScope, true, =
!(templateDirective &amp;&amp; (templateDirective =3D=3D=3D =
newIsolateScopeDirective ||=0A=
              templateDirective =3D=3D=3D =
newIsolateScopeDirective.$$originalDirective)));=0A=
          compile.$$addScopeClass($element, true);=0A=
=0A=
          var isolateScopeController =3D controllers &amp;&amp; =
controllers[newIsolateScopeDirective.name];=0A=
          var isolateBindingContext =3D isolateScope;=0A=
          if (isolateScopeController &amp;&amp; =
isolateScopeController.identifier &amp;&amp;=0A=
              newIsolateScopeDirective.bindToController =3D=3D=3D true) {=0A=
            isolateBindingContext =3D isolateScopeController.instance;=0A=
          }=0A=
=0A=
          forEach(isolateScope.$$isolateBindings =3D =
newIsolateScopeDirective.$$isolateBindings, function(definition, =
scopeName) {=0A=
            var attrName =3D definition.attrName,=0A=
                optional =3D definition.optional,=0A=
                mode =3D definition.mode, // @, =3D, or &amp;=0A=
                lastValue,=0A=
                parentGet, parentSet, compare;=0A=
=0A=
            switch (mode) {=0A=
=0A=
              case '@':=0A=
                attrs.$observe(attrName, function(value) {=0A=
                  isolateBindingContext[scopeName] =3D value;=0A=
                });=0A=
                attrs.$$observers[attrName].$$scope =3D scope;=0A=
                if( attrs[attrName] ) {=0A=
                  // If the attribute has been provided then we trigger =
an interpolation to ensure=0A=
                  // the value is there for use in the link fn=0A=
                  isolateBindingContext[scopeName] =3D =
$interpolate(attrs[attrName])(scope);=0A=
                }=0A=
                break;=0A=
=0A=
              case '=3D':=0A=
                if (optional &amp;&amp; !attrs[attrName]) {=0A=
                  return;=0A=
                }=0A=
                parentGet =3D $parse(attrs[attrName]);=0A=
                if (parentGet.literal) {=0A=
                  compare =3D equals;=0A=
                } else {=0A=
                  compare =3D function(a,b) { return a =3D=3D=3D b || (a =
!=3D=3D a &amp;&amp; b !=3D=3D b); };=0A=
                }=0A=
                parentSet =3D parentGet.assign || function() {=0A=
                  // reset the change, or we will throw this exception =
on every $digest=0A=
                  lastValue =3D isolateBindingContext[scopeName] =3D =
parentGet(scope);=0A=
                  throw $compileMinErr('nonassign',=0A=
                      "Expression '{0}' used with directive '{1}' is =
non-assignable!",=0A=
                      attrs[attrName], newIsolateScopeDirective.name);=0A=
                };=0A=
                lastValue =3D isolateBindingContext[scopeName] =3D =
parentGet(scope);=0A=
                var parentValueWatch =3D function =
parentValueWatch(parentValue) {=0A=
                  if (!compare(parentValue, =
isolateBindingContext[scopeName])) {=0A=
                    // we are out of sync and need to copy=0A=
                    if (!compare(parentValue, lastValue)) {=0A=
                      // parent changed and it has precedence=0A=
                      isolateBindingContext[scopeName] =3D parentValue;=0A=
                    } else {=0A=
                      // if the parent can be assigned then do so=0A=
                      parentSet(scope, parentValue =3D =
isolateBindingContext[scopeName]);=0A=
                    }=0A=
                  }=0A=
                  return lastValue =3D parentValue;=0A=
                };=0A=
                parentValueWatch.$stateful =3D true;=0A=
                var unwatch =3D scope.$watch($parse(attrs[attrName], =
parentValueWatch), null, parentGet.literal);=0A=
                isolateScope.$on('$destroy', unwatch);=0A=
                break;=0A=
=0A=
              case '&amp;':=0A=
                parentGet =3D $parse(attrs[attrName]);=0A=
                isolateBindingContext[scopeName] =3D function(locals) {=0A=
                  return parentGet(scope, locals);=0A=
                };=0A=
                break;=0A=
            }=0A=
          });=0A=
        }=0A=
        if (controllers) {=0A=
          forEach(controllers, function(controller) {=0A=
            controller();=0A=
          });=0A=
          controllers =3D null;=0A=
        }=0A=
=0A=
        // PRELINKING=0A=
        for(i =3D 0, ii =3D preLinkFns.length; i &lt; ii; i++) {=0A=
          linkFn =3D preLinkFns[i];=0A=
          invokeLinkFn(linkFn,=0A=
              linkFn.isolateScope ? isolateScope : scope,=0A=
              $element,=0A=
              attrs,=0A=
              linkFn.require &amp;&amp; =
getControllers(linkFn.directiveName, linkFn.require, $element, =
elementControllers),=0A=
              transcludeFn=0A=
          );=0A=
        }=0A=
=0A=
        // RECURSION=0A=
        // We only pass the isolate scope, if the isolate directive has =
a template,=0A=
        // otherwise the child elements do not belong to the isolate =
directive.=0A=
        var scopeToChild =3D scope;=0A=
        if (newIsolateScopeDirective &amp;&amp; =
(newIsolateScopeDirective.template || =
newIsolateScopeDirective.templateUrl =3D=3D=3D null)) {=0A=
          scopeToChild =3D isolateScope;=0A=
        }=0A=
        childLinkFn &amp;&amp; childLinkFn(scopeToChild, =
linkNode.childNodes, undefined, boundTranscludeFn);=0A=
=0A=
        // POSTLINKING=0A=
        for(i =3D postLinkFns.length - 1; i &gt;=3D 0; i--) {=0A=
          linkFn =3D postLinkFns[i];=0A=
          invokeLinkFn(linkFn,=0A=
              linkFn.isolateScope ? isolateScope : scope,=0A=
              $element,=0A=
              attrs,=0A=
              linkFn.require &amp;&amp; =
getControllers(linkFn.directiveName, linkFn.require, $element, =
elementControllers),=0A=
              transcludeFn=0A=
          );=0A=
        }=0A=
=0A=
        // This is the function that is injected as `$transclude`.=0A=
        // Note: all arguments are optional!=0A=
        function controllersBoundTransclude(scope, cloneAttachFn, =
futureParentElement) {=0A=
          var transcludeControllers;=0A=
=0A=
          // No scope passed in:=0A=
          if (!isScope(scope)) {=0A=
            futureParentElement =3D cloneAttachFn;=0A=
            cloneAttachFn =3D scope;=0A=
            scope =3D undefined;=0A=
          }=0A=
=0A=
          if (hasElementTranscludeDirective) {=0A=
            transcludeControllers =3D elementControllers;=0A=
          }=0A=
          if (!futureParentElement) {=0A=
            futureParentElement =3D hasElementTranscludeDirective ? =
$element.parent() : $element;=0A=
          }=0A=
          return boundTranscludeFn(scope, cloneAttachFn, =
transcludeControllers, futureParentElement, scopeToChild);=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    function markDirectivesAsIsolate(directives) {=0A=
      // mark all directives as needing isolate scope.=0A=
      for (var j =3D 0, jj =3D directives.length; j &lt; jj; j++) {=0A=
        directives[j] =3D inherit(directives[j], {$$isolateScope: true});=0A=
      }=0A=
    }=0A=
=0A=
    /**=0A=
     * looks up the directive and decorates it with exception handling =
and proper parameters. We=0A=
     * call this the boundDirective.=0A=
     *=0A=
     * @param {string} name name of the directive to look up.=0A=
     * @param {string} location The directive must be found in specific =
format.=0A=
     *   String containing any of theses characters:=0A=
     *=0A=
     *   * `E`: element name=0A=
     *   * `A': attribute=0A=
     *   * `C`: class=0A=
     *   * `M`: comment=0A=
     * @returns {boolean} true if directive was added.=0A=
     */=0A=
    function addDirective(tDirectives, name, location, maxPriority, =
ignoreDirective, startAttrName,=0A=
                          endAttrName) {=0A=
      if (name =3D=3D=3D ignoreDirective) return null;=0A=
      var match =3D null;=0A=
      if (hasDirectives.hasOwnProperty(name)) {=0A=
        for(var directive, directives =3D $injector.get(name + Suffix),=0A=
            i =3D 0, ii =3D directives.length; i&lt;ii; i++) {=0A=
          try {=0A=
            directive =3D directives[i];=0A=
            if ( (maxPriority =3D=3D=3D undefined || maxPriority &gt; =
directive.priority) &amp;&amp;=0A=
                 directive.restrict.indexOf(location) !=3D -1) {=0A=
              if (startAttrName) {=0A=
                directive =3D inherit(directive, {$$start: =
startAttrName, $$end: endAttrName});=0A=
              }=0A=
              tDirectives.push(directive);=0A=
              match =3D directive;=0A=
            }=0A=
          } catch(e) { $exceptionHandler(e); }=0A=
        }=0A=
      }=0A=
      return match;=0A=
    }=0A=
=0A=
=0A=
    /**=0A=
     * looks up the directive and returns true if it is a multi-element =
directive,=0A=
     * and therefore requires DOM nodes between -start and -end markers =
to be grouped=0A=
     * together.=0A=
     *=0A=
     * @param {string} name name of the directive to look up.=0A=
     * @returns true if directive was registered as multi-element.=0A=
     */=0A=
    function directiveIsMultiElement(name) {=0A=
      if (hasDirectives.hasOwnProperty(name)) {=0A=
        for(var directive, directives =3D $injector.get(name + Suffix),=0A=
            i =3D 0, ii =3D directives.length; i&lt;ii; i++) {=0A=
          directive =3D directives[i];=0A=
          if (directive.multiElement) {=0A=
            return true;=0A=
          }=0A=
        }=0A=
      }=0A=
      return false;=0A=
    }=0A=
=0A=
    /**=0A=
     * When the element is replaced with HTML template then the new =
attributes=0A=
     * on the template need to be merged with the existing attributes in =
the DOM.=0A=
     * The desired effect is to have both of the attributes present.=0A=
     *=0A=
     * @param {object} dst destination attributes (original DOM)=0A=
     * @param {object} src source attributes (from the directive =
template)=0A=
     */=0A=
    function mergeTemplateAttributes(dst, src) {=0A=
      var srcAttr =3D src.$attr,=0A=
          dstAttr =3D dst.$attr,=0A=
          $element =3D dst.$$element;=0A=
=0A=
      // reapply the old attributes to the new element=0A=
      forEach(dst, function(value, key) {=0A=
        if (key.charAt(0) !=3D '$') {=0A=
          if (src[key] &amp;&amp; src[key] !=3D=3D value) {=0A=
            value +=3D (key =3D=3D=3D 'style' ? ';' : ' ') + src[key];=0A=
          }=0A=
          dst.$set(key, value, true, srcAttr[key]);=0A=
        }=0A=
      });=0A=
=0A=
      // copy the new attributes on the old attrs object=0A=
      forEach(src, function(value, key) {=0A=
        if (key =3D=3D 'class') {=0A=
          safeAddClass($element, value);=0A=
          dst['class'] =3D (dst['class'] ? dst['class'] + ' ' : '') + =
value;=0A=
        } else if (key =3D=3D 'style') {=0A=
          $element.attr('style', $element.attr('style') + ';' + value);=0A=
          dst['style'] =3D (dst['style'] ? dst['style'] + ';' : '') + =
value;=0A=
          // `dst` will never contain hasOwnProperty as DOM parser won't =
let it.=0A=
          // You will get an "InvalidCharacterError: DOM Exception 5" =
error if you=0A=
          // have an attribute like "has-own-property" or =
"data-has-own-property", etc.=0A=
        } else if (key.charAt(0) !=3D '$' &amp;&amp; =
!dst.hasOwnProperty(key)) {=0A=
          dst[key] =3D value;=0A=
          dstAttr[key] =3D srcAttr[key];=0A=
        }=0A=
      });=0A=
    }=0A=
=0A=
=0A=
    function compileTemplateUrl(directives, $compileNode, tAttrs,=0A=
        $rootElement, childTranscludeFn, preLinkFns, postLinkFns, =
previousCompileContext) {=0A=
      var linkQueue =3D [],=0A=
          afterTemplateNodeLinkFn,=0A=
          afterTemplateChildLinkFn,=0A=
          beforeTemplateCompileNode =3D $compileNode[0],=0A=
          origAsyncDirective =3D directives.shift(),=0A=
          // The fact that we have to copy and patch the directive seems =
wrong!=0A=
          derivedSyncDirective =3D extend({}, origAsyncDirective, {=0A=
            templateUrl: null, transclude: null, replace: null, =
$$originalDirective: origAsyncDirective=0A=
          }),=0A=
          templateUrl =3D (isFunction(origAsyncDirective.templateUrl))=0A=
              ? origAsyncDirective.templateUrl($compileNode, tAttrs)=0A=
              : origAsyncDirective.templateUrl,=0A=
          templateNamespace =3D origAsyncDirective.templateNamespace;=0A=
=0A=
      $compileNode.empty();=0A=
=0A=
      $templateRequest($sce.getTrustedResourceUrl(templateUrl))=0A=
        .then(function(content) {=0A=
          var compileNode, tempTemplateAttrs, $template, =
childBoundTranscludeFn;=0A=
=0A=
          content =3D denormalizeTemplate(content);=0A=
=0A=
          if (origAsyncDirective.replace) {=0A=
            if (jqLiteIsTextNode(content)) {=0A=
              $template =3D [];=0A=
            } else {=0A=
              $template =3D =
removeComments(wrapTemplate(templateNamespace, trim(content)));=0A=
            }=0A=
            compileNode =3D $template[0];=0A=
=0A=
            if ($template.length !=3D 1 || compileNode.nodeType !=3D=3D =
NODE_TYPE_ELEMENT) {=0A=
              throw $compileMinErr('tplrt',=0A=
                  "Template for directive '{0}' must have exactly one =
root element. {1}",=0A=
                  origAsyncDirective.name, templateUrl);=0A=
            }=0A=
=0A=
            tempTemplateAttrs =3D {$attr: {}};=0A=
            replaceWith($rootElement, $compileNode, compileNode);=0A=
            var templateDirectives =3D collectDirectives(compileNode, =
[], tempTemplateAttrs);=0A=
=0A=
            if (isObject(origAsyncDirective.scope)) {=0A=
              markDirectivesAsIsolate(templateDirectives);=0A=
            }=0A=
            directives =3D templateDirectives.concat(directives);=0A=
            mergeTemplateAttributes(tAttrs, tempTemplateAttrs);=0A=
          } else {=0A=
            compileNode =3D beforeTemplateCompileNode;=0A=
            $compileNode.html(content);=0A=
          }=0A=
=0A=
          directives.unshift(derivedSyncDirective);=0A=
=0A=
          afterTemplateNodeLinkFn =3D applyDirectivesToNode(directives, =
compileNode, tAttrs,=0A=
              childTranscludeFn, $compileNode, origAsyncDirective, =
preLinkFns, postLinkFns,=0A=
              previousCompileContext);=0A=
          forEach($rootElement, function(node, i) {=0A=
            if (node =3D=3D compileNode) {=0A=
              $rootElement[i] =3D $compileNode[0];=0A=
            }=0A=
          });=0A=
          afterTemplateChildLinkFn =3D =
compileNodes($compileNode[0].childNodes, childTranscludeFn);=0A=
=0A=
          while(linkQueue.length) {=0A=
            var scope =3D linkQueue.shift(),=0A=
                beforeTemplateLinkNode =3D linkQueue.shift(),=0A=
                linkRootElement =3D linkQueue.shift(),=0A=
                boundTranscludeFn =3D linkQueue.shift(),=0A=
                linkNode =3D $compileNode[0];=0A=
=0A=
            if (scope.$$destroyed) continue;=0A=
=0A=
            if (beforeTemplateLinkNode !=3D=3D =
beforeTemplateCompileNode) {=0A=
              var oldClasses =3D beforeTemplateLinkNode.className;=0A=
=0A=
              if (!(previousCompileContext.hasElementTranscludeDirective =
&amp;&amp;=0A=
                  origAsyncDirective.replace)) {=0A=
                // it was cloned therefore we have to clone as well.=0A=
                linkNode =3D jqLiteClone(compileNode);=0A=
              }=0A=
              replaceWith(linkRootElement, =
jqLite(beforeTemplateLinkNode), linkNode);=0A=
=0A=
              // Copy in CSS classes from original node=0A=
              safeAddClass(jqLite(linkNode), oldClasses);=0A=
            }=0A=
            if (afterTemplateNodeLinkFn.transcludeOnThisElement) {=0A=
              childBoundTranscludeFn =3D createBoundTranscludeFn(scope, =
afterTemplateNodeLinkFn.transclude, boundTranscludeFn);=0A=
            } else {=0A=
              childBoundTranscludeFn =3D boundTranscludeFn;=0A=
            }=0A=
            afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, =
linkNode, $rootElement,=0A=
              childBoundTranscludeFn);=0A=
          }=0A=
          linkQueue =3D null;=0A=
        });=0A=
=0A=
      return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, =
rootElement, boundTranscludeFn) {=0A=
        var childBoundTranscludeFn =3D boundTranscludeFn;=0A=
        if (scope.$$destroyed) return;=0A=
        if (linkQueue) {=0A=
          linkQueue.push(scope);=0A=
          linkQueue.push(node);=0A=
          linkQueue.push(rootElement);=0A=
          linkQueue.push(childBoundTranscludeFn);=0A=
        } else {=0A=
          if (afterTemplateNodeLinkFn.transcludeOnThisElement) {=0A=
            childBoundTranscludeFn =3D createBoundTranscludeFn(scope, =
afterTemplateNodeLinkFn.transclude, boundTranscludeFn);=0A=
          }=0A=
          afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, =
rootElement, childBoundTranscludeFn);=0A=
        }=0A=
      };=0A=
    }=0A=
=0A=
=0A=
    /**=0A=
     * Sorting function for bound directives.=0A=
     */=0A=
    function byPriority(a, b) {=0A=
      var diff =3D b.priority - a.priority;=0A=
      if (diff !=3D=3D 0) return diff;=0A=
      if (a.name !=3D=3D b.name) return (a.name &lt; b.name) ? -1 : 1;=0A=
      return a.index - b.index;=0A=
    }=0A=
=0A=
=0A=
    function assertNoDuplicate(what, previousDirective, directive, =
element) {=0A=
      if (previousDirective) {=0A=
        throw $compileMinErr('multidir', 'Multiple directives [{0}, {1}] =
asking for {2} on: {3}',=0A=
            previousDirective.name, directive.name, what, =
startingTag(element));=0A=
      }=0A=
    }=0A=
=0A=
=0A=
    function addTextInterpolateDirective(directives, text) {=0A=
      var interpolateFn =3D $interpolate(text, true);=0A=
      if (interpolateFn) {=0A=
        directives.push({=0A=
          priority: 0,=0A=
          compile: function textInterpolateCompileFn(templateNode) {=0A=
            var templateNodeParent =3D templateNode.parent(),=0A=
                hasCompileParent =3D !!templateNodeParent.length;=0A=
=0A=
            // When transcluding a template that has bindings in the root=0A=
            // we don't have a parent and thus need to add the class =
during linking fn.=0A=
            if (hasCompileParent) =
compile.$$addBindingClass(templateNodeParent);=0A=
=0A=
            return function textInterpolateLinkFn(scope, node) {=0A=
              var parent =3D node.parent();=0A=
              if (!hasCompileParent) compile.$$addBindingClass(parent);=0A=
              compile.$$addBindingInfo(parent, =
interpolateFn.expressions);=0A=
              scope.$watch(interpolateFn, function =
interpolateFnWatchAction(value) {=0A=
                node[0].nodeValue =3D value;=0A=
              });=0A=
            };=0A=
          }=0A=
        });=0A=
      }=0A=
    }=0A=
=0A=
=0A=
    function wrapTemplate(type, template) {=0A=
      type =3D lowercase(type || 'html');=0A=
      switch(type) {=0A=
      case 'svg':=0A=
      case 'math':=0A=
        var wrapper =3D document.createElement('div');=0A=
        wrapper.innerHTML =3D =
'&lt;'+type+'&gt;'+template+'&lt;/'+type+'&gt;';=0A=
        return wrapper.childNodes[0].childNodes;=0A=
      default:=0A=
        return template;=0A=
      }=0A=
    }=0A=
=0A=
=0A=
    function getTrustedContext(node, attrNormalizedName) {=0A=
      if (attrNormalizedName =3D=3D "srcdoc") {=0A=
        return $sce.HTML;=0A=
      }=0A=
      var tag =3D nodeName_(node);=0A=
      // maction[xlink:href] can source SVG.  It's not limited to =
&lt;maction&gt;.=0A=
      if (attrNormalizedName =3D=3D "xlinkHref" ||=0A=
          (tag =3D=3D "form" &amp;&amp; attrNormalizedName =3D=3D =
"action") ||=0A=
          (tag !=3D "img" &amp;&amp; (attrNormalizedName =3D=3D "src" ||=0A=
                            attrNormalizedName =3D=3D "ngSrc"))) {=0A=
        return $sce.RESOURCE_URL;=0A=
      }=0A=
    }=0A=
=0A=
=0A=
    function addAttrInterpolateDirective(node, directives, value, name, =
allOrNothing) {=0A=
      var interpolateFn =3D $interpolate(value, true);=0A=
=0A=
      // no interpolation found -&gt; ignore=0A=
      if (!interpolateFn) return;=0A=
=0A=
=0A=
      if (name =3D=3D=3D "multiple" &amp;&amp; nodeName_(node) =3D=3D=3D =
"select") {=0A=
        throw $compileMinErr("selmulti",=0A=
            "Binding to the 'multiple' attribute is not supported. =
Element: {0}",=0A=
            startingTag(node));=0A=
      }=0A=
=0A=
      directives.push({=0A=
        priority: 100,=0A=
        compile: function() {=0A=
            return {=0A=
              pre: function attrInterpolatePreLinkFn(scope, element, =
attr) {=0A=
                var $$observers =3D (attr.$$observers || =
(attr.$$observers =3D {}));=0A=
=0A=
                if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {=0A=
                  throw $compileMinErr('nodomevents',=0A=
                      "Interpolations for HTML DOM event attributes are =
disallowed.  Please use the " +=0A=
                          "ng- versions (such as ng-click instead of =
onclick) instead.");=0A=
                }=0A=
=0A=
                // If the attribute was removed, then we are done=0A=
                if (!attr[name]) {=0A=
                  return;=0A=
                }=0A=
=0A=
                // we need to interpolate again, in case the attribute =
value has been updated=0A=
                // (e.g. by another directive's compile function)=0A=
                interpolateFn =3D $interpolate(attr[name], true, =
getTrustedContext(node, name),=0A=
                    ALL_OR_NOTHING_ATTRS[name] || allOrNothing);=0A=
=0A=
                // if attribute was updated so that there is no =
interpolation going on we don't want to=0A=
                // register any observers=0A=
                if (!interpolateFn) return;=0A=
=0A=
                // initialize attr object so that it's ready in case we =
need the value for isolate=0A=
                // scope initialization, otherwise the value would not =
be available from isolate=0A=
                // directive's linking fn during linking phase=0A=
                attr[name] =3D interpolateFn(scope);=0A=
=0A=
                ($$observers[name] || ($$observers[name] =3D =
[])).$$inter =3D true;=0A=
                (attr.$$observers &amp;&amp; =
attr.$$observers[name].$$scope || scope).=0A=
                  $watch(interpolateFn, function =
interpolateFnWatchAction(newValue, oldValue) {=0A=
                    //special case for class attribute addition + removal=0A=
                    //so that class changes can tap into the animation=0A=
                    //hooks provided by the $animate service. Be sure to=0A=
                    //skip animations when the first digest occurs (when=0A=
                    //both the new and the old values are the same) since=0A=
                    //the CSS classes are the non-interpolated values=0A=
                    if(name =3D=3D=3D 'class' &amp;&amp; newValue !=3D =
oldValue) {=0A=
                      attr.$updateClass(newValue, oldValue);=0A=
                    } else {=0A=
                      attr.$set(name, newValue);=0A=
                    }=0A=
                  });=0A=
              }=0A=
            };=0A=
          }=0A=
      });=0A=
    }=0A=
=0A=
=0A=
    /**=0A=
     * This is a special jqLite.replaceWith, which can replace items =
which=0A=
     * have no parents, provided that the containing jqLite collection =
is provided.=0A=
     *=0A=
     * @param {JqLite=3D} $rootElement The root of the compile tree. =
Used so that we can replace nodes=0A=
     *                               in the root of the tree.=0A=
     * @param {JqLite} elementsToRemove The jqLite element which we are =
going to replace. We keep=0A=
     *                                  the shell, but replace its DOM =
node reference.=0A=
     * @param {Node} newNode The new DOM node.=0A=
     */=0A=
    function replaceWith($rootElement, elementsToRemove, newNode) {=0A=
      var firstElementToRemove =3D elementsToRemove[0],=0A=
          removeCount =3D elementsToRemove.length,=0A=
          parent =3D firstElementToRemove.parentNode,=0A=
          i, ii;=0A=
=0A=
      if ($rootElement) {=0A=
        for(i =3D 0, ii =3D $rootElement.length; i &lt; ii; i++) {=0A=
          if ($rootElement[i] =3D=3D firstElementToRemove) {=0A=
            $rootElement[i++] =3D newNode;=0A=
            for (var j =3D i, j2 =3D j + removeCount - 1,=0A=
                     jj =3D $rootElement.length;=0A=
                 j &lt; jj; j++, j2++) {=0A=
              if (j2 &lt; jj) {=0A=
                $rootElement[j] =3D $rootElement[j2];=0A=
              } else {=0A=
                delete $rootElement[j];=0A=
              }=0A=
            }=0A=
            $rootElement.length -=3D removeCount - 1;=0A=
=0A=
            // If the replaced element is also the jQuery .context then =
replace it=0A=
            // .context is a deprecated jQuery api, so we should set it =
only when jQuery set it=0A=
            // http://api.jquery.com/context/=0A=
            if ($rootElement.context =3D=3D=3D firstElementToRemove) {=0A=
              $rootElement.context =3D newNode;=0A=
            }=0A=
            break;=0A=
          }=0A=
        }=0A=
      }=0A=
=0A=
      if (parent) {=0A=
        parent.replaceChild(newNode, firstElementToRemove);=0A=
      }=0A=
=0A=
      // TODO(perf): what's this document fragment for? is it needed? =
can we at least reuse it?=0A=
      var fragment =3D document.createDocumentFragment();=0A=
      fragment.appendChild(firstElementToRemove);=0A=
=0A=
      // Copy over user data (that includes Angular's $scope etc.). =
Don't copy private=0A=
      // data here because there's no public interface in jQuery to do =
that and copying over=0A=
      // event listeners (which is the main use of private data) =
wouldn't work anyway.=0A=
      jqLite(newNode).data(jqLite(firstElementToRemove).data());=0A=
=0A=
      // Remove data of the replaced element. We cannot just call =
.remove()=0A=
      // on the element it since that would deallocate scope that is =
needed=0A=
      // for the new node. Instead, remove the data "manually".=0A=
      if (!jQuery) {=0A=
        delete jqLite.cache[firstElementToRemove[jqLite.expando]];=0A=
      } else {=0A=
        // jQuery 2.x doesn't expose the data storage. Use =
jQuery.cleanData to clean up after=0A=
        // the replaced element. The cleanData version monkey-patched by =
Angular would cause=0A=
        // the scope to be trashed and we do need the very same scope to =
work with the new=0A=
        // element. However, we cannot just cache the non-patched =
version and use it here as=0A=
        // that would break if another library patches the method after =
Angular does (one=0A=
        // example is jQuery UI). Instead, set a flag indicating scope =
destroying should be=0A=
        // skipped this one time.=0A=
        skipDestroyOnNextJQueryCleanData =3D true;=0A=
        jQuery.cleanData([firstElementToRemove]);=0A=
      }=0A=
=0A=
      for (var k =3D 1, kk =3D elementsToRemove.length; k &lt; kk; k++) {=0A=
        var element =3D elementsToRemove[k];=0A=
        jqLite(element).remove(); // must do this way to clean up expando=0A=
        fragment.appendChild(element);=0A=
        delete elementsToRemove[k];=0A=
      }=0A=
=0A=
      elementsToRemove[0] =3D newNode;=0A=
      elementsToRemove.length =3D 1;=0A=
    }=0A=
=0A=
=0A=
    function cloneAndAnnotateFn(fn, annotation) {=0A=
      return extend(function() { return fn.apply(null, arguments); }, =
fn, annotation);=0A=
    }=0A=
=0A=
=0A=
    function invokeLinkFn(linkFn, scope, $element, attrs, controllers, =
transcludeFn) {=0A=
      try {=0A=
        linkFn(scope, $element, attrs, controllers, transcludeFn);=0A=
      } catch(e) {=0A=
        $exceptionHandler(e, startingTag($element));=0A=
      }=0A=
    }=0A=
  }];=0A=
}=0A=
=0A=
var PREFIX_REGEXP =3D /^(x[\:\-_]|data[\:\-_])/i;=0A=
/**=0A=
 * Converts all accepted directives format into proper directive name.=0A=
 * All of these will become 'myDirective':=0A=
 *   my:Directive=0A=
 *   my-directive=0A=
 *   x-my-directive=0A=
 *   data-my:directive=0A=
 *=0A=
 * Also there is special case for Moz prefix starting with upper case =
letter.=0A=
 * @param name Name to normalize=0A=
 */=0A=
function directiveNormalize(name) {=0A=
  return camelCase(name.replace(PREFIX_REGEXP, ''));=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc type=0A=
 * @name $compile.directive.Attributes=0A=
 *=0A=
 * @description=0A=
 * A shared object between directive compile / linking functions which =
contains normalized DOM=0A=
 * element attributes. The values reflect current binding state `{{ }}`. =
The normalization is=0A=
 * needed since all of these are treated as equivalent in Angular:=0A=
 *=0A=
 * ```=0A=
 *    &lt;span ng:bind=3D"a" ng-bind=3D"a" data-ng-bind=3D"a" =
x-ng-bind=3D"a"&gt;=0A=
 * ```=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc property=0A=
 * @name $compile.directive.Attributes#$attr=0A=
 *=0A=
 * @description=0A=
 * A map of DOM element attribute names to the normalized name. This is=0A=
 * needed to do reverse lookup from normalized name back to actual name.=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $compile.directive.Attributes#$set=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Set DOM element attribute value.=0A=
 *=0A=
 *=0A=
 * @param {string} name Normalized element attribute name of the =
property to modify. The name is=0A=
 *          reverse-translated using the {@link =
ng.$compile.directive.Attributes#$attr $attr}=0A=
 *          property to the original name.=0A=
 * @param {string} value Value to set the attribute to. The value can be =
an interpolated string.=0A=
 */=0A=
=0A=
=0A=
=0A=
/**=0A=
 * Closure compiler type information=0A=
 */=0A=
=0A=
function nodesetLinkingFn(=0A=
  /* angular.Scope */ scope,=0A=
  /* NodeList */ nodeList,=0A=
  /* Element */ rootElement,=0A=
  /* function(Function) */ boundTranscludeFn=0A=
){}=0A=
=0A=
function directiveLinkingFn(=0A=
  /* nodesetLinkingFn */ nodesetLinkingFn,=0A=
  /* angular.Scope */ scope,=0A=
  /* Node */ node,=0A=
  /* Element */ rootElement,=0A=
  /* function(Function) */ boundTranscludeFn=0A=
){}=0A=
=0A=
function tokenDifference(str1, str2) {=0A=
  var values =3D '',=0A=
      tokens1 =3D str1.split(/\s+/),=0A=
      tokens2 =3D str2.split(/\s+/);=0A=
=0A=
  outer:=0A=
  for(var i =3D 0; i &lt; tokens1.length; i++) {=0A=
    var token =3D tokens1[i];=0A=
    for(var j =3D 0; j &lt; tokens2.length; j++) {=0A=
      if(token =3D=3D tokens2[j]) continue outer;=0A=
    }=0A=
    values +=3D (values.length &gt; 0 ? ' ' : '') + token;=0A=
  }=0A=
  return values;=0A=
}=0A=
=0A=
function removeComments(jqNodes) {=0A=
  jqNodes =3D jqLite(jqNodes);=0A=
  var i =3D jqNodes.length;=0A=
=0A=
  if (i &lt;=3D 1) {=0A=
    return jqNodes;=0A=
  }=0A=
=0A=
  while (i--) {=0A=
    var node =3D jqNodes[i];=0A=
    if (node.nodeType =3D=3D=3D NODE_TYPE_COMMENT) {=0A=
      splice.call(jqNodes, i, 1);=0A=
    }=0A=
  }=0A=
  return jqNodes;=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $controllerProvider=0A=
 * @description=0A=
 * The {@link ng.$controller $controller service} is used by Angular to =
create new=0A=
 * controllers.=0A=
 *=0A=
 * This provider allows controller registration via the=0A=
 * {@link ng.$controllerProvider#register register} method.=0A=
 */=0A=
function $ControllerProvider() {=0A=
  var controllers =3D {},=0A=
      globals =3D false,=0A=
      CNTRL_REG =3D /^(\S+)(\s+as\s+(\w+))?$/;=0A=
=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $controllerProvider#register=0A=
   * @param {string|Object} name Controller name, or an object map of =
controllers where the keys are=0A=
   *    the names and the values are the constructors.=0A=
   * @param {Function|Array} constructor Controller constructor fn =
(optionally decorated with DI=0A=
   *    annotations in the array notation).=0A=
   */=0A=
  this.register =3D function(name, constructor) {=0A=
    assertNotHasOwnProperty(name, 'controller');=0A=
    if (isObject(name)) {=0A=
      extend(controllers, name);=0A=
    } else {=0A=
      controllers[name] =3D constructor;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $controllerProvider#allowGlobals=0A=
   * @description If called, allows `$controller` to find controller =
constructors on `window`=0A=
   */=0A=
  this.allowGlobals =3D function() {=0A=
    globals =3D true;=0A=
  };=0A=
=0A=
=0A=
  this.$get =3D ['$injector', '$window', function($injector, $window) {=0A=
=0A=
    /**=0A=
     * @ngdoc service=0A=
     * @name $controller=0A=
     * @requires $injector=0A=
     *=0A=
     * @param {Function|string} constructor If called with a function =
then it's considered to be the=0A=
     *    controller constructor function. Otherwise it's considered to =
be a string which is used=0A=
     *    to retrieve the controller constructor using the following =
steps:=0A=
     *=0A=
     *    * check if a controller with given name is registered via =
`$controllerProvider`=0A=
     *    * check if evaluating the string on the current scope returns =
a constructor=0A=
     *    * if $controllerProvider#allowGlobals, check =
`window[constructor]` on the global=0A=
     *      `window` object (not recommended)=0A=
     *=0A=
     * @param {Object} locals Injection locals for Controller.=0A=
     * @return {Object} Instance of given controller.=0A=
     *=0A=
     * @description=0A=
     * `$controller` service is responsible for instantiating =
controllers.=0A=
     *=0A=
     * It's just a simple call to {@link auto.$injector $injector}, but =
extracted into=0A=
     * a service, so that one can override this service with [BC =
version](https://gist.github.com/1649788).=0A=
     */=0A=
    return function(expression, locals, later, ident) {=0A=
      // PRIVATE API:=0A=
      //   param `later` --- indicates that the controller's constructor =
is invoked at a later time.=0A=
      //                     If true, $controller will allocate the =
object with the correct=0A=
      //                     prototype chain, but will not invoke the =
controller until a returned=0A=
      //                     callback is invoked.=0A=
      //   param `ident` --- An optional label which overrides the label =
parsed from the controller=0A=
      //                     expression, if any.=0A=
      var instance, match, constructor, identifier;=0A=
      later =3D later =3D=3D=3D true;=0A=
      if (ident &amp;&amp; isString(ident)) {=0A=
        identifier =3D ident;=0A=
      }=0A=
=0A=
      if(isString(expression)) {=0A=
        match =3D expression.match(CNTRL_REG),=0A=
        constructor =3D match[1],=0A=
        identifier =3D identifier || match[3];=0A=
        expression =3D controllers.hasOwnProperty(constructor)=0A=
            ? controllers[constructor]=0A=
            : getter(locals.$scope, constructor, true) ||=0A=
                (globals ? getter($window, constructor, true) : =
undefined);=0A=
=0A=
        assertArgFn(expression, constructor, true);=0A=
      }=0A=
=0A=
      if (later) {=0A=
        // Instantiate controller later:=0A=
        // This machinery is used to create an instance of the object =
before calling the=0A=
        // controller's constructor itself.=0A=
        //=0A=
        // This allows properties to be added to the controller before =
the constructor is=0A=
        // invoked. Primarily, this is used for isolate scope bindings =
in $compile.=0A=
        //=0A=
        // This feature is not intended for use by applications, and is =
thus not documented=0A=
        // publicly.=0A=
        var Constructor =3D function() {};=0A=
        Constructor.prototype =3D (isArray(expression) ?=0A=
          expression[expression.length - 1] : expression).prototype;=0A=
        instance =3D new Constructor();=0A=
=0A=
        if (identifier) {=0A=
          addIdentifier(locals, identifier, instance, constructor || =
expression.name);=0A=
        }=0A=
=0A=
        return extend(function() {=0A=
          $injector.invoke(expression, instance, locals, constructor);=0A=
          return instance;=0A=
        }, {=0A=
          instance: instance,=0A=
          identifier: identifier=0A=
        });=0A=
      }=0A=
=0A=
      instance =3D $injector.instantiate(expression, locals, =
constructor);=0A=
=0A=
      if (identifier) {=0A=
        addIdentifier(locals, identifier, instance, constructor || =
expression.name);=0A=
      }=0A=
=0A=
      return instance;=0A=
    };=0A=
=0A=
    function addIdentifier(locals, identifier, instance, name) {=0A=
      if (!(locals &amp;&amp; isObject(locals.$scope))) {=0A=
        throw minErr('$controller')('noscp',=0A=
          "Cannot export controller '{0}' as '{1}'! No $scope object =
provided via `locals`.",=0A=
          name, identifier);=0A=
      }=0A=
=0A=
      locals.$scope[identifier] =3D instance;=0A=
    }=0A=
  }];=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $document=0A=
 * @requires $window=0A=
 *=0A=
 * @description=0A=
 * A {@link angular.element jQuery or jqLite} wrapper for the browser's =
`window.document` object.=0A=
 *=0A=
 * @example=0A=
   &lt;example module=3D"documentExample"&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
         &lt;p&gt;$document title: &lt;b =
ng-bind=3D"title"&gt;&lt;/b&gt;&lt;/p&gt;=0A=
         &lt;p&gt;window.document title: &lt;b =
ng-bind=3D"windowTitle"&gt;&lt;/b&gt;&lt;/p&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"script.js"&gt;=0A=
       angular.module('documentExample', [])=0A=
         .controller('ExampleController', ['$scope', '$document', =
function($scope, $document) {=0A=
           $scope.title =3D $document[0].title;=0A=
           $scope.windowTitle =3D =
angular.element(window.document)[0].title;=0A=
         }]);=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
function $DocumentProvider(){=0A=
  this.$get =3D ['$window', function(window){=0A=
    return jqLite(window.document);=0A=
  }];=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $exceptionHandler=0A=
 * @requires ng.$log=0A=
 *=0A=
 * @description=0A=
 * Any uncaught exception in angular expressions is delegated to this =
service.=0A=
 * The default implementation simply delegates to `$log.error` which =
logs it into=0A=
 * the browser console.=0A=
 *=0A=
 * In unit tests, if `angular-mocks.js` is loaded, this service is =
overridden by=0A=
 * {@link ngMock.$exceptionHandler mock $exceptionHandler} which aids in =
testing.=0A=
 *=0A=
 * ## Example:=0A=
 *=0A=
 * ```js=0A=
 *   angular.module('exceptionOverride', =
[]).factory('$exceptionHandler', function () {=0A=
 *     return function (exception, cause) {=0A=
 *       exception.message +=3D ' (caused by "' + cause + '")';=0A=
 *       throw exception;=0A=
 *     };=0A=
 *   });=0A=
 * ```=0A=
 *=0A=
 * This example will override the normal action of `$exceptionHandler`, =
to make angular=0A=
 * exceptions fail hard when they happen, instead of just logging to the =
console.=0A=
 *=0A=
 * &lt;hr /&gt;=0A=
 * Note, that code executed in event-listeners (even those registered =
using jqLite's `on`/`bind`=0A=
 * methods) does not delegate exceptions to the {@link =
ng.$exceptionHandler $exceptionHandler}=0A=
 * (unless executed during a digest).=0A=
 *=0A=
 * If you wish, you can manually delegate exceptions, e.g.=0A=
 * `try { ... } catch(e) { $exceptionHandler(e); }`=0A=
 *=0A=
 * @param {Error} exception Exception associated with the error.=0A=
 * @param {string=3D} cause optional information about the context in =
which=0A=
 *       the error was thrown.=0A=
 *=0A=
 */=0A=
function $ExceptionHandlerProvider() {=0A=
  this.$get =3D ['$log', function($log) {=0A=
    return function(exception, cause) {=0A=
      $log.error.apply($log, arguments);=0A=
    };=0A=
  }];=0A=
}=0A=
=0A=
/**=0A=
 * Parse headers into key value object=0A=
 *=0A=
 * @param {string} headers Raw headers as a string=0A=
 * @returns {Object} Parsed headers as key value object=0A=
 */=0A=
function parseHeaders(headers) {=0A=
  var parsed =3D {}, key, val, i;=0A=
=0A=
  if (!headers) return parsed;=0A=
=0A=
  forEach(headers.split('\n'), function(line) {=0A=
    i =3D line.indexOf(':');=0A=
    key =3D lowercase(trim(line.substr(0, i)));=0A=
    val =3D trim(line.substr(i + 1));=0A=
=0A=
    if (key) {=0A=
      parsed[key] =3D parsed[key] ? parsed[key] + ', ' + val : val;=0A=
    }=0A=
  });=0A=
=0A=
  return parsed;=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * Returns a function that provides access to parsed headers.=0A=
 *=0A=
 * Headers are lazy parsed when first requested.=0A=
 * @see parseHeaders=0A=
 *=0A=
 * @param {(string|Object)} headers Headers to provide access to.=0A=
 * @returns {function(string=3D)} Returns a getter function which if =
called with:=0A=
 *=0A=
 *   - if called with single an argument returns a single header value =
or null=0A=
 *   - if called with no arguments returns an object containing all =
headers.=0A=
 */=0A=
function headersGetter(headers) {=0A=
  var headersObj =3D isObject(headers) ? headers : undefined;=0A=
=0A=
  return function(name) {=0A=
    if (!headersObj) headersObj =3D  parseHeaders(headers);=0A=
=0A=
    if (name) {=0A=
      return headersObj[lowercase(name)] || null;=0A=
    }=0A=
=0A=
    return headersObj;=0A=
  };=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * Chain all given functions=0A=
 *=0A=
 * This function is used for both request and response transforming=0A=
 *=0A=
 * @param {*} data Data to transform.=0A=
 * @param {function(string=3D)} headers Http headers getter fn.=0A=
 * @param {(Function|Array.&lt;Function&gt;)} fns Function or an array =
of functions.=0A=
 * @returns {*} Transformed data.=0A=
 */=0A=
function transformData(data, headers, fns) {=0A=
  if (isFunction(fns))=0A=
    return fns(data, headers);=0A=
=0A=
  forEach(fns, function(fn) {=0A=
    data =3D fn(data, headers);=0A=
  });=0A=
=0A=
  return data;=0A=
}=0A=
=0A=
=0A=
function isSuccess(status) {=0A=
  return 200 &lt;=3D status &amp;&amp; status &lt; 300;=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $httpProvider=0A=
 * @description=0A=
 * Use `$httpProvider` to change the default behavior of the {@link =
ng.$http $http} service.=0A=
 * */=0A=
function $HttpProvider() {=0A=
  var JSON_START =3D /^\s*(\[|\{[^\{])/,=0A=
      JSON_END =3D /[\}\]]\s*$/,=0A=
      PROTECTION_PREFIX =3D /^\)\]\}',?\n/,=0A=
      APPLICATION_JSON =3D 'application/json',=0A=
      CONTENT_TYPE_APPLICATION_JSON =3D {'Content-Type': =
APPLICATION_JSON + ';charset=3Dutf-8'};=0A=
=0A=
  /**=0A=
   * @ngdoc property=0A=
   * @name $httpProvider#defaults=0A=
   * @description=0A=
   *=0A=
   * Object containing default values for all {@link ng.$http $http} =
requests.=0A=
   *=0A=
   * - **`defaults.xsrfCookieName`** - {string} - Name of cookie =
containing the XSRF token.=0A=
   * Defaults value is `'XSRF-TOKEN'`.=0A=
   *=0A=
   * - **`defaults.xsrfHeaderName`** - {string} - Name of HTTP header to =
populate with the=0A=
   * XSRF token. Defaults value is `'X-XSRF-TOKEN'`.=0A=
   *=0A=
   * - **`defaults.headers`** - {Object} - Default headers for all $http =
requests.=0A=
   * Refer to {@link ng.$http#setting-http-headers $http} for =
documentation on=0A=
   * setting default headers.=0A=
   *     - **`defaults.headers.common`**=0A=
   *     - **`defaults.headers.post`**=0A=
   *     - **`defaults.headers.put`**=0A=
   *     - **`defaults.headers.patch`**=0A=
   **/=0A=
  var defaults =3D this.defaults =3D {=0A=
    // transform incoming response data=0A=
    transformResponse: [function defaultHttpResponseTransform(data, =
headers) {=0A=
      if (isString(data)) {=0A=
        // strip json vulnerability protection prefix=0A=
        data =3D data.replace(PROTECTION_PREFIX, '');=0A=
        var contentType =3D headers('Content-Type');=0A=
        if ((contentType &amp;&amp; =
contentType.indexOf(APPLICATION_JSON) =3D=3D=3D 0) ||=0A=
            (JSON_START.test(data) &amp;&amp; JSON_END.test(data))) {=0A=
          data =3D fromJson(data);=0A=
        }=0A=
      }=0A=
      return data;=0A=
    }],=0A=
=0A=
    // transform outgoing request data=0A=
    transformRequest: [function(d) {=0A=
      return isObject(d) &amp;&amp; !isFile(d) &amp;&amp; !isBlob(d) ? =
toJson(d) : d;=0A=
    }],=0A=
=0A=
    // default headers=0A=
    headers: {=0A=
      common: {=0A=
        'Accept': 'application/json, text/plain, */*'=0A=
      },=0A=
      post:   shallowCopy(CONTENT_TYPE_APPLICATION_JSON),=0A=
      put:    shallowCopy(CONTENT_TYPE_APPLICATION_JSON),=0A=
      patch:  shallowCopy(CONTENT_TYPE_APPLICATION_JSON)=0A=
    },=0A=
=0A=
    xsrfCookieName: 'XSRF-TOKEN',=0A=
    xsrfHeaderName: 'X-XSRF-TOKEN'=0A=
  };=0A=
=0A=
  var useApplyAsync =3D false;=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $httpProvider#useApplyAsync=0A=
   * @description=0A=
   *=0A=
   * Configure $http service to combine processing of multiple http =
responses received at around=0A=
   * the same time via {@link ng.$rootScope.Scope#$applyAsync =
$rootScope.$applyAsync}. This can result in=0A=
   * significant performance improvement for bigger applications that =
make many HTTP requests=0A=
   * concurrently (common during application bootstrap).=0A=
   *=0A=
   * Defaults to false. If no value is specifed, returns the current =
configured value.=0A=
   *=0A=
   * @param {boolean=3D} value If true, when requests are loaded, they =
will schedule a deferred=0A=
   *    "apply" on the next tick, giving time for subsequent requests in =
a roughly ~10ms window=0A=
   *    to load and share the same digest cycle.=0A=
   *=0A=
   * @returns {boolean|Object} If a value is specified, returns the =
$httpProvider for chaining.=0A=
   *    otherwise, returns the current configured value.=0A=
   **/=0A=
  this.useApplyAsync =3D function(value) {=0A=
    if (isDefined(value)) {=0A=
      useApplyAsync =3D !!value;=0A=
      return this;=0A=
    }=0A=
    return useApplyAsync;=0A=
  };=0A=
=0A=
  /**=0A=
   * Are ordered by request, i.e. they are applied in the same order as =
the=0A=
   * array, on request, but reverse order, on response.=0A=
   */=0A=
  var interceptorFactories =3D this.interceptors =3D [];=0A=
=0A=
  this.$get =3D ['$httpBackend', '$browser', '$cacheFactory', =
'$rootScope', '$q', '$injector',=0A=
      function($httpBackend, $browser, $cacheFactory, $rootScope, $q, =
$injector) {=0A=
=0A=
    var defaultCache =3D $cacheFactory('$http');=0A=
=0A=
    /**=0A=
     * Interceptors stored in reverse order. Inner interceptors before =
outer interceptors.=0A=
     * The reversal is needed so that we can build up the interception =
chain around the=0A=
     * server request.=0A=
     */=0A=
    var reversedInterceptors =3D [];=0A=
=0A=
    forEach(interceptorFactories, function(interceptorFactory) {=0A=
      reversedInterceptors.unshift(isString(interceptorFactory)=0A=
          ? $injector.get(interceptorFactory) : =
$injector.invoke(interceptorFactory));=0A=
    });=0A=
=0A=
    /**=0A=
     * @ngdoc service=0A=
     * @kind function=0A=
     * @name $http=0A=
     * @requires ng.$httpBackend=0A=
     * @requires $cacheFactory=0A=
     * @requires $rootScope=0A=
     * @requires $q=0A=
     * @requires $injector=0A=
     *=0A=
     * @description=0A=
     * The `$http` service is a core Angular service that facilitates =
communication with the remote=0A=
     * HTTP servers via the browser's =
[XMLHttpRequest](https://developer.mozilla.org/en/xmlhttprequest)=0A=
     * object or via [JSONP](http://en.wikipedia.org/wiki/JSONP).=0A=
     *=0A=
     * For unit testing applications that use `$http` service, see=0A=
     * {@link ngMock.$httpBackend $httpBackend mock}.=0A=
     *=0A=
     * For a higher level of abstraction, please check out the {@link =
ngResource.$resource=0A=
     * $resource} service.=0A=
     *=0A=
     * The $http API is based on the {@link ng.$q deferred/promise APIs} =
exposed by=0A=
     * the $q service. While for simple usage patterns this doesn't =
matter much, for advanced usage=0A=
     * it is important to familiarize yourself with these APIs and the =
guarantees they provide.=0A=
     *=0A=
     *=0A=
     * ## General usage=0A=
     * The `$http` service is a function which takes a single argument =
=E2=80&#65533; a configuration object =E2=80&#65533;=0A=
     * that is used to generate an HTTP request and returns  a {@link =
ng.$q promise}=0A=
     * with two $http specific methods: `success` and `error`.=0A=
     *=0A=
     * ```js=0A=
     *   // Simple GET request example :=0A=
     *   $http.get('/someUrl').=0A=
     *     success(function(data, status, headers, config) {=0A=
     *       // this callback will be called asynchronously=0A=
     *       // when the response is available=0A=
     *     }).=0A=
     *     error(function(data, status, headers, config) {=0A=
     *       // called asynchronously if an error occurs=0A=
     *       // or server returns response with an error status.=0A=
     *     });=0A=
     * ```=0A=
     *=0A=
     * ```js=0A=
     *   // Simple POST request example (passing data) :=0A=
     *   $http.post('/someUrl', {msg:'hello word!'}).=0A=
     *     success(function(data, status, headers, config) {=0A=
     *       // this callback will be called asynchronously=0A=
     *       // when the response is available=0A=
     *     }).=0A=
     *     error(function(data, status, headers, config) {=0A=
     *       // called asynchronously if an error occurs=0A=
     *       // or server returns response with an error status.=0A=
     *     });=0A=
     * ```=0A=
     *=0A=
     *=0A=
     * Since the returned value of calling the $http function is a =
`promise`, you can also use=0A=
     * the `then` method to register callbacks, and these callbacks will =
receive a single argument =E2=80&#65533;=0A=
     * an object representing the response. See the API signature and =
type info below for more=0A=
     * details.=0A=
     *=0A=
     * A response status code between 200 and 299 is considered a =
success status and=0A=
     * will result in the success callback being called. Note that if =
the response is a redirect,=0A=
     * XMLHttpRequest will transparently follow it, meaning that the =
error callback will not be=0A=
     * called for such responses.=0A=
     *=0A=
     * ## Writing Unit Tests that use $http=0A=
     * When unit testing (using {@link ngMock ngMock}), it is necessary =
to call=0A=
     * {@link ngMock.$httpBackend#flush $httpBackend.flush()} to flush =
each pending=0A=
     * request using trained responses.=0A=
     *=0A=
     * ```=0A=
     * $httpBackend.expectGET(...);=0A=
     * $http.get(...);=0A=
     * $httpBackend.flush();=0A=
     * ```=0A=
     *=0A=
     * ## Shortcut methods=0A=
     *=0A=
     * Shortcut methods are also available. All shortcut methods require =
passing in the URL, and=0A=
     * request data must be passed in for POST/PUT requests.=0A=
     *=0A=
     * ```js=0A=
     *   $http.get('/someUrl').success(successCallback);=0A=
     *   $http.post('/someUrl', data).success(successCallback);=0A=
     * ```=0A=
     *=0A=
     * Complete list of shortcut methods:=0A=
     *=0A=
     * - {@link ng.$http#get $http.get}=0A=
     * - {@link ng.$http#head $http.head}=0A=
     * - {@link ng.$http#post $http.post}=0A=
     * - {@link ng.$http#put $http.put}=0A=
     * - {@link ng.$http#delete $http.delete}=0A=
     * - {@link ng.$http#jsonp $http.jsonp}=0A=
     * - {@link ng.$http#patch $http.patch}=0A=
     *=0A=
     *=0A=
     * ## Setting HTTP Headers=0A=
     *=0A=
     * The $http service will automatically add certain HTTP headers to =
all requests. These defaults=0A=
     * can be fully configured by accessing the =
`$httpProvider.defaults.headers` configuration=0A=
     * object, which currently contains this default configuration:=0A=
     *=0A=
     * - `$httpProvider.defaults.headers.common` (headers that are =
common for all requests):=0A=
     *   - `Accept: application/json, text/plain, * / *`=0A=
     * - `$httpProvider.defaults.headers.post`: (header defaults for =
POST requests)=0A=
     *   - `Content-Type: application/json`=0A=
     * - `$httpProvider.defaults.headers.put` (header defaults for PUT =
requests)=0A=
     *   - `Content-Type: application/json`=0A=
     *=0A=
     * To add or overwrite these defaults, simply add or remove a =
property from these configuration=0A=
     * objects. To add headers for an HTTP method other than POST or =
PUT, simply add a new object=0A=
     * with the lowercased HTTP method name as the key, e.g.=0A=
     * `$httpProvider.defaults.headers.get =3D { 'My-Header' : 'value' }.=0A=
     *=0A=
     * The defaults can also be set at runtime via the `$http.defaults` =
object in the same=0A=
     * fashion. For example:=0A=
     *=0A=
     * ```=0A=
     * module.run(function($http) {=0A=
     *   $http.defaults.headers.common.Authorization =3D 'Basic =
YmVlcDpib29w'=0A=
     * });=0A=
     * ```=0A=
     *=0A=
     * In addition, you can supply a `headers` property in the config =
object passed when=0A=
     * calling `$http(config)`, which overrides the defaults without =
changing them globally.=0A=
     *=0A=
     *=0A=
     * ## Transforming Requests and Responses=0A=
     *=0A=
     * Both requests and responses can be transformed using =
transformation functions: `transformRequest`=0A=
     * and `transformResponse`. These properties can be a single =
function that returns=0A=
     * the transformed value (`{function(data, headersGetter)`) or an =
array of such transformation functions,=0A=
     * which allows you to `push` or `unshift` a new transformation =
function into the transformation chain.=0A=
     *=0A=
     * ### Default Transformations=0A=
     *=0A=
     * The `$httpProvider` provider and `$http` service expose =
`defaults.transformRequest` and=0A=
     * `defaults.transformResponse` properties. If a request does not =
provide its own transformations=0A=
     * then these will be applied.=0A=
     *=0A=
     * You can augment or replace the default transformations by =
modifying these properties by adding to or=0A=
     * replacing the array.=0A=
     *=0A=
     * Angular provides the following default transformations:=0A=
     *=0A=
     * Request transformations =
(`$httpProvider.defaults.transformRequest` and =
`$http.defaults.transformRequest`):=0A=
     *=0A=
     * - If the `data` property of the request configuration object =
contains an object, serialize it=0A=
     *   into JSON format.=0A=
     *=0A=
     * Response transformations =
(`$httpProvider.defaults.transformResponse` and =
`$http.defaults.transformResponse`):=0A=
     *=0A=
     *  - If XSRF prefix is detected, strip it (see Security =
Considerations section below).=0A=
     *  - If JSON response is detected, deserialize it using a JSON =
parser.=0A=
     *=0A=
     *=0A=
     * ### Overriding the Default Transformations Per Request=0A=
     *=0A=
     * If you wish override the request/response transformations only =
for a single request then provide=0A=
     * `transformRequest` and/or `transformResponse` properties on the =
configuration object passed=0A=
     * into `$http`.=0A=
     *=0A=
     * Note that if you provide these properties on the config object =
the default transformations will be=0A=
     * overwritten. If you wish to augment the default transformations =
then you must include them in your=0A=
     * local transformation array.=0A=
     *=0A=
     * The following code demonstrates adding a new response =
transformation to be run after the default response=0A=
     * transformations have been run.=0A=
     *=0A=
     * ```js=0A=
     * function appendTransform(defaults, transform) {=0A=
     *=0A=
     *   // We can't guarantee that the default transformation is an =
array=0A=
     *   defaults =3D angular.isArray(defaults) ? defaults : [defaults];=0A=
     *=0A=
     *   // Append the new transformation to the defaults=0A=
     *   return defaults.concat(transform);=0A=
     * }=0A=
     *=0A=
     * $http({=0A=
     *   url: '...',=0A=
     *   method: 'GET',=0A=
     *   transformResponse: =
appendTransform($http.defaults.transformResponse, function(value) {=0A=
     *     return doTransform(value);=0A=
     *   })=0A=
     * });=0A=
     * ```=0A=
     *=0A=
     *=0A=
     * ## Caching=0A=
     *=0A=
     * To enable caching, set the request configuration `cache` property =
to `true` (to use default=0A=
     * cache) or to a custom cache object (built with {@link =
ng.$cacheFactory `$cacheFactory`}).=0A=
     * When the cache is enabled, `$http` stores the response from the =
server in the specified=0A=
     * cache. The next time the same request is made, the response is =
served from the cache without=0A=
     * sending a request to the server.=0A=
     *=0A=
     * Note that even if the response is served from cache, delivery of =
the data is asynchronous in=0A=
     * the same way that real requests are.=0A=
     *=0A=
     * If there are multiple GET requests for the same URL that should =
be cached using the same=0A=
     * cache, but the cache is not populated yet, only one request to =
the server will be made and=0A=
     * the remaining requests will be fulfilled using the response from =
the first request.=0A=
     *=0A=
     * You can change the default cache to a new object (built with=0A=
     * {@link ng.$cacheFactory `$cacheFactory`}) by updating the=0A=
     * {@link ng.$http#defaults `$http.defaults.cache`} property. All =
requests who set=0A=
     * their `cache` property to `true` will now use this cache object.=0A=
     *=0A=
     * If you set the default cache to `false` then only requests that =
specify their own custom=0A=
     * cache object will be cached.=0A=
     *=0A=
     * ## Interceptors=0A=
     *=0A=
     * Before you start creating interceptors, be sure to understand the=0A=
     * {@link ng.$q $q and deferred/promise APIs}.=0A=
     *=0A=
     * For purposes of global error handling, authentication, or any =
kind of synchronous or=0A=
     * asynchronous pre-processing of request or postprocessing of =
responses, it is desirable to be=0A=
     * able to intercept requests before they are handed to the server =
and=0A=
     * responses before they are handed over to the application code that=0A=
     * initiated these requests. The interceptors leverage the {@link =
ng.$q=0A=
     * promise APIs} to fulfill this need for both synchronous and =
asynchronous pre-processing.=0A=
     *=0A=
     * The interceptors are service factories that are registered with =
the `$httpProvider` by=0A=
     * adding them to the `$httpProvider.interceptors` array. The =
factory is called and=0A=
     * injected with dependencies (if specified) and returns the =
interceptor.=0A=
     *=0A=
     * There are two kinds of interceptors (and two kinds of rejection =
interceptors):=0A=
     *=0A=
     *   * `request`: interceptors get called with a http `config` =
object. The function is free to=0A=
     *     modify the `config` object or create a new one. The function =
needs to return the `config`=0A=
     *     object directly, or a promise containing the `config` or a =
new `config` object.=0A=
     *   * `requestError`: interceptor gets called when a previous =
interceptor threw an error or=0A=
     *     resolved with a rejection.=0A=
     *   * `response`: interceptors get called with http `response` =
object. The function is free to=0A=
     *     modify the `response` object or create a new one. The =
function needs to return the `response`=0A=
     *     object directly, or as a promise containing the `response` or =
a new `response` object.=0A=
     *   * `responseError`: interceptor gets called when a previous =
interceptor threw an error or=0A=
     *     resolved with a rejection.=0A=
     *=0A=
     *=0A=
     * ```js=0A=
     *   // register the interceptor as a service=0A=
     *   $provide.factory('myHttpInterceptor', function($q, dependency1, =
dependency2) {=0A=
     *     return {=0A=
     *       // optional method=0A=
     *       'request': function(config) {=0A=
     *         // do something on success=0A=
     *         return config;=0A=
     *       },=0A=
     *=0A=
     *       // optional method=0A=
     *      'requestError': function(rejection) {=0A=
     *         // do something on error=0A=
     *         if (canRecover(rejection)) {=0A=
     *           return responseOrNewPromise=0A=
     *         }=0A=
     *         return $q.reject(rejection);=0A=
     *       },=0A=
     *=0A=
     *=0A=
     *=0A=
     *       // optional method=0A=
     *       'response': function(response) {=0A=
     *         // do something on success=0A=
     *         return response;=0A=
     *       },=0A=
     *=0A=
     *       // optional method=0A=
     *      'responseError': function(rejection) {=0A=
     *         // do something on error=0A=
     *         if (canRecover(rejection)) {=0A=
     *           return responseOrNewPromise=0A=
     *         }=0A=
     *         return $q.reject(rejection);=0A=
     *       }=0A=
     *     };=0A=
     *   });=0A=
     *=0A=
     *   $httpProvider.interceptors.push('myHttpInterceptor');=0A=
     *=0A=
     *=0A=
     *   // alternatively, register the interceptor via an anonymous =
factory=0A=
     *   $httpProvider.interceptors.push(function($q, dependency1, =
dependency2) {=0A=
     *     return {=0A=
     *      'request': function(config) {=0A=
     *          // same as above=0A=
     *       },=0A=
     *=0A=
     *       'response': function(response) {=0A=
     *          // same as above=0A=
     *       }=0A=
     *     };=0A=
     *   });=0A=
     * ```=0A=
     *=0A=
     * ## Security Considerations=0A=
     *=0A=
     * When designing web applications, consider security threats from:=0A=
     *=0A=
     * - [JSON =
vulnerability](http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-=
json-vulnerability.aspx)=0A=
     * - [XSRF](http://en.wikipedia.org/wiki/Cross-site_request_forgery)=0A=
     *=0A=
     * Both server and the client must cooperate in order to eliminate =
these threats. Angular comes=0A=
     * pre-configured with strategies that address these issues, but for =
this to work backend server=0A=
     * cooperation is required.=0A=
     *=0A=
     * ### JSON Vulnerability Protection=0A=
     *=0A=
     * A [JSON =
vulnerability](http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-=
json-vulnerability.aspx)=0A=
     * allows third party website to turn your JSON resource URL into=0A=
     * [JSONP](http://en.wikipedia.org/wiki/JSONP) request under some =
conditions. To=0A=
     * counter this your server can prefix all JSON requests with =
following string `")]}',\n"`.=0A=
     * Angular will automatically strip the prefix before processing it =
as JSON.=0A=
     *=0A=
     * For example if your server needs to return:=0A=
     * ```js=0A=
     * ['one','two']=0A=
     * ```=0A=
     *=0A=
     * which is vulnerable to attack, your server can return:=0A=
     * ```js=0A=
     * )]}',=0A=
     * ['one','two']=0A=
     * ```=0A=
     *=0A=
     * Angular will strip the prefix, before processing the JSON.=0A=
     *=0A=
     *=0A=
     * ### Cross Site Request Forgery (XSRF) Protection=0A=
     *=0A=
     * [XSRF](http://en.wikipedia.org/wiki/Cross-site_request_forgery) =
is a technique by which=0A=
     * an unauthorized site can gain your user's private data. Angular =
provides a mechanism=0A=
     * to counter XSRF. When performing XHR requests, the $http service =
reads a token from a cookie=0A=
     * (by default, `XSRF-TOKEN`) and sets it as an HTTP header =
(`X-XSRF-TOKEN`). Since only=0A=
     * JavaScript that runs on your domain could read the cookie, your =
server can be assured that=0A=
     * the XHR came from JavaScript running on your domain. The header =
will not be set for=0A=
     * cross-domain requests.=0A=
     *=0A=
     * To take advantage of this, your server needs to set a token in a =
JavaScript readable session=0A=
     * cookie called `XSRF-TOKEN` on the first HTTP GET request. On =
subsequent XHR requests the=0A=
     * server can verify that the cookie matches `X-XSRF-TOKEN` HTTP =
header, and therefore be sure=0A=
     * that only JavaScript running on your domain could have sent the =
request. The token must be=0A=
     * unique for each user and must be verifiable by the server (to =
prevent the JavaScript from=0A=
     * making up its own tokens). We recommend that the token is a =
digest of your site's=0A=
     * authentication cookie with a =
[salt](https://en.wikipedia.org/wiki/Salt_(cryptography&amp;#41;)=0A=
     * for added security.=0A=
     *=0A=
     * The name of the headers can be specified using the xsrfHeaderName =
and xsrfCookieName=0A=
     * properties of either $httpProvider.defaults at config-time, =
$http.defaults at run-time,=0A=
     * or the per-request config object.=0A=
     *=0A=
     *=0A=
     * @param {object} config Object describing the request to be made =
and how it should be=0A=
     *    processed. The object has following properties:=0A=
     *=0A=
     *    - **method** =E2=80&#65533; `{string}` =E2=80&#65533; HTTP =
method (e.g. 'GET', 'POST', etc)=0A=
     *    - **url** =E2=80&#65533; `{string}` =E2=80&#65533; Absolute or =
relative URL of the resource that is being requested.=0A=
     *    - **params** =E2=80&#65533; `{Object.&lt;string|Object&gt;}` =
=E2=80&#65533; Map of strings or objects which will be turned=0A=
     *      to `?key1=3Dvalue1&amp;key2=3Dvalue2` after the url. If the =
value is not a string, it will be=0A=
     *      JSONified.=0A=
     *    - **data** =E2=80&#65533; `{string|Object}` =E2=80&#65533; =
Data to be sent as the request message data.=0A=
     *    - **headers** =E2=80&#65533; `{Object}` =E2=80&#65533; Map of =
strings or functions which return strings representing=0A=
     *      HTTP headers to send to the server. If the return value of a =
function is null, the=0A=
     *      header will not be sent.=0A=
     *    - **xsrfHeaderName** =E2=80&#65533; `{string}` =E2=80&#65533; =
Name of HTTP header to populate with the XSRF token.=0A=
     *    - **xsrfCookieName** =E2=80&#65533; `{string}` =E2=80&#65533; =
Name of cookie containing the XSRF token.=0A=
     *    - **transformRequest** =E2=80&#65533;=0A=
     *      `{function(data, headersGetter)|Array.&lt;function(data, =
headersGetter)&gt;}` =E2=80&#65533;=0A=
     *      transform function or an array of such functions. The =
transform function takes the http=0A=
     *      request body and headers and returns its transformed =
(typically serialized) version.=0A=
     *      See {@link =
#overriding-the-default-transformations-per-request Overriding the =
Default Transformations}=0A=
     *    - **transformResponse** =E2=80&#65533;=0A=
     *      `{function(data, headersGetter)|Array.&lt;function(data, =
headersGetter)&gt;}` =E2=80&#65533;=0A=
     *      transform function or an array of such functions. The =
transform function takes the http=0A=
     *      response body and headers and returns its transformed =
(typically deserialized) version.=0A=
     *      See {@link =
#overriding-the-default-transformations-per-request Overriding the =
Default Transformations}=0A=
     *    - **cache** =E2=80&#65533; `{boolean|Cache}` =E2=80&#65533; If =
true, a default $http cache will be used to cache the=0A=
     *      GET request, otherwise if a cache instance built with=0A=
     *      {@link ng.$cacheFactory $cacheFactory}, this cache will be =
used for=0A=
     *      caching.=0A=
     *    - **timeout** =E2=80&#65533; `{number|Promise}` =E2=80&#65533; =
timeout in milliseconds, or {@link ng.$q promise}=0A=
     *      that should abort the request when resolved.=0A=
     *    - **withCredentials** - `{boolean}` - whether to set the =
`withCredentials` flag on the=0A=
     *      XHR object. See [requests with =
credentials](https://developer.mozilla.org/docs/Web/HTTP/Access_control_C=
ORS#Requests_with_credentials)=0A=
     *      for more information.=0A=
     *    - **responseType** - `{string}` - see=0A=
     *      =
[requestType](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest=
#responseType).=0A=
     *=0A=
     * @returns {HttpPromise} Returns a {@link ng.$q promise} object =
with the=0A=
     *   standard `then` method and two http specific methods: `success` =
and `error`. The `then`=0A=
     *   method takes two arguments a success and an error callback =
which will be called with a=0A=
     *   response object. The `success` and `error` methods take a =
single argument - a function that=0A=
     *   will be called when the request succeeds or fails respectively. =
The arguments passed into=0A=
     *   these functions are destructured representation of the response =
object passed into the=0A=
     *   `then` method. The response object has these properties:=0A=
     *=0A=
     *   - **data** =E2=80&#65533; `{string|Object}` =E2=80&#65533; The =
response body transformed with the transform=0A=
     *     functions.=0A=
     *   - **status** =E2=80&#65533; `{number}` =E2=80&#65533; HTTP =
status code of the response.=0A=
     *   - **headers** =E2=80&#65533; `{function([headerName])}` =
=E2=80&#65533; Header getter function.=0A=
     *   - **config** =E2=80&#65533; `{Object}` =E2=80&#65533; The =
configuration object that was used to generate the request.=0A=
     *   - **statusText** =E2=80&#65533; `{string}` =E2=80&#65533; HTTP =
status text of the response.=0A=
     *=0A=
     * @property {Array.&lt;Object&gt;} pendingRequests Array of config =
objects for currently pending=0A=
     *   requests. This is primarily meant to be used for debugging =
purposes.=0A=
     *=0A=
     *=0A=
     * @example=0A=
&lt;example module=3D"httpExample"&gt;=0A=
&lt;file name=3D"todoList.html"&gt;=0A=
  &lt;div ng-controller=3D"FetchController"&gt;=0A=
    &lt;select ng-model=3D"method"&gt;=0A=
      &lt;option&gt;GET&lt;/option&gt;=0A=
      &lt;option&gt;JSONP&lt;/option&gt;=0A=
    &lt;/select&gt;=0A=
    &lt;input type=3D"text" ng-model=3D"url" size=3D"80"/&gt;=0A=
    &lt;button id=3D"fetchbtn" =
ng-click=3D"fetch()"&gt;fetch&lt;/button&gt;&lt;br&gt;=0A=
    &lt;button id=3D"samplegetbtn" ng-click=3D"updateModel('GET', =
'http-hello.html')"&gt;Sample GET&lt;/button&gt;=0A=
    &lt;button id=3D"samplejsonpbtn"=0A=
      ng-click=3D"updateModel('JSONP',=0A=
                    =
'https://angularjs.org/greet.php?callback=3DJSON_CALLBACK&amp;name=3DSupe=
r%20Hero')"&gt;=0A=
      Sample JSONP=0A=
    &lt;/button&gt;=0A=
    &lt;button id=3D"invalidjsonpbtn"=0A=
      ng-click=3D"updateModel('JSONP', =
'https://angularjs.org/doesntexist&amp;callback=3DJSON_CALLBACK')"&gt;=0A=
        Invalid JSONP=0A=
      &lt;/button&gt;=0A=
    &lt;pre&gt;http status code: {{status}}&lt;/pre&gt;=0A=
    &lt;pre&gt;http response data: {{data}}&lt;/pre&gt;=0A=
  &lt;/div&gt;=0A=
&lt;/file&gt;=0A=
&lt;file name=3D"script.js"&gt;=0A=
  angular.module('httpExample', [])=0A=
    .controller('FetchController', ['$scope', '$http', '$templateCache',=0A=
      function($scope, $http, $templateCache) {=0A=
        $scope.method =3D 'GET';=0A=
        $scope.url =3D 'http-hello.html';=0A=
=0A=
        $scope.fetch =3D function() {=0A=
          $scope.code =3D null;=0A=
          $scope.response =3D null;=0A=
=0A=
          $http({method: $scope.method, url: $scope.url, cache: =
$templateCache}).=0A=
            success(function(data, status) {=0A=
              $scope.status =3D status;=0A=
              $scope.data =3D data;=0A=
            }).=0A=
            error(function(data, status) {=0A=
              $scope.data =3D data || "Request failed";=0A=
              $scope.status =3D status;=0A=
          });=0A=
        };=0A=
=0A=
        $scope.updateModel =3D function(method, url) {=0A=
          $scope.method =3D method;=0A=
          $scope.url =3D url;=0A=
        };=0A=
      }]);=0A=
&lt;/file&gt;=0A=
&lt;file name=3D"http-hello.html"&gt;=0A=
  Hello, $http!=0A=
&lt;/file&gt;=0A=
&lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
  var status =3D element(by.binding('status'));=0A=
  var data =3D element(by.binding('data'));=0A=
  var fetchBtn =3D element(by.id('fetchbtn'));=0A=
  var sampleGetBtn =3D element(by.id('samplegetbtn'));=0A=
  var sampleJsonpBtn =3D element(by.id('samplejsonpbtn'));=0A=
  var invalidJsonpBtn =3D element(by.id('invalidjsonpbtn'));=0A=
=0A=
  it('should make an xhr GET request', function() {=0A=
    sampleGetBtn.click();=0A=
    fetchBtn.click();=0A=
    expect(status.getText()).toMatch('200');=0A=
    expect(data.getText()).toMatch(/Hello, \$http!/);=0A=
  });=0A=
=0A=
// Commented out due to flakes. See =
https://github.com/angular/angular.js/issues/9185=0A=
// it('should make a JSONP request to angularjs.org', function() {=0A=
//   sampleJsonpBtn.click();=0A=
//   fetchBtn.click();=0A=
//   expect(status.getText()).toMatch('200');=0A=
//   expect(data.getText()).toMatch(/Super Hero!/);=0A=
// });=0A=
=0A=
  it('should make JSONP request to invalid URL and invoke the error =
handler',=0A=
      function() {=0A=
    invalidJsonpBtn.click();=0A=
    fetchBtn.click();=0A=
    expect(status.getText()).toMatch('0');=0A=
    expect(data.getText()).toMatch('Request failed');=0A=
  });=0A=
&lt;/file&gt;=0A=
&lt;/example&gt;=0A=
     */=0A=
    function $http(requestConfig) {=0A=
      var config =3D {=0A=
        method: 'get',=0A=
        transformRequest: defaults.transformRequest,=0A=
        transformResponse: defaults.transformResponse=0A=
      };=0A=
      var headers =3D mergeHeaders(requestConfig);=0A=
=0A=
      extend(config, requestConfig);=0A=
      config.headers =3D headers;=0A=
      config.method =3D uppercase(config.method);=0A=
=0A=
      var serverRequest =3D function(config) {=0A=
        headers =3D config.headers;=0A=
        var reqData =3D transformData(config.data, =
headersGetter(headers), config.transformRequest);=0A=
=0A=
        // strip content-type if data is undefined=0A=
        if (isUndefined(reqData)) {=0A=
          forEach(headers, function(value, header) {=0A=
            if (lowercase(header) =3D=3D=3D 'content-type') {=0A=
                delete headers[header];=0A=
            }=0A=
          });=0A=
        }=0A=
=0A=
        if (isUndefined(config.withCredentials) &amp;&amp; =
!isUndefined(defaults.withCredentials)) {=0A=
          config.withCredentials =3D defaults.withCredentials;=0A=
        }=0A=
=0A=
        // send request=0A=
        return sendReq(config, reqData, headers).then(transformResponse, =
transformResponse);=0A=
      };=0A=
=0A=
      var chain =3D [serverRequest, undefined];=0A=
      var promise =3D $q.when(config);=0A=
=0A=
      // apply interceptors=0A=
      forEach(reversedInterceptors, function(interceptor) {=0A=
        if (interceptor.request || interceptor.requestError) {=0A=
          chain.unshift(interceptor.request, interceptor.requestError);=0A=
        }=0A=
        if (interceptor.response || interceptor.responseError) {=0A=
          chain.push(interceptor.response, interceptor.responseError);=0A=
        }=0A=
      });=0A=
=0A=
      while(chain.length) {=0A=
        var thenFn =3D chain.shift();=0A=
        var rejectFn =3D chain.shift();=0A=
=0A=
        promise =3D promise.then(thenFn, rejectFn);=0A=
      }=0A=
=0A=
      promise.success =3D function(fn) {=0A=
        promise.then(function(response) {=0A=
          fn(response.data, response.status, response.headers, config);=0A=
        });=0A=
        return promise;=0A=
      };=0A=
=0A=
      promise.error =3D function(fn) {=0A=
        promise.then(null, function(response) {=0A=
          fn(response.data, response.status, response.headers, config);=0A=
        });=0A=
        return promise;=0A=
      };=0A=
=0A=
      return promise;=0A=
=0A=
      function transformResponse(response) {=0A=
        // make a copy since the response must be cacheable=0A=
        var resp =3D extend({}, response);=0A=
        if (!response.data) {=0A=
          resp.data =3D response.data;=0A=
        } else {=0A=
          resp.data =3D transformData(response.data, response.headers, =
config.transformResponse);=0A=
        }=0A=
        return (isSuccess(response.status))=0A=
          ? resp=0A=
          : $q.reject(resp);=0A=
      }=0A=
=0A=
      function mergeHeaders(config) {=0A=
        var defHeaders =3D defaults.headers,=0A=
            reqHeaders =3D extend({}, config.headers),=0A=
            defHeaderName, lowercaseDefHeaderName, reqHeaderName;=0A=
=0A=
        defHeaders =3D extend({}, defHeaders.common, =
defHeaders[lowercase(config.method)]);=0A=
=0A=
        // using for-in instead of forEach to avoid unecessary iteration =
after header has been found=0A=
        defaultHeadersIteration:=0A=
        for (defHeaderName in defHeaders) {=0A=
          lowercaseDefHeaderName =3D lowercase(defHeaderName);=0A=
=0A=
          for (reqHeaderName in reqHeaders) {=0A=
            if (lowercase(reqHeaderName) =3D=3D=3D =
lowercaseDefHeaderName) {=0A=
              continue defaultHeadersIteration;=0A=
            }=0A=
          }=0A=
=0A=
          reqHeaders[defHeaderName] =3D defHeaders[defHeaderName];=0A=
        }=0A=
=0A=
        // execute if header value is a function for merged headers=0A=
        execHeaders(reqHeaders);=0A=
        return reqHeaders;=0A=
=0A=
        function execHeaders(headers) {=0A=
          var headerContent;=0A=
=0A=
          forEach(headers, function(headerFn, header) {=0A=
            if (isFunction(headerFn)) {=0A=
              headerContent =3D headerFn();=0A=
              if (headerContent !=3D null) {=0A=
                headers[header] =3D headerContent;=0A=
              } else {=0A=
                delete headers[header];=0A=
              }=0A=
            }=0A=
          });=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    $http.pendingRequests =3D [];=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $http#get=0A=
     *=0A=
     * @description=0A=
     * Shortcut method to perform `GET` request.=0A=
     *=0A=
     * @param {string} url Relative or absolute URL specifying the =
destination of the request=0A=
     * @param {Object=3D} config Optional configuration object=0A=
     * @returns {HttpPromise} Future object=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $http#delete=0A=
     *=0A=
     * @description=0A=
     * Shortcut method to perform `DELETE` request.=0A=
     *=0A=
     * @param {string} url Relative or absolute URL specifying the =
destination of the request=0A=
     * @param {Object=3D} config Optional configuration object=0A=
     * @returns {HttpPromise} Future object=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $http#head=0A=
     *=0A=
     * @description=0A=
     * Shortcut method to perform `HEAD` request.=0A=
     *=0A=
     * @param {string} url Relative or absolute URL specifying the =
destination of the request=0A=
     * @param {Object=3D} config Optional configuration object=0A=
     * @returns {HttpPromise} Future object=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $http#jsonp=0A=
     *=0A=
     * @description=0A=
     * Shortcut method to perform `JSONP` request.=0A=
     *=0A=
     * @param {string} url Relative or absolute URL specifying the =
destination of the request.=0A=
     *                     The name of the callback should be the string =
`JSON_CALLBACK`.=0A=
     * @param {Object=3D} config Optional configuration object=0A=
     * @returns {HttpPromise} Future object=0A=
     */=0A=
    createShortMethods('get', 'delete', 'head', 'jsonp');=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $http#post=0A=
     *=0A=
     * @description=0A=
     * Shortcut method to perform `POST` request.=0A=
     *=0A=
     * @param {string} url Relative or absolute URL specifying the =
destination of the request=0A=
     * @param {*} data Request content=0A=
     * @param {Object=3D} config Optional configuration object=0A=
     * @returns {HttpPromise} Future object=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $http#put=0A=
     *=0A=
     * @description=0A=
     * Shortcut method to perform `PUT` request.=0A=
     *=0A=
     * @param {string} url Relative or absolute URL specifying the =
destination of the request=0A=
     * @param {*} data Request content=0A=
     * @param {Object=3D} config Optional configuration object=0A=
     * @returns {HttpPromise} Future object=0A=
     */=0A=
=0A=
     /**=0A=
      * @ngdoc method=0A=
      * @name $http#patch=0A=
      *=0A=
      * @description=0A=
      * Shortcut method to perform `PATCH` request.=0A=
      *=0A=
      * @param {string} url Relative or absolute URL specifying the =
destination of the request=0A=
      * @param {*} data Request content=0A=
      * @param {Object=3D} config Optional configuration object=0A=
      * @returns {HttpPromise} Future object=0A=
      */=0A=
    createShortMethodsWithData('post', 'put', 'patch');=0A=
=0A=
        /**=0A=
         * @ngdoc property=0A=
         * @name $http#defaults=0A=
         *=0A=
         * @description=0A=
         * Runtime equivalent of the `$httpProvider.defaults` property. =
Allows configuration of=0A=
         * default headers, withCredentials as well as request and =
response transformations.=0A=
         *=0A=
         * See "Setting HTTP Headers" and "Transforming Requests and =
Responses" sections above.=0A=
         */=0A=
    $http.defaults =3D defaults;=0A=
=0A=
=0A=
    return $http;=0A=
=0A=
=0A=
    function createShortMethods(names) {=0A=
      forEach(arguments, function(name) {=0A=
        $http[name] =3D function(url, config) {=0A=
          return $http(extend(config || {}, {=0A=
            method: name,=0A=
            url: url=0A=
          }));=0A=
        };=0A=
      });=0A=
    }=0A=
=0A=
=0A=
    function createShortMethodsWithData(name) {=0A=
      forEach(arguments, function(name) {=0A=
        $http[name] =3D function(url, data, config) {=0A=
          return $http(extend(config || {}, {=0A=
            method: name,=0A=
            url: url,=0A=
            data: data=0A=
          }));=0A=
        };=0A=
      });=0A=
    }=0A=
=0A=
=0A=
    /**=0A=
     * Makes the request.=0A=
     *=0A=
     * !!! ACCESSES CLOSURE VARS:=0A=
     * $httpBackend, defaults, $log, $rootScope, defaultCache, =
$http.pendingRequests=0A=
     */=0A=
    function sendReq(config, reqData, reqHeaders) {=0A=
      var deferred =3D $q.defer(),=0A=
          promise =3D deferred.promise,=0A=
          cache,=0A=
          cachedResp,=0A=
          url =3D buildUrl(config.url, config.params);=0A=
=0A=
      $http.pendingRequests.push(config);=0A=
      promise.then(removePendingReq, removePendingReq);=0A=
=0A=
=0A=
      if ((config.cache || defaults.cache) &amp;&amp; config.cache =
!=3D=3D false &amp;&amp;=0A=
          (config.method =3D=3D=3D 'GET' || config.method =3D=3D=3D =
'JSONP')) {=0A=
        cache =3D isObject(config.cache) ? config.cache=0A=
              : isObject(defaults.cache) ? defaults.cache=0A=
              : defaultCache;=0A=
      }=0A=
=0A=
      if (cache) {=0A=
        cachedResp =3D cache.get(url);=0A=
        if (isDefined(cachedResp)) {=0A=
          if (isPromiseLike(cachedResp)) {=0A=
            // cached request has already been sent, but there is no =
response yet=0A=
            cachedResp.then(removePendingReq, removePendingReq);=0A=
            return cachedResp;=0A=
          } else {=0A=
            // serving from cache=0A=
            if (isArray(cachedResp)) {=0A=
              resolvePromise(cachedResp[1], cachedResp[0], =
shallowCopy(cachedResp[2]), cachedResp[3]);=0A=
            } else {=0A=
              resolvePromise(cachedResp, 200, {}, 'OK');=0A=
            }=0A=
          }=0A=
        } else {=0A=
          // put the promise for the non-transformed response into cache =
as a placeholder=0A=
          cache.put(url, promise);=0A=
        }=0A=
      }=0A=
=0A=
=0A=
      // if we won't have the response in cache, set the xsrf headers and=0A=
      // send the request to the backend=0A=
      if (isUndefined(cachedResp)) {=0A=
        var xsrfValue =3D urlIsSameOrigin(config.url)=0A=
            ? $browser.cookies()[config.xsrfCookieName || =
defaults.xsrfCookieName]=0A=
            : undefined;=0A=
        if (xsrfValue) {=0A=
          reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] =
=3D xsrfValue;=0A=
        }=0A=
=0A=
        $httpBackend(config.method, url, reqData, done, reqHeaders, =
config.timeout,=0A=
            config.withCredentials, config.responseType);=0A=
      }=0A=
=0A=
      return promise;=0A=
=0A=
=0A=
      /**=0A=
       * Callback registered to $httpBackend():=0A=
       *  - caches the response if desired=0A=
       *  - resolves the raw $http promise=0A=
       *  - calls $apply=0A=
       */=0A=
      function done(status, response, headersString, statusText) {=0A=
        if (cache) {=0A=
          if (isSuccess(status)) {=0A=
            cache.put(url, [status, response, =
parseHeaders(headersString), statusText]);=0A=
          } else {=0A=
            // remove promise from the cache=0A=
            cache.remove(url);=0A=
          }=0A=
        }=0A=
=0A=
        function resolveHttpPromise() {=0A=
          resolvePromise(response, status, headersString, statusText);=0A=
        }=0A=
=0A=
        if (useApplyAsync) {=0A=
          $rootScope.$applyAsync(resolveHttpPromise);=0A=
        } else {=0A=
          resolveHttpPromise();=0A=
          if (!$rootScope.$$phase) $rootScope.$apply();=0A=
        }=0A=
      }=0A=
=0A=
=0A=
      /**=0A=
       * Resolves the raw $http promise.=0A=
       */=0A=
      function resolvePromise(response, status, headers, statusText) {=0A=
        // normalize internal statuses to 0=0A=
        status =3D Math.max(status, 0);=0A=
=0A=
        (isSuccess(status) ? deferred.resolve : deferred.reject)({=0A=
          data: response,=0A=
          status: status,=0A=
          headers: headersGetter(headers),=0A=
          config: config,=0A=
          statusText : statusText=0A=
        });=0A=
      }=0A=
=0A=
=0A=
      function removePendingReq() {=0A=
        var idx =3D $http.pendingRequests.indexOf(config);=0A=
        if (idx !=3D=3D -1) $http.pendingRequests.splice(idx, 1);=0A=
      }=0A=
    }=0A=
=0A=
=0A=
    function buildUrl(url, params) {=0A=
      if (!params) return url;=0A=
      var parts =3D [];=0A=
      forEachSorted(params, function(value, key) {=0A=
        if (value =3D=3D=3D null || isUndefined(value)) return;=0A=
        if (!isArray(value)) value =3D [value];=0A=
=0A=
        forEach(value, function(v) {=0A=
          if (isObject(v)) {=0A=
            if (isDate(v)){=0A=
              v =3D v.toISOString();=0A=
            } else {=0A=
              v =3D toJson(v);=0A=
            }=0A=
          }=0A=
          parts.push(encodeUriQuery(key) + '=3D' +=0A=
                     encodeUriQuery(v));=0A=
        });=0A=
      });=0A=
      if(parts.length &gt; 0) {=0A=
        url +=3D ((url.indexOf('?') =3D=3D -1) ? '?' : '&amp;') + =
parts.join('&amp;');=0A=
      }=0A=
      return url;=0A=
    }=0A=
  }];=0A=
}=0A=
=0A=
function createXhr() {=0A=
    return new window.XMLHttpRequest();=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $httpBackend=0A=
 * @requires $window=0A=
 * @requires $document=0A=
 *=0A=
 * @description=0A=
 * HTTP backend used by the {@link ng.$http service} that delegates to=0A=
 * XMLHttpRequest object or JSONP and deals with browser =
incompatibilities.=0A=
 *=0A=
 * You should never need to use this service directly, instead use the =
higher-level abstractions:=0A=
 * {@link ng.$http $http} or {@link ngResource.$resource $resource}.=0A=
 *=0A=
 * During testing this implementation is swapped with {@link =
ngMock.$httpBackend mock=0A=
 * $httpBackend} which can be trained with responses.=0A=
 */=0A=
function $HttpBackendProvider() {=0A=
  this.$get =3D ['$browser', '$window', '$document', function($browser, =
$window, $document) {=0A=
    return createHttpBackend($browser, createXhr, $browser.defer, =
$window.angular.callbacks, $document[0]);=0A=
  }];=0A=
}=0A=
=0A=
function createHttpBackend($browser, createXhr, $browserDefer, =
callbacks, rawDocument) {=0A=
  // TODO(vojta): fix the signature=0A=
  return function(method, url, post, callback, headers, timeout, =
withCredentials, responseType) {=0A=
    $browser.$$incOutstandingRequestCount();=0A=
    url =3D url || $browser.url();=0A=
=0A=
    if (lowercase(method) =3D=3D 'jsonp') {=0A=
      var callbackId =3D '_' + (callbacks.counter++).toString(36);=0A=
      callbacks[callbackId] =3D function(data) {=0A=
        callbacks[callbackId].data =3D data;=0A=
        callbacks[callbackId].called =3D true;=0A=
      };=0A=
=0A=
      var jsonpDone =3D jsonpReq(url.replace('JSON_CALLBACK', =
'angular.callbacks.' + callbackId),=0A=
          callbackId, function(status, text) {=0A=
        completeRequest(callback, status, callbacks[callbackId].data, =
"", text);=0A=
        callbacks[callbackId] =3D noop;=0A=
      });=0A=
    } else {=0A=
=0A=
      var xhr =3D createXhr();=0A=
=0A=
      xhr.open(method, url, true);=0A=
      forEach(headers, function(value, key) {=0A=
        if (isDefined(value)) {=0A=
            xhr.setRequestHeader(key, value);=0A=
        }=0A=
      });=0A=
=0A=
      xhr.onload =3D function requestLoaded() {=0A=
        var statusText =3D xhr.statusText || '';=0A=
=0A=
        // responseText is the old-school way of retrieving response =
(supported by IE8 &amp; 9)=0A=
        // response/responseType properties were introduced in XHR =
Level2 spec (supported by IE10)=0A=
        var response =3D ('response' in xhr) ? xhr.response : =
xhr.responseText;=0A=
=0A=
        // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)=0A=
        var status =3D xhr.status =3D=3D=3D 1223 ? 204 : xhr.status;=0A=
=0A=
        // fix status code when it is 0 (0 status is undocumented).=0A=
        // Occurs when accessing file resources or on Android 4.1 stock =
browser=0A=
        // while retrieving files from application cache.=0A=
        if (status =3D=3D=3D 0) {=0A=
          status =3D response ? 200 : urlResolve(url).protocol =3D=3D =
'file' ? 404 : 0;=0A=
        }=0A=
=0A=
        completeRequest(callback,=0A=
            status,=0A=
            response,=0A=
            xhr.getAllResponseHeaders(),=0A=
            statusText);=0A=
      };=0A=
=0A=
      var requestError =3D function () {=0A=
        // The response is always empty=0A=
        // See https://xhr.spec.whatwg.org/#request-error-steps and =
https://fetch.spec.whatwg.org/#concept-network-error=0A=
        completeRequest(callback, -1, null, null, '');=0A=
      };=0A=
=0A=
      xhr.onerror =3D requestError;=0A=
      xhr.onabort =3D requestError;=0A=
=0A=
      if (withCredentials) {=0A=
        xhr.withCredentials =3D true;=0A=
      }=0A=
=0A=
      if (responseType) {=0A=
        try {=0A=
          xhr.responseType =3D responseType;=0A=
        } catch (e) {=0A=
          // WebKit added support for the json responseType value on =
09/03/2013=0A=
          // https://bugs.webkit.org/show_bug.cgi?id=3D73648. Versions =
of Safari prior to 7 are=0A=
          // known to throw when setting the value "json" as the =
response type. Other older=0A=
          // browsers implementing the responseType=0A=
          //=0A=
          // The json response type can be ignored if not supported, =
because JSON payloads are=0A=
          // parsed on the client-side regardless.=0A=
          if (responseType !=3D=3D 'json') {=0A=
            throw e;=0A=
          }=0A=
        }=0A=
      }=0A=
=0A=
      xhr.send(post || null);=0A=
    }=0A=
=0A=
    if (timeout &gt; 0) {=0A=
      var timeoutId =3D $browserDefer(timeoutRequest, timeout);=0A=
    } else if (isPromiseLike(timeout)) {=0A=
      timeout.then(timeoutRequest);=0A=
    }=0A=
=0A=
=0A=
    function timeoutRequest() {=0A=
      jsonpDone &amp;&amp; jsonpDone();=0A=
      xhr &amp;&amp; xhr.abort();=0A=
    }=0A=
=0A=
    function completeRequest(callback, status, response, headersString, =
statusText) {=0A=
      // cancel timeout and subsequent timeout promise resolution=0A=
      timeoutId &amp;&amp; $browserDefer.cancel(timeoutId);=0A=
      jsonpDone =3D xhr =3D null;=0A=
=0A=
      callback(status, response, headersString, statusText);=0A=
      $browser.$$completeOutstandingRequest(noop);=0A=
    }=0A=
  };=0A=
=0A=
  function jsonpReq(url, callbackId, done) {=0A=
    // we can't use jQuery/jqLite here because jQuery does crazy shit =
with script elements, e.g.:=0A=
    // - fetches local scripts via XHR and evals them=0A=
    // - adds and immediately removes script elements from the document=0A=
    var script =3D rawDocument.createElement('script'), callback =3D =
null;=0A=
    script.type =3D "text/javascript";=0A=
    script.src =3D url;=0A=
    script.async =3D true;=0A=
=0A=
    callback =3D function(event) {=0A=
      removeEventListenerFn(script, "load", callback);=0A=
      removeEventListenerFn(script, "error", callback);=0A=
      rawDocument.body.removeChild(script);=0A=
      script =3D null;=0A=
      var status =3D -1;=0A=
      var text =3D "unknown";=0A=
=0A=
      if (event) {=0A=
        if (event.type =3D=3D=3D "load" &amp;&amp; =
!callbacks[callbackId].called) {=0A=
          event =3D { type: "error" };=0A=
        }=0A=
        text =3D event.type;=0A=
        status =3D event.type =3D=3D=3D "error" ? 404 : 200;=0A=
      }=0A=
=0A=
      if (done) {=0A=
        done(status, text);=0A=
      }=0A=
    };=0A=
=0A=
    addEventListenerFn(script, "load", callback);=0A=
    addEventListenerFn(script, "error", callback);=0A=
    rawDocument.body.appendChild(script);=0A=
    return callback;=0A=
  }=0A=
}=0A=
=0A=
var $interpolateMinErr =3D minErr('$interpolate');=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $interpolateProvider=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * Used for configuring the interpolation markup. Defaults to `{{` and =
`}}`.=0A=
 *=0A=
 * @example=0A=
&lt;example module=3D"customInterpolationApp"&gt;=0A=
&lt;file name=3D"todoList.html"&gt;=0A=
&lt;script&gt;=0A=
  var customInterpolationApp =3D =
angular.module('customInterpolationApp', []);=0A=
=0A=
  customInterpolationApp.config(function($interpolateProvider) {=0A=
    $interpolateProvider.startSymbol('//');=0A=
    $interpolateProvider.endSymbol('//');=0A=
  });=0A=
=0A=
=0A=
  customInterpolationApp.controller('DemoController', function() {=0A=
      this.label =3D "This binding is brought you by // interpolation =
symbols.";=0A=
  });=0A=
&lt;/script&gt;=0A=
&lt;div ng-app=3D"App" ng-controller=3D"DemoController as demo"&gt;=0A=
    //demo.label//=0A=
&lt;/div&gt;=0A=
&lt;/file&gt;=0A=
&lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
  it('should interpolate binding with custom symbols', function() {=0A=
    expect(element(by.binding('demo.label')).getText()).toBe('This =
binding is brought you by // interpolation symbols.');=0A=
  });=0A=
&lt;/file&gt;=0A=
&lt;/example&gt;=0A=
 */=0A=
function $InterpolateProvider() {=0A=
  var startSymbol =3D '{{';=0A=
  var endSymbol =3D '}}';=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $interpolateProvider#startSymbol=0A=
   * @description=0A=
   * Symbol to denote start of expression in the interpolated string. =
Defaults to `{{`.=0A=
   *=0A=
   * @param {string=3D} value new value to set the starting symbol to.=0A=
   * @returns {string|self} Returns the symbol when used as getter and =
self if used as setter.=0A=
   */=0A=
  this.startSymbol =3D function(value){=0A=
    if (value) {=0A=
      startSymbol =3D value;=0A=
      return this;=0A=
    } else {=0A=
      return startSymbol;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $interpolateProvider#endSymbol=0A=
   * @description=0A=
   * Symbol to denote the end of expression in the interpolated string. =
Defaults to `}}`.=0A=
   *=0A=
   * @param {string=3D} value new value to set the ending symbol to.=0A=
   * @returns {string|self} Returns the symbol when used as getter and =
self if used as setter.=0A=
   */=0A=
  this.endSymbol =3D function(value){=0A=
    if (value) {=0A=
      endSymbol =3D value;=0A=
      return this;=0A=
    } else {=0A=
      return endSymbol;=0A=
    }=0A=
  };=0A=
=0A=
=0A=
  this.$get =3D ['$parse', '$exceptionHandler', '$sce', function($parse, =
$exceptionHandler, $sce) {=0A=
    var startSymbolLength =3D startSymbol.length,=0A=
        endSymbolLength =3D endSymbol.length,=0A=
        escapedStartRegexp =3D new RegExp(startSymbol.replace(/./g, =
escape), 'g'),=0A=
        escapedEndRegexp =3D new RegExp(endSymbol.replace(/./g, escape), =
'g');=0A=
=0A=
    function escape(ch) {=0A=
      return '\\\\\\' + ch;=0A=
    }=0A=
=0A=
    /**=0A=
     * @ngdoc service=0A=
     * @name $interpolate=0A=
     * @kind function=0A=
     *=0A=
     * @requires $parse=0A=
     * @requires $sce=0A=
     *=0A=
     * @description=0A=
     *=0A=
     * Compiles a string with markup into an interpolation function. =
This service is used by the=0A=
     * HTML {@link ng.$compile $compile} service for data binding. See=0A=
     * {@link ng.$interpolateProvider $interpolateProvider} for =
configuring the=0A=
     * interpolation markup.=0A=
     *=0A=
     *=0A=
     * ```js=0A=
     *   var $interpolate =3D ...; // injected=0A=
     *   var exp =3D $interpolate('Hello {{name | uppercase}}!');=0A=
     *   expect(exp({name:'Angular'}).toEqual('Hello ANGULAR!');=0A=
     * ```=0A=
     *=0A=
     * `$interpolate` takes an optional fourth argument, `allOrNothing`. =
If `allOrNothing` is=0A=
     * `true`, the interpolation function will return `undefined` unless =
all embedded expressions=0A=
     * evaluate to a value other than `undefined`.=0A=
     *=0A=
     * ```js=0A=
     *   var $interpolate =3D ...; // injected=0A=
     *   var context =3D {greeting: 'Hello', name: undefined };=0A=
     *=0A=
     *   // default "forgiving" mode=0A=
     *   var exp =3D $interpolate('{{greeting}} {{name}}!');=0A=
     *   expect(exp(context)).toEqual('Hello !');=0A=
     *=0A=
     *   // "allOrNothing" mode=0A=
     *   exp =3D $interpolate('{{greeting}} {{name}}!', false, null, =
true);=0A=
     *   expect(exp(context)).toBeUndefined();=0A=
     *   context.name =3D 'Angular';=0A=
     *   expect(exp(context)).toEqual('Hello Angular!');=0A=
     * ```=0A=
     *=0A=
     * `allOrNothing` is useful for interpolating URLs. `ngSrc` and =
`ngSrcset` use this behavior.=0A=
     *=0A=
     * ####Escaped Interpolation=0A=
     * $interpolate provides a mechanism for escaping interpolation =
markers. Start and end markers=0A=
     * can be escaped by preceding each of their characters with a =
REVERSE SOLIDUS U+005C (backslash).=0A=
     * It will be rendered as a regular start/end marker, and will not =
be interpreted as an expression=0A=
     * or binding.=0A=
     *=0A=
     * This enables web-servers to prevent script injection attacks and =
defacing attacks, to some=0A=
     * degree, while also enabling code examples to work without relying =
on the=0A=
     * {@link ng.directive:ngNonBindable ngNonBindable} directive.=0A=
     *=0A=
     * **For security purposes, it is strongly encouraged that web =
servers escape user-supplied data,=0A=
     * replacing angle brackets (&amp;lt;, &amp;gt;) with &amp;amp;lt; =
and &amp;amp;gt; respectively, and replacing all=0A=
     * interpolation start/end markers with their escaped counterparts.**=0A=
     *=0A=
     * Escaped interpolation markers are only replaced with the actual =
interpolation markers in rendered=0A=
     * output when the $interpolate service processes the text. So, for =
HTML elements interpolated=0A=
     * by {@link ng.$compile $compile}, or otherwise interpolated with =
the `mustHaveExpression` parameter=0A=
     * set to `true`, the interpolated text must contain an unescaped =
interpolation expression. As such,=0A=
     * this is typically useful only when user-data is used in rendering =
a template from the server, or=0A=
     * when otherwise untrusted data is used by a directive.=0A=
     *=0A=
     * &lt;example&gt;=0A=
     *  &lt;file name=3D"todoList.html"&gt;=0A=
     *    &lt;div ng-init=3D"username=3D'A user'"&gt;=0A=
     *      &lt;p ng-init=3D"apptitle=3D'Escaping =
demo'"&gt;{{apptitle}}: \{\{ username =3D "defaced value"; \}\}=0A=
     *        &lt;/p&gt;=0A=
     *      &lt;p&gt;&lt;strong&gt;{{username}}&lt;/strong&gt; attempts =
to inject code which will deface the=0A=
     *        application, but fails to accomplish their task, because =
the server has correctly=0A=
     *        escaped the interpolation start/end markers with REVERSE =
SOLIDUS U+005C (backslash)=0A=
     *        characters.&lt;/p&gt;=0A=
     *      &lt;p&gt;Instead, the result of the attempted script =
injection is visible, and can be removed=0A=
     *        from the database by an administrator.&lt;/p&gt;=0A=
     *    &lt;/div&gt;=0A=
     *  &lt;/file&gt;=0A=
     * &lt;/example&gt;=0A=
     *=0A=
     * @param {string} text The text with markup to interpolate.=0A=
     * @param {boolean=3D} mustHaveExpression if set to true then the =
interpolation string must have=0A=
     *    embedded expression in order to return an interpolation =
function. Strings with no=0A=
     *    embedded expression will return null for the interpolation =
function.=0A=
     * @param {string=3D} trustedContext when provided, the returned =
function passes the interpolated=0A=
     *    result through {@link ng.$sce#getTrusted =
$sce.getTrusted(interpolatedResult,=0A=
     *    trustedContext)} before returning it.  Refer to the {@link =
ng.$sce $sce} service that=0A=
     *    provides Strict Contextual Escaping for details.=0A=
     * @param {boolean=3D} allOrNothing if `true`, then the returned =
function returns undefined=0A=
     *    unless all embedded expressions evaluate to a value other than =
`undefined`.=0A=
     * @returns {function(context)} an interpolation function which is =
used to compute the=0A=
     *    interpolated string. The function has these parameters:=0A=
     *=0A=
     * - `context`: evaluation context for all expressions embedded in =
the interpolated text=0A=
     */=0A=
    function $interpolate(text, mustHaveExpression, trustedContext, =
allOrNothing) {=0A=
      allOrNothing =3D !!allOrNothing;=0A=
      var startIndex,=0A=
          endIndex,=0A=
          index =3D 0,=0A=
          expressions =3D [],=0A=
          parseFns =3D [],=0A=
          textLength =3D text.length,=0A=
          exp,=0A=
          concat =3D [],=0A=
          expressionPositions =3D [];=0A=
=0A=
      while(index &lt; textLength) {=0A=
        if ( ((startIndex =3D text.indexOf(startSymbol, index)) !=3D -1) =
&amp;&amp;=0A=
             ((endIndex =3D text.indexOf(endSymbol, startIndex + =
startSymbolLength)) !=3D -1) ) {=0A=
          if (index !=3D=3D startIndex) {=0A=
            concat.push(unescapeText(text.substring(index, startIndex)));=0A=
          }=0A=
          exp =3D text.substring(startIndex + startSymbolLength, =
endIndex);=0A=
          expressions.push(exp);=0A=
          parseFns.push($parse(exp, parseStringifyInterceptor));=0A=
          index =3D endIndex + endSymbolLength;=0A=
          expressionPositions.push(concat.length);=0A=
          concat.push('');=0A=
        } else {=0A=
          // we did not find an interpolation, so we have to add the =
remainder to the separators array=0A=
          if (index !=3D=3D textLength) {=0A=
            concat.push(unescapeText(text.substring(index)));=0A=
          }=0A=
          break;=0A=
        }=0A=
      }=0A=
=0A=
      // Concatenating expressions makes it hard to reason about whether =
some combination of=0A=
      // concatenated values are unsafe to use and could easily lead to =
XSS.  By requiring that a=0A=
      // single expression be used for iframe[src], object[src], etc., =
we ensure that the value=0A=
      // that's used is assigned or constructed by some JS code =
somewhere that is more testable or=0A=
      // make it obvious that you bound the value to some user =
controlled value.  This helps reduce=0A=
      // the load when auditing for XSS issues.=0A=
      if (trustedContext &amp;&amp; concat.length &gt; 1) {=0A=
          throw $interpolateMinErr('noconcat',=0A=
              "Error while interpolating: {0}\nStrict Contextual =
Escaping disallows " +=0A=
              "interpolations that concatenate multiple expressions when =
a trusted value is " +=0A=
              "required.  See http://docs.angularjs.org/api/ng.$sce", =
text);=0A=
      }=0A=
=0A=
      if (!mustHaveExpression || expressions.length) {=0A=
        var compute =3D function(values) {=0A=
          for(var i =3D 0, ii =3D expressions.length; i &lt; ii; i++) {=0A=
            if (allOrNothing &amp;&amp; isUndefined(values[i])) return;=0A=
            concat[expressionPositions[i]] =3D values[i];=0A=
          }=0A=
          return concat.join('');=0A=
        };=0A=
=0A=
        var getValue =3D function (value) {=0A=
          return trustedContext ?=0A=
            $sce.getTrusted(trustedContext, value) :=0A=
            $sce.valueOf(value);=0A=
        };=0A=
=0A=
        var stringify =3D function (value) {=0A=
          if (value =3D=3D null) { // null || undefined=0A=
            return '';=0A=
          }=0A=
          switch (typeof value) {=0A=
            case 'string':=0A=
              break;=0A=
            case 'number':=0A=
              value =3D '' + value;=0A=
              break;=0A=
            default:=0A=
              value =3D toJson(value);=0A=
          }=0A=
=0A=
          return value;=0A=
        };=0A=
=0A=
        return extend(function interpolationFn(context) {=0A=
            var i =3D 0;=0A=
            var ii =3D expressions.length;=0A=
            var values =3D new Array(ii);=0A=
=0A=
            try {=0A=
              for (; i &lt; ii; i++) {=0A=
                values[i] =3D parseFns[i](context);=0A=
              }=0A=
=0A=
              return compute(values);=0A=
            } catch(err) {=0A=
              var newErr =3D $interpolateMinErr('interr', "Can't =
interpolate: {0}\n{1}", text,=0A=
                  err.toString());=0A=
              $exceptionHandler(newErr);=0A=
            }=0A=
=0A=
          }, {=0A=
          // all of these properties are undocumented for now=0A=
          exp: text, //just for compatibility with regular watchers =
created via $watch=0A=
          expressions: expressions,=0A=
          $$watchDelegate: function (scope, listener, objectEquality) {=0A=
            var lastValue;=0A=
            return scope.$watchGroup(parseFns, function =
interpolateFnWatcher(values, oldValues) {=0A=
              var currValue =3D compute(values);=0A=
              if (isFunction(listener)) {=0A=
                listener.call(this, currValue, values !=3D=3D oldValues =
? lastValue : currValue, scope);=0A=
              }=0A=
              lastValue =3D currValue;=0A=
            }, objectEquality);=0A=
          }=0A=
        });=0A=
      }=0A=
=0A=
      function unescapeText(text) {=0A=
        return text.replace(escapedStartRegexp, startSymbol).=0A=
          replace(escapedEndRegexp, endSymbol);=0A=
      }=0A=
=0A=
      function parseStringifyInterceptor(value) {=0A=
        try {=0A=
          return stringify(getValue(value));=0A=
        } catch(err) {=0A=
          var newErr =3D $interpolateMinErr('interr', "Can't =
interpolate: {0}\n{1}", text,=0A=
            err.toString());=0A=
          $exceptionHandler(newErr);=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $interpolate#startSymbol=0A=
     * @description=0A=
     * Symbol to denote the start of expression in the interpolated =
string. Defaults to `{{`.=0A=
     *=0A=
     * Use {@link ng.$interpolateProvider#startSymbol =
`$interpolateProvider.startSymbol`} to change=0A=
     * the symbol.=0A=
     *=0A=
     * @returns {string} start symbol.=0A=
     */=0A=
    $interpolate.startSymbol =3D function() {=0A=
      return startSymbol;=0A=
    };=0A=
=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $interpolate#endSymbol=0A=
     * @description=0A=
     * Symbol to denote the end of expression in the interpolated =
string. Defaults to `}}`.=0A=
     *=0A=
     * Use {@link ng.$interpolateProvider#endSymbol =
`$interpolateProvider.endSymbol`} to change=0A=
     * the symbol.=0A=
     *=0A=
     * @returns {string} end symbol.=0A=
     */=0A=
    $interpolate.endSymbol =3D function() {=0A=
      return endSymbol;=0A=
    };=0A=
=0A=
    return $interpolate;=0A=
  }];=0A=
}=0A=
=0A=
function $IntervalProvider() {=0A=
  this.$get =3D ['$rootScope', '$window', '$q', '$$q',=0A=
       function($rootScope,   $window,   $q,   $$q) {=0A=
    var intervals =3D {};=0A=
=0A=
=0A=
     /**=0A=
      * @ngdoc service=0A=
      * @name $interval=0A=
      *=0A=
      * @description=0A=
      * Angular's wrapper for `window.setInterval`. The `fn` function is =
executed every `delay`=0A=
      * milliseconds.=0A=
      *=0A=
      * The return value of registering an interval function is a =
promise. This promise will be=0A=
      * notified upon each tick of the interval, and will be resolved =
after `count` iterations, or=0A=
      * run indefinitely if `count` is not defined. The value of the =
notification will be the=0A=
      * number of iterations that have run.=0A=
      * To cancel an interval, call `$interval.cancel(promise)`.=0A=
      *=0A=
      * In tests you can use {@link ngMock.$interval#flush =
`$interval.flush(millis)`} to=0A=
      * move forward by `millis` milliseconds and trigger any functions =
scheduled to run in that=0A=
      * time.=0A=
      *=0A=
      * &lt;div class=3D"alert alert-warning"&gt;=0A=
      * **Note**: Intervals created by this service must be explicitly =
destroyed when you are finished=0A=
      * with them.  In particular they are not automatically destroyed =
when a controller's scope or a=0A=
      * directive's element are destroyed.=0A=
      * You should take this into consideration and make sure to always =
cancel the interval at the=0A=
      * appropriate moment.  See the example below for more details on =
how and when to do this.=0A=
      * &lt;/div&gt;=0A=
      *=0A=
      * @param {function()} fn A function that should be called =
repeatedly.=0A=
      * @param {number} delay Number of milliseconds between each =
function call.=0A=
      * @param {number=3D} [count=3D0] Number of times to repeat. If not =
set, or 0, will repeat=0A=
      *   indefinitely.=0A=
      * @param {boolean=3D} [invokeApply=3Dtrue] If set to `false` skips =
model dirty checking, otherwise=0A=
      *   will invoke `fn` within the {@link ng.$rootScope.Scope#$apply =
$apply} block.=0A=
      * @returns {promise} A promise which will be notified on each =
iteration.=0A=
      *=0A=
      * @example=0A=
      * &lt;example module=3D"intervalExample"&gt;=0A=
      * &lt;file name=3D"todoList.html"&gt;=0A=
      *   &lt;script&gt;=0A=
      *     angular.module('intervalExample', [])=0A=
      *       .controller('ExampleController', ['$scope', '$interval',=0A=
      *         function($scope, $interval) {=0A=
      *           $scope.format =3D 'M/d/yy h:mm:ss a';=0A=
      *           $scope.blood_1 =3D 100;=0A=
      *           $scope.blood_2 =3D 120;=0A=
      *=0A=
      *           var stop;=0A=
      *           $scope.fight =3D function() {=0A=
      *             // Don't start a new fight if we are already fighting=0A=
      *             if ( angular.isDefined(stop) ) return;=0A=
      *=0A=
      *           stop =3D $interval(function() {=0A=
      *             if ($scope.blood_1 &gt; 0 &amp;&amp; $scope.blood_2 =
&gt; 0) {=0A=
      *               $scope.blood_1 =3D $scope.blood_1 - 3;=0A=
      *               $scope.blood_2 =3D $scope.blood_2 - 4;=0A=
      *             } else {=0A=
      *               $scope.stopFight();=0A=
      *             }=0A=
      *           }, 100);=0A=
      *         };=0A=
      *=0A=
      *         $scope.stopFight =3D function() {=0A=
      *           if (angular.isDefined(stop)) {=0A=
      *             $interval.cancel(stop);=0A=
      *             stop =3D undefined;=0A=
      *           }=0A=
      *         };=0A=
      *=0A=
      *         $scope.resetFight =3D function() {=0A=
      *           $scope.blood_1 =3D 100;=0A=
      *           $scope.blood_2 =3D 120;=0A=
      *         };=0A=
      *=0A=
      *         $scope.$on('$destroy', function() {=0A=
      *           // Make sure that the interval is destroyed too=0A=
      *           $scope.stopFight();=0A=
      *         });=0A=
      *       }])=0A=
      *       // Register the 'myCurrentTime' directive factory method.=0A=
      *       // We inject $interval and dateFilter service since the =
factory method is DI.=0A=
      *       .directive('myCurrentTime', ['$interval', 'dateFilter',=0A=
      *         function($interval, dateFilter) {=0A=
      *           // return the directive link function. (compile =
function not needed)=0A=
      *           return function(scope, element, attrs) {=0A=
      *             var format,  // date format=0A=
      *                 stopTime; // so that we can cancel the time =
updates=0A=
      *=0A=
      *             // used to update the UI=0A=
      *             function updateTime() {=0A=
      *               element.text(dateFilter(new Date(), format));=0A=
      *             }=0A=
      *=0A=
      *             // watch the expression, and update the UI on change.=0A=
      *             scope.$watch(attrs.myCurrentTime, function(value) {=0A=
      *               format =3D value;=0A=
      *               updateTime();=0A=
      *             });=0A=
      *=0A=
      *             stopTime =3D $interval(updateTime, 1000);=0A=
      *=0A=
      *             // listen on DOM destroy (removal) event, and cancel =
the next UI update=0A=
      *             // to prevent updating time after the DOM element =
was removed.=0A=
      *             element.on('$destroy', function() {=0A=
      *               $interval.cancel(stopTime);=0A=
      *             });=0A=
      *           }=0A=
      *         }]);=0A=
      *   &lt;/script&gt;=0A=
      *=0A=
      *   &lt;div&gt;=0A=
      *     &lt;div ng-controller=3D"ExampleController"&gt;=0A=
      *       Date format: &lt;input ng-model=3D"format"&gt; &lt;hr/&gt;=0A=
      *       Current time is: &lt;span =
my-current-time=3D"format"&gt;&lt;/span&gt;=0A=
      *       &lt;hr/&gt;=0A=
      *       Blood 1 : &lt;font =
color=3D'red'&gt;{{blood_1}}&lt;/font&gt;=0A=
      *       Blood 2 : &lt;font =
color=3D'red'&gt;{{blood_2}}&lt;/font&gt;=0A=
      *       &lt;button type=3D"button" =
data-ng-click=3D"fight()"&gt;Fight&lt;/button&gt;=0A=
      *       &lt;button type=3D"button" =
data-ng-click=3D"stopFight()"&gt;StopFight&lt;/button&gt;=0A=
      *       &lt;button type=3D"button" =
data-ng-click=3D"resetFight()"&gt;resetFight&lt;/button&gt;=0A=
      *     &lt;/div&gt;=0A=
      *   &lt;/div&gt;=0A=
      *=0A=
      * &lt;/file&gt;=0A=
      * &lt;/example&gt;=0A=
      */=0A=
    function interval(fn, delay, count, invokeApply) {=0A=
      var setInterval =3D $window.setInterval,=0A=
          clearInterval =3D $window.clearInterval,=0A=
          iteration =3D 0,=0A=
          skipApply =3D (isDefined(invokeApply) &amp;&amp; !invokeApply),=0A=
          deferred =3D (skipApply ? $$q : $q).defer(),=0A=
          promise =3D deferred.promise;=0A=
=0A=
      count =3D isDefined(count) ? count : 0;=0A=
=0A=
      promise.then(null, null, fn);=0A=
=0A=
      promise.$$intervalId =3D setInterval(function tick() {=0A=
        deferred.notify(iteration++);=0A=
=0A=
        if (count &gt; 0 &amp;&amp; iteration &gt;=3D count) {=0A=
          deferred.resolve(iteration);=0A=
          clearInterval(promise.$$intervalId);=0A=
          delete intervals[promise.$$intervalId];=0A=
        }=0A=
=0A=
        if (!skipApply) $rootScope.$apply();=0A=
=0A=
      }, delay);=0A=
=0A=
      intervals[promise.$$intervalId] =3D deferred;=0A=
=0A=
      return promise;=0A=
    }=0A=
=0A=
=0A=
     /**=0A=
      * @ngdoc method=0A=
      * @name $interval#cancel=0A=
      *=0A=
      * @description=0A=
      * Cancels a task associated with the `promise`.=0A=
      *=0A=
      * @param {promise} promise returned by the `$interval` function.=0A=
      * @returns {boolean} Returns `true` if the task was successfully =
canceled.=0A=
      */=0A=
    interval.cancel =3D function(promise) {=0A=
      if (promise &amp;&amp; promise.$$intervalId in intervals) {=0A=
        intervals[promise.$$intervalId].reject('canceled');=0A=
        $window.clearInterval(promise.$$intervalId);=0A=
        delete intervals[promise.$$intervalId];=0A=
        return true;=0A=
      }=0A=
      return false;=0A=
    };=0A=
=0A=
    return interval;=0A=
  }];=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $locale=0A=
 *=0A=
 * @description=0A=
 * $locale service provides localization rules for various Angular =
components. As of right now the=0A=
 * only public api is:=0A=
 *=0A=
 * * `id` =E2=80&#65533; `{string}` =E2=80&#65533; locale id formatted =
as `languageId-countryId` (e.g. `en-us`)=0A=
 */=0A=
function $LocaleProvider(){=0A=
  this.$get =3D function() {=0A=
    return {=0A=
      id: 'en-us',=0A=
=0A=
      NUMBER_FORMATS: {=0A=
        DECIMAL_SEP: '.',=0A=
        GROUP_SEP: ',',=0A=
        PATTERNS: [=0A=
          { // Decimal Pattern=0A=
            minInt: 1,=0A=
            minFrac: 0,=0A=
            maxFrac: 3,=0A=
            posPre: '',=0A=
            posSuf: '',=0A=
            negPre: '-',=0A=
            negSuf: '',=0A=
            gSize: 3,=0A=
            lgSize: 3=0A=
          },{ //Currency Pattern=0A=
            minInt: 1,=0A=
            minFrac: 2,=0A=
            maxFrac: 2,=0A=
            posPre: '\u00A4',=0A=
            posSuf: '',=0A=
            negPre: '(\u00A4',=0A=
            negSuf: ')',=0A=
            gSize: 3,=0A=
            lgSize: 3=0A=
          }=0A=
        ],=0A=
        CURRENCY_SYM: '$'=0A=
      },=0A=
=0A=
      DATETIME_FORMATS: {=0A=
        MONTH:=0A=
            =
'January,February,March,April,May,June,July,August,September,October,Nove=
mber,December'=0A=
            .split(','),=0A=
        SHORTMONTH:  =
'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),=0A=
        DAY: =
'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),=0A=
        SHORTDAY: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(','),=0A=
        AMPMS: ['AM','PM'],=0A=
        medium: 'MMM d, y h:mm:ss a',=0A=
        short: 'M/d/yy h:mm a',=0A=
        fullDate: 'EEEE, MMMM d, y',=0A=
        longDate: 'MMMM d, y',=0A=
        mediumDate: 'MMM d, y',=0A=
        shortDate: 'M/d/yy',=0A=
        mediumTime: 'h:mm:ss a',=0A=
        shortTime: 'h:mm a'=0A=
      },=0A=
=0A=
      pluralCat: function(num) {=0A=
        if (num =3D=3D=3D 1) {=0A=
          return 'one';=0A=
        }=0A=
        return 'other';=0A=
      }=0A=
    };=0A=
  };=0A=
}=0A=
=0A=
var PATH_MATCH =3D /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,=0A=
    DEFAULT_PORTS =3D {'http': 80, 'https': 443, 'ftp': 21};=0A=
var $locationMinErr =3D minErr('$location');=0A=
=0A=
=0A=
/**=0A=
 * Encode path using encodeUriSegment, ignoring forward slashes=0A=
 *=0A=
 * @param {string} path Path to encode=0A=
 * @returns {string}=0A=
 */=0A=
function encodePath(path) {=0A=
  var segments =3D path.split('/'),=0A=
      i =3D segments.length;=0A=
=0A=
  while (i--) {=0A=
    segments[i] =3D encodeUriSegment(segments[i]);=0A=
  }=0A=
=0A=
  return segments.join('/');=0A=
}=0A=
=0A=
function parseAbsoluteUrl(absoluteUrl, locationObj, appBase) {=0A=
  var parsedUrl =3D urlResolve(absoluteUrl, appBase);=0A=
=0A=
  locationObj.$$protocol =3D parsedUrl.protocol;=0A=
  locationObj.$$host =3D parsedUrl.hostname;=0A=
  locationObj.$$port =3D int(parsedUrl.port) || =
DEFAULT_PORTS[parsedUrl.protocol] || null;=0A=
}=0A=
=0A=
=0A=
function parseAppUrl(relativeUrl, locationObj, appBase) {=0A=
  var prefixed =3D (relativeUrl.charAt(0) !=3D=3D '/');=0A=
  if (prefixed) {=0A=
    relativeUrl =3D '/' + relativeUrl;=0A=
  }=0A=
  var match =3D urlResolve(relativeUrl, appBase);=0A=
  locationObj.$$path =3D decodeURIComponent(prefixed &amp;&amp; =
match.pathname.charAt(0) =3D=3D=3D '/' ?=0A=
      match.pathname.substring(1) : match.pathname);=0A=
  locationObj.$$search =3D parseKeyValue(match.search);=0A=
  locationObj.$$hash =3D decodeURIComponent(match.hash);=0A=
=0A=
  // make sure path starts with '/';=0A=
  if (locationObj.$$path &amp;&amp; locationObj.$$path.charAt(0) !=3D =
'/') {=0A=
    locationObj.$$path =3D '/' + locationObj.$$path;=0A=
  }=0A=
}=0A=
=0A=
=0A=
/**=0A=
 *=0A=
 * @param {string} begin=0A=
 * @param {string} whole=0A=
 * @returns {string} returns text from whole after begin or undefined if =
it does not begin with=0A=
 *                   expected string.=0A=
 */=0A=
function beginsWith(begin, whole) {=0A=
  if (whole.indexOf(begin) =3D=3D=3D 0) {=0A=
    return whole.substr(begin.length);=0A=
  }=0A=
}=0A=
=0A=
=0A=
function stripHash(url) {=0A=
  var index =3D url.indexOf('#');=0A=
  return index =3D=3D -1 ? url : url.substr(0, index);=0A=
}=0A=
=0A=
=0A=
function stripFile(url) {=0A=
  return url.substr(0, stripHash(url).lastIndexOf('/') + 1);=0A=
}=0A=
=0A=
/* return the server only (scheme://host:port) */=0A=
function serverBase(url) {=0A=
  return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * LocationHtml5Url represents an url=0A=
 * This object is exposed as $location service when HTML5 mode is =
enabled and supported=0A=
 *=0A=
 * @constructor=0A=
 * @param {string} appBase application base URL=0A=
 * @param {string} basePrefix url path prefix=0A=
 */=0A=
function LocationHtml5Url(appBase, basePrefix) {=0A=
  this.$$html5 =3D true;=0A=
  basePrefix =3D basePrefix || '';=0A=
  var appBaseNoFile =3D stripFile(appBase);=0A=
  parseAbsoluteUrl(appBase, this, appBase);=0A=
=0A=
=0A=
  /**=0A=
   * Parse given html5 (regular) url string into properties=0A=
   * @param {string} newAbsoluteUrl HTML5 url=0A=
   * @private=0A=
   */=0A=
  this.$$parse =3D function(url) {=0A=
    var pathUrl =3D beginsWith(appBaseNoFile, url);=0A=
    if (!isString(pathUrl)) {=0A=
      throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path =
prefix "{1}".', url,=0A=
          appBaseNoFile);=0A=
    }=0A=
=0A=
    parseAppUrl(pathUrl, this, appBase);=0A=
=0A=
    if (!this.$$path) {=0A=
      this.$$path =3D '/';=0A=
    }=0A=
=0A=
    this.$$compose();=0A=
  };=0A=
=0A=
  /**=0A=
   * Compose url and update `absUrl` property=0A=
   * @private=0A=
   */=0A=
  this.$$compose =3D function() {=0A=
    var search =3D toKeyValue(this.$$search),=0A=
        hash =3D this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';=0A=
=0A=
    this.$$url =3D encodePath(this.$$path) + (search ? '?' + search : =
'') + hash;=0A=
    this.$$absUrl =3D appBaseNoFile + this.$$url.substr(1); // first =
char is always '/'=0A=
  };=0A=
=0A=
  this.$$parseLinkUrl =3D function(url, relHref) {=0A=
    if (relHref &amp;&amp; relHref[0] =3D=3D=3D '#') {=0A=
      // special case for links to hash fragments:=0A=
      // keep the old url and only replace the hash fragment=0A=
      this.hash(relHref.slice(1));=0A=
      return true;=0A=
    }=0A=
    var appUrl, prevAppUrl;=0A=
    var rewrittenUrl;=0A=
=0A=
    if ( (appUrl =3D beginsWith(appBase, url)) !=3D=3D undefined ) {=0A=
      prevAppUrl =3D appUrl;=0A=
      if ( (appUrl =3D beginsWith(basePrefix, appUrl)) !=3D=3D undefined =
) {=0A=
        rewrittenUrl =3D appBaseNoFile + (beginsWith('/', appUrl) || =
appUrl);=0A=
      } else {=0A=
        rewrittenUrl =3D appBase + prevAppUrl;=0A=
      }=0A=
    } else if ( (appUrl =3D beginsWith(appBaseNoFile, url)) !=3D=3D =
undefined ) {=0A=
      rewrittenUrl =3D appBaseNoFile + appUrl;=0A=
    } else if (appBaseNoFile =3D=3D url + '/') {=0A=
      rewrittenUrl =3D appBaseNoFile;=0A=
    }=0A=
    if (rewrittenUrl) {=0A=
      this.$$parse(rewrittenUrl);=0A=
    }=0A=
    return !!rewrittenUrl;=0A=
  };=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * LocationHashbangUrl represents url=0A=
 * This object is exposed as $location service when developer doesn't =
opt into html5 mode.=0A=
 * It also serves as the base class for html5 mode fallback on legacy =
browsers.=0A=
 *=0A=
 * @constructor=0A=
 * @param {string} appBase application base URL=0A=
 * @param {string} hashPrefix hashbang prefix=0A=
 */=0A=
function LocationHashbangUrl(appBase, hashPrefix) {=0A=
  var appBaseNoFile =3D stripFile(appBase);=0A=
=0A=
  parseAbsoluteUrl(appBase, this, appBase);=0A=
=0A=
=0A=
  /**=0A=
   * Parse given hashbang url into properties=0A=
   * @param {string} url Hashbang url=0A=
   * @private=0A=
   */=0A=
  this.$$parse =3D function(url) {=0A=
    var withoutBaseUrl =3D beginsWith(appBase, url) || =
beginsWith(appBaseNoFile, url);=0A=
    var withoutHashUrl =3D withoutBaseUrl.charAt(0) =3D=3D '#'=0A=
        ? beginsWith(hashPrefix, withoutBaseUrl)=0A=
        : (this.$$html5)=0A=
          ? withoutBaseUrl=0A=
          : '';=0A=
=0A=
    if (!isString(withoutHashUrl)) {=0A=
      throw $locationMinErr('ihshprfx', 'Invalid url "{0}", missing hash =
prefix "{1}".', url,=0A=
          hashPrefix);=0A=
    }=0A=
    parseAppUrl(withoutHashUrl, this, appBase);=0A=
=0A=
    this.$$path =3D removeWindowsDriveName(this.$$path, withoutHashUrl, =
appBase);=0A=
=0A=
    this.$$compose();=0A=
=0A=
    /*=0A=
     * In Windows, on an anchor node on documents loaded from=0A=
     * the filesystem, the browser will return a pathname=0A=
     * prefixed with the drive name ('/C:/path') when a=0A=
     * pathname without a drive is set:=0A=
     *  * a.setAttribute('href', '/foo')=0A=
     *   * a.pathname =3D=3D=3D '/C:/foo' //true=0A=
     *=0A=
     * Inside of Angular, we're always using pathnames that=0A=
     * do not include drive names for routing.=0A=
     */=0A=
    function removeWindowsDriveName (path, url, base) {=0A=
      /*=0A=
      Matches paths for file protocol on windows,=0A=
      such as /C:/foo/bar, and captures only /foo/bar.=0A=
      */=0A=
      var windowsFilePathExp =3D /^\/[A-Z]:(\/.*)/;=0A=
=0A=
      var firstPathSegmentMatch;=0A=
=0A=
      //Get the relative path from the input URL.=0A=
      if (url.indexOf(base) =3D=3D=3D 0) {=0A=
        url =3D url.replace(base, '');=0A=
      }=0A=
=0A=
      // The input URL intentionally contains a first path segment that =
ends with a colon.=0A=
      if (windowsFilePathExp.exec(url)) {=0A=
        return path;=0A=
      }=0A=
=0A=
      firstPathSegmentMatch =3D windowsFilePathExp.exec(path);=0A=
      return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * Compose hashbang url and update `absUrl` property=0A=
   * @private=0A=
   */=0A=
  this.$$compose =3D function() {=0A=
    var search =3D toKeyValue(this.$$search),=0A=
        hash =3D this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';=0A=
=0A=
    this.$$url =3D encodePath(this.$$path) + (search ? '?' + search : =
'') + hash;=0A=
    this.$$absUrl =3D appBase + (this.$$url ? hashPrefix + this.$$url : =
'');=0A=
  };=0A=
=0A=
  this.$$parseLinkUrl =3D function(url, relHref) {=0A=
    if(stripHash(appBase) =3D=3D stripHash(url)) {=0A=
      this.$$parse(url);=0A=
      return true;=0A=
    }=0A=
    return false;=0A=
  };=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * LocationHashbangUrl represents url=0A=
 * This object is exposed as $location service when html5 history api is =
enabled but the browser=0A=
 * does not support it.=0A=
 *=0A=
 * @constructor=0A=
 * @param {string} appBase application base URL=0A=
 * @param {string} hashPrefix hashbang prefix=0A=
 */=0A=
function LocationHashbangInHtml5Url(appBase, hashPrefix) {=0A=
  this.$$html5 =3D true;=0A=
  LocationHashbangUrl.apply(this, arguments);=0A=
=0A=
  var appBaseNoFile =3D stripFile(appBase);=0A=
=0A=
  this.$$parseLinkUrl =3D function(url, relHref) {=0A=
    if (relHref &amp;&amp; relHref[0] =3D=3D=3D '#') {=0A=
      // special case for links to hash fragments:=0A=
      // keep the old url and only replace the hash fragment=0A=
      this.hash(relHref.slice(1));=0A=
      return true;=0A=
    }=0A=
=0A=
    var rewrittenUrl;=0A=
    var appUrl;=0A=
=0A=
    if ( appBase =3D=3D stripHash(url) ) {=0A=
      rewrittenUrl =3D url;=0A=
    } else if ( (appUrl =3D beginsWith(appBaseNoFile, url)) ) {=0A=
      rewrittenUrl =3D appBase + hashPrefix + appUrl;=0A=
    } else if ( appBaseNoFile =3D=3D=3D url + '/') {=0A=
      rewrittenUrl =3D appBaseNoFile;=0A=
    }=0A=
    if (rewrittenUrl) {=0A=
      this.$$parse(rewrittenUrl);=0A=
    }=0A=
    return !!rewrittenUrl;=0A=
  };=0A=
=0A=
  this.$$compose =3D function() {=0A=
    var search =3D toKeyValue(this.$$search),=0A=
        hash =3D this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';=0A=
=0A=
    this.$$url =3D encodePath(this.$$path) + (search ? '?' + search : =
'') + hash;=0A=
    // include hashPrefix in $$absUrl when $$url is empty so IE8 &amp; 9 =
do not reload page because of removal of '#'=0A=
    this.$$absUrl =3D appBase + hashPrefix + this.$$url;=0A=
  };=0A=
=0A=
}=0A=
=0A=
=0A=
var locationPrototype =3D {=0A=
=0A=
  /**=0A=
   * Are we in html5 mode?=0A=
   * @private=0A=
   */=0A=
  $$html5: false,=0A=
=0A=
  /**=0A=
   * Has any change been replacing?=0A=
   * @private=0A=
   */=0A=
  $$replace: false,=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $location#absUrl=0A=
   *=0A=
   * @description=0A=
   * This method is getter only.=0A=
   *=0A=
   * Return full url representation with all segments encoded according =
to rules specified in=0A=
   * [RFC 3986](http://www.ietf.org/rfc/rfc3986.txt).=0A=
   *=0A=
   * @return {string} full url=0A=
   */=0A=
  absUrl: locationGetter('$$absUrl'),=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $location#url=0A=
   *=0A=
   * @description=0A=
   * This method is getter / setter.=0A=
   *=0A=
   * Return url (e.g. `/path?a=3Db#hash`) when called without any =
parameter.=0A=
   *=0A=
   * Change path, search and hash, when called with parameter and return =
`$location`.=0A=
   *=0A=
   * @param {string=3D} url New url without base prefix (e.g. =
`/path?a=3Db#hash`)=0A=
   * @return {string} url=0A=
   */=0A=
  url: function(url) {=0A=
    if (isUndefined(url))=0A=
      return this.$$url;=0A=
=0A=
    var match =3D PATH_MATCH.exec(url);=0A=
    if (match[1]) this.path(decodeURIComponent(match[1]));=0A=
    if (match[2] || match[1]) this.search(match[3] || '');=0A=
    this.hash(match[5] || '');=0A=
=0A=
    return this;=0A=
  },=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $location#protocol=0A=
   *=0A=
   * @description=0A=
   * This method is getter only.=0A=
   *=0A=
   * Return protocol of current url.=0A=
   *=0A=
   * @return {string} protocol of current url=0A=
   */=0A=
  protocol: locationGetter('$$protocol'),=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $location#host=0A=
   *=0A=
   * @description=0A=
   * This method is getter only.=0A=
   *=0A=
   * Return host of current url.=0A=
   *=0A=
   * @return {string} host of current url.=0A=
   */=0A=
  host: locationGetter('$$host'),=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $location#port=0A=
   *=0A=
   * @description=0A=
   * This method is getter only.=0A=
   *=0A=
   * Return port of current url.=0A=
   *=0A=
   * @return {Number} port=0A=
   */=0A=
  port: locationGetter('$$port'),=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $location#path=0A=
   *=0A=
   * @description=0A=
   * This method is getter / setter.=0A=
   *=0A=
   * Return path of current url when called without any parameter.=0A=
   *=0A=
   * Change path when called with parameter and return `$location`.=0A=
   *=0A=
   * Note: Path should always begin with forward slash (/), this method =
will add the forward slash=0A=
   * if it is missing.=0A=
   *=0A=
   * @param {(string|number)=3D} path New path=0A=
   * @return {string} path=0A=
   */=0A=
  path: locationGetterSetter('$$path', function(path) {=0A=
    path =3D path !=3D=3D null ? path.toString() : '';=0A=
    return path.charAt(0) =3D=3D '/' ? path : '/' + path;=0A=
  }),=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $location#search=0A=
   *=0A=
   * @description=0A=
   * This method is getter / setter.=0A=
   *=0A=
   * Return search part (as object) of current url when called without =
any parameter.=0A=
   *=0A=
   * Change search part when called with parameter and return =
`$location`.=0A=
   *=0A=
   *=0A=
   * ```js=0A=
   * // given url http://example.com/#/some/path?foo=3Dbar&amp;baz=3Dxoxo=0A=
   * var searchObject =3D $location.search();=0A=
   * // =3D&gt; {foo: 'bar', baz: 'xoxo'}=0A=
   *=0A=
   *=0A=
   * // set foo to 'yipee'=0A=
   * $location.search('foo', 'yipee');=0A=
   * // =3D&gt; $location=0A=
   * ```=0A=
   *=0A=
   * @param =
{string|Object.&lt;string&gt;|Object.&lt;Array.&lt;string&gt;&gt;} =
search New search params - string or=0A=
   * hash object.=0A=
   *=0A=
   * When called with a single argument the method acts as a setter, =
setting the `search` component=0A=
   * of `$location` to the specified value.=0A=
   *=0A=
   * If the argument is a hash object containing an array of values, =
these values will be encoded=0A=
   * as duplicate search parameters in the url.=0A=
   *=0A=
   * @param {(string|Number|Array&lt;string&gt;|boolean)=3D} paramValue =
If `search` is a string or number, then `paramValue`=0A=
   * will override only a single search property.=0A=
   *=0A=
   * If `paramValue` is an array, it will override the property of the =
`search` component of=0A=
   * `$location` specified via the first argument.=0A=
   *=0A=
   * If `paramValue` is `null`, the property specified via the first =
argument will be deleted.=0A=
   *=0A=
   * If `paramValue` is `true`, the property specified via the first =
argument will be added with no=0A=
   * value nor trailing equal sign.=0A=
   *=0A=
   * @return {Object} If called with no arguments returns the parsed =
`search` object. If called with=0A=
   * one or more arguments returns `$location` object itself.=0A=
   */=0A=
  search: function(search, paramValue) {=0A=
    switch (arguments.length) {=0A=
      case 0:=0A=
        return this.$$search;=0A=
      case 1:=0A=
        if (isString(search) || isNumber(search)) {=0A=
          search =3D search.toString();=0A=
          this.$$search =3D parseKeyValue(search);=0A=
        } else if (isObject(search)) {=0A=
          search =3D copy(search, {});=0A=
          // remove object undefined or null properties=0A=
          forEach(search, function(value, key) {=0A=
            if (value =3D=3D null) delete search[key];=0A=
          });=0A=
=0A=
          this.$$search =3D search;=0A=
        } else {=0A=
          throw $locationMinErr('isrcharg',=0A=
              'The first argument of the `$location#search()` call must =
be a string or an object.');=0A=
        }=0A=
        break;=0A=
      default:=0A=
        if (isUndefined(paramValue) || paramValue =3D=3D=3D null) {=0A=
          delete this.$$search[search];=0A=
        } else {=0A=
          this.$$search[search] =3D paramValue;=0A=
        }=0A=
    }=0A=
=0A=
    this.$$compose();=0A=
    return this;=0A=
  },=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $location#hash=0A=
   *=0A=
   * @description=0A=
   * This method is getter / setter.=0A=
   *=0A=
   * Return hash fragment when called without any parameter.=0A=
   *=0A=
   * Change hash fragment when called with parameter and return =
`$location`.=0A=
   *=0A=
   * @param {(string|number)=3D} hash New hash fragment=0A=
   * @return {string} hash=0A=
   */=0A=
  hash: locationGetterSetter('$$hash', function(hash) {=0A=
    return hash !=3D=3D null ? hash.toString() : '';=0A=
  }),=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $location#replace=0A=
   *=0A=
   * @description=0A=
   * If called, all changes to $location during current `$digest` will =
be replacing current history=0A=
   * record, instead of adding new one.=0A=
   */=0A=
  replace: function() {=0A=
    this.$$replace =3D true;=0A=
    return this;=0A=
  }=0A=
};=0A=
=0A=
forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, =
LocationHtml5Url], function (Location) {=0A=
  Location.prototype =3D Object.create(locationPrototype);=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $location#state=0A=
   *=0A=
   * @description=0A=
   * This method is getter / setter.=0A=
   *=0A=
   * Return the history state object when called without any parameter.=0A=
   *=0A=
   * Change the history state object when called with one parameter and =
return `$location`.=0A=
   * The state object is later passed to `pushState` or `replaceState`.=0A=
   *=0A=
   * NOTE: This method is supported only in HTML5 mode and only in =
browsers supporting=0A=
   * the HTML5 History API (i.e. methods `pushState` and =
`replaceState`). If you need to support=0A=
   * older browsers (like IE9 or Android &lt; 4.0), don't use this =
method.=0A=
   *=0A=
   * @param {object=3D} state State object for pushState or replaceState=0A=
   * @return {object} state=0A=
   */=0A=
  Location.prototype.state =3D function(state) {=0A=
    if (!arguments.length)=0A=
      return this.$$state;=0A=
=0A=
    if (Location !=3D=3D LocationHtml5Url || !this.$$html5) {=0A=
      throw $locationMinErr('nostate', 'History API state support is =
available only ' +=0A=
        'in HTML5 mode and only in browsers supporting HTML5 History =
API');=0A=
    }=0A=
    // The user might modify `stateObject` after invoking =
`$location.state(stateObject)`=0A=
    // but we're changing the $$state reference to $browser.state() =
during the $digest=0A=
    // so the modification window is narrow.=0A=
    this.$$state =3D isUndefined(state) ? null : state;=0A=
=0A=
    return this;=0A=
  };=0A=
});=0A=
=0A=
=0A=
function locationGetter(property) {=0A=
  return function() {=0A=
    return this[property];=0A=
  };=0A=
}=0A=
=0A=
=0A=
function locationGetterSetter(property, preprocess) {=0A=
  return function(value) {=0A=
    if (isUndefined(value))=0A=
      return this[property];=0A=
=0A=
    this[property] =3D preprocess(value);=0A=
    this.$$compose();=0A=
=0A=
    return this;=0A=
  };=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $location=0A=
 *=0A=
 * @requires $rootElement=0A=
 *=0A=
 * @description=0A=
 * The $location service parses the URL in the browser address bar =
(based on the=0A=
 * [window.location](https://developer.mozilla.org/en/window.location)) =
and makes the URL=0A=
 * available to your application. Changes to the URL in the address bar =
are reflected into=0A=
 * $location service and changes to $location are reflected into the =
browser address bar.=0A=
 *=0A=
 * **The $location service:**=0A=
 *=0A=
 * - Exposes the current URL in the browser address bar, so you can=0A=
 *   - Watch and observe the URL.=0A=
 *   - Change the URL.=0A=
 * - Synchronizes the URL with the browser when the user=0A=
 *   - Changes the address bar.=0A=
 *   - Clicks the back or forward button (or clicks a History link).=0A=
 *   - Clicks on a link.=0A=
 * - Represents the URL object as a set of methods (protocol, host, =
port, path, search, hash).=0A=
 *=0A=
 * For more information see {@link guide/$location Developer Guide: =
Using $location}=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $locationProvider=0A=
 * @description=0A=
 * Use the `$locationProvider` to configure how the application deep =
linking paths are stored.=0A=
 */=0A=
function $LocationProvider(){=0A=
  var hashPrefix =3D '',=0A=
      html5Mode =3D {=0A=
        enabled: false,=0A=
        requireBase: true,=0A=
        rewriteLinks: true=0A=
      };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $locationProvider#hashPrefix=0A=
   * @description=0A=
   * @param {string=3D} prefix Prefix for hash part (containing path and =
search)=0A=
   * @returns {*} current value if used as getter or itself (chaining) =
if used as setter=0A=
   */=0A=
  this.hashPrefix =3D function(prefix) {=0A=
    if (isDefined(prefix)) {=0A=
      hashPrefix =3D prefix;=0A=
      return this;=0A=
    } else {=0A=
      return hashPrefix;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $locationProvider#html5Mode=0A=
   * @description=0A=
   * @param {(boolean|Object)=3D} mode If boolean, sets =
`html5Mode.enabled` to value.=0A=
   *   If object, sets `enabled`, `requireBase` and `rewriteLinks` to =
respective values. Supported=0A=
   *   properties:=0A=
   *   - **enabled** =E2=80&#65533; `{boolean}` =E2=80&#65533; (default: =
false) If true, will rely on `history.pushState` to=0A=
   *     change urls where supported. Will fall back to hash-prefixed =
paths in browsers that do not=0A=
   *     support `pushState`.=0A=
   *   - **requireBase** - `{boolean}` - (default: `true`) When =
html5Mode is enabled, specifies=0A=
   *     whether or not a &lt;base&gt; tag is required to be present. If =
`enabled` and `requireBase` are=0A=
   *     true, and a base tag is not present, an error will be thrown =
when `$location` is injected.=0A=
   *     See the {@link guide/$location $location guide for more =
information}=0A=
   *   - **rewriteLinks** - `{boolean}` - (default: `true`) When =
html5Mode is enabled,=0A=
   *     enables/disables url rewriting for relative links.=0A=
   *=0A=
   * @returns {Object} html5Mode object if used as getter or itself =
(chaining) if used as setter=0A=
   */=0A=
  this.html5Mode =3D function(mode) {=0A=
    if (isBoolean(mode)) {=0A=
      html5Mode.enabled =3D mode;=0A=
      return this;=0A=
    } else if (isObject(mode)) {=0A=
=0A=
      if (isBoolean(mode.enabled)) {=0A=
        html5Mode.enabled =3D mode.enabled;=0A=
      }=0A=
=0A=
      if (isBoolean(mode.requireBase)) {=0A=
        html5Mode.requireBase =3D mode.requireBase;=0A=
      }=0A=
=0A=
      if (isBoolean(mode.rewriteLinks)) {=0A=
        html5Mode.rewriteLinks =3D mode.rewriteLinks;=0A=
      }=0A=
=0A=
      return this;=0A=
    } else {=0A=
      return html5Mode;=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc event=0A=
   * @name $location#$locationChangeStart=0A=
   * @eventType broadcast on root scope=0A=
   * @description=0A=
   * Broadcasted before a URL will change.=0A=
   *=0A=
   * This change can be prevented by calling=0A=
   * `preventDefault` method of the event. See {@link =
ng.$rootScope.Scope#$on} for more=0A=
   * details about event object. Upon successful change=0A=
   * {@link ng.$location#$locationChangeSuccess $locationChangeSuccess} =
is fired.=0A=
   *=0A=
   * The `newState` and `oldState` parameters may be defined only in =
HTML5 mode and when=0A=
   * the browser supports the HTML5 History API.=0A=
   *=0A=
   * @param {Object} angularEvent Synthetic event object.=0A=
   * @param {string} newUrl New URL=0A=
   * @param {string=3D} oldUrl URL that was before it was changed.=0A=
   * @param {string=3D} newState New history state object=0A=
   * @param {string=3D} oldState History state object that was before it =
was changed.=0A=
   */=0A=
=0A=
  /**=0A=
   * @ngdoc event=0A=
   * @name $location#$locationChangeSuccess=0A=
   * @eventType broadcast on root scope=0A=
   * @description=0A=
   * Broadcasted after a URL was changed.=0A=
   *=0A=
   * The `newState` and `oldState` parameters may be defined only in =
HTML5 mode and when=0A=
   * the browser supports the HTML5 History API.=0A=
   *=0A=
   * @param {Object} angularEvent Synthetic event object.=0A=
   * @param {string} newUrl New URL=0A=
   * @param {string=3D} oldUrl URL that was before it was changed.=0A=
   * @param {string=3D} newState New history state object=0A=
   * @param {string=3D} oldState History state object that was before it =
was changed.=0A=
   */=0A=
=0A=
  this.$get =3D ['$rootScope', '$browser', '$sniffer', '$rootElement',=0A=
      function( $rootScope,   $browser,   $sniffer,   $rootElement) {=0A=
    var $location,=0A=
        LocationMode,=0A=
        baseHref =3D $browser.baseHref(), // if base[href] is undefined, =
it defaults to ''=0A=
        initialUrl =3D $browser.url(),=0A=
        appBase;=0A=
=0A=
    if (html5Mode.enabled) {=0A=
      if (!baseHref &amp;&amp; html5Mode.requireBase) {=0A=
        throw $locationMinErr('nobase',=0A=
          "$location in HTML5 mode requires a &lt;base&gt; tag to be =
present!");=0A=
      }=0A=
      appBase =3D serverBase(initialUrl) + (baseHref || '/');=0A=
      LocationMode =3D $sniffer.history ? LocationHtml5Url : =
LocationHashbangInHtml5Url;=0A=
    } else {=0A=
      appBase =3D stripHash(initialUrl);=0A=
      LocationMode =3D LocationHashbangUrl;=0A=
    }=0A=
    $location =3D new LocationMode(appBase, '#' + hashPrefix);=0A=
    $location.$$parseLinkUrl(initialUrl, initialUrl);=0A=
=0A=
    $location.$$state =3D $browser.state();=0A=
=0A=
    var IGNORE_URI_REGEXP =3D /^\s*(javascript|mailto):/i;=0A=
=0A=
    function setBrowserUrlWithFallback(url, replace, state) {=0A=
      var oldUrl =3D $location.url();=0A=
      var oldState =3D $location.$$state;=0A=
      try {=0A=
        $browser.url(url, replace, state);=0A=
=0A=
        // Make sure $location.state() returns referentially identical =
(not just deeply equal)=0A=
        // state object; this makes possible quick checking if the state =
changed in the digest=0A=
        // loop. Checking deep equality would be too expensive.=0A=
        $location.$$state =3D $browser.state();=0A=
      } catch (e) {=0A=
        // Restore old values if pushState fails=0A=
        $location.url(oldUrl);=0A=
        $location.$$state =3D oldState;=0A=
=0A=
        throw e;=0A=
      }=0A=
    }=0A=
=0A=
    $rootElement.on('click', function(event) {=0A=
      // TODO(vojta): rewrite link when opening in new tab/window (in =
legacy browser)=0A=
      // currently we open nice url link and redirect then=0A=
=0A=
      if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || =
event.which =3D=3D 2) return;=0A=
=0A=
      var elm =3D jqLite(event.target);=0A=
=0A=
      // traverse the DOM up to find first A tag=0A=
      while (nodeName_(elm[0]) !=3D=3D 'a') {=0A=
        // ignore rewriting if no A tag (reached root element, or no =
parent - removed from document)=0A=
        if (elm[0] =3D=3D=3D $rootElement[0] || !(elm =3D =
elm.parent())[0]) return;=0A=
      }=0A=
=0A=
      var absHref =3D elm.prop('href');=0A=
      // get the actual href attribute - see=0A=
      // =
http://msdn.microsoft.com/en-us/library/ie/dd347148(v=3Dvs.85).aspx=0A=
      var relHref =3D elm.attr('href') || elm.attr('xlink:href');=0A=
=0A=
      if (isObject(absHref) &amp;&amp; absHref.toString() =3D=3D=3D =
'[object SVGAnimatedString]') {=0A=
        // SVGAnimatedString.animVal should be identical to =
SVGAnimatedString.baseVal, unless during=0A=
        // an animation.=0A=
        absHref =3D urlResolve(absHref.animVal).href;=0A=
      }=0A=
=0A=
      // Ignore when url is started with javascript: or mailto:=0A=
      if (IGNORE_URI_REGEXP.test(absHref)) return;=0A=
=0A=
      if (absHref &amp;&amp; !elm.attr('target') &amp;&amp; =
!event.isDefaultPrevented()) {=0A=
        if ($location.$$parseLinkUrl(absHref, relHref)) {=0A=
          // We do a preventDefault for all urls that are part of the =
angular application,=0A=
          // in html5mode and also without, so that we are able to abort =
navigation without=0A=
          // getting double entries in the location history.=0A=
          event.preventDefault();=0A=
          // update location manually=0A=
          if ($location.absUrl() !=3D $browser.url()) {=0A=
            $rootScope.$apply();=0A=
            // hack to work around FF6 bug 684208 when scenario runner =
clicks on links=0A=
            window.angular['ff-684208-preventDefault'] =3D true;=0A=
          }=0A=
        }=0A=
      }=0A=
    });=0A=
=0A=
=0A=
    // rewrite hashbang url &lt;&gt; html5 url=0A=
    if ($location.absUrl() !=3D initialUrl) {=0A=
      $browser.url($location.absUrl(), true);=0A=
    }=0A=
=0A=
    var initializing =3D true;=0A=
=0A=
    // update $location when $browser url changes=0A=
    $browser.onUrlChange(function(newUrl, newState) {=0A=
      $rootScope.$evalAsync(function() {=0A=
        var oldUrl =3D $location.absUrl();=0A=
        var oldState =3D $location.$$state;=0A=
=0A=
        $location.$$parse(newUrl);=0A=
        $location.$$state =3D newState;=0A=
        if ($rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl,=0A=
            newState, oldState).defaultPrevented) {=0A=
          $location.$$parse(oldUrl);=0A=
          $location.$$state =3D oldState;=0A=
          setBrowserUrlWithFallback(oldUrl, false, oldState);=0A=
        } else {=0A=
          initializing =3D false;=0A=
          afterLocationChange(oldUrl, oldState);=0A=
        }=0A=
      });=0A=
      if (!$rootScope.$$phase) $rootScope.$digest();=0A=
    });=0A=
=0A=
    // update browser=0A=
    $rootScope.$watch(function $locationWatch() {=0A=
      var oldUrl =3D $browser.url();=0A=
      var oldState =3D $browser.state();=0A=
      var currentReplace =3D $location.$$replace;=0A=
      var urlOrStateChanged =3D oldUrl !=3D=3D $location.absUrl() ||=0A=
        ($location.$$html5 &amp;&amp; $sniffer.history &amp;&amp; =
oldState !=3D=3D $location.$$state);=0A=
=0A=
      if (initializing || urlOrStateChanged) {=0A=
        initializing =3D false;=0A=
=0A=
        $rootScope.$evalAsync(function() {=0A=
          if ($rootScope.$broadcast('$locationChangeStart', =
$location.absUrl(), oldUrl,=0A=
              $location.$$state, oldState).defaultPrevented) {=0A=
            $location.$$parse(oldUrl);=0A=
            $location.$$state =3D oldState;=0A=
          } else {=0A=
            if (urlOrStateChanged) {=0A=
              setBrowserUrlWithFallback($location.absUrl(), =
currentReplace,=0A=
                                        oldState =3D=3D=3D =
$location.$$state ? null : $location.$$state);=0A=
            }=0A=
            afterLocationChange(oldUrl, oldState);=0A=
          }=0A=
        });=0A=
      }=0A=
=0A=
      $location.$$replace =3D false;=0A=
=0A=
      // we don't need to return anything because $evalAsync will make =
the digest loop dirty when=0A=
      // there is a change=0A=
    });=0A=
=0A=
    return $location;=0A=
=0A=
    function afterLocationChange(oldUrl, oldState) {=0A=
      $rootScope.$broadcast('$locationChangeSuccess', =
$location.absUrl(), oldUrl,=0A=
        $location.$$state, oldState);=0A=
    }=0A=
}];=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $log=0A=
 * @requires $window=0A=
 *=0A=
 * @description=0A=
 * Simple service for logging. Default implementation safely writes the =
message=0A=
 * into the browser's console (if present).=0A=
 *=0A=
 * The main purpose of this service is to simplify debugging and =
troubleshooting.=0A=
 *=0A=
 * The default is to log `debug` messages. You can use=0A=
 * {@link ng.$logProvider ng.$logProvider#debugEnabled} to change this.=0A=
 *=0A=
 * @example=0A=
   &lt;example module=3D"logExample"&gt;=0A=
     &lt;file name=3D"script.js"&gt;=0A=
       angular.module('logExample', [])=0A=
         .controller('LogController', ['$scope', '$log', =
function($scope, $log) {=0A=
           $scope.$log =3D $log;=0A=
           $scope.message =3D 'Hello World!';=0A=
         }]);=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
       &lt;div ng-controller=3D"LogController"&gt;=0A=
         &lt;p&gt;Reload this page with open console, enter text and hit =
the log button...&lt;/p&gt;=0A=
         Message:=0A=
         &lt;input type=3D"text" ng-model=3D"message"/&gt;=0A=
         &lt;button ng-click=3D"$log.log(message)"&gt;log&lt;/button&gt;=0A=
         &lt;button =
ng-click=3D"$log.warn(message)"&gt;warn&lt;/button&gt;=0A=
         &lt;button =
ng-click=3D"$log.info(message)"&gt;info&lt;/button&gt;=0A=
         &lt;button =
ng-click=3D"$log.error(message)"&gt;error&lt;/button&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $logProvider=0A=
 * @description=0A=
 * Use the `$logProvider` to configure how the application logs messages=0A=
 */=0A=
function $LogProvider(){=0A=
  var debug =3D true,=0A=
      self =3D this;=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $logProvider#debugEnabled=0A=
   * @description=0A=
   * @param {boolean=3D} flag enable or disable debug level messages=0A=
   * @returns {*} current value if used as getter or itself (chaining) =
if used as setter=0A=
   */=0A=
  this.debugEnabled =3D function(flag) {=0A=
    if (isDefined(flag)) {=0A=
      debug =3D flag;=0A=
    return this;=0A=
    } else {=0A=
      return debug;=0A=
    }=0A=
  };=0A=
=0A=
  this.$get =3D ['$window', function($window){=0A=
    return {=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $log#log=0A=
       *=0A=
       * @description=0A=
       * Write a log message=0A=
       */=0A=
      log: consoleLog('log'),=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $log#info=0A=
       *=0A=
       * @description=0A=
       * Write an information message=0A=
       */=0A=
      info: consoleLog('info'),=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $log#warn=0A=
       *=0A=
       * @description=0A=
       * Write a warning message=0A=
       */=0A=
      warn: consoleLog('warn'),=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $log#error=0A=
       *=0A=
       * @description=0A=
       * Write an error message=0A=
       */=0A=
      error: consoleLog('error'),=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $log#debug=0A=
       *=0A=
       * @description=0A=
       * Write a debug message=0A=
       */=0A=
      debug: (function () {=0A=
        var fn =3D consoleLog('debug');=0A=
=0A=
        return function() {=0A=
          if (debug) {=0A=
            fn.apply(self, arguments);=0A=
          }=0A=
        };=0A=
      }())=0A=
    };=0A=
=0A=
    function formatError(arg) {=0A=
      if (arg instanceof Error) {=0A=
        if (arg.stack) {=0A=
          arg =3D (arg.message &amp;&amp; arg.stack.indexOf(arg.message) =
=3D=3D=3D -1)=0A=
              ? 'Error: ' + arg.message + '\n' + arg.stack=0A=
              : arg.stack;=0A=
        } else if (arg.sourceURL) {=0A=
          arg =3D arg.message + '\n' + arg.sourceURL + ':' + arg.line;=0A=
        }=0A=
      }=0A=
      return arg;=0A=
    }=0A=
=0A=
    function consoleLog(type) {=0A=
      var console =3D $window.console || {},=0A=
          logFn =3D console[type] || console.log || noop,=0A=
          hasApply =3D false;=0A=
=0A=
      // Note: reading logFn.apply throws an error in IE11 in IE8 =
document mode.=0A=
      // The reason behind this is that console.log has type "object" in =
IE8...=0A=
      try {=0A=
        hasApply =3D !!logFn.apply;=0A=
      } catch (e) {}=0A=
=0A=
      if (hasApply) {=0A=
        return function() {=0A=
          var args =3D [];=0A=
          forEach(arguments, function(arg) {=0A=
            args.push(formatError(arg));=0A=
          });=0A=
          return logFn.apply(console, args);=0A=
        };=0A=
      }=0A=
=0A=
      // we are IE which either doesn't have window.console =3D&gt; this =
is noop and we do nothing,=0A=
      // or we are IE where console.log doesn't have apply so we log at =
least first 2 args=0A=
      return function(arg1, arg2) {=0A=
        logFn(arg1, arg2 =3D=3D null ? '' : arg2);=0A=
      };=0A=
    }=0A=
  }];=0A=
}=0A=
=0A=
var $parseMinErr =3D minErr('$parse');=0A=
=0A=
// Sandboxing Angular Expressions=0A=
// ------------------------------=0A=
// Angular expressions are generally considered safe because these =
expressions only have direct=0A=
// access to $scope and locals. However, one can obtain the ability to =
execute arbitrary JS code by=0A=
// obtaining a reference to native JS functions such as the Function =
constructor.=0A=
//=0A=
// As an example, consider the following Angular expression:=0A=
//=0A=
//   {}.toString.constructor('alert("evil JS code")')=0A=
//=0A=
// This sandboxing technique is not perfect and doesn't aim to be. The =
goal is to prevent exploits=0A=
// against the expression language, but not to prevent exploits that =
were enabled by exposing=0A=
// sensitive JavaScript or browser apis on Scope. Exposing such objects =
on a Scope is never a good=0A=
// practice and therefore we are not even trying to protect against =
interaction with an object=0A=
// explicitly exposed in this way.=0A=
//=0A=
// In general, it is not possible to access a Window object from an =
angular expression unless a=0A=
// window or some DOM object that has a reference to window is published =
onto a Scope.=0A=
// Similarly we prevent invocations of function known to be dangerous, =
as well as assignments to=0A=
// native objects.=0A=
=0A=
=0A=
function ensureSafeMemberName(name, fullExpression) {=0A=
  if (name =3D=3D=3D "__defineGetter__" || name =3D=3D=3D =
"__defineSetter__"=0A=
      || name =3D=3D=3D "__lookupGetter__" || name =3D=3D=3D =
"__lookupSetter__"=0A=
      || name =3D=3D=3D "__proto__") {=0A=
    throw $parseMinErr('isecfld',=0A=
        'Attempting to access a disallowed field in Angular expressions! =
'=0A=
        +'Expression: {0}', fullExpression);=0A=
  }=0A=
  return name;=0A=
}=0A=
=0A=
function ensureSafeObject(obj, fullExpression) {=0A=
  // nifty check if obj is Function that is fast and works across =
iframes and other contexts=0A=
  if (obj) {=0A=
    if (obj.constructor =3D=3D=3D obj) {=0A=
      throw $parseMinErr('isecfn',=0A=
          'Referencing Function in Angular expressions is disallowed! =
Expression: {0}',=0A=
          fullExpression);=0A=
    } else if (// isWindow(obj)=0A=
        obj.window =3D=3D=3D obj) {=0A=
      throw $parseMinErr('isecwindow',=0A=
          'Referencing the Window in Angular expressions is disallowed! =
Expression: {0}',=0A=
          fullExpression);=0A=
    } else if (// isElement(obj)=0A=
        obj.children &amp;&amp; (obj.nodeName || (obj.prop &amp;&amp; =
obj.attr &amp;&amp; obj.find))) {=0A=
      throw $parseMinErr('isecdom',=0A=
          'Referencing DOM nodes in Angular expressions is disallowed! =
Expression: {0}',=0A=
          fullExpression);=0A=
    } else if (// block Object so that we can't get hold of dangerous =
Object.* methods=0A=
        obj =3D=3D=3D Object) {=0A=
      throw $parseMinErr('isecobj',=0A=
          'Referencing Object in Angular expressions is disallowed! =
Expression: {0}',=0A=
          fullExpression);=0A=
    }=0A=
  }=0A=
  return obj;=0A=
}=0A=
=0A=
var CALL =3D Function.prototype.call;=0A=
var APPLY =3D Function.prototype.apply;=0A=
var BIND =3D Function.prototype.bind;=0A=
=0A=
function ensureSafeFunction(obj, fullExpression) {=0A=
  if (obj) {=0A=
    if (obj.constructor =3D=3D=3D obj) {=0A=
      throw $parseMinErr('isecfn',=0A=
        'Referencing Function in Angular expressions is disallowed! =
Expression: {0}',=0A=
        fullExpression);=0A=
    } else if (obj =3D=3D=3D CALL || obj =3D=3D=3D APPLY || obj =
=3D=3D=3D BIND) {=0A=
      throw $parseMinErr('isecff',=0A=
        'Referencing call, apply or bind in Angular expressions is =
disallowed! Expression: {0}',=0A=
        fullExpression);=0A=
    }=0A=
  }=0A=
}=0A=
=0A=
//Keyword constants=0A=
var CONSTANTS =3D createMap();=0A=
forEach({=0A=
  'null': function() { return null; },=0A=
  'true': function() { return true; },=0A=
  'false': function() { return false; },=0A=
  'undefined': function() {}=0A=
}, function(constantGetter, name) {=0A=
  constantGetter.constant =3D constantGetter.literal =3D =
constantGetter.sharedGetter =3D true;=0A=
  CONSTANTS[name] =3D constantGetter;=0A=
});=0A=
=0A=
//Not quite a constant, but can be lex/parsed the same=0A=
CONSTANTS['this'] =3D function(self) { return self; };=0A=
CONSTANTS['this'].sharedGetter =3D true;=0A=
=0A=
=0A=
//Operators - will be wrapped by binaryFn/unaryFn/assignment/filter=0A=
var OPERATORS =3D extend(createMap(), {=0A=
    '+':function(self, locals, a,b){=0A=
      a=3Da(self, locals); b=3Db(self, locals);=0A=
      if (isDefined(a)) {=0A=
        if (isDefined(b)) {=0A=
          return a + b;=0A=
        }=0A=
        return a;=0A=
      }=0A=
      return isDefined(b)?b:undefined;},=0A=
    '-':function(self, locals, a,b){=0A=
          a=3Da(self, locals); b=3Db(self, locals);=0A=
          return (isDefined(a)?a:0)-(isDefined(b)?b:0);=0A=
        },=0A=
    '*':function(self, locals, a,b){return a(self, locals)*b(self, =
locals);},=0A=
    '/':function(self, locals, a,b){return a(self, locals)/b(self, =
locals);},=0A=
    '%':function(self, locals, a,b){return a(self, locals)%b(self, =
locals);},=0A=
    '=3D=3D=3D':function(self, locals, a, b){return a(self, =
locals)=3D=3D=3Db(self, locals);},=0A=
    '!=3D=3D':function(self, locals, a, b){return a(self, =
locals)!=3D=3Db(self, locals);},=0A=
    '=3D=3D':function(self, locals, a,b){return a(self, =
locals)=3D=3Db(self, locals);},=0A=
    '!=3D':function(self, locals, a,b){return a(self, locals)!=3Db(self, =
locals);},=0A=
    '&lt;':function(self, locals, a,b){return a(self, locals)&lt;b(self, =
locals);},=0A=
    '&gt;':function(self, locals, a,b){return a(self, locals)&gt;b(self, =
locals);},=0A=
    '&lt;=3D':function(self, locals, a,b){return a(self, =
locals)&lt;=3Db(self, locals);},=0A=
    '&gt;=3D':function(self, locals, a,b){return a(self, =
locals)&gt;=3Db(self, locals);},=0A=
    '&amp;&amp;':function(self, locals, a,b){return a(self, =
locals)&amp;&amp;b(self, locals);},=0A=
    '||':function(self, locals, a,b){return a(self, locals)||b(self, =
locals);},=0A=
    '!':function(self, locals, a){return !a(self, locals);},=0A=
=0A=
    //Tokenized as operators but parsed as assignment/filters=0A=
    '=3D':true,=0A=
    '|':true=0A=
});=0A=
var ESCAPE =3D {"n":"\n", "f":"\f", "r":"\r", "t":"\t", "v":"\v", =
"'":"'", '"':'"'};=0A=
=0A=
=0A=
/////////////////////////////////////////=0A=
=0A=
=0A=
/**=0A=
 * @constructor=0A=
 */=0A=
var Lexer =3D function (options) {=0A=
  this.options =3D options;=0A=
};=0A=
=0A=
Lexer.prototype =3D {=0A=
  constructor: Lexer,=0A=
=0A=
  lex: function (text) {=0A=
    this.text =3D text;=0A=
    this.index =3D 0;=0A=
    this.ch =3D undefined;=0A=
    this.tokens =3D [];=0A=
=0A=
    while (this.index &lt; this.text.length) {=0A=
      this.ch =3D this.text.charAt(this.index);=0A=
      if (this.is('"\'')) {=0A=
        this.readString(this.ch);=0A=
      } else if (this.isNumber(this.ch) || this.is('.') &amp;&amp; =
this.isNumber(this.peek())) {=0A=
        this.readNumber();=0A=
      } else if (this.isIdent(this.ch)) {=0A=
        this.readIdent();=0A=
      } else if (this.is('(){}[].,;:?')) {=0A=
        this.tokens.push({=0A=
          index: this.index,=0A=
          text: this.ch=0A=
        });=0A=
        this.index++;=0A=
      } else if (this.isWhitespace(this.ch)) {=0A=
        this.index++;=0A=
      } else {=0A=
        var ch2 =3D this.ch + this.peek();=0A=
        var ch3 =3D ch2 + this.peek(2);=0A=
        var fn =3D OPERATORS[this.ch];=0A=
        var fn2 =3D OPERATORS[ch2];=0A=
        var fn3 =3D OPERATORS[ch3];=0A=
        if (fn3) {=0A=
          this.tokens.push({index: this.index, text: ch3, fn: fn3});=0A=
          this.index +=3D 3;=0A=
        } else if (fn2) {=0A=
          this.tokens.push({index: this.index, text: ch2, fn: fn2});=0A=
          this.index +=3D 2;=0A=
        } else if (fn) {=0A=
          this.tokens.push({=0A=
            index: this.index,=0A=
            text: this.ch,=0A=
            fn: fn=0A=
          });=0A=
          this.index +=3D 1;=0A=
        } else {=0A=
          this.throwError('Unexpected next character ', this.index, =
this.index + 1);=0A=
        }=0A=
      }=0A=
    }=0A=
    return this.tokens;=0A=
  },=0A=
=0A=
  is: function(chars) {=0A=
    return chars.indexOf(this.ch) !=3D=3D -1;=0A=
  },=0A=
=0A=
  peek: function(i) {=0A=
    var num =3D i || 1;=0A=
    return (this.index + num &lt; this.text.length) ? =
this.text.charAt(this.index + num) : false;=0A=
  },=0A=
=0A=
  isNumber: function(ch) {=0A=
    return ('0' &lt;=3D ch &amp;&amp; ch &lt;=3D '9');=0A=
  },=0A=
=0A=
  isWhitespace: function(ch) {=0A=
    // IE treats non-breaking space as \u00A0=0A=
    return (ch =3D=3D=3D ' ' || ch =3D=3D=3D '\r' || ch =3D=3D=3D '\t' ||=0A=
            ch =3D=3D=3D '\n' || ch =3D=3D=3D '\v' || ch =3D=3D=3D =
'\u00A0');=0A=
  },=0A=
=0A=
  isIdent: function(ch) {=0A=
    return ('a' &lt;=3D ch &amp;&amp; ch &lt;=3D 'z' ||=0A=
            'A' &lt;=3D ch &amp;&amp; ch &lt;=3D 'Z' ||=0A=
            '_' =3D=3D=3D ch || ch =3D=3D=3D '$');=0A=
  },=0A=
=0A=
  isExpOperator: function(ch) {=0A=
    return (ch =3D=3D=3D '-' || ch =3D=3D=3D '+' || this.isNumber(ch));=0A=
  },=0A=
=0A=
  throwError: function(error, start, end) {=0A=
    end =3D end || this.index;=0A=
    var colStr =3D (isDefined(start)=0A=
            ? 's ' + start +  '-' + this.index + ' [' + =
this.text.substring(start, end) + ']'=0A=
            : ' ' + end);=0A=
    throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in =
expression [{2}].',=0A=
        error, colStr, this.text);=0A=
  },=0A=
=0A=
  readNumber: function() {=0A=
    var number =3D '';=0A=
    var start =3D this.index;=0A=
    while (this.index &lt; this.text.length) {=0A=
      var ch =3D lowercase(this.text.charAt(this.index));=0A=
      if (ch =3D=3D '.' || this.isNumber(ch)) {=0A=
        number +=3D ch;=0A=
      } else {=0A=
        var peekCh =3D this.peek();=0A=
        if (ch =3D=3D 'e' &amp;&amp; this.isExpOperator(peekCh)) {=0A=
          number +=3D ch;=0A=
        } else if (this.isExpOperator(ch) &amp;&amp;=0A=
            peekCh &amp;&amp; this.isNumber(peekCh) &amp;&amp;=0A=
            number.charAt(number.length - 1) =3D=3D 'e') {=0A=
          number +=3D ch;=0A=
        } else if (this.isExpOperator(ch) &amp;&amp;=0A=
            (!peekCh || !this.isNumber(peekCh)) &amp;&amp;=0A=
            number.charAt(number.length - 1) =3D=3D 'e') {=0A=
          this.throwError('Invalid exponent');=0A=
        } else {=0A=
          break;=0A=
        }=0A=
      }=0A=
      this.index++;=0A=
    }=0A=
    number =3D 1 * number;=0A=
    this.tokens.push({=0A=
      index: start,=0A=
      text: number,=0A=
      constant: true,=0A=
      fn: function() { return number; }=0A=
    });=0A=
  },=0A=
=0A=
  readIdent: function() {=0A=
    var expression =3D this.text;=0A=
=0A=
    var ident =3D '';=0A=
    var start =3D this.index;=0A=
=0A=
    var lastDot, peekIndex, methodName, ch;=0A=
=0A=
    while (this.index &lt; this.text.length) {=0A=
      ch =3D this.text.charAt(this.index);=0A=
      if (ch =3D=3D=3D '.' || this.isIdent(ch) || this.isNumber(ch)) {=0A=
        if (ch =3D=3D=3D '.') lastDot =3D this.index;=0A=
        ident +=3D ch;=0A=
      } else {=0A=
        break;=0A=
      }=0A=
      this.index++;=0A=
    }=0A=
=0A=
    //check if the identifier ends with . and if so move back one char=0A=
    if (lastDot &amp;&amp; ident[ident.length - 1] =3D=3D=3D '.') {=0A=
      this.index--;=0A=
      ident =3D ident.slice(0, -1);=0A=
      lastDot =3D ident.lastIndexOf('.');=0A=
      if (lastDot =3D=3D=3D -1) {=0A=
        lastDot =3D undefined;=0A=
      }=0A=
    }=0A=
=0A=
    //check if this is not a method invocation and if it is back out to =
last dot=0A=
    if (lastDot) {=0A=
      peekIndex =3D this.index;=0A=
      while (peekIndex &lt; this.text.length) {=0A=
        ch =3D this.text.charAt(peekIndex);=0A=
        if (ch =3D=3D=3D '(') {=0A=
          methodName =3D ident.substr(lastDot - start + 1);=0A=
          ident =3D ident.substr(0, lastDot - start);=0A=
          this.index =3D peekIndex;=0A=
          break;=0A=
        }=0A=
        if (this.isWhitespace(ch)) {=0A=
          peekIndex++;=0A=
        } else {=0A=
          break;=0A=
        }=0A=
      }=0A=
    }=0A=
=0A=
    this.tokens.push({=0A=
      index: start,=0A=
      text: ident,=0A=
      fn: CONSTANTS[ident] || getterFn(ident, this.options, expression)=0A=
    });=0A=
=0A=
    if (methodName) {=0A=
      this.tokens.push({=0A=
        index: lastDot,=0A=
        text: '.'=0A=
      });=0A=
      this.tokens.push({=0A=
        index: lastDot + 1,=0A=
        text: methodName=0A=
      });=0A=
    }=0A=
  },=0A=
=0A=
  readString: function(quote) {=0A=
    var start =3D this.index;=0A=
    this.index++;=0A=
    var string =3D '';=0A=
    var rawString =3D quote;=0A=
    var escape =3D false;=0A=
    while (this.index &lt; this.text.length) {=0A=
      var ch =3D this.text.charAt(this.index);=0A=
      rawString +=3D ch;=0A=
      if (escape) {=0A=
        if (ch =3D=3D=3D 'u') {=0A=
          var hex =3D this.text.substring(this.index + 1, this.index + =
5);=0A=
          if (!hex.match(/[\da-f]{4}/i))=0A=
            this.throwError('Invalid unicode escape [\\u' + hex + ']');=0A=
          this.index +=3D 4;=0A=
          string +=3D String.fromCharCode(parseInt(hex, 16));=0A=
        } else {=0A=
          var rep =3D ESCAPE[ch];=0A=
          string =3D string + (rep || ch);=0A=
        }=0A=
        escape =3D false;=0A=
      } else if (ch =3D=3D=3D '\\') {=0A=
        escape =3D true;=0A=
      } else if (ch =3D=3D=3D quote) {=0A=
        this.index++;=0A=
        this.tokens.push({=0A=
          index: start,=0A=
          text: rawString,=0A=
          string: string,=0A=
          constant: true,=0A=
          fn: function() { return string; }=0A=
        });=0A=
        return;=0A=
      } else {=0A=
        string +=3D ch;=0A=
      }=0A=
      this.index++;=0A=
    }=0A=
    this.throwError('Unterminated quote', start);=0A=
  }=0A=
};=0A=
=0A=
=0A=
function isConstant(exp) {=0A=
  return exp.constant;=0A=
}=0A=
=0A=
/**=0A=
 * @constructor=0A=
 */=0A=
var Parser =3D function (lexer, $filter, options) {=0A=
  this.lexer =3D lexer;=0A=
  this.$filter =3D $filter;=0A=
  this.options =3D options;=0A=
};=0A=
=0A=
Parser.ZERO =3D extend(function () {=0A=
  return 0;=0A=
}, {=0A=
  sharedGetter: true,=0A=
  constant: true=0A=
});=0A=
=0A=
Parser.prototype =3D {=0A=
  constructor: Parser,=0A=
=0A=
  parse: function (text) {=0A=
    this.text =3D text;=0A=
    this.tokens =3D this.lexer.lex(text);=0A=
=0A=
    var value =3D this.statements();=0A=
=0A=
    if (this.tokens.length !=3D=3D 0) {=0A=
      this.throwError('is an unexpected token', this.tokens[0]);=0A=
    }=0A=
=0A=
    value.literal =3D !!value.literal;=0A=
    value.constant =3D !!value.constant;=0A=
=0A=
    return value;=0A=
  },=0A=
=0A=
  primary: function () {=0A=
    var primary;=0A=
    if (this.expect('(')) {=0A=
      primary =3D this.filterChain();=0A=
      this.consume(')');=0A=
    } else if (this.expect('[')) {=0A=
      primary =3D this.arrayDeclaration();=0A=
    } else if (this.expect('{')) {=0A=
      primary =3D this.object();=0A=
    } else {=0A=
      var token =3D this.expect();=0A=
      primary =3D token.fn;=0A=
      if (!primary) {=0A=
        this.throwError('not a primary expression', token);=0A=
      }=0A=
      if (token.constant) {=0A=
        primary.constant =3D true;=0A=
        primary.literal =3D true;=0A=
      }=0A=
    }=0A=
=0A=
    var next, context;=0A=
    while ((next =3D this.expect('(', '[', '.'))) {=0A=
      if (next.text =3D=3D=3D '(') {=0A=
        primary =3D this.functionCall(primary, context);=0A=
        context =3D null;=0A=
      } else if (next.text =3D=3D=3D '[') {=0A=
        context =3D primary;=0A=
        primary =3D this.objectIndex(primary);=0A=
      } else if (next.text =3D=3D=3D '.') {=0A=
        context =3D primary;=0A=
        primary =3D this.fieldAccess(primary);=0A=
      } else {=0A=
        this.throwError('IMPOSSIBLE');=0A=
      }=0A=
    }=0A=
    return primary;=0A=
  },=0A=
=0A=
  throwError: function(msg, token) {=0A=
    throw $parseMinErr('syntax',=0A=
        'Syntax Error: Token \'{0}\' {1} at column {2} of the expression =
[{3}] starting at [{4}].',=0A=
          token.text, msg, (token.index + 1), this.text, =
this.text.substring(token.index));=0A=
  },=0A=
=0A=
  peekToken: function() {=0A=
    if (this.tokens.length =3D=3D=3D 0)=0A=
      throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', =
this.text);=0A=
    return this.tokens[0];=0A=
  },=0A=
=0A=
  peek: function(e1, e2, e3, e4) {=0A=
    if (this.tokens.length &gt; 0) {=0A=
      var token =3D this.tokens[0];=0A=
      var t =3D token.text;=0A=
      if (t =3D=3D=3D e1 || t =3D=3D=3D e2 || t =3D=3D=3D e3 || t =
=3D=3D=3D e4 ||=0A=
          (!e1 &amp;&amp; !e2 &amp;&amp; !e3 &amp;&amp; !e4)) {=0A=
        return token;=0A=
      }=0A=
    }=0A=
    return false;=0A=
  },=0A=
=0A=
  expect: function(e1, e2, e3, e4){=0A=
    var token =3D this.peek(e1, e2, e3, e4);=0A=
    if (token) {=0A=
      this.tokens.shift();=0A=
      return token;=0A=
    }=0A=
    return false;=0A=
  },=0A=
=0A=
  consume: function(e1){=0A=
    if (!this.expect(e1)) {=0A=
      this.throwError('is unexpected, expecting [' + e1 + ']', =
this.peek());=0A=
    }=0A=
  },=0A=
=0A=
  unaryFn: function(fn, right) {=0A=
    return extend(function $parseUnaryFn(self, locals) {=0A=
      return fn(self, locals, right);=0A=
    }, {=0A=
      constant:right.constant,=0A=
      inputs: [right]=0A=
    });=0A=
  },=0A=
=0A=
  binaryFn: function(left, fn, right, isBranching) {=0A=
    return extend(function $parseBinaryFn(self, locals) {=0A=
      return fn(self, locals, left, right);=0A=
    }, {=0A=
      constant: left.constant &amp;&amp; right.constant,=0A=
      inputs: !isBranching &amp;&amp; [left, right]=0A=
    });=0A=
  },=0A=
=0A=
  statements: function() {=0A=
    var statements =3D [];=0A=
    while (true) {=0A=
      if (this.tokens.length &gt; 0 &amp;&amp; !this.peek('}', ')', ';', =
']'))=0A=
        statements.push(this.filterChain());=0A=
      if (!this.expect(';')) {=0A=
        // optimize for the common case where there is only one =
statement.=0A=
        // TODO(size): maybe we should not support multiple statements?=0A=
        return (statements.length =3D=3D=3D 1)=0A=
            ? statements[0]=0A=
            : function $parseStatements(self, locals) {=0A=
                var value;=0A=
                for (var i =3D 0, ii =3D statements.length; i &lt; ii; =
i++) {=0A=
                  value =3D statements[i](self, locals);=0A=
                }=0A=
                return value;=0A=
              };=0A=
      }=0A=
    }=0A=
  },=0A=
=0A=
  filterChain: function() {=0A=
    var left =3D this.expression();=0A=
    var token;=0A=
    while ((token =3D this.expect('|'))) {=0A=
      left =3D this.filter(left);=0A=
    }=0A=
    return left;=0A=
  },=0A=
=0A=
  filter: function(inputFn) {=0A=
    var token =3D this.expect();=0A=
    var fn =3D this.$filter(token.text);=0A=
    var argsFn;=0A=
    var args;=0A=
=0A=
    if (this.peek(':')) {=0A=
      argsFn =3D [];=0A=
      args =3D []; // we can safely reuse the array=0A=
      while (this.expect(':')) {=0A=
        argsFn.push(this.expression());=0A=
      }=0A=
    }=0A=
=0A=
    var inputs =3D [inputFn].concat(argsFn || []);=0A=
=0A=
    return extend(function $parseFilter(self, locals) {=0A=
      var input =3D inputFn(self, locals);=0A=
      if (args) {=0A=
        args[0] =3D input;=0A=
=0A=
        var i =3D argsFn.length;=0A=
        while (i--) {=0A=
          args[i + 1] =3D argsFn[i](self, locals);=0A=
        }=0A=
=0A=
        return fn.apply(undefined, args);=0A=
      }=0A=
=0A=
      return fn(input);=0A=
    }, {=0A=
      constant: !fn.$stateful &amp;&amp; inputs.every(isConstant),=0A=
      inputs: !fn.$stateful &amp;&amp; inputs=0A=
    });=0A=
  },=0A=
=0A=
  expression: function() {=0A=
    return this.assignment();=0A=
  },=0A=
=0A=
  assignment: function() {=0A=
    var left =3D this.ternary();=0A=
    var right;=0A=
    var token;=0A=
    if ((token =3D this.expect('=3D'))) {=0A=
      if (!left.assign) {=0A=
        this.throwError('implies assignment but [' +=0A=
            this.text.substring(0, token.index) + '] can not be assigned =
to', token);=0A=
      }=0A=
      right =3D this.ternary();=0A=
      return extend(function $parseAssignment(scope, locals) {=0A=
        return left.assign(scope, right(scope, locals), locals);=0A=
      }, {=0A=
        inputs: [left, right]=0A=
      });=0A=
    }=0A=
    return left;=0A=
  },=0A=
=0A=
  ternary: function() {=0A=
    var left =3D this.logicalOR();=0A=
    var middle;=0A=
    var token;=0A=
    if ((token =3D this.expect('?'))) {=0A=
      middle =3D this.assignment();=0A=
      if ((token =3D this.expect(':'))) {=0A=
        var right =3D this.assignment();=0A=
=0A=
        return extend(function $parseTernary(self, locals){=0A=
          return left(self, locals) ? middle(self, locals) : right(self, =
locals);=0A=
        }, {=0A=
          constant: left.constant &amp;&amp; middle.constant &amp;&amp; =
right.constant=0A=
        });=0A=
=0A=
      } else {=0A=
        this.throwError('expected :', token);=0A=
      }=0A=
    }=0A=
=0A=
    return left;=0A=
  },=0A=
=0A=
  logicalOR: function() {=0A=
    var left =3D this.logicalAND();=0A=
    var token;=0A=
    while ((token =3D this.expect('||'))) {=0A=
      left =3D this.binaryFn(left, token.fn, this.logicalAND(), true);=0A=
    }=0A=
    return left;=0A=
  },=0A=
=0A=
  logicalAND: function() {=0A=
    var left =3D this.equality();=0A=
    var token;=0A=
    if ((token =3D this.expect('&amp;&amp;'))) {=0A=
      left =3D this.binaryFn(left, token.fn, this.logicalAND(), true);=0A=
    }=0A=
    return left;=0A=
  },=0A=
=0A=
  equality: function() {=0A=
    var left =3D this.relational();=0A=
    var token;=0A=
    if ((token =3D this.expect('=3D=3D','!=3D','=3D=3D=3D','!=3D=3D'))) {=0A=
      left =3D this.binaryFn(left, token.fn, this.equality());=0A=
    }=0A=
    return left;=0A=
  },=0A=
=0A=
  relational: function() {=0A=
    var left =3D this.additive();=0A=
    var token;=0A=
    if ((token =3D this.expect('&lt;', '&gt;', '&lt;=3D', '&gt;=3D'))) {=0A=
      left =3D this.binaryFn(left, token.fn, this.relational());=0A=
    }=0A=
    return left;=0A=
  },=0A=
=0A=
  additive: function() {=0A=
    var left =3D this.multiplicative();=0A=
    var token;=0A=
    while ((token =3D this.expect('+','-'))) {=0A=
      left =3D this.binaryFn(left, token.fn, this.multiplicative());=0A=
    }=0A=
    return left;=0A=
  },=0A=
=0A=
  multiplicative: function() {=0A=
    var left =3D this.unary();=0A=
    var token;=0A=
    while ((token =3D this.expect('*','/','%'))) {=0A=
      left =3D this.binaryFn(left, token.fn, this.unary());=0A=
    }=0A=
    return left;=0A=
  },=0A=
=0A=
  unary: function() {=0A=
    var token;=0A=
    if (this.expect('+')) {=0A=
      return this.primary();=0A=
    } else if ((token =3D this.expect('-'))) {=0A=
      return this.binaryFn(Parser.ZERO, token.fn, this.unary());=0A=
    } else if ((token =3D this.expect('!'))) {=0A=
      return this.unaryFn(token.fn, this.unary());=0A=
    } else {=0A=
      return this.primary();=0A=
    }=0A=
  },=0A=
=0A=
  fieldAccess: function(object) {=0A=
    var expression =3D this.text;=0A=
    var field =3D this.expect().text;=0A=
    var getter =3D getterFn(field, this.options, expression);=0A=
=0A=
    return extend(function $parseFieldAccess(scope, locals, self) {=0A=
      return getter(self || object(scope, locals));=0A=
    }, {=0A=
      assign: function(scope, value, locals) {=0A=
        var o =3D object(scope, locals);=0A=
        if (!o) object.assign(scope, o =3D {});=0A=
        return setter(o, field, value, expression);=0A=
      }=0A=
    });=0A=
  },=0A=
=0A=
  objectIndex: function(obj) {=0A=
    var expression =3D this.text;=0A=
=0A=
    var indexFn =3D this.expression();=0A=
    this.consume(']');=0A=
=0A=
    return extend(function $parseObjectIndex(self, locals) {=0A=
      var o =3D obj(self, locals),=0A=
          i =3D indexFn(self, locals),=0A=
          v;=0A=
=0A=
      ensureSafeMemberName(i, expression);=0A=
      if (!o) return undefined;=0A=
      v =3D ensureSafeObject(o[i], expression);=0A=
      return v;=0A=
    }, {=0A=
      assign: function(self, value, locals) {=0A=
        var key =3D ensureSafeMemberName(indexFn(self, locals), =
expression);=0A=
        // prevent overwriting of Function.constructor which would break =
ensureSafeObject check=0A=
        var o =3D ensureSafeObject(obj(self, locals), expression);=0A=
        if (!o) obj.assign(self, o =3D {});=0A=
        return o[key] =3D value;=0A=
      }=0A=
    });=0A=
  },=0A=
=0A=
  functionCall: function(fnGetter, contextGetter) {=0A=
    var argsFn =3D [];=0A=
    if (this.peekToken().text !=3D=3D ')') {=0A=
      do {=0A=
        argsFn.push(this.expression());=0A=
      } while (this.expect(','));=0A=
    }=0A=
    this.consume(')');=0A=
=0A=
    var expressionText =3D this.text;=0A=
    // we can safely reuse the array across invocations=0A=
    var args =3D argsFn.length ? [] : null;=0A=
=0A=
    return function $parseFunctionCall(scope, locals) {=0A=
      var context =3D contextGetter ? contextGetter(scope, locals) : =
scope;=0A=
      var fn =3D fnGetter(scope, locals, context) || noop;=0A=
=0A=
      if (args) {=0A=
        var i =3D argsFn.length;=0A=
        while (i--) {=0A=
          args[i] =3D ensureSafeObject(argsFn[i](scope, locals), =
expressionText);=0A=
        }=0A=
      }=0A=
=0A=
      ensureSafeObject(context, expressionText);=0A=
      ensureSafeFunction(fn, expressionText);=0A=
=0A=
      // IE stupidity! (IE doesn't have apply for some native functions)=0A=
      var v =3D fn.apply=0A=
            ? fn.apply(context, args)=0A=
            : fn(args[0], args[1], args[2], args[3], args[4]);=0A=
=0A=
      return ensureSafeObject(v, expressionText);=0A=
    };=0A=
  },=0A=
=0A=
  // This is used with json array declaration=0A=
  arrayDeclaration: function () {=0A=
    var elementFns =3D [];=0A=
    if (this.peekToken().text !=3D=3D ']') {=0A=
      do {=0A=
        if (this.peek(']')) {=0A=
          // Support trailing commas per ES5.1.=0A=
          break;=0A=
        }=0A=
        var elementFn =3D this.expression();=0A=
        elementFns.push(elementFn);=0A=
      } while (this.expect(','));=0A=
    }=0A=
    this.consume(']');=0A=
=0A=
    return extend(function $parseArrayLiteral(self, locals) {=0A=
      var array =3D [];=0A=
      for (var i =3D 0, ii =3D elementFns.length; i &lt; ii; i++) {=0A=
        array.push(elementFns[i](self, locals));=0A=
      }=0A=
      return array;=0A=
    }, {=0A=
      literal: true,=0A=
      constant: elementFns.every(isConstant),=0A=
      inputs: elementFns=0A=
    });=0A=
  },=0A=
=0A=
  object: function () {=0A=
    var keys =3D [], valueFns =3D [];=0A=
    if (this.peekToken().text !=3D=3D '}') {=0A=
      do {=0A=
        if (this.peek('}')) {=0A=
          // Support trailing commas per ES5.1.=0A=
          break;=0A=
        }=0A=
        var token =3D this.expect();=0A=
        keys.push(token.string || token.text);=0A=
        this.consume(':');=0A=
        var value =3D this.expression();=0A=
        valueFns.push(value);=0A=
      } while (this.expect(','));=0A=
    }=0A=
    this.consume('}');=0A=
=0A=
    return extend(function $parseObjectLiteral(self, locals) {=0A=
      var object =3D {};=0A=
      for (var i =3D 0, ii =3D valueFns.length; i &lt; ii; i++) {=0A=
        object[keys[i]] =3D valueFns[i](self, locals);=0A=
      }=0A=
      return object;=0A=
    }, {=0A=
      literal: true,=0A=
      constant: valueFns.every(isConstant),=0A=
      inputs: valueFns=0A=
    });=0A=
  }=0A=
};=0A=
=0A=
=0A=
//////////////////////////////////////////////////=0A=
// Parser helper functions=0A=
//////////////////////////////////////////////////=0A=
=0A=
function setter(obj, path, setValue, fullExp) {=0A=
  ensureSafeObject(obj, fullExp);=0A=
=0A=
  var element =3D path.split('.'), key;=0A=
  for (var i =3D 0; element.length &gt; 1; i++) {=0A=
    key =3D ensureSafeMemberName(element.shift(), fullExp);=0A=
    var propertyObj =3D ensureSafeObject(obj[key], fullExp);=0A=
    if (!propertyObj) {=0A=
      propertyObj =3D {};=0A=
      obj[key] =3D propertyObj;=0A=
    }=0A=
    obj =3D propertyObj;=0A=
  }=0A=
  key =3D ensureSafeMemberName(element.shift(), fullExp);=0A=
  ensureSafeObject(obj[key], fullExp);=0A=
  obj[key] =3D setValue;=0A=
  return setValue;=0A=
}=0A=
=0A=
var getterFnCache =3D createMap();=0A=
=0A=
/**=0A=
 * Implementation of the "Black Hole" variant from:=0A=
 * - http://jsperf.com/angularjs-parse-getter/4=0A=
 * - http://jsperf.com/path-evaluation-simplified/7=0A=
 */=0A=
function cspSafeGetterFn(key0, key1, key2, key3, key4, fullExp) {=0A=
  ensureSafeMemberName(key0, fullExp);=0A=
  ensureSafeMemberName(key1, fullExp);=0A=
  ensureSafeMemberName(key2, fullExp);=0A=
  ensureSafeMemberName(key3, fullExp);=0A=
  ensureSafeMemberName(key4, fullExp);=0A=
=0A=
  return function cspSafeGetter(scope, locals) {=0A=
    var pathVal =3D (locals &amp;&amp; locals.hasOwnProperty(key0)) ? =
locals : scope;=0A=
=0A=
    if (pathVal =3D=3D null) return pathVal;=0A=
    pathVal =3D pathVal[key0];=0A=
=0A=
    if (!key1) return pathVal;=0A=
    if (pathVal =3D=3D null) return undefined;=0A=
    pathVal =3D pathVal[key1];=0A=
=0A=
    if (!key2) return pathVal;=0A=
    if (pathVal =3D=3D null) return undefined;=0A=
    pathVal =3D pathVal[key2];=0A=
=0A=
    if (!key3) return pathVal;=0A=
    if (pathVal =3D=3D null) return undefined;=0A=
    pathVal =3D pathVal[key3];=0A=
=0A=
    if (!key4) return pathVal;=0A=
    if (pathVal =3D=3D null) return undefined;=0A=
    pathVal =3D pathVal[key4];=0A=
=0A=
    return pathVal;=0A=
  };=0A=
}=0A=
=0A=
function getterFn(path, options, fullExp) {=0A=
  var fn =3D getterFnCache[path];=0A=
=0A=
  if (fn) return fn;=0A=
=0A=
  var pathKeys =3D path.split('.'),=0A=
      pathKeysLength =3D pathKeys.length;=0A=
=0A=
  // http://jsperf.com/angularjs-parse-getter/6=0A=
  if (options.csp) {=0A=
    if (pathKeysLength &lt; 6) {=0A=
      fn =3D cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], =
pathKeys[3], pathKeys[4], fullExp);=0A=
    } else {=0A=
      fn =3D function cspSafeGetter(scope, locals) {=0A=
        var i =3D 0, val;=0A=
        do {=0A=
          val =3D cspSafeGetterFn(pathKeys[i++], pathKeys[i++], =
pathKeys[i++], pathKeys[i++],=0A=
                                pathKeys[i++], fullExp)(scope, locals);=0A=
=0A=
          locals =3D undefined; // clear after first iteration=0A=
          scope =3D val;=0A=
        } while (i &lt; pathKeysLength);=0A=
        return val;=0A=
      };=0A=
    }=0A=
  } else {=0A=
    var code =3D '';=0A=
    forEach(pathKeys, function(key, index) {=0A=
      ensureSafeMemberName(key, fullExp);=0A=
      code +=3D 'if(s =3D=3D null) return undefined;\n' +=0A=
              's=3D'+ (index=0A=
                      // we simply dereference 's' on any .dot notation=0A=
                      ? 's'=0A=
                      // but if we are first then we check locals first, =
and if so read it first=0A=
                      : '((l&amp;&amp;l.hasOwnProperty("' + key + =
'"))?l:s)') + '.' + key + ';\n';=0A=
    });=0A=
    code +=3D 'return s;';=0A=
=0A=
    /* jshint -W054 */=0A=
    var evaledFnGetter =3D new Function('s', 'l', code); // s=3Dscope, =
l=3Dlocals=0A=
    /* jshint +W054 */=0A=
    evaledFnGetter.toString =3D valueFn(code);=0A=
=0A=
    fn =3D evaledFnGetter;=0A=
  }=0A=
=0A=
  fn.sharedGetter =3D true;=0A=
  fn.assign =3D function(self, value) {=0A=
    return setter(self, path, value, path);=0A=
  };=0A=
  getterFnCache[path] =3D fn;=0A=
  return fn;=0A=
}=0A=
=0A=
///////////////////////////////////=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $parse=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * Converts Angular {@link guide/expression expression} into a function.=0A=
 *=0A=
 * ```js=0A=
 *   var getter =3D $parse('user.name');=0A=
 *   var setter =3D getter.assign;=0A=
 *   var context =3D {user:{name:'angular'}};=0A=
 *   var locals =3D {user:{name:'local'}};=0A=
 *=0A=
 *   expect(getter(context)).toEqual('angular');=0A=
 *   setter(context, 'newValue');=0A=
 *   expect(context.user.name).toEqual('newValue');=0A=
 *   expect(getter(context, locals)).toEqual('local');=0A=
 * ```=0A=
 *=0A=
 *=0A=
 * @param {string} expression String expression to compile.=0A=
 * @returns {function(context, locals)} a function which represents the =
compiled expression:=0A=
 *=0A=
 *    * `context` =E2=80&#65533; `{object}` =E2=80&#65533; an object =
against which any expressions embedded in the strings=0A=
 *      are evaluated against (typically a scope object).=0A=
 *    * `locals` =E2=80&#65533; `{object=3D}` =E2=80&#65533; local =
variables context object, useful for overriding values in=0A=
 *      `context`.=0A=
 *=0A=
 *    The returned function also has the following properties:=0A=
 *      * `literal` =E2=80&#65533; `{boolean}` =E2=80&#65533; whether =
the expression's top-level node is a JavaScript=0A=
 *        literal.=0A=
 *      * `constant` =E2=80&#65533; `{boolean}` =E2=80&#65533; whether =
the expression is made entirely of JavaScript=0A=
 *        constant literals.=0A=
 *      * `assign` =E2=80&#65533; `{?function(context, value)}` =
=E2=80&#65533; if the expression is assignable, this will be=0A=
 *        set to a function to change its value on the given context.=0A=
 *=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $parseProvider=0A=
 *=0A=
 * @description=0A=
 * `$parseProvider` can be used for configuring the default behavior of =
the {@link ng.$parse $parse}=0A=
 *  service.=0A=
 */=0A=
function $ParseProvider() {=0A=
  var cache =3D createMap();=0A=
=0A=
  var $parseOptions =3D {=0A=
    csp: false=0A=
  };=0A=
=0A=
=0A=
  this.$get =3D ['$filter', '$sniffer', function($filter, $sniffer) {=0A=
    $parseOptions.csp =3D $sniffer.csp;=0A=
=0A=
    function wrapSharedExpression(exp) {=0A=
      var wrapped =3D exp;=0A=
=0A=
      if (exp.sharedGetter) {=0A=
        wrapped =3D function $parseWrapper(self, locals) {=0A=
          return exp(self, locals);=0A=
        };=0A=
        wrapped.literal =3D exp.literal;=0A=
        wrapped.constant =3D exp.constant;=0A=
        wrapped.assign =3D exp.assign;=0A=
      }=0A=
=0A=
      return wrapped;=0A=
    }=0A=
=0A=
    return function $parse(exp, interceptorFn) {=0A=
      var parsedExpression, oneTime, cacheKey;=0A=
=0A=
      switch (typeof exp) {=0A=
        case 'string':=0A=
          cacheKey =3D exp =3D exp.trim();=0A=
=0A=
          parsedExpression =3D cache[cacheKey];=0A=
=0A=
          if (!parsedExpression) {=0A=
            if (exp.charAt(0) =3D=3D=3D ':' &amp;&amp; exp.charAt(1) =
=3D=3D=3D ':') {=0A=
              oneTime =3D true;=0A=
              exp =3D exp.substring(2);=0A=
            }=0A=
=0A=
            var lexer =3D new Lexer($parseOptions);=0A=
            var parser =3D new Parser(lexer, $filter, $parseOptions);=0A=
            parsedExpression =3D parser.parse(exp);=0A=
=0A=
            if (parsedExpression.constant) {=0A=
              parsedExpression.$$watchDelegate =3D constantWatchDelegate;=0A=
            } else if (oneTime) {=0A=
              //oneTime is not part of the exp passed to the Parser so =
we may have to=0A=
              //wrap the parsedExpression before adding a $$watchDelegate=0A=
              parsedExpression =3D =
wrapSharedExpression(parsedExpression);=0A=
              parsedExpression.$$watchDelegate =3D =
parsedExpression.literal ?=0A=
                oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;=0A=
            } else if (parsedExpression.inputs) {=0A=
              parsedExpression.$$watchDelegate =3D inputsWatchDelegate;=0A=
            }=0A=
=0A=
            cache[cacheKey] =3D parsedExpression;=0A=
          }=0A=
          return addInterceptor(parsedExpression, interceptorFn);=0A=
=0A=
        case 'function':=0A=
          return addInterceptor(exp, interceptorFn);=0A=
=0A=
        default:=0A=
          return addInterceptor(noop, interceptorFn);=0A=
      }=0A=
    };=0A=
=0A=
    function collectExpressionInputs(inputs, list) {=0A=
      for (var i =3D 0, ii =3D inputs.length; i &lt; ii; i++) {=0A=
        var input =3D inputs[i];=0A=
        if (!input.constant) {=0A=
          if (input.inputs) {=0A=
            collectExpressionInputs(input.inputs, list);=0A=
          } else if (list.indexOf(input) =3D=3D=3D -1) { // TODO(perf) =
can we do better?=0A=
            list.push(input);=0A=
          }=0A=
        }=0A=
      }=0A=
=0A=
      return list;=0A=
    }=0A=
=0A=
    function expressionInputDirtyCheck(newValue, oldValueOfValue) {=0A=
=0A=
      if (newValue =3D=3D null || oldValueOfValue =3D=3D null) { // =
null/undefined=0A=
        return newValue =3D=3D=3D oldValueOfValue;=0A=
      }=0A=
=0A=
      if (typeof newValue =3D=3D=3D 'object') {=0A=
=0A=
        // attempt to convert the value to a primitive type=0A=
        // TODO(docs): add a note to docs that by implementing valueOf =
even objects and arrays can=0A=
        //             be cheaply dirty-checked=0A=
        newValue =3D newValue.valueOf();=0A=
=0A=
        if (typeof newValue =3D=3D=3D 'object') {=0A=
          // objects/arrays are not supported - deep-watching them would =
be too expensive=0A=
          return false;=0A=
        }=0A=
=0A=
        // fall-through to the primitive equality check=0A=
      }=0A=
=0A=
      //Primitive or NaN=0A=
      return newValue =3D=3D=3D oldValueOfValue || (newValue !=3D=3D =
newValue &amp;&amp; oldValueOfValue !=3D=3D oldValueOfValue);=0A=
    }=0A=
=0A=
    function inputsWatchDelegate(scope, listener, objectEquality, =
parsedExpression) {=0A=
      var inputExpressions =3D parsedExpression.$$inputs ||=0A=
                    (parsedExpression.$$inputs =3D =
collectExpressionInputs(parsedExpression.inputs, []));=0A=
=0A=
      var lastResult;=0A=
=0A=
      if (inputExpressions.length =3D=3D=3D 1) {=0A=
        var oldInputValue =3D expressionInputDirtyCheck; // init to =
something unique so that equals check fails=0A=
        inputExpressions =3D inputExpressions[0];=0A=
        return scope.$watch(function expressionInputWatch(scope) {=0A=
          var newInputValue =3D inputExpressions(scope);=0A=
          if (!expressionInputDirtyCheck(newInputValue, oldInputValue)) {=0A=
            lastResult =3D parsedExpression(scope);=0A=
            oldInputValue =3D newInputValue &amp;&amp; =
newInputValue.valueOf();=0A=
          }=0A=
          return lastResult;=0A=
        }, listener, objectEquality);=0A=
      }=0A=
=0A=
      var oldInputValueOfValues =3D [];=0A=
      for (var i =3D 0, ii =3D inputExpressions.length; i &lt; ii; i++) {=0A=
        oldInputValueOfValues[i] =3D expressionInputDirtyCheck; // init =
to something unique so that equals check fails=0A=
      }=0A=
=0A=
      return scope.$watch(function expressionInputsWatch(scope) {=0A=
        var changed =3D false;=0A=
=0A=
        for (var i =3D 0, ii =3D inputExpressions.length; i &lt; ii; =
i++) {=0A=
          var newInputValue =3D inputExpressions[i](scope);=0A=
          if (changed || (changed =3D =
!expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {=0A=
            oldInputValueOfValues[i] =3D newInputValue &amp;&amp; =
newInputValue.valueOf();=0A=
          }=0A=
        }=0A=
=0A=
        if (changed) {=0A=
          lastResult =3D parsedExpression(scope);=0A=
        }=0A=
=0A=
        return lastResult;=0A=
      }, listener, objectEquality);=0A=
    }=0A=
=0A=
    function oneTimeWatchDelegate(scope, listener, objectEquality, =
parsedExpression) {=0A=
      var unwatch, lastValue;=0A=
      return unwatch =3D scope.$watch(function oneTimeWatch(scope) {=0A=
        return parsedExpression(scope);=0A=
      }, function oneTimeListener(value, old, scope) {=0A=
        lastValue =3D value;=0A=
        if (isFunction(listener)) {=0A=
          listener.apply(this, arguments);=0A=
        }=0A=
        if (isDefined(value)) {=0A=
          scope.$$postDigest(function () {=0A=
            if (isDefined(lastValue)) {=0A=
              unwatch();=0A=
            }=0A=
          });=0A=
        }=0A=
      }, objectEquality);=0A=
    }=0A=
=0A=
    function oneTimeLiteralWatchDelegate(scope, listener, =
objectEquality, parsedExpression) {=0A=
      var unwatch, lastValue;=0A=
      return unwatch =3D scope.$watch(function oneTimeWatch(scope) {=0A=
        return parsedExpression(scope);=0A=
      }, function oneTimeListener(value, old, scope) {=0A=
        lastValue =3D value;=0A=
        if (isFunction(listener)) {=0A=
          listener.call(this, value, old, scope);=0A=
        }=0A=
        if (isAllDefined(value)) {=0A=
          scope.$$postDigest(function () {=0A=
            if(isAllDefined(lastValue)) unwatch();=0A=
          });=0A=
        }=0A=
      }, objectEquality);=0A=
=0A=
      function isAllDefined(value) {=0A=
        var allDefined =3D true;=0A=
        forEach(value, function (val) {=0A=
          if (!isDefined(val)) allDefined =3D false;=0A=
        });=0A=
        return allDefined;=0A=
      }=0A=
    }=0A=
=0A=
    function constantWatchDelegate(scope, listener, objectEquality, =
parsedExpression) {=0A=
      var unwatch;=0A=
      return unwatch =3D scope.$watch(function constantWatch(scope) {=0A=
        return parsedExpression(scope);=0A=
      }, function constantListener(value, old, scope) {=0A=
        if (isFunction(listener)) {=0A=
          listener.apply(this, arguments);=0A=
        }=0A=
        unwatch();=0A=
      }, objectEquality);=0A=
    }=0A=
=0A=
    function addInterceptor(parsedExpression, interceptorFn) {=0A=
      if (!interceptorFn) return parsedExpression;=0A=
=0A=
      var fn =3D function interceptedExpression(scope, locals) {=0A=
        var value =3D parsedExpression(scope, locals);=0A=
        var result =3D interceptorFn(value, scope, locals);=0A=
        // we only return the interceptor's result if the=0A=
        // initial value is defined (for bind-once)=0A=
        return isDefined(value) ? result : value;=0A=
      };=0A=
=0A=
      // Propagate $$watchDelegates other then inputsWatchDelegate=0A=
      if (parsedExpression.$$watchDelegate &amp;&amp;=0A=
          parsedExpression.$$watchDelegate !=3D=3D inputsWatchDelegate) {=0A=
        fn.$$watchDelegate =3D parsedExpression.$$watchDelegate;=0A=
      } else if (!interceptorFn.$stateful) {=0A=
        // If there is an interceptor, but no watchDelegate then treat =
the interceptor like=0A=
        // we treat filters - it is assumed to be a pure function unless =
flagged with $stateful=0A=
        fn.$$watchDelegate =3D inputsWatchDelegate;=0A=
        fn.inputs =3D [parsedExpression];=0A=
      }=0A=
=0A=
      return fn;=0A=
    }=0A=
  }];=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $q=0A=
 * @requires $rootScope=0A=
 *=0A=
 * @description=0A=
 * A promise/deferred implementation inspired by [Kris Kowal's =
Q](https://github.com/kriskowal/q).=0A=
 *=0A=
 * $q can be used in two fashions --- one which is more similar to Kris =
Kowal's Q or jQuery's Deferred=0A=
 * implementations, and the other which resembles ES6 promises to some =
degree.=0A=
 *=0A=
 * # $q constructor=0A=
 *=0A=
 * The streamlined ES6 style promise is essentially just using $q as a =
constructor which takes a `resolver`=0A=
 * function as the first argument. This is similar to the native Promise =
implementation from ES6 Harmony,=0A=
 * see =
[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/G=
lobal_Objects/Promise).=0A=
 *=0A=
 * While the constructor-style use is supported, not all of the =
supporting methods from ES6 Harmony promises are=0A=
 * available yet.=0A=
 *=0A=
 * It can be used like so:=0A=
 *=0A=
 * ```js=0A=
 *   // for the purpose of this example let's assume that variables `$q` =
and `okToGreet`=0A=
 *   // are available in the current lexical scope (they could have been =
injected or passed in).=0A=
 *=0A=
 *   function asyncGreet(name) {=0A=
 *     // perform some asynchronous operation, resolve or reject the =
promise when appropriate.=0A=
 *     return $q(function(resolve, reject) {=0A=
 *       setTimeout(function() {=0A=
 *         if (okToGreet(name)) {=0A=
 *           resolve('Hello, ' + name + '!');=0A=
 *         } else {=0A=
 *           reject('Greeting ' + name + ' is not allowed.');=0A=
 *         }=0A=
 *       }, 1000);=0A=
 *     });=0A=
 *   }=0A=
 *=0A=
 *   var promise =3D asyncGreet('Robin Hood');=0A=
 *   promise.then(function(greeting) {=0A=
 *     alert('Success: ' + greeting);=0A=
 *   }, function(reason) {=0A=
 *     alert('Failed: ' + reason);=0A=
 *   });=0A=
 * ```=0A=
 *=0A=
 * Note: progress/notify callbacks are not currently supported via the =
ES6-style interface.=0A=
 *=0A=
 * However, the more traditional CommonJS-style usage is still =
available, and documented below.=0A=
 *=0A=
 * [The CommonJS Promise =
proposal](http://wiki.commonjs.org/wiki/Promises) describes a promise as =
an=0A=
 * interface for interacting with an object that represents the result =
of an action that is=0A=
 * performed asynchronously, and may or may not be finished at any given =
point in time.=0A=
 *=0A=
 * From the perspective of dealing with error handling, deferred and =
promise APIs are to=0A=
 * asynchronous programming what `try`, `catch` and `throw` keywords are =
to synchronous programming.=0A=
 *=0A=
 * ```js=0A=
 *   // for the purpose of this example let's assume that variables `$q` =
and `okToGreet`=0A=
 *   // are available in the current lexical scope (they could have been =
injected or passed in).=0A=
 *=0A=
 *   function asyncGreet(name) {=0A=
 *     var deferred =3D $q.defer();=0A=
 *=0A=
 *     setTimeout(function() {=0A=
 *       deferred.notify('About to greet ' + name + '.');=0A=
 *=0A=
 *       if (okToGreet(name)) {=0A=
 *         deferred.resolve('Hello, ' + name + '!');=0A=
 *       } else {=0A=
 *         deferred.reject('Greeting ' + name + ' is not allowed.');=0A=
 *       }=0A=
 *     }, 1000);=0A=
 *=0A=
 *     return deferred.promise;=0A=
 *   }=0A=
 *=0A=
 *   var promise =3D asyncGreet('Robin Hood');=0A=
 *   promise.then(function(greeting) {=0A=
 *     alert('Success: ' + greeting);=0A=
 *   }, function(reason) {=0A=
 *     alert('Failed: ' + reason);=0A=
 *   }, function(update) {=0A=
 *     alert('Got notification: ' + update);=0A=
 *   });=0A=
 * ```=0A=
 *=0A=
 * At first it might not be obvious why this extra complexity is worth =
the trouble. The payoff=0A=
 * comes in the way of guarantees that promise and deferred APIs make, =
see=0A=
 * =
https://github.com/kriskowal/uncommonjs/blob/master/promises/specificatio=
n.md.=0A=
 *=0A=
 * Additionally the promise api allows for composition that is very hard =
to do with the=0A=
 * traditional callback =
([CPS](http://en.wikipedia.org/wiki/Continuation-passing_style)) =
approach.=0A=
 * For more on this please see the [Q =
documentation](https://github.com/kriskowal/q) especially the=0A=
 * section on serial or parallel joining of promises.=0A=
 *=0A=
 * # The Deferred API=0A=
 *=0A=
 * A new instance of deferred is constructed by calling `$q.defer()`.=0A=
 *=0A=
 * The purpose of the deferred object is to expose the associated =
Promise instance as well as APIs=0A=
 * that can be used for signaling the successful or unsuccessful =
completion, as well as the status=0A=
 * of the task.=0A=
 *=0A=
 * **Methods**=0A=
 *=0A=
 * - `resolve(value)` =E2=80&#65533; resolves the derived promise with =
the `value`. If the value is a rejection=0A=
 *   constructed via `$q.reject`, the promise will be rejected instead.=0A=
 * - `reject(reason)` =E2=80&#65533; rejects the derived promise with =
the `reason`. This is equivalent to=0A=
 *   resolving it with a rejection constructed via `$q.reject`.=0A=
 * - `notify(value)` - provides updates on the status of the promise's =
execution. This may be called=0A=
 *   multiple times before the promise is either resolved or rejected.=0A=
 *=0A=
 * **Properties**=0A=
 *=0A=
 * - promise =E2=80&#65533; `{Promise}` =E2=80&#65533; promise object =
associated with this deferred.=0A=
 *=0A=
 *=0A=
 * # The Promise API=0A=
 *=0A=
 * A new promise instance is created when a deferred instance is created =
and can be retrieved by=0A=
 * calling `deferred.promise`.=0A=
 *=0A=
 * The purpose of the promise object is to allow for interested parties =
to get access to the result=0A=
 * of the deferred task when it completes.=0A=
 *=0A=
 * **Methods**=0A=
 *=0A=
 * - `then(successCallback, errorCallback, notifyCallback)` =
=E2=80&#65533; regardless of when the promise was or=0A=
 *   will be resolved or rejected, `then` calls one of the success or =
error callbacks asynchronously=0A=
 *   as soon as the result is available. The callbacks are called with a =
single argument: the result=0A=
 *   or rejection reason. Additionally, the notify callback may be =
called zero or more times to=0A=
 *   provide a progress indication, before the promise is resolved or =
rejected.=0A=
 *=0A=
 *   This method *returns a new promise* which is resolved or rejected =
via the return value of the=0A=
 *   `successCallback`, `errorCallback`. It also notifies via the return =
value of the=0A=
 *   `notifyCallback` method. The promise cannot be resolved or rejected =
from the notifyCallback=0A=
 *   method.=0A=
 *=0A=
 * - `catch(errorCallback)` =E2=80&#65533; shorthand for =
`promise.then(null, errorCallback)`=0A=
 *=0A=
 * - `finally(callback)` =E2=80&#65533; allows you to observe either the =
fulfillment or rejection of a promise,=0A=
 *   but to do so without modifying the final value. This is useful to =
release resources or do some=0A=
 *   clean-up that needs to be done whether the promise was rejected or =
resolved. See the [full=0A=
 *   =
specification](https://github.com/kriskowal/q/wiki/API-Reference#promisef=
inallycallback) for=0A=
 *   more information.=0A=
 *=0A=
 *   Because `finally` is a reserved word in JavaScript and reserved =
keywords are not supported as=0A=
 *   property names by ES3, you'll need to invoke the method like =
`promise['finally'](callback)` to=0A=
 *   make your code IE8 and Android 2.x compatible.=0A=
 *=0A=
 * # Chaining promises=0A=
 *=0A=
 * Because calling the `then` method of a promise returns a new derived =
promise, it is easily=0A=
 * possible to create a chain of promises:=0A=
 *=0A=
 * ```js=0A=
 *   promiseB =3D promiseA.then(function(result) {=0A=
 *     return result + 1;=0A=
 *   });=0A=
 *=0A=
 *   // promiseB will be resolved immediately after promiseA is resolved =
and its value=0A=
 *   // will be the result of promiseA incremented by 1=0A=
 * ```=0A=
 *=0A=
 * It is possible to create chains of any length and since a promise can =
be resolved with another=0A=
 * promise (which will defer its resolution further), it is possible to =
pause/defer resolution of=0A=
 * the promises at any point in the chain. This makes it possible to =
implement powerful APIs like=0A=
 * $http's response interceptors.=0A=
 *=0A=
 *=0A=
 * # Differences between Kris Kowal's Q and $q=0A=
 *=0A=
 *  There are two main differences:=0A=
 *=0A=
 * - $q is integrated with the {@link ng.$rootScope.Scope} Scope model =
observation=0A=
 *   mechanism in angular, which means faster propagation of resolution =
or rejection into your=0A=
 *   models and avoiding unnecessary browser repaints, which would =
result in flickering UI.=0A=
 * - Q has many more features than $q, but that comes at a cost of =
bytes. $q is tiny, but contains=0A=
 *   all the important functionality needed for common async tasks.=0A=
 *=0A=
 *  # Testing=0A=
 *=0A=
 *  ```js=0A=
 *    it('should simulate promise', inject(function($q, $rootScope) {=0A=
 *      var deferred =3D $q.defer();=0A=
 *      var promise =3D deferred.promise;=0A=
 *      var resolvedValue;=0A=
 *=0A=
 *      promise.then(function(value) { resolvedValue =3D value; });=0A=
 *      expect(resolvedValue).toBeUndefined();=0A=
 *=0A=
 *      // Simulate resolving of promise=0A=
 *      deferred.resolve(123);=0A=
 *      // Note that the 'then' function does not get called =
synchronously.=0A=
 *      // This is because we want the promise API to always be async, =
whether or not=0A=
 *      // it got called synchronously or asynchronously.=0A=
 *      expect(resolvedValue).toBeUndefined();=0A=
 *=0A=
 *      // Propagate promise resolution to 'then' functions using =
$apply().=0A=
 *      $rootScope.$apply();=0A=
 *      expect(resolvedValue).toEqual(123);=0A=
 *    }));=0A=
 *  ```=0A=
 *=0A=
 * @param {function(function, function)} resolver Function which is =
responsible for resolving or=0A=
 *   rejecting the newly created promise. The first parameter is a =
function which resolves the=0A=
 *   promise, the second parameter is a function which rejects the =
promise.=0A=
 *=0A=
 * @returns {Promise} The newly created promise.=0A=
 */=0A=
function $QProvider() {=0A=
=0A=
  this.$get =3D ['$rootScope', '$exceptionHandler', function($rootScope, =
$exceptionHandler) {=0A=
    return qFactory(function(callback) {=0A=
      $rootScope.$evalAsync(callback);=0A=
    }, $exceptionHandler);=0A=
  }];=0A=
}=0A=
=0A=
function $$QProvider() {=0A=
  this.$get =3D ['$browser', '$exceptionHandler', function($browser, =
$exceptionHandler) {=0A=
    return qFactory(function(callback) {=0A=
      $browser.defer(callback);=0A=
    }, $exceptionHandler);=0A=
  }];=0A=
}=0A=
=0A=
/**=0A=
 * Constructs a promise manager.=0A=
 *=0A=
 * @param {function(function)} nextTick Function for executing functions =
in the next turn.=0A=
 * @param {function(...*)} exceptionHandler Function into which =
unexpected exceptions are passed for=0A=
 *     debugging purposes.=0A=
 * @returns {object} Promise manager.=0A=
 */=0A=
function qFactory(nextTick, exceptionHandler) {=0A=
  var $qMinErr =3D minErr('$q', TypeError);=0A=
  function callOnce(self, resolveFn, rejectFn) {=0A=
    var called =3D false;=0A=
    function wrap(fn) {=0A=
      return function(value) {=0A=
        if (called) return;=0A=
        called =3D true;=0A=
        fn.call(self, value);=0A=
      };=0A=
    }=0A=
=0A=
    return [wrap(resolveFn), wrap(rejectFn)];=0A=
  }=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name ng.$q#defer=0A=
   * @kind function=0A=
   *=0A=
   * @description=0A=
   * Creates a `Deferred` object which represents a task which will =
finish in the future.=0A=
   *=0A=
   * @returns {Deferred} Returns a new instance of deferred.=0A=
   */=0A=
  var defer =3D function() {=0A=
    return new Deferred();=0A=
  };=0A=
=0A=
  function Promise() {=0A=
    this.$$state =3D { status: 0 };=0A=
  }=0A=
=0A=
  Promise.prototype =3D {=0A=
    then: function(onFulfilled, onRejected, progressBack) {=0A=
      var result =3D new Deferred();=0A=
=0A=
      this.$$state.pending =3D this.$$state.pending || [];=0A=
      this.$$state.pending.push([result, onFulfilled, onRejected, =
progressBack]);=0A=
      if (this.$$state.status &gt; 0) scheduleProcessQueue(this.$$state);=0A=
=0A=
      return result.promise;=0A=
    },=0A=
=0A=
    "catch": function(callback) {=0A=
      return this.then(null, callback);=0A=
    },=0A=
=0A=
    "finally": function(callback, progressBack) {=0A=
      return this.then(function(value) {=0A=
        return handleCallback(value, true, callback);=0A=
      }, function(error) {=0A=
        return handleCallback(error, false, callback);=0A=
      }, progressBack);=0A=
    }=0A=
  };=0A=
=0A=
  //Faster, more basic than angular.bind =
http://jsperf.com/angular-bind-vs-custom-vs-native=0A=
  function simpleBind(context, fn) {=0A=
    return function(value) {=0A=
      fn.call(context, value);=0A=
    };=0A=
  }=0A=
=0A=
  function processQueue(state) {=0A=
    var fn, promise, pending;=0A=
=0A=
    pending =3D state.pending;=0A=
    state.processScheduled =3D false;=0A=
    state.pending =3D undefined;=0A=
    for (var i =3D 0, ii =3D pending.length; i &lt; ii; ++i) {=0A=
      promise =3D pending[i][0];=0A=
      fn =3D pending[i][state.status];=0A=
      try {=0A=
        if (isFunction(fn)) {=0A=
          promise.resolve(fn(state.value));=0A=
        } else if (state.status =3D=3D=3D 1) {=0A=
          promise.resolve(state.value);=0A=
        } else {=0A=
          promise.reject(state.value);=0A=
        }=0A=
      } catch(e) {=0A=
        promise.reject(e);=0A=
        exceptionHandler(e);=0A=
      }=0A=
    }=0A=
  }=0A=
=0A=
  function scheduleProcessQueue(state) {=0A=
    if (state.processScheduled || !state.pending) return;=0A=
    state.processScheduled =3D true;=0A=
    nextTick(function() { processQueue(state); });=0A=
  }=0A=
=0A=
  function Deferred() {=0A=
    this.promise =3D new Promise();=0A=
    //Necessary to support unbound execution :/=0A=
    this.resolve =3D simpleBind(this, this.resolve);=0A=
    this.reject =3D simpleBind(this, this.reject);=0A=
    this.notify =3D simpleBind(this, this.notify);=0A=
  }=0A=
=0A=
  Deferred.prototype =3D {=0A=
    resolve: function(val) {=0A=
      if (this.promise.$$state.status) return;=0A=
      if (val =3D=3D=3D this.promise) {=0A=
        this.$$reject($qMinErr(=0A=
          'qcycle',=0A=
          "Expected promise to be resolved with value other than itself =
'{0}'",=0A=
          val));=0A=
      }=0A=
      else {=0A=
        this.$$resolve(val);=0A=
      }=0A=
=0A=
    },=0A=
=0A=
    $$resolve: function(val) {=0A=
      var then, fns;=0A=
=0A=
      fns =3D callOnce(this, this.$$resolve, this.$$reject);=0A=
      try {=0A=
        if ((isObject(val) || isFunction(val))) then =3D val &amp;&amp; =
val.then;=0A=
        if (isFunction(then)) {=0A=
          this.promise.$$state.status =3D -1;=0A=
          then.call(val, fns[0], fns[1], this.notify);=0A=
        } else {=0A=
          this.promise.$$state.value =3D val;=0A=
          this.promise.$$state.status =3D 1;=0A=
          scheduleProcessQueue(this.promise.$$state);=0A=
        }=0A=
      } catch(e) {=0A=
        fns[1](e);=0A=
        exceptionHandler(e);=0A=
      }=0A=
    },=0A=
=0A=
    reject: function(reason) {=0A=
      if (this.promise.$$state.status) return;=0A=
      this.$$reject(reason);=0A=
    },=0A=
=0A=
    $$reject: function(reason) {=0A=
      this.promise.$$state.value =3D reason;=0A=
      this.promise.$$state.status =3D 2;=0A=
      scheduleProcessQueue(this.promise.$$state);=0A=
    },=0A=
=0A=
    notify: function(progress) {=0A=
      var callbacks =3D this.promise.$$state.pending;=0A=
=0A=
      if ((this.promise.$$state.status &lt;=3D 0) &amp;&amp; callbacks =
&amp;&amp; callbacks.length) {=0A=
        nextTick(function() {=0A=
          var callback, result;=0A=
          for (var i =3D 0, ii =3D callbacks.length; i &lt; ii; i++) {=0A=
            result =3D callbacks[i][0];=0A=
            callback =3D callbacks[i][3];=0A=
            try {=0A=
              result.notify(isFunction(callback) ? callback(progress) : =
progress);=0A=
            } catch(e) {=0A=
              exceptionHandler(e);=0A=
            }=0A=
          }=0A=
        });=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $q#reject=0A=
   * @kind function=0A=
   *=0A=
   * @description=0A=
   * Creates a promise that is resolved as rejected with the specified =
`reason`. This api should be=0A=
   * used to forward rejection in a chain of promises. If you are =
dealing with the last promise in=0A=
   * a promise chain, you don't need to worry about it.=0A=
   *=0A=
   * When comparing deferreds/promises to the familiar behavior of =
try/catch/throw, think of=0A=
   * `reject` as the `throw` keyword in JavaScript. This also means that =
if you "catch" an error via=0A=
   * a promise error callback and you want to forward the error to the =
promise derived from the=0A=
   * current promise, you have to "rethrow" the error by returning a =
rejection constructed via=0A=
   * `reject`.=0A=
   *=0A=
   * ```js=0A=
   *   promiseB =3D promiseA.then(function(result) {=0A=
   *     // success: do something and resolve promiseB=0A=
   *     //          with the old or a new result=0A=
   *     return result;=0A=
   *   }, function(reason) {=0A=
   *     // error: handle the error if possible and=0A=
   *     //        resolve promiseB with newPromiseOrValue,=0A=
   *     //        otherwise forward the rejection to promiseB=0A=
   *     if (canHandle(reason)) {=0A=
   *      // handle the error and recover=0A=
   *      return newPromiseOrValue;=0A=
   *     }=0A=
   *     return $q.reject(reason);=0A=
   *   });=0A=
   * ```=0A=
   *=0A=
   * @param {*} reason Constant, message, exception or an object =
representing the rejection reason.=0A=
   * @returns {Promise} Returns a promise that was already resolved as =
rejected with the `reason`.=0A=
   */=0A=
  var reject =3D function(reason) {=0A=
    var result =3D new Deferred();=0A=
    result.reject(reason);=0A=
    return result.promise;=0A=
  };=0A=
=0A=
  var makePromise =3D function makePromise(value, resolved) {=0A=
    var result =3D new Deferred();=0A=
    if (resolved) {=0A=
      result.resolve(value);=0A=
    } else {=0A=
      result.reject(value);=0A=
    }=0A=
    return result.promise;=0A=
  };=0A=
=0A=
  var handleCallback =3D function handleCallback(value, isResolved, =
callback) {=0A=
    var callbackOutput =3D null;=0A=
    try {=0A=
      if (isFunction(callback)) callbackOutput =3D callback();=0A=
    } catch(e) {=0A=
      return makePromise(e, false);=0A=
    }=0A=
    if (isPromiseLike(callbackOutput)) {=0A=
      return callbackOutput.then(function() {=0A=
        return makePromise(value, isResolved);=0A=
      }, function(error) {=0A=
        return makePromise(error, false);=0A=
      });=0A=
    } else {=0A=
      return makePromise(value, isResolved);=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $q#when=0A=
   * @kind function=0A=
   *=0A=
   * @description=0A=
   * Wraps an object that might be a value or a (3rd party) then-able =
promise into a $q promise.=0A=
   * This is useful when you are dealing with an object that might or =
might not be a promise, or if=0A=
   * the promise comes from a source that can't be trusted.=0A=
   *=0A=
   * @param {*} value Value or a promise=0A=
   * @returns {Promise} Returns a promise of the passed value or promise=0A=
   */=0A=
=0A=
=0A=
  var when =3D function(value, callback, errback, progressBack) {=0A=
    var result =3D new Deferred();=0A=
    result.resolve(value);=0A=
    return result.promise.then(callback, errback, progressBack);=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $q#all=0A=
   * @kind function=0A=
   *=0A=
   * @description=0A=
   * Combines multiple promises into a single promise that is resolved =
when all of the input=0A=
   * promises are resolved.=0A=
   *=0A=
   * @param {Array.&lt;Promise&gt;|Object.&lt;Promise&gt;} promises An =
array or hash of promises.=0A=
   * @returns {Promise} Returns a single promise that will be resolved =
with an array/hash of values,=0A=
   *   each value corresponding to the promise at the same index/key in =
the `promises` array/hash.=0A=
   *   If any of the promises is resolved with a rejection, this =
resulting promise will be rejected=0A=
   *   with the same rejection value.=0A=
   */=0A=
=0A=
  function all(promises) {=0A=
    var deferred =3D new Deferred(),=0A=
        counter =3D 0,=0A=
        results =3D isArray(promises) ? [] : {};=0A=
=0A=
    forEach(promises, function(promise, key) {=0A=
      counter++;=0A=
      when(promise).then(function(value) {=0A=
        if (results.hasOwnProperty(key)) return;=0A=
        results[key] =3D value;=0A=
        if (!(--counter)) deferred.resolve(results);=0A=
      }, function(reason) {=0A=
        if (results.hasOwnProperty(key)) return;=0A=
        deferred.reject(reason);=0A=
      });=0A=
    });=0A=
=0A=
    if (counter =3D=3D=3D 0) {=0A=
      deferred.resolve(results);=0A=
    }=0A=
=0A=
    return deferred.promise;=0A=
  }=0A=
=0A=
  var $Q =3D function Q(resolver) {=0A=
    if (!isFunction(resolver)) {=0A=
      throw $qMinErr('norslvr', "Expected resolverFn, got '{0}'", =
resolver);=0A=
    }=0A=
=0A=
    if (!(this instanceof Q)) {=0A=
      // More useful when $Q is the Promise itself.=0A=
      return new Q(resolver);=0A=
    }=0A=
=0A=
    var deferred =3D new Deferred();=0A=
=0A=
    function resolveFn(value) {=0A=
      deferred.resolve(value);=0A=
    }=0A=
=0A=
    function rejectFn(reason) {=0A=
      deferred.reject(reason);=0A=
    }=0A=
=0A=
    resolver(resolveFn, rejectFn);=0A=
=0A=
    return deferred.promise;=0A=
  };=0A=
=0A=
  $Q.defer =3D defer;=0A=
  $Q.reject =3D reject;=0A=
  $Q.when =3D when;=0A=
  $Q.all =3D all;=0A=
=0A=
  return $Q;=0A=
}=0A=
=0A=
function $$RAFProvider(){ //rAF=0A=
  this.$get =3D ['$window', '$timeout', function($window, $timeout) {=0A=
    var requestAnimationFrame =3D $window.requestAnimationFrame ||=0A=
                                $window.webkitRequestAnimationFrame ||=0A=
                                $window.mozRequestAnimationFrame;=0A=
=0A=
    var cancelAnimationFrame =3D $window.cancelAnimationFrame ||=0A=
                               $window.webkitCancelAnimationFrame ||=0A=
                               $window.mozCancelAnimationFrame ||=0A=
                               $window.webkitCancelRequestAnimationFrame;=0A=
=0A=
    var rafSupported =3D !!requestAnimationFrame;=0A=
    var raf =3D rafSupported=0A=
      ? function(fn) {=0A=
          var id =3D requestAnimationFrame(fn);=0A=
          return function() {=0A=
            cancelAnimationFrame(id);=0A=
          };=0A=
        }=0A=
      : function(fn) {=0A=
          var timer =3D $timeout(fn, 16.66, false); // 1000 / 60 =3D =
16.666=0A=
          return function() {=0A=
            $timeout.cancel(timer);=0A=
          };=0A=
        };=0A=
=0A=
    raf.supported =3D rafSupported;=0A=
=0A=
    return raf;=0A=
  }];=0A=
}=0A=
=0A=
/**=0A=
 * DESIGN NOTES=0A=
 *=0A=
 * The design decisions behind the scope are heavily favored for speed =
and memory consumption.=0A=
 *=0A=
 * The typical use of scope is to watch the expressions, which most of =
the time return the same=0A=
 * value as last time so we optimize the operation.=0A=
 *=0A=
 * Closures construction is expensive in terms of speed as well as =
memory:=0A=
 *   - No closures, instead use prototypical inheritance for API=0A=
 *   - Internal state needs to be stored on scope directly, which means =
that private state is=0A=
 *     exposed as $$____ properties=0A=
 *=0A=
 * Loop operations are optimized by using while(count--) { ... }=0A=
 *   - this means that in order to keep the same order of execution as =
addition we have to add=0A=
 *     items to the array at the beginning (unshift) instead of at the =
end (push)=0A=
 *=0A=
 * Child scopes are created and removed often=0A=
 *   - Using an array would be slow since inserts in middle are =
expensive so we use linked list=0A=
 *=0A=
 * There are few watches then a lot of observers. This is why you don't =
want the observer to be=0A=
 * implemented in the same way as watch. Watch requires return of =
initialization function which=0A=
 * are expensive to construct.=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $rootScopeProvider=0A=
 * @description=0A=
 *=0A=
 * Provider for the $rootScope service.=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc method=0A=
 * @name $rootScopeProvider#digestTtl=0A=
 * @description=0A=
 *=0A=
 * Sets the number of `$digest` iterations the scope should attempt to =
execute before giving up and=0A=
 * assuming that the model is unstable.=0A=
 *=0A=
 * The current default is 10 iterations.=0A=
 *=0A=
 * In complex applications it's possible that the dependencies between =
`$watch`s will result in=0A=
 * several digest iterations. However if an application needs more than =
the default 10 digest=0A=
 * iterations for its model to stabilize then you should investigate =
what is causing the model to=0A=
 * continuously change during the digest.=0A=
 *=0A=
 * Increasing the TTL could have performance implications, so you should =
not change it without=0A=
 * proper justification.=0A=
 *=0A=
 * @param {number} limit The number of digest iterations.=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $rootScope=0A=
 * @description=0A=
 *=0A=
 * Every application has a single root {@link ng.$rootScope.Scope scope}.=0A=
 * All other scopes are descendant scopes of the root scope. Scopes =
provide separation=0A=
 * between the model and the view, via a mechanism for watching the =
model for changes.=0A=
 * They also provide an event emission/broadcast and subscription =
facility. See the=0A=
 * {@link guide/scope developer guide on scopes}.=0A=
 */=0A=
function $RootScopeProvider(){=0A=
  var TTL =3D 10;=0A=
  var $rootScopeMinErr =3D minErr('$rootScope');=0A=
  var lastDirtyWatch =3D null;=0A=
  var applyAsyncId =3D null;=0A=
=0A=
  this.digestTtl =3D function(value) {=0A=
    if (arguments.length) {=0A=
      TTL =3D value;=0A=
    }=0A=
    return TTL;=0A=
  };=0A=
=0A=
  this.$get =3D ['$injector', '$exceptionHandler', '$parse', '$browser',=0A=
      function( $injector,   $exceptionHandler,   $parse,   $browser) {=0A=
=0A=
    /**=0A=
     * @ngdoc type=0A=
     * @name $rootScope.Scope=0A=
     *=0A=
     * @description=0A=
     * A root scope can be retrieved using the {@link ng.$rootScope =
$rootScope} key from the=0A=
     * {@link auto.$injector $injector}. Child scopes are created using =
the=0A=
     * {@link ng.$rootScope.Scope#$new $new()} method. (Most scopes are =
created automatically when=0A=
     * compiled HTML template is executed.)=0A=
     *=0A=
     * Here is a simple scope snippet to show how you can interact with =
the scope.=0A=
     * ```html=0A=
     * &lt;file src=3D"./test/ng/rootScopeSpec.js" tag=3D"docs1" /&gt;=0A=
     * ```=0A=
     *=0A=
     * # Inheritance=0A=
     * A scope can inherit from a parent scope, as in this example:=0A=
     * ```js=0A=
         var parent =3D $rootScope;=0A=
         var child =3D parent.$new();=0A=
=0A=
         parent.salutation =3D "Hello";=0A=
         child.name =3D "World";=0A=
         expect(child.salutation).toEqual('Hello');=0A=
=0A=
         child.salutation =3D "Welcome";=0A=
         expect(child.salutation).toEqual('Welcome');=0A=
         expect(parent.salutation).toEqual('Hello');=0A=
     * ```=0A=
     *=0A=
     *=0A=
     * @param {Object.&lt;string, function()&gt;=3D} providers Map of =
service factory which need to be=0A=
     *                                       provided for the current =
scope. Defaults to {@link ng}.=0A=
     * @param {Object.&lt;string, *&gt;=3D} instanceCache Provides =
pre-instantiated services which should=0A=
     *                              append/override services provided by =
`providers`. This is handy=0A=
     *                              when unit-testing and having the =
need to override a default=0A=
     *                              service.=0A=
     * @returns {Object} Newly created scope.=0A=
     *=0A=
     */=0A=
    function Scope() {=0A=
      this.$id =3D nextUid();=0A=
      this.$$phase =3D this.$parent =3D this.$$watchers =3D=0A=
                     this.$$nextSibling =3D this.$$prevSibling =3D=0A=
                     this.$$childHead =3D this.$$childTail =3D null;=0A=
      this.$root =3D this;=0A=
      this.$$destroyed =3D false;=0A=
      this.$$listeners =3D {};=0A=
      this.$$listenerCount =3D {};=0A=
      this.$$isolateBindings =3D null;=0A=
    }=0A=
=0A=
    /**=0A=
     * @ngdoc property=0A=
     * @name $rootScope.Scope#$id=0A=
     *=0A=
     * @description=0A=
     * Unique scope ID (monotonically increasing) useful for debugging.=0A=
     */=0A=
=0A=
     /**=0A=
      * @ngdoc property=0A=
      * @name $rootScope.Scope#$parent=0A=
      *=0A=
      * @description=0A=
      * Reference to the parent scope.=0A=
      */=0A=
=0A=
      /**=0A=
       * @ngdoc property=0A=
       * @name $rootScope.Scope#$root=0A=
       *=0A=
       * @description=0A=
       * Reference to the root scope.=0A=
       */=0A=
=0A=
    Scope.prototype =3D {=0A=
      constructor: Scope,=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$new=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Creates a new child {@link ng.$rootScope.Scope scope}.=0A=
       *=0A=
       * The parent scope will propagate the {@link =
ng.$rootScope.Scope#$digest $digest()} event.=0A=
       * The scope can be removed from the scope hierarchy using {@link =
ng.$rootScope.Scope#$destroy $destroy()}.=0A=
       *=0A=
       * {@link ng.$rootScope.Scope#$destroy $destroy()} must be called =
on a scope when it is=0A=
       * desired for the scope and its child scopes to be permanently =
detached from the parent and=0A=
       * thus stop participating in model change detection and listener =
notification by invoking.=0A=
       *=0A=
       * @param {boolean} isolate If true, then the scope does not =
prototypically inherit from the=0A=
       *         parent scope. The scope is isolated, as it can not see =
parent scope properties.=0A=
       *         When creating widgets, it is useful for the widget to =
not accidentally read parent=0A=
       *         state.=0A=
       *=0A=
       * @param {Scope} [parent=3Dthis] The {@link ng.$rootScope.Scope =
`Scope`} that will be the `$parent`=0A=
       *                              of the newly created scope. =
Defaults to `this` scope if not provided.=0A=
       *                              This is used when creating a =
transclude scope to correctly place it=0A=
       *                              in the scope hierarchy while =
maintaining the correct prototypical=0A=
       *                              inheritance.=0A=
       *=0A=
       * @returns {Object} The newly created child scope.=0A=
       *=0A=
       */=0A=
      $new: function(isolate, parent) {=0A=
        var child;=0A=
=0A=
        parent =3D parent || this;=0A=
=0A=
        if (isolate) {=0A=
          child =3D new Scope();=0A=
          child.$root =3D this.$root;=0A=
        } else {=0A=
          // Only create a child scope class if somebody asks for one,=0A=
          // but cache it to allow the VM to optimize lookups.=0A=
          if (!this.$$ChildScope) {=0A=
            this.$$ChildScope =3D function ChildScope() {=0A=
              this.$$watchers =3D this.$$nextSibling =3D=0A=
                  this.$$childHead =3D this.$$childTail =3D null;=0A=
              this.$$listeners =3D {};=0A=
              this.$$listenerCount =3D {};=0A=
              this.$id =3D nextUid();=0A=
              this.$$ChildScope =3D null;=0A=
            };=0A=
            this.$$ChildScope.prototype =3D this;=0A=
          }=0A=
          child =3D new this.$$ChildScope();=0A=
        }=0A=
        child.$parent =3D parent;=0A=
        child.$$prevSibling =3D parent.$$childTail;=0A=
        if (parent.$$childHead) {=0A=
          parent.$$childTail.$$nextSibling =3D child;=0A=
          parent.$$childTail =3D child;=0A=
        } else {=0A=
          parent.$$childHead =3D parent.$$childTail =3D child;=0A=
        }=0A=
=0A=
        // When the new scope is not isolated or we inherit from `this`, =
and=0A=
        // the parent scope is destroyed, the property `$$destroyed` is =
inherited=0A=
        // prototypically. In all other cases, this property needs to be =
set=0A=
        // when the parent scope is destroyed.=0A=
        // The listener needs to be added after the parent is set=0A=
        if (isolate || parent !=3D this) child.$on('$destroy', =
destroyChild);=0A=
=0A=
        return child;=0A=
=0A=
        function destroyChild() {=0A=
          child.$$destroyed =3D true;=0A=
        }=0A=
      },=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$watch=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Registers a `listener` callback to be executed whenever the =
`watchExpression` changes.=0A=
       *=0A=
       * - The `watchExpression` is called on every call to {@link =
ng.$rootScope.Scope#$digest=0A=
       *   $digest()} and should return the value that will be watched. =
(Since=0A=
       *   {@link ng.$rootScope.Scope#$digest $digest()} reruns when it =
detects changes the=0A=
       *   `watchExpression` can execute multiple times per=0A=
       *   {@link ng.$rootScope.Scope#$digest $digest()} and should be =
idempotent.)=0A=
       * - The `listener` is called only when the value from the current =
`watchExpression` and the=0A=
       *   previous call to `watchExpression` are not equal (with the =
exception of the initial run,=0A=
       *   see below). Inequality is determined according to reference =
inequality,=0A=
       *   [strict =
comparison](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Refer=
ence/Operators/Comparison_Operators)=0A=
       *    via the `!=3D=3D` Javascript operator, unless =
`objectEquality =3D=3D true`=0A=
       *   (see next point)=0A=
       * - When `objectEquality =3D=3D true`, inequality of the =
`watchExpression` is determined=0A=
       *   according to the {@link angular.equals} function. To save the =
value of the object for=0A=
       *   later comparison, the {@link angular.copy} function is used. =
This therefore means that=0A=
       *   watching complex objects will have adverse memory and =
performance implications.=0A=
       * - The watch `listener` may change the model, which may trigger =
other `listener`s to fire.=0A=
       *   This is achieved by rerunning the watchers until no changes =
are detected. The rerun=0A=
       *   iteration limit is 10 to prevent an infinite loop deadlock.=0A=
       *=0A=
       *=0A=
       * If you want to be notified whenever {@link =
ng.$rootScope.Scope#$digest $digest} is called,=0A=
       * you can register a `watchExpression` function with no =
`listener`. (Since `watchExpression`=0A=
       * can execute multiple times per {@link =
ng.$rootScope.Scope#$digest $digest} cycle when a=0A=
       * change is detected, be prepared for multiple calls to your =
listener.)=0A=
       *=0A=
       * After a watcher is registered with the scope, the `listener` fn =
is called asynchronously=0A=
       * (via {@link ng.$rootScope.Scope#$evalAsync $evalAsync}) to =
initialize the=0A=
       * watcher. In rare cases, this is undesirable because the =
listener is called when the result=0A=
       * of `watchExpression` didn't change. To detect this scenario =
within the `listener` fn, you=0A=
       * can compare the `newVal` and `oldVal`. If these two values are =
identical (`=3D=3D=3D`) then the=0A=
       * listener was called due to initialization.=0A=
       *=0A=
       *=0A=
       *=0A=
       * # Example=0A=
       * ```js=0A=
           // let's assume that scope was dependency injected as the =
$rootScope=0A=
           var scope =3D $rootScope;=0A=
           scope.name =3D 'misko';=0A=
           scope.counter =3D 0;=0A=
=0A=
           expect(scope.counter).toEqual(0);=0A=
           scope.$watch('name', function(newValue, oldValue) {=0A=
             scope.counter =3D scope.counter + 1;=0A=
           });=0A=
           expect(scope.counter).toEqual(0);=0A=
=0A=
           scope.$digest();=0A=
           // the listener is always called during the first $digest =
loop after it was registered=0A=
           expect(scope.counter).toEqual(1);=0A=
=0A=
           scope.$digest();=0A=
           // but now it will not be called unless the value changes=0A=
           expect(scope.counter).toEqual(1);=0A=
=0A=
           scope.name =3D 'adam';=0A=
           scope.$digest();=0A=
           expect(scope.counter).toEqual(2);=0A=
=0A=
=0A=
=0A=
           // Using a function as a watchExpression=0A=
           var food;=0A=
           scope.foodCounter =3D 0;=0A=
           expect(scope.foodCounter).toEqual(0);=0A=
           scope.$watch(=0A=
             // This function returns the value being watched. It is =
called for each turn of the $digest loop=0A=
             function() { return food; },=0A=
             // This is the change listener, called when the value =
returned from the above function changes=0A=
             function(newValue, oldValue) {=0A=
               if ( newValue !=3D=3D oldValue ) {=0A=
                 // Only increment the counter if the value changed=0A=
                 scope.foodCounter =3D scope.foodCounter + 1;=0A=
               }=0A=
             }=0A=
           );=0A=
           // No digest has been run so the counter will be zero=0A=
           expect(scope.foodCounter).toEqual(0);=0A=
=0A=
           // Run the digest but since food has not changed count will =
still be zero=0A=
           scope.$digest();=0A=
           expect(scope.foodCounter).toEqual(0);=0A=
=0A=
           // Update food and run digest.  Now the counter will increment=0A=
           food =3D 'cheeseburger';=0A=
           scope.$digest();=0A=
           expect(scope.foodCounter).toEqual(1);=0A=
=0A=
       * ```=0A=
       *=0A=
       *=0A=
       *=0A=
       * @param {(function()|string)} watchExpression Expression that is =
evaluated on each=0A=
       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. A change =
in the return value triggers=0A=
       *    a call to the `listener`.=0A=
       *=0A=
       *    - `string`: Evaluated as {@link guide/expression expression}=0A=
       *    - `function(scope)`: called with current `scope` as a =
parameter.=0A=
       * @param {function(newVal, oldVal, scope)} listener Callback =
called whenever the value=0A=
       *    of `watchExpression` changes.=0A=
       *=0A=
       *    - `newVal` contains the current value of the =
`watchExpression`=0A=
       *    - `oldVal` contains the previous value of the =
`watchExpression`=0A=
       *    - `scope` refers to the current scope=0A=
       * @param {boolean=3D} objectEquality Compare for object equality =
using {@link angular.equals} instead of=0A=
       *     comparing for reference equality.=0A=
       * @returns {function()} Returns a deregistration function for =
this listener.=0A=
       */=0A=
      $watch: function(watchExp, listener, objectEquality) {=0A=
        var get =3D $parse(watchExp);=0A=
=0A=
        if (get.$$watchDelegate) {=0A=
          return get.$$watchDelegate(this, listener, objectEquality, =
get);=0A=
        }=0A=
        var scope =3D this,=0A=
            array =3D scope.$$watchers,=0A=
            watcher =3D {=0A=
              fn: listener,=0A=
              last: initWatchVal,=0A=
              get: get,=0A=
              exp: watchExp,=0A=
              eq: !!objectEquality=0A=
            };=0A=
=0A=
        lastDirtyWatch =3D null;=0A=
=0A=
        if (!isFunction(listener)) {=0A=
          watcher.fn =3D noop;=0A=
        }=0A=
=0A=
        if (!array) {=0A=
          array =3D scope.$$watchers =3D [];=0A=
        }=0A=
        // we use unshift since we use a while loop in $digest for speed.=0A=
        // the while loop reads in reverse order.=0A=
        array.unshift(watcher);=0A=
=0A=
        return function deregisterWatch() {=0A=
          arrayRemove(array, watcher);=0A=
          lastDirtyWatch =3D null;=0A=
        };=0A=
      },=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$watchGroup=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * A variant of {@link ng.$rootScope.Scope#$watch $watch()} where =
it watches an array of `watchExpressions`.=0A=
       * If any one expression in the collection changes the `listener` =
is executed.=0A=
       *=0A=
       * - The items in the `watchExpressions` array are observed via =
standard $watch operation and are examined on every=0A=
       *   call to $digest() to see if any items changes.=0A=
       * - The `listener` is called whenever any expression in the =
`watchExpressions` array changes.=0A=
       *=0A=
       * @param {Array.&lt;string|Function(scope)&gt;} watchExpressions =
Array of expressions that will be individually=0A=
       * watched using {@link ng.$rootScope.Scope#$watch $watch()}=0A=
       *=0A=
       * @param {function(newValues, oldValues, scope)} listener =
Callback called whenever the return value of any=0A=
       *    expression in `watchExpressions` changes=0A=
       *    The `newValues` array contains the current values of the =
`watchExpressions`, with the indexes matching=0A=
       *    those of `watchExpression`=0A=
       *    and the `oldValues` array contains the previous values of =
the `watchExpressions`, with the indexes matching=0A=
       *    those of `watchExpression`=0A=
       *    The `scope` refers to the current scope.=0A=
       * @returns {function()} Returns a de-registration function for =
all listeners.=0A=
       */=0A=
      $watchGroup: function(watchExpressions, listener) {=0A=
        var oldValues =3D new Array(watchExpressions.length);=0A=
        var newValues =3D new Array(watchExpressions.length);=0A=
        var deregisterFns =3D [];=0A=
        var self =3D this;=0A=
        var changeReactionScheduled =3D false;=0A=
        var firstRun =3D true;=0A=
=0A=
        if (!watchExpressions.length) {=0A=
          // No expressions means we call the listener ASAP=0A=
          var shouldCall =3D true;=0A=
          self.$evalAsync(function () {=0A=
            if (shouldCall) listener(newValues, newValues, self);=0A=
          });=0A=
          return function deregisterWatchGroup() {=0A=
            shouldCall =3D false;=0A=
          };=0A=
        }=0A=
=0A=
        if (watchExpressions.length =3D=3D=3D 1) {=0A=
          // Special case size of one=0A=
          return this.$watch(watchExpressions[0], function =
watchGroupAction(value, oldValue, scope) {=0A=
            newValues[0] =3D value;=0A=
            oldValues[0] =3D oldValue;=0A=
            listener(newValues, (value =3D=3D=3D oldValue) ? newValues : =
oldValues, scope);=0A=
          });=0A=
        }=0A=
=0A=
        forEach(watchExpressions, function (expr, i) {=0A=
          var unwatchFn =3D self.$watch(expr, function =
watchGroupSubAction(value, oldValue) {=0A=
            newValues[i] =3D value;=0A=
            oldValues[i] =3D oldValue;=0A=
            if (!changeReactionScheduled) {=0A=
              changeReactionScheduled =3D true;=0A=
              self.$evalAsync(watchGroupAction);=0A=
            }=0A=
          });=0A=
          deregisterFns.push(unwatchFn);=0A=
        });=0A=
=0A=
        function watchGroupAction() {=0A=
          changeReactionScheduled =3D false;=0A=
=0A=
          if (firstRun) {=0A=
            firstRun =3D false;=0A=
            listener(newValues, newValues, self);=0A=
          } else {=0A=
            listener(newValues, oldValues, self);=0A=
          }=0A=
        }=0A=
=0A=
        return function deregisterWatchGroup() {=0A=
          while (deregisterFns.length) {=0A=
            deregisterFns.shift()();=0A=
          }=0A=
        };=0A=
      },=0A=
=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$watchCollection=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Shallow watches the properties of an object and fires whenever =
any of the properties change=0A=
       * (for arrays, this implies watching the array items; for object =
maps, this implies watching=0A=
       * the properties). If a change is detected, the `listener` =
callback is fired.=0A=
       *=0A=
       * - The `obj` collection is observed via standard $watch =
operation and is examined on every=0A=
       *   call to $digest() to see if any items have been added, =
removed, or moved.=0A=
       * - The `listener` is called whenever anything within the `obj` =
has changed. Examples include=0A=
       *   adding, removing, and moving items belonging to an object or =
array.=0A=
       *=0A=
       *=0A=
       * # Example=0A=
       * ```js=0A=
          $scope.names =3D ['igor', 'matias', 'misko', 'james'];=0A=
          $scope.dataCount =3D 4;=0A=
=0A=
          $scope.$watchCollection('names', function(newNames, oldNames) {=0A=
            $scope.dataCount =3D newNames.length;=0A=
          });=0A=
=0A=
          expect($scope.dataCount).toEqual(4);=0A=
          $scope.$digest();=0A=
=0A=
          //still at 4 ... no changes=0A=
          expect($scope.dataCount).toEqual(4);=0A=
=0A=
          $scope.names.pop();=0A=
          $scope.$digest();=0A=
=0A=
          //now there's been a change=0A=
          expect($scope.dataCount).toEqual(3);=0A=
       * ```=0A=
       *=0A=
       *=0A=
       * @param {string|function(scope)} obj Evaluated as {@link =
guide/expression expression}. The=0A=
       *    expression value should evaluate to an object or an array =
which is observed on each=0A=
       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. Any =
shallow change within the=0A=
       *    collection will trigger a call to the `listener`.=0A=
       *=0A=
       * @param {function(newCollection, oldCollection, scope)} listener =
a callback function called=0A=
       *    when a change is detected.=0A=
       *    - The `newCollection` object is the newly modified data =
obtained from the `obj` expression=0A=
       *    - The `oldCollection` object is a copy of the former =
collection data.=0A=
       *      Due to performance considerations, the`oldCollection` =
value is computed only if the=0A=
       *      `listener` function declares two or more arguments.=0A=
       *    - The `scope` argument refers to the current scope.=0A=
       *=0A=
       * @returns {function()} Returns a de-registration function for =
this listener. When the=0A=
       *    de-registration function is executed, the internal watch =
operation is terminated.=0A=
       */=0A=
      $watchCollection: function(obj, listener) {=0A=
        $watchCollectionInterceptor.$stateful =3D true;=0A=
=0A=
        var self =3D this;=0A=
        // the current value, updated on each dirty-check run=0A=
        var newValue;=0A=
        // a shallow copy of the newValue from the last dirty-check run,=0A=
        // updated to match newValue during dirty-check run=0A=
        var oldValue;=0A=
        // a shallow copy of the newValue from when the last change =
happened=0A=
        var veryOldValue;=0A=
        // only track veryOldValue if the listener is asking for it=0A=
        var trackVeryOldValue =3D (listener.length &gt; 1);=0A=
        var changeDetected =3D 0;=0A=
        var changeDetector =3D $parse(obj, $watchCollectionInterceptor);=0A=
        var internalArray =3D [];=0A=
        var internalObject =3D {};=0A=
        var initRun =3D true;=0A=
        var oldLength =3D 0;=0A=
=0A=
        function $watchCollectionInterceptor(_value) {=0A=
          newValue =3D _value;=0A=
          var newLength, key, bothNaN, newItem, oldItem;=0A=
=0A=
          if (!isObject(newValue)) { // if primitive=0A=
            if (oldValue !=3D=3D newValue) {=0A=
              oldValue =3D newValue;=0A=
              changeDetected++;=0A=
            }=0A=
          } else if (isArrayLike(newValue)) {=0A=
            if (oldValue !=3D=3D internalArray) {=0A=
              // we are transitioning from something which was not an =
array into array.=0A=
              oldValue =3D internalArray;=0A=
              oldLength =3D oldValue.length =3D 0;=0A=
              changeDetected++;=0A=
            }=0A=
=0A=
            newLength =3D newValue.length;=0A=
=0A=
            if (oldLength !=3D=3D newLength) {=0A=
              // if lengths do not match we need to trigger change =
notification=0A=
              changeDetected++;=0A=
              oldValue.length =3D oldLength =3D newLength;=0A=
            }=0A=
            // copy the items to oldValue and look for changes.=0A=
            for (var i =3D 0; i &lt; newLength; i++) {=0A=
              oldItem =3D oldValue[i];=0A=
              newItem =3D newValue[i];=0A=
=0A=
              bothNaN =3D (oldItem !=3D=3D oldItem) &amp;&amp; (newItem =
!=3D=3D newItem);=0A=
              if (!bothNaN &amp;&amp; (oldItem !=3D=3D newItem)) {=0A=
                changeDetected++;=0A=
                oldValue[i] =3D newItem;=0A=
              }=0A=
            }=0A=
          } else {=0A=
            if (oldValue !=3D=3D internalObject) {=0A=
              // we are transitioning from something which was not an =
object into object.=0A=
              oldValue =3D internalObject =3D {};=0A=
              oldLength =3D 0;=0A=
              changeDetected++;=0A=
            }=0A=
            // copy the items to oldValue and look for changes.=0A=
            newLength =3D 0;=0A=
            for (key in newValue) {=0A=
              if (newValue.hasOwnProperty(key)) {=0A=
                newLength++;=0A=
                newItem =3D newValue[key];=0A=
                oldItem =3D oldValue[key];=0A=
=0A=
                if (key in oldValue) {=0A=
                  bothNaN =3D (oldItem !=3D=3D oldItem) &amp;&amp; =
(newItem !=3D=3D newItem);=0A=
                  if (!bothNaN &amp;&amp; (oldItem !=3D=3D newItem)) {=0A=
                    changeDetected++;=0A=
                    oldValue[key] =3D newItem;=0A=
                  }=0A=
                } else {=0A=
                  oldLength++;=0A=
                  oldValue[key] =3D newItem;=0A=
                  changeDetected++;=0A=
                }=0A=
              }=0A=
            }=0A=
            if (oldLength &gt; newLength) {=0A=
              // we used to have more keys, need to find them and =
destroy them.=0A=
              changeDetected++;=0A=
              for(key in oldValue) {=0A=
                if (!newValue.hasOwnProperty(key)) {=0A=
                  oldLength--;=0A=
                  delete oldValue[key];=0A=
                }=0A=
              }=0A=
            }=0A=
          }=0A=
          return changeDetected;=0A=
        }=0A=
=0A=
        function $watchCollectionAction() {=0A=
          if (initRun) {=0A=
            initRun =3D false;=0A=
            listener(newValue, newValue, self);=0A=
          } else {=0A=
            listener(newValue, veryOldValue, self);=0A=
          }=0A=
=0A=
          // make a copy for the next time a collection is changed=0A=
          if (trackVeryOldValue) {=0A=
            if (!isObject(newValue)) {=0A=
              //primitive=0A=
              veryOldValue =3D newValue;=0A=
            } else if (isArrayLike(newValue)) {=0A=
              veryOldValue =3D new Array(newValue.length);=0A=
              for (var i =3D 0; i &lt; newValue.length; i++) {=0A=
                veryOldValue[i] =3D newValue[i];=0A=
              }=0A=
            } else { // if object=0A=
              veryOldValue =3D {};=0A=
              for (var key in newValue) {=0A=
                if (hasOwnProperty.call(newValue, key)) {=0A=
                  veryOldValue[key] =3D newValue[key];=0A=
                }=0A=
              }=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        return this.$watch(changeDetector, $watchCollectionAction);=0A=
      },=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$digest=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Processes all of the {@link ng.$rootScope.Scope#$watch =
watchers} of the current scope and=0A=
       * its children. Because a {@link ng.$rootScope.Scope#$watch =
watcher}'s listener can change=0A=
       * the model, the `$digest()` keeps calling the {@link =
ng.$rootScope.Scope#$watch watchers}=0A=
       * until no more listeners are firing. This means that it is =
possible to get into an infinite=0A=
       * loop. This function will throw `'Maximum iteration limit =
exceeded.'` if the number of=0A=
       * iterations exceeds 10.=0A=
       *=0A=
       * Usually, you don't call `$digest()` directly in=0A=
       * {@link ng.directive:ngController controllers} or in=0A=
       * {@link ng.$compileProvider#directive directives}.=0A=
       * Instead, you should call {@link ng.$rootScope.Scope#$apply =
$apply()} (typically from within=0A=
       * a {@link ng.$compileProvider#directive directive}), which will =
force a `$digest()`.=0A=
       *=0A=
       * If you want to be notified whenever `$digest()` is called,=0A=
       * you can register a `watchExpression` function with=0A=
       * {@link ng.$rootScope.Scope#$watch $watch()} with no `listener`.=0A=
       *=0A=
       * In unit tests, you may need to call `$digest()` to simulate the =
scope life cycle.=0A=
       *=0A=
       * # Example=0A=
       * ```js=0A=
           var scope =3D ...;=0A=
           scope.name =3D 'misko';=0A=
           scope.counter =3D 0;=0A=
=0A=
           expect(scope.counter).toEqual(0);=0A=
           scope.$watch('name', function(newValue, oldValue) {=0A=
             scope.counter =3D scope.counter + 1;=0A=
           });=0A=
           expect(scope.counter).toEqual(0);=0A=
=0A=
           scope.$digest();=0A=
           // the listener is always called during the first $digest =
loop after it was registered=0A=
           expect(scope.counter).toEqual(1);=0A=
=0A=
           scope.$digest();=0A=
           // but now it will not be called unless the value changes=0A=
           expect(scope.counter).toEqual(1);=0A=
=0A=
           scope.name =3D 'adam';=0A=
           scope.$digest();=0A=
           expect(scope.counter).toEqual(2);=0A=
       * ```=0A=
       *=0A=
       */=0A=
      $digest: function() {=0A=
        var watch, value, last,=0A=
            watchers,=0A=
            length,=0A=
            dirty, ttl =3D TTL,=0A=
            next, current, target =3D this,=0A=
            watchLog =3D [],=0A=
            logIdx, logMsg, asyncTask;=0A=
=0A=
        beginPhase('$digest');=0A=
        // Check for changes to browser url that happened in sync before =
the call to $digest=0A=
        $browser.$$checkUrlChange();=0A=
=0A=
        if (this =3D=3D=3D $rootScope &amp;&amp; applyAsyncId !=3D=3D =
null) {=0A=
          // If this is the root scope, and $applyAsync has scheduled a =
deferred $apply(), then=0A=
          // cancel the scheduled $apply and flush the queue of =
expressions to be evaluated.=0A=
          $browser.defer.cancel(applyAsyncId);=0A=
          flushApplyAsync();=0A=
        }=0A=
=0A=
        lastDirtyWatch =3D null;=0A=
=0A=
        do { // "while dirty" loop=0A=
          dirty =3D false;=0A=
          current =3D target;=0A=
=0A=
          while(asyncQueue.length) {=0A=
            try {=0A=
              asyncTask =3D asyncQueue.shift();=0A=
              asyncTask.scope.$eval(asyncTask.expression);=0A=
            } catch (e) {=0A=
              $exceptionHandler(e);=0A=
            }=0A=
            lastDirtyWatch =3D null;=0A=
          }=0A=
=0A=
          traverseScopesLoop:=0A=
          do { // "traverse the scopes" loop=0A=
            if ((watchers =3D current.$$watchers)) {=0A=
              // process our watches=0A=
              length =3D watchers.length;=0A=
              while (length--) {=0A=
                try {=0A=
                  watch =3D watchers[length];=0A=
                  // Most common watches are on primitives, in which =
case we can short=0A=
                  // circuit it with =3D=3D=3D operator, only when =
=3D=3D=3D fails do we use .equals=0A=
                  if (watch) {=0A=
                    if ((value =3D watch.get(current)) !=3D=3D (last =3D =
watch.last) &amp;&amp;=0A=
                        !(watch.eq=0A=
                            ? equals(value, last)=0A=
                            : (typeof value =3D=3D=3D 'number' =
&amp;&amp; typeof last =3D=3D=3D 'number'=0A=
                               &amp;&amp; isNaN(value) &amp;&amp; =
isNaN(last)))) {=0A=
                      dirty =3D true;=0A=
                      lastDirtyWatch =3D watch;=0A=
                      watch.last =3D watch.eq ? copy(value, null) : =
value;=0A=
                      watch.fn(value, ((last =3D=3D=3D initWatchVal) ? =
value : last), current);=0A=
                      if (ttl &lt; 5) {=0A=
                        logIdx =3D 4 - ttl;=0A=
                        if (!watchLog[logIdx]) watchLog[logIdx] =3D [];=0A=
                        logMsg =3D (isFunction(watch.exp))=0A=
                            ? 'fn: ' + (watch.exp.name || =
watch.exp.toString())=0A=
                            : watch.exp;=0A=
                        logMsg +=3D '; newVal: ' + toJson(value) + '; =
oldVal: ' + toJson(last);=0A=
                        watchLog[logIdx].push(logMsg);=0A=
                      }=0A=
                    } else if (watch =3D=3D=3D lastDirtyWatch) {=0A=
                      // If the most recently dirty watcher is now =
clean, short circuit since the remaining watchers=0A=
                      // have already been tested.=0A=
                      dirty =3D false;=0A=
                      break traverseScopesLoop;=0A=
                    }=0A=
                  }=0A=
                } catch (e) {=0A=
                  $exceptionHandler(e);=0A=
                }=0A=
              }=0A=
            }=0A=
=0A=
            // Insanity Warning: scope depth-first traversal=0A=
            // yes, this code is a bit crazy, but it works and we have =
tests to prove it!=0A=
            // this piece should be kept in sync with the traversal in =
$broadcast=0A=
            if (!(next =3D (current.$$childHead ||=0A=
                (current !=3D=3D target &amp;&amp; =
current.$$nextSibling)))) {=0A=
              while(current !=3D=3D target &amp;&amp; !(next =3D =
current.$$nextSibling)) {=0A=
                current =3D current.$parent;=0A=
              }=0A=
            }=0A=
          } while ((current =3D next));=0A=
=0A=
          // `break traverseScopesLoop;` takes us to here=0A=
=0A=
          if((dirty || asyncQueue.length) &amp;&amp; !(ttl--)) {=0A=
            clearPhase();=0A=
            throw $rootScopeMinErr('infdig',=0A=
                '{0} $digest() iterations reached. Aborting!\n' +=0A=
                'Watchers fired in the last 5 iterations: {1}',=0A=
                TTL, toJson(watchLog));=0A=
          }=0A=
=0A=
        } while (dirty || asyncQueue.length);=0A=
=0A=
        clearPhase();=0A=
=0A=
        while(postDigestQueue.length) {=0A=
          try {=0A=
            postDigestQueue.shift()();=0A=
          } catch (e) {=0A=
            $exceptionHandler(e);=0A=
          }=0A=
        }=0A=
      },=0A=
=0A=
=0A=
      /**=0A=
       * @ngdoc event=0A=
       * @name $rootScope.Scope#$destroy=0A=
       * @eventType broadcast on scope being destroyed=0A=
       *=0A=
       * @description=0A=
       * Broadcasted when a scope and its children are being destroyed.=0A=
       *=0A=
       * Note that, in AngularJS, there is also a `$destroy` jQuery =
event, which can be used to=0A=
       * clean up DOM bindings before an element is removed from the DOM.=0A=
       */=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$destroy=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Removes the current scope (and all of its children) from the =
parent scope. Removal implies=0A=
       * that calls to {@link ng.$rootScope.Scope#$digest $digest()} =
will no longer=0A=
       * propagate to the current scope and its children. Removal also =
implies that the current=0A=
       * scope is eligible for garbage collection.=0A=
       *=0A=
       * The `$destroy()` is usually used by directives such as=0A=
       * {@link ng.directive:ngRepeat ngRepeat} for managing the=0A=
       * unrolling of the loop.=0A=
       *=0A=
       * Just before a scope is destroyed, a `$destroy` event is =
broadcasted on this scope.=0A=
       * Application code can register a `$destroy` event handler that =
will give it a chance to=0A=
       * perform any necessary cleanup.=0A=
       *=0A=
       * Note that, in AngularJS, there is also a `$destroy` jQuery =
event, which can be used to=0A=
       * clean up DOM bindings before an element is removed from the DOM.=0A=
       */=0A=
      $destroy: function() {=0A=
        // we can't destroy the root scope or a scope that has been =
already destroyed=0A=
        if (this.$$destroyed) return;=0A=
        var parent =3D this.$parent;=0A=
=0A=
        this.$broadcast('$destroy');=0A=
        this.$$destroyed =3D true;=0A=
        if (this =3D=3D=3D $rootScope) return;=0A=
=0A=
        for (var eventName in this.$$listenerCount) {=0A=
          decrementListenerCount(this, this.$$listenerCount[eventName], =
eventName);=0A=
        }=0A=
=0A=
        // sever all the references to parent scopes (after this =
cleanup, the current scope should=0A=
        // not be retained by any of our references and should be =
eligible for garbage collection)=0A=
        if (parent.$$childHead =3D=3D this) parent.$$childHead =3D =
this.$$nextSibling;=0A=
        if (parent.$$childTail =3D=3D this) parent.$$childTail =3D =
this.$$prevSibling;=0A=
        if (this.$$prevSibling) this.$$prevSibling.$$nextSibling =3D =
this.$$nextSibling;=0A=
        if (this.$$nextSibling) this.$$nextSibling.$$prevSibling =3D =
this.$$prevSibling;=0A=
=0A=
        // Disable listeners, watchers and apply/digest methods=0A=
        this.$destroy =3D this.$digest =3D this.$apply =3D =
this.$evalAsync =3D this.$applyAsync =3D noop;=0A=
        this.$on =3D this.$watch =3D this.$watchGroup =3D function() { =
return noop; };=0A=
        this.$$listeners =3D {};=0A=
=0A=
        // All of the code below is bogus code that works around V8's =
memory leak via optimized code=0A=
        // and inline caches.=0A=
        //=0A=
        // see:=0A=
        // - https://code.google.com/p/v8/issues/detail?id=3D2073#c26=0A=
        // - =
https://github.com/angular/angular.js/issues/6794#issuecomment-38648909=0A=
        // - =
https://github.com/angular/angular.js/issues/1313#issuecomment-10378451=0A=
=0A=
        this.$parent =3D this.$$nextSibling =3D this.$$prevSibling =3D =
this.$$childHead =3D=0A=
            this.$$childTail =3D this.$root =3D this.$$watchers =3D null;=0A=
      },=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$eval=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Executes the `expression` on the current scope and returns the =
result. Any exceptions in=0A=
       * the expression are propagated (uncaught). This is useful when =
evaluating Angular=0A=
       * expressions.=0A=
       *=0A=
       * # Example=0A=
       * ```js=0A=
           var scope =3D ng.$rootScope.Scope();=0A=
           scope.a =3D 1;=0A=
           scope.b =3D 2;=0A=
=0A=
           expect(scope.$eval('a+b')).toEqual(3);=0A=
           expect(scope.$eval(function(scope){ return scope.a + scope.b; =
})).toEqual(3);=0A=
       * ```=0A=
       *=0A=
       * @param {(string|function())=3D} expression An angular =
expression to be executed.=0A=
       *=0A=
       *    - `string`: execute using the rules as defined in  {@link =
guide/expression expression}.=0A=
       *    - `function(scope)`: execute the function with the current =
`scope` parameter.=0A=
       *=0A=
       * @param {(object)=3D} locals Local variables object, useful for =
overriding values in scope.=0A=
       * @returns {*} The result of evaluating the expression.=0A=
       */=0A=
      $eval: function(expr, locals) {=0A=
        return $parse(expr)(this, locals);=0A=
      },=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$evalAsync=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Executes the expression on the current scope at a later point =
in time.=0A=
       *=0A=
       * The `$evalAsync` makes no guarantees as to when the =
`expression` will be executed, only=0A=
       * that:=0A=
       *=0A=
       *   - it will execute after the function that scheduled the =
evaluation (preferably before DOM=0A=
       *     rendering).=0A=
       *   - at least one {@link ng.$rootScope.Scope#$digest $digest =
cycle} will be performed after=0A=
       *     `expression` execution.=0A=
       *=0A=
       * Any exceptions from the execution of the expression are =
forwarded to the=0A=
       * {@link ng.$exceptionHandler $exceptionHandler} service.=0A=
       *=0A=
       * __Note:__ if this function is called outside of a `$digest` =
cycle, a new `$digest` cycle=0A=
       * will be scheduled. However, it is encouraged to always call =
code that changes the model=0A=
       * from within an `$apply` call. That includes code evaluated via =
`$evalAsync`.=0A=
       *=0A=
       * @param {(string|function())=3D} expression An angular =
expression to be executed.=0A=
       *=0A=
       *    - `string`: execute using the rules as defined in {@link =
guide/expression expression}.=0A=
       *    - `function(scope)`: execute the function with the current =
`scope` parameter.=0A=
       *=0A=
       */=0A=
      $evalAsync: function(expr) {=0A=
        // if we are outside of an $digest loop and this is the first =
time we are scheduling async=0A=
        // task also schedule async auto-flush=0A=
        if (!$rootScope.$$phase &amp;&amp; !asyncQueue.length) {=0A=
          $browser.defer(function() {=0A=
            if (asyncQueue.length) {=0A=
              $rootScope.$digest();=0A=
            }=0A=
          });=0A=
        }=0A=
=0A=
        asyncQueue.push({scope: this, expression: expr});=0A=
      },=0A=
=0A=
      $$postDigest : function(fn) {=0A=
        postDigestQueue.push(fn);=0A=
      },=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$apply=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * `$apply()` is used to execute an expression in angular from =
outside of the angular=0A=
       * framework. (For example from browser DOM events, setTimeout, =
XHR or third party libraries).=0A=
       * Because we are calling into the angular framework we need to =
perform proper scope life=0A=
       * cycle of {@link ng.$exceptionHandler exception handling},=0A=
       * {@link ng.$rootScope.Scope#$digest executing watches}.=0A=
       *=0A=
       * ## Life cycle=0A=
       *=0A=
       * # Pseudo-Code of `$apply()`=0A=
       * ```js=0A=
           function $apply(expr) {=0A=
             try {=0A=
               return $eval(expr);=0A=
             } catch (e) {=0A=
               $exceptionHandler(e);=0A=
             } finally {=0A=
               $root.$digest();=0A=
             }=0A=
           }=0A=
       * ```=0A=
       *=0A=
       *=0A=
       * Scope's `$apply()` method transitions through the following =
stages:=0A=
       *=0A=
       * 1. The {@link guide/expression expression} is executed using the=0A=
       *    {@link ng.$rootScope.Scope#$eval $eval()} method.=0A=
       * 2. Any exceptions from the execution of the expression are =
forwarded to the=0A=
       *    {@link ng.$exceptionHandler $exceptionHandler} service.=0A=
       * 3. The {@link ng.$rootScope.Scope#$watch watch} listeners are =
fired immediately after the=0A=
       *    expression was executed using the {@link =
ng.$rootScope.Scope#$digest $digest()} method.=0A=
       *=0A=
       *=0A=
       * @param {(string|function())=3D} exp An angular expression to be =
executed.=0A=
       *=0A=
       *    - `string`: execute using the rules as defined in {@link =
guide/expression expression}.=0A=
       *    - `function(scope)`: execute the function with current =
`scope` parameter.=0A=
       *=0A=
       * @returns {*} The result of evaluating the expression.=0A=
       */=0A=
      $apply: function(expr) {=0A=
        try {=0A=
          beginPhase('$apply');=0A=
          return this.$eval(expr);=0A=
        } catch (e) {=0A=
          $exceptionHandler(e);=0A=
        } finally {=0A=
          clearPhase();=0A=
          try {=0A=
            $rootScope.$digest();=0A=
          } catch (e) {=0A=
            $exceptionHandler(e);=0A=
            throw e;=0A=
          }=0A=
        }=0A=
      },=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$applyAsync=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Schedule the invokation of $apply to occur at a later time. The =
actual time difference=0A=
       * varies across browsers, but is typically around ~10 =
milliseconds.=0A=
       *=0A=
       * This can be used to queue up multiple expressions which need to =
be evaluated in the same=0A=
       * digest.=0A=
       *=0A=
       * @param {(string|function())=3D} exp An angular expression to be =
executed.=0A=
       *=0A=
       *    - `string`: execute using the rules as defined in {@link =
guide/expression expression}.=0A=
       *    - `function(scope)`: execute the function with current =
`scope` parameter.=0A=
       */=0A=
      $applyAsync: function(expr) {=0A=
        var scope =3D this;=0A=
        expr &amp;&amp; applyAsyncQueue.push($applyAsyncExpression);=0A=
        scheduleApplyAsync();=0A=
=0A=
        function $applyAsyncExpression() {=0A=
          scope.$eval(expr);=0A=
        }=0A=
      },=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$on=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Listens on events of a given type. See {@link =
ng.$rootScope.Scope#$emit $emit} for=0A=
       * discussion of event life cycle.=0A=
       *=0A=
       * The event listener function format is: `function(event, =
args...)`. The `event` object=0A=
       * passed into the listener has the following attributes:=0A=
       *=0A=
       *   - `targetScope` - `{Scope}`: the scope on which the event was =
`$emit`-ed or=0A=
       *     `$broadcast`-ed.=0A=
       *   - `currentScope` - `{Scope}`: the scope that is currently =
handling the event. Once the=0A=
       *     event propagates through the scope hierarchy, this property =
is set to null.=0A=
       *   - `name` - `{string}`: name of the event.=0A=
       *   - `stopPropagation` - `{function=3D}`: calling =
`stopPropagation` function will cancel=0A=
       *     further event propagation (available only for events that =
were `$emit`-ed).=0A=
       *   - `preventDefault` - `{function}`: calling `preventDefault` =
sets `defaultPrevented` flag=0A=
       *     to true.=0A=
       *   - `defaultPrevented` - `{boolean}`: true if `preventDefault` =
was called.=0A=
       *=0A=
       * @param {string} name Event name to listen on.=0A=
       * @param {function(event, ...args)} listener Function to call =
when the event is emitted.=0A=
       * @returns {function()} Returns a deregistration function for =
this listener.=0A=
       */=0A=
      $on: function(name, listener) {=0A=
        var namedListeners =3D this.$$listeners[name];=0A=
        if (!namedListeners) {=0A=
          this.$$listeners[name] =3D namedListeners =3D [];=0A=
        }=0A=
        namedListeners.push(listener);=0A=
=0A=
        var current =3D this;=0A=
        do {=0A=
          if (!current.$$listenerCount[name]) {=0A=
            current.$$listenerCount[name] =3D 0;=0A=
          }=0A=
          current.$$listenerCount[name]++;=0A=
        } while ((current =3D current.$parent));=0A=
=0A=
        var self =3D this;=0A=
        return function() {=0A=
          namedListeners[namedListeners.indexOf(listener)] =3D null;=0A=
          decrementListenerCount(self, 1, name);=0A=
        };=0A=
      },=0A=
=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$emit=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Dispatches an event `name` upwards through the scope hierarchy =
notifying the=0A=
       * registered {@link ng.$rootScope.Scope#$on} listeners.=0A=
       *=0A=
       * The event life cycle starts at the scope on which `$emit` was =
called. All=0A=
       * {@link ng.$rootScope.Scope#$on listeners} listening for `name` =
event on this scope get=0A=
       * notified. Afterwards, the event traverses upwards toward the =
root scope and calls all=0A=
       * registered listeners along the way. The event will stop =
propagating if one of the listeners=0A=
       * cancels it.=0A=
       *=0A=
       * Any exception emitted from the {@link ng.$rootScope.Scope#$on =
listeners} will be passed=0A=
       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.=0A=
       *=0A=
       * @param {string} name Event name to emit.=0A=
       * @param {...*} args Optional one or more arguments which will be =
passed onto the event listeners.=0A=
       * @return {Object} Event object (see {@link =
ng.$rootScope.Scope#$on}).=0A=
       */=0A=
      $emit: function(name, args) {=0A=
        var empty =3D [],=0A=
            namedListeners,=0A=
            scope =3D this,=0A=
            stopPropagation =3D false,=0A=
            event =3D {=0A=
              name: name,=0A=
              targetScope: scope,=0A=
              stopPropagation: function() {stopPropagation =3D true;},=0A=
              preventDefault: function() {=0A=
                event.defaultPrevented =3D true;=0A=
              },=0A=
              defaultPrevented: false=0A=
            },=0A=
            listenerArgs =3D concat([event], arguments, 1),=0A=
            i, length;=0A=
=0A=
        do {=0A=
          namedListeners =3D scope.$$listeners[name] || empty;=0A=
          event.currentScope =3D scope;=0A=
          for (i=3D0, length=3DnamedListeners.length; i&lt;length; i++) {=0A=
=0A=
            // if listeners were deregistered, defragment the array=0A=
            if (!namedListeners[i]) {=0A=
              namedListeners.splice(i, 1);=0A=
              i--;=0A=
              length--;=0A=
              continue;=0A=
            }=0A=
            try {=0A=
              //allow all listeners attached to the current scope to run=0A=
              namedListeners[i].apply(null, listenerArgs);=0A=
            } catch (e) {=0A=
              $exceptionHandler(e);=0A=
            }=0A=
          }=0A=
          //if any listener on the current scope stops propagation, =
prevent bubbling=0A=
          if (stopPropagation) {=0A=
            event.currentScope =3D null;=0A=
            return event;=0A=
          }=0A=
          //traverse upwards=0A=
          scope =3D scope.$parent;=0A=
        } while (scope);=0A=
=0A=
        event.currentScope =3D null;=0A=
=0A=
        return event;=0A=
      },=0A=
=0A=
=0A=
      /**=0A=
       * @ngdoc method=0A=
       * @name $rootScope.Scope#$broadcast=0A=
       * @kind function=0A=
       *=0A=
       * @description=0A=
       * Dispatches an event `name` downwards to all child scopes (and =
their children) notifying the=0A=
       * registered {@link ng.$rootScope.Scope#$on} listeners.=0A=
       *=0A=
       * The event life cycle starts at the scope on which `$broadcast` =
was called. All=0A=
       * {@link ng.$rootScope.Scope#$on listeners} listening for `name` =
event on this scope get=0A=
       * notified. Afterwards, the event propagates to all direct and =
indirect scopes of the current=0A=
       * scope and calls all registered listeners along the way. The =
event cannot be canceled.=0A=
       *=0A=
       * Any exception emitted from the {@link ng.$rootScope.Scope#$on =
listeners} will be passed=0A=
       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.=0A=
       *=0A=
       * @param {string} name Event name to broadcast.=0A=
       * @param {...*} args Optional one or more arguments which will be =
passed onto the event listeners.=0A=
       * @return {Object} Event object, see {@link =
ng.$rootScope.Scope#$on}=0A=
       */=0A=
      $broadcast: function(name, args) {=0A=
        var target =3D this,=0A=
            current =3D target,=0A=
            next =3D target,=0A=
            event =3D {=0A=
              name: name,=0A=
              targetScope: target,=0A=
              preventDefault: function() {=0A=
                event.defaultPrevented =3D true;=0A=
              },=0A=
              defaultPrevented: false=0A=
            };=0A=
=0A=
        if (!target.$$listenerCount[name]) return event;=0A=
=0A=
        var listenerArgs =3D concat([event], arguments, 1),=0A=
            listeners, i, length;=0A=
=0A=
        //down while you can, then up and next sibling or up and next =
sibling until back at root=0A=
        while ((current =3D next)) {=0A=
          event.currentScope =3D current;=0A=
          listeners =3D current.$$listeners[name] || [];=0A=
          for (i=3D0, length =3D listeners.length; i&lt;length; i++) {=0A=
            // if listeners were deregistered, defragment the array=0A=
            if (!listeners[i]) {=0A=
              listeners.splice(i, 1);=0A=
              i--;=0A=
              length--;=0A=
              continue;=0A=
            }=0A=
=0A=
            try {=0A=
              listeners[i].apply(null, listenerArgs);=0A=
            } catch(e) {=0A=
              $exceptionHandler(e);=0A=
            }=0A=
          }=0A=
=0A=
          // Insanity Warning: scope depth-first traversal=0A=
          // yes, this code is a bit crazy, but it works and we have =
tests to prove it!=0A=
          // this piece should be kept in sync with the traversal in =
$digest=0A=
          // (though it differs due to having the extra check for =
$$listenerCount)=0A=
          if (!(next =3D ((current.$$listenerCount[name] &amp;&amp; =
current.$$childHead) ||=0A=
              (current !=3D=3D target &amp;&amp; =
current.$$nextSibling)))) {=0A=
            while(current !=3D=3D target &amp;&amp; !(next =3D =
current.$$nextSibling)) {=0A=
              current =3D current.$parent;=0A=
            }=0A=
          }=0A=
        }=0A=
=0A=
        event.currentScope =3D null;=0A=
        return event;=0A=
      }=0A=
    };=0A=
=0A=
    var $rootScope =3D new Scope();=0A=
=0A=
    //The internal queues. Expose them on the $rootScope for =
debugging/testing purposes.=0A=
    var asyncQueue =3D $rootScope.$$asyncQueue =3D [];=0A=
    var postDigestQueue =3D $rootScope.$$postDigestQueue =3D [];=0A=
    var applyAsyncQueue =3D $rootScope.$$applyAsyncQueue =3D [];=0A=
=0A=
    return $rootScope;=0A=
=0A=
=0A=
    function beginPhase(phase) {=0A=
      if ($rootScope.$$phase) {=0A=
        throw $rootScopeMinErr('inprog', '{0} already in progress', =
$rootScope.$$phase);=0A=
      }=0A=
=0A=
      $rootScope.$$phase =3D phase;=0A=
    }=0A=
=0A=
    function clearPhase() {=0A=
      $rootScope.$$phase =3D null;=0A=
    }=0A=
=0A=
=0A=
    function decrementListenerCount(current, count, name) {=0A=
      do {=0A=
        current.$$listenerCount[name] -=3D count;=0A=
=0A=
        if (current.$$listenerCount[name] =3D=3D=3D 0) {=0A=
          delete current.$$listenerCount[name];=0A=
        }=0A=
      } while ((current =3D current.$parent));=0A=
    }=0A=
=0A=
    /**=0A=
     * function used as an initial value for watchers.=0A=
     * because it's unique we can easily tell it apart from other values=0A=
     */=0A=
    function initWatchVal() {}=0A=
=0A=
    function flushApplyAsync() {=0A=
      while (applyAsyncQueue.length) {=0A=
        try {=0A=
          applyAsyncQueue.shift()();=0A=
        } catch(e) {=0A=
          $exceptionHandler(e);=0A=
        }=0A=
      }=0A=
      applyAsyncId =3D null;=0A=
    }=0A=
=0A=
    function scheduleApplyAsync() {=0A=
      if (applyAsyncId =3D=3D=3D null) {=0A=
        applyAsyncId =3D $browser.defer(function() {=0A=
          $rootScope.$apply(flushApplyAsync);=0A=
        });=0A=
      }=0A=
    }=0A=
  }];=0A=
}=0A=
=0A=
/**=0A=
 * @description=0A=
 * Private service to sanitize uris for links and images. Used by =
$compile and $sanitize.=0A=
 */=0A=
function $$SanitizeUriProvider() {=0A=
  var aHrefSanitizationWhitelist =3D /^\s*(https?|ftp|mailto|tel|file):/,=0A=
    imgSrcSanitizationWhitelist =3D =
/^\s*((https?|ftp|file|blob):|data:image\/)/;=0A=
=0A=
  /**=0A=
   * @description=0A=
   * Retrieves or overrides the default regular expression that is used =
for whitelisting of safe=0A=
   * urls during a[href] sanitization.=0A=
   *=0A=
   * The sanitization is a security measure aimed at prevent XSS attacks =
via html links.=0A=
   *=0A=
   * Any url about to be assigned to a[href] via data-binding is first =
normalized and turned into=0A=
   * an absolute url. Afterwards, the url is matched against the =
`aHrefSanitizationWhitelist`=0A=
   * regular expression. If a match is found, the original url is =
written into the dom. Otherwise,=0A=
   * the absolute url is prefixed with `'unsafe:'` string and only then =
is it written into the DOM.=0A=
   *=0A=
   * @param {RegExp=3D} regexp New regexp to whitelist urls with.=0A=
   * @returns {RegExp|ng.$compileProvider} Current RegExp if called =
without value or self for=0A=
   *    chaining otherwise.=0A=
   */=0A=
  this.aHrefSanitizationWhitelist =3D function(regexp) {=0A=
    if (isDefined(regexp)) {=0A=
      aHrefSanitizationWhitelist =3D regexp;=0A=
      return this;=0A=
    }=0A=
    return aHrefSanitizationWhitelist;=0A=
  };=0A=
=0A=
=0A=
  /**=0A=
   * @description=0A=
   * Retrieves or overrides the default regular expression that is used =
for whitelisting of safe=0A=
   * urls during img[src] sanitization.=0A=
   *=0A=
   * The sanitization is a security measure aimed at prevent XSS attacks =
via html links.=0A=
   *=0A=
   * Any url about to be assigned to img[src] via data-binding is first =
normalized and turned into=0A=
   * an absolute url. Afterwards, the url is matched against the =
`imgSrcSanitizationWhitelist`=0A=
   * regular expression. If a match is found, the original url is =
written into the dom. Otherwise,=0A=
   * the absolute url is prefixed with `'unsafe:'` string and only then =
is it written into the DOM.=0A=
   *=0A=
   * @param {RegExp=3D} regexp New regexp to whitelist urls with.=0A=
   * @returns {RegExp|ng.$compileProvider} Current RegExp if called =
without value or self for=0A=
   *    chaining otherwise.=0A=
   */=0A=
  this.imgSrcSanitizationWhitelist =3D function(regexp) {=0A=
    if (isDefined(regexp)) {=0A=
      imgSrcSanitizationWhitelist =3D regexp;=0A=
      return this;=0A=
    }=0A=
    return imgSrcSanitizationWhitelist;=0A=
  };=0A=
=0A=
  this.$get =3D function() {=0A=
    return function sanitizeUri(uri, isImage) {=0A=
      var regex =3D isImage ? imgSrcSanitizationWhitelist : =
aHrefSanitizationWhitelist;=0A=
      var normalizedVal;=0A=
      normalizedVal =3D urlResolve(uri).href;=0A=
      if (normalizedVal !=3D=3D '' &amp;&amp; =
!normalizedVal.match(regex)) {=0A=
        return 'unsafe:'+normalizedVal;=0A=
      }=0A=
      return uri;=0A=
    };=0A=
  };=0A=
}=0A=
=0A=
var $sceMinErr =3D minErr('$sce');=0A=
=0A=
var SCE_CONTEXTS =3D {=0A=
  HTML: 'html',=0A=
  CSS: 'css',=0A=
  URL: 'url',=0A=
  // RESOURCE_URL is a subtype of URL used in contexts where a =
privileged resource is sourced from a=0A=
  // url.  (e.g. ng-include, script src, templateUrl)=0A=
  RESOURCE_URL: 'resourceUrl',=0A=
  JS: 'js'=0A=
};=0A=
=0A=
// Helper functions follow.=0A=
=0A=
// Copied from:=0A=
// =
http://docs.closure-library.googlecode.com/git/closure_goog_string_string=
.js.source.html#line962=0A=
// Prereq: s is a string.=0A=
function escapeForRegexp(s) {=0A=
  return s.replace(/([-()\[\]{}+?*.$\^|,:#&lt;!\\])/g, '\\$1').=0A=
           replace(/\x08/g, '\\x08');=0A=
}=0A=
=0A=
=0A=
function adjustMatcher(matcher) {=0A=
  if (matcher =3D=3D=3D 'self') {=0A=
    return matcher;=0A=
  } else if (isString(matcher)) {=0A=
    // Strings match exactly except for 2 wildcards - '*' and '**'.=0A=
    // '*' matches any character except those from the set ':/.?&amp;'.=0A=
    // '**' matches any character (like .* in a RegExp).=0A=
    // More than 2 *'s raises an error as it's ill defined.=0A=
    if (matcher.indexOf('***') &gt; -1) {=0A=
      throw $sceMinErr('iwcard',=0A=
          'Illegal sequence *** in string matcher.  String: {0}', =
matcher);=0A=
    }=0A=
    matcher =3D escapeForRegexp(matcher).=0A=
                  replace('\\*\\*', '.*').=0A=
                  replace('\\*', '[^:/.?&amp;;]*');=0A=
    return new RegExp('^' + matcher + '$');=0A=
  } else if (isRegExp(matcher)) {=0A=
    // The only other type of matcher allowed is a Regexp.=0A=
    // Match entire URL / disallow partial matches.=0A=
    // Flags are reset (i.e. no global, ignoreCase or multiline)=0A=
    return new RegExp('^' + matcher.source + '$');=0A=
  } else {=0A=
    throw $sceMinErr('imatcher',=0A=
        'Matchers may only be "self", string patterns or RegExp =
objects');=0A=
  }=0A=
}=0A=
=0A=
=0A=
function adjustMatchers(matchers) {=0A=
  var adjustedMatchers =3D [];=0A=
  if (isDefined(matchers)) {=0A=
    forEach(matchers, function(matcher) {=0A=
      adjustedMatchers.push(adjustMatcher(matcher));=0A=
    });=0A=
  }=0A=
  return adjustedMatchers;=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $sceDelegate=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * `$sceDelegate` is a service that is used by the `$sce` service to =
provide {@link ng.$sce Strict=0A=
 * Contextual Escaping (SCE)} services to AngularJS.=0A=
 *=0A=
 * Typically, you would configure or override the {@link ng.$sceDelegate =
$sceDelegate} instead of=0A=
 * the `$sce` service to customize the way Strict Contextual Escaping =
works in AngularJS.  This is=0A=
 * because, while the `$sce` provides numerous shorthand methods, etc., =
you really only need to=0A=
 * override 3 core functions (`trustAs`, `getTrusted` and `valueOf`) to =
replace the way things=0A=
 * work because `$sce` delegates to `$sceDelegate` for these operations.=0A=
 *=0A=
 * Refer {@link ng.$sceDelegateProvider $sceDelegateProvider} to =
configure this service.=0A=
 *=0A=
 * The default instance of `$sceDelegate` should work out of the box =
with little pain.  While you=0A=
 * can override it completely to change the behavior of `$sce`, the =
common case would=0A=
 * involve configuring the {@link ng.$sceDelegateProvider =
$sceDelegateProvider} instead by setting=0A=
 * your own whitelists and blacklists for trusting URLs used for loading =
AngularJS resources such as=0A=
 * templates.  Refer {@link ng.$sceDelegateProvider#resourceUrlWhitelist=0A=
 * $sceDelegateProvider.resourceUrlWhitelist} and {@link=0A=
 * ng.$sceDelegateProvider#resourceUrlBlacklist =
$sceDelegateProvider.resourceUrlBlacklist}=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $sceDelegateProvider=0A=
 * @description=0A=
 *=0A=
 * The `$sceDelegateProvider` provider allows developers to configure =
the {@link ng.$sceDelegate=0A=
 * $sceDelegate} service.  This allows one to get/set the whitelists and =
blacklists used to ensure=0A=
 * that the URLs used for sourcing Angular templates are safe.  Refer =
{@link=0A=
 * ng.$sceDelegateProvider#resourceUrlWhitelist =
$sceDelegateProvider.resourceUrlWhitelist} and=0A=
 * {@link ng.$sceDelegateProvider#resourceUrlBlacklist =
$sceDelegateProvider.resourceUrlBlacklist}=0A=
 *=0A=
 * For the general details about this service in Angular, read the main =
page for {@link ng.$sce=0A=
 * Strict Contextual Escaping (SCE)}.=0A=
 *=0A=
 * **Example**:  Consider the following case. &lt;a =
name=3D"example"&gt;&lt;/a&gt;=0A=
 *=0A=
 * - your app is hosted at url `http://myapp.example.com/`=0A=
 * - but some of your templates are hosted on other domains you control =
such as=0A=
 *   `http://srv01.assets.example.com/`,=C2=A0 =
`http://srv02.assets.example.com/`, etc.=0A=
 * - and you have an open redirect at =
`http://myapp.example.com/clickThru?...`.=0A=
 *=0A=
 * Here is what a secure configuration for this scenario might look like:=0A=
 *=0A=
 * ```=0A=
 *  angular.module('myApp', []).config(function($sceDelegateProvider) {=0A=
 *    $sceDelegateProvider.resourceUrlWhitelist([=0A=
 *      // Allow same origin resource loads.=0A=
 *      'self',=0A=
 *      // Allow loading from our assets domain.  Notice the difference =
between * and **.=0A=
 *      'http://srv*.assets.example.com/**'=0A=
 *    ]);=0A=
 *=0A=
 *    // The blacklist overrides the whitelist so the open redirect here =
is blocked.=0A=
 *    $sceDelegateProvider.resourceUrlBlacklist([=0A=
 *      'http://myapp.example.com/clickThru**'=0A=
 *    ]);=0A=
 *  });=0A=
 * ```=0A=
 */=0A=
=0A=
function $SceDelegateProvider() {=0A=
  this.SCE_CONTEXTS =3D SCE_CONTEXTS;=0A=
=0A=
  // Resource URLs can also be trusted by policy.=0A=
  var resourceUrlWhitelist =3D ['self'],=0A=
      resourceUrlBlacklist =3D [];=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $sceDelegateProvider#resourceUrlWhitelist=0A=
   * @kind function=0A=
   *=0A=
   * @param {Array=3D} whitelist When provided, replaces the =
resourceUrlWhitelist with the value=0A=
   *     provided.  This must be an array or null.  A snapshot of this =
array is used so further=0A=
   *     changes to the array are ignored.=0A=
   *=0A=
   *     Follow {@link ng.$sce#resourceUrlPatternItem this link} for a =
description of the items=0A=
   *     allowed in this array.=0A=
   *=0A=
   *     Note: **an empty whitelist array will block all URLs**!=0A=
   *=0A=
   * @return {Array} the currently set whitelist array.=0A=
   *=0A=
   * The **default value** when no whitelist has been explicitly set is =
`['self']` allowing only=0A=
   * same origin resource requests.=0A=
   *=0A=
   * @description=0A=
   * Sets/Gets the whitelist of trusted resource URLs.=0A=
   */=0A=
  this.resourceUrlWhitelist =3D function (value) {=0A=
    if (arguments.length) {=0A=
      resourceUrlWhitelist =3D adjustMatchers(value);=0A=
    }=0A=
    return resourceUrlWhitelist;=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $sceDelegateProvider#resourceUrlBlacklist=0A=
   * @kind function=0A=
   *=0A=
   * @param {Array=3D} blacklist When provided, replaces the =
resourceUrlBlacklist with the value=0A=
   *     provided.  This must be an array or null.  A snapshot of this =
array is used so further=0A=
   *     changes to the array are ignored.=0A=
   *=0A=
   *     Follow {@link ng.$sce#resourceUrlPatternItem this link} for a =
description of the items=0A=
   *     allowed in this array.=0A=
   *=0A=
   *     The typical usage for the blacklist is to **block=0A=
   *     [open =
redirects](http://cwe.mitre.org/data/definitions/601.html)** served by =
your domain as=0A=
   *     these would otherwise be trusted but actually return content =
from the redirected domain.=0A=
   *=0A=
   *     Finally, **the blacklist overrides the whitelist** and has the =
final say.=0A=
   *=0A=
   * @return {Array} the currently set blacklist array.=0A=
   *=0A=
   * The **default value** when no whitelist has been explicitly set is =
the empty array (i.e. there=0A=
   * is no blacklist.)=0A=
   *=0A=
   * @description=0A=
   * Sets/Gets the blacklist of trusted resource URLs.=0A=
   */=0A=
=0A=
  this.resourceUrlBlacklist =3D function (value) {=0A=
    if (arguments.length) {=0A=
      resourceUrlBlacklist =3D adjustMatchers(value);=0A=
    }=0A=
    return resourceUrlBlacklist;=0A=
  };=0A=
=0A=
  this.$get =3D ['$injector', function($injector) {=0A=
=0A=
    var htmlSanitizer =3D function htmlSanitizer(html) {=0A=
      throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a =
safe context.');=0A=
    };=0A=
=0A=
    if ($injector.has('$sanitize')) {=0A=
      htmlSanitizer =3D $injector.get('$sanitize');=0A=
    }=0A=
=0A=
=0A=
    function matchUrl(matcher, parsedUrl) {=0A=
      if (matcher =3D=3D=3D 'self') {=0A=
        return urlIsSameOrigin(parsedUrl);=0A=
      } else {=0A=
        // definitely a regex.  See adjustMatchers()=0A=
        return !!matcher.exec(parsedUrl.href);=0A=
      }=0A=
    }=0A=
=0A=
    function isResourceUrlAllowedByPolicy(url) {=0A=
      var parsedUrl =3D urlResolve(url.toString());=0A=
      var i, n, allowed =3D false;=0A=
      // Ensure that at least one item from the whitelist allows this =
url.=0A=
      for (i =3D 0, n =3D resourceUrlWhitelist.length; i &lt; n; i++) {=0A=
        if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {=0A=
          allowed =3D true;=0A=
          break;=0A=
        }=0A=
      }=0A=
      if (allowed) {=0A=
        // Ensure that no item from the blacklist blocked this url.=0A=
        for (i =3D 0, n =3D resourceUrlBlacklist.length; i &lt; n; i++) {=0A=
          if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {=0A=
            allowed =3D false;=0A=
            break;=0A=
          }=0A=
        }=0A=
      }=0A=
      return allowed;=0A=
    }=0A=
=0A=
    function generateHolderType(Base) {=0A=
      var holderType =3D function TrustedValueHolderType(trustedValue) {=0A=
        this.$$unwrapTrustedValue =3D function() {=0A=
          return trustedValue;=0A=
        };=0A=
      };=0A=
      if (Base) {=0A=
        holderType.prototype =3D new Base();=0A=
      }=0A=
      holderType.prototype.valueOf =3D function sceValueOf() {=0A=
        return this.$$unwrapTrustedValue();=0A=
      };=0A=
      holderType.prototype.toString =3D function sceToString() {=0A=
        return this.$$unwrapTrustedValue().toString();=0A=
      };=0A=
      return holderType;=0A=
    }=0A=
=0A=
    var trustedValueHolderBase =3D generateHolderType(),=0A=
        byType =3D {};=0A=
=0A=
    byType[SCE_CONTEXTS.HTML] =3D =
generateHolderType(trustedValueHolderBase);=0A=
    byType[SCE_CONTEXTS.CSS] =3D =
generateHolderType(trustedValueHolderBase);=0A=
    byType[SCE_CONTEXTS.URL] =3D =
generateHolderType(trustedValueHolderBase);=0A=
    byType[SCE_CONTEXTS.JS] =3D =
generateHolderType(trustedValueHolderBase);=0A=
    byType[SCE_CONTEXTS.RESOURCE_URL] =3D =
generateHolderType(byType[SCE_CONTEXTS.URL]);=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sceDelegate#trustAs=0A=
     *=0A=
     * @description=0A=
     * Returns an object that is trusted by angular for use in specified =
strict=0A=
     * contextual escaping contexts (such as ng-bind-html, ng-include, =
any src=0A=
     * attribute interpolation, any dom event binding attribute =
interpolation=0A=
     * such as for onclick,  etc.) that uses the provided value.=0A=
     * See {@link ng.$sce $sce} for enabling strict contextual escaping.=0A=
     *=0A=
     * @param {string} type The kind of context in which this value is =
safe for use.  e.g. url,=0A=
     *   resourceUrl, html, js and css.=0A=
     * @param {*} value The value that that should be considered =
trusted/safe.=0A=
     * @returns {*} A value that can be used to stand in for the =
provided `value` in places=0A=
     * where Angular expects a $sce.trustAs() return value.=0A=
     */=0A=
    function trustAs(type, trustedValue) {=0A=
      var Constructor =3D (byType.hasOwnProperty(type) ? byType[type] : =
null);=0A=
      if (!Constructor) {=0A=
        throw $sceMinErr('icontext',=0A=
            'Attempted to trust a value in invalid context. Context: =
{0}; Value: {1}',=0A=
            type, trustedValue);=0A=
      }=0A=
      if (trustedValue =3D=3D=3D null || trustedValue =3D=3D=3D =
undefined || trustedValue =3D=3D=3D '') {=0A=
        return trustedValue;=0A=
      }=0A=
      // All the current contexts in SCE_CONTEXTS happen to be strings.  =
In order to avoid trusting=0A=
      // mutable objects, we ensure here that the value passed in is =
actually a string.=0A=
      if (typeof trustedValue !=3D=3D 'string') {=0A=
        throw $sceMinErr('itype',=0A=
            'Attempted to trust a non-string value in a content =
requiring a string: Context: {0}',=0A=
            type);=0A=
      }=0A=
      return new Constructor(trustedValue);=0A=
    }=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sceDelegate#valueOf=0A=
     *=0A=
     * @description=0A=
     * If the passed parameter had been returned by a prior call to =
{@link ng.$sceDelegate#trustAs=0A=
     * `$sceDelegate.trustAs`}, returns the value that had been passed =
to {@link=0A=
     * ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}.=0A=
     *=0A=
     * If the passed parameter is not a value that had been returned by =
{@link=0A=
     * ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}, returns it as-is.=0A=
     *=0A=
     * @param {*} value The result of a prior {@link =
ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}=0A=
     *      call or anything else.=0A=
     * @returns {*} The `value` that was originally provided to {@link =
ng.$sceDelegate#trustAs=0A=
     *     `$sceDelegate.trustAs`} if `value` is the result of such a =
call.  Otherwise, returns=0A=
     *     `value` unchanged.=0A=
     */=0A=
    function valueOf(maybeTrusted) {=0A=
      if (maybeTrusted instanceof trustedValueHolderBase) {=0A=
        return maybeTrusted.$$unwrapTrustedValue();=0A=
      } else {=0A=
        return maybeTrusted;=0A=
      }=0A=
    }=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sceDelegate#getTrusted=0A=
     *=0A=
     * @description=0A=
     * Takes the result of a {@link ng.$sceDelegate#trustAs =
`$sceDelegate.trustAs`} call and=0A=
     * returns the originally supplied value if the queried context type =
is a supertype of the=0A=
     * created type.  If this condition isn't satisfied, throws an =
exception.=0A=
     *=0A=
     * @param {string} type The kind of context in which this value is =
to be used.=0A=
     * @param {*} maybeTrusted The result of a prior {@link =
ng.$sceDelegate#trustAs=0A=
     *     `$sceDelegate.trustAs`} call.=0A=
     * @returns {*} The value the was originally provided to {@link =
ng.$sceDelegate#trustAs=0A=
     *     `$sceDelegate.trustAs`} if valid in this context.  Otherwise, =
throws an exception.=0A=
     */=0A=
    function getTrusted(type, maybeTrusted) {=0A=
      if (maybeTrusted =3D=3D=3D null || maybeTrusted =3D=3D=3D =
undefined || maybeTrusted =3D=3D=3D '') {=0A=
        return maybeTrusted;=0A=
      }=0A=
      var constructor =3D (byType.hasOwnProperty(type) ? byType[type] : =
null);=0A=
      if (constructor &amp;&amp; maybeTrusted instanceof constructor) {=0A=
        return maybeTrusted.$$unwrapTrustedValue();=0A=
      }=0A=
      // If we get here, then we may only take one of two actions.=0A=
      // 1. sanitize the value for the requested type, or=0A=
      // 2. throw an exception.=0A=
      if (type =3D=3D=3D SCE_CONTEXTS.RESOURCE_URL) {=0A=
        if (isResourceUrlAllowedByPolicy(maybeTrusted)) {=0A=
          return maybeTrusted;=0A=
        } else {=0A=
          throw $sceMinErr('insecurl',=0A=
              'Blocked loading resource from url not allowed by =
$sceDelegate policy.  URL: {0}',=0A=
              maybeTrusted.toString());=0A=
        }=0A=
      } else if (type =3D=3D=3D SCE_CONTEXTS.HTML) {=0A=
        return htmlSanitizer(maybeTrusted);=0A=
      }=0A=
      throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a =
safe context.');=0A=
    }=0A=
=0A=
    return { trustAs: trustAs,=0A=
             getTrusted: getTrusted,=0A=
             valueOf: valueOf };=0A=
  }];=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $sceProvider=0A=
 * @description=0A=
 *=0A=
 * The $sceProvider provider allows developers to configure the {@link =
ng.$sce $sce} service.=0A=
 * -   enable/disable Strict Contextual Escaping (SCE) in a module=0A=
 * -   override the default implementation with a custom delegate=0A=
 *=0A=
 * Read more about {@link ng.$sce Strict Contextual Escaping (SCE)}.=0A=
 */=0A=
=0A=
/* jshint maxlen: false*/=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $sce=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * `$sce` is a service that provides Strict Contextual Escaping services =
to AngularJS.=0A=
 *=0A=
 * # Strict Contextual Escaping=0A=
 *=0A=
 * Strict Contextual Escaping (SCE) is a mode in which AngularJS =
requires bindings in certain=0A=
 * contexts to result in a value that is marked as safe to use for that =
context.  One example of=0A=
 * such a context is binding arbitrary html controlled by the user via =
`ng-bind-html`.  We refer=0A=
 * to these contexts as privileged or SCE contexts.=0A=
 *=0A=
 * As of version 1.2, Angular ships with SCE enabled by default.=0A=
 *=0A=
 * Note:  When enabled (the default), IE&lt;11 in quirks mode is not =
supported.  In this mode, IE&lt;11 allow=0A=
 * one to execute arbitrary javascript by the use of the expression() =
syntax.  Refer=0A=
 * =
&lt;http://blogs.msdn.com/b/ie/archive/2008/10/16/ending-expressions.aspx=
&gt; to learn more about them.=0A=
 * You can ensure your document is in standards mode and not quirks mode =
by adding `&lt;!doctype html&gt;`=0A=
 * to the top of your HTML document.=0A=
 *=0A=
 * SCE assists in writing code in way that (a) is secure by default and =
(b) makes auditing for=0A=
 * security vulnerabilities such as XSS, clickjacking, etc. a lot easier.=0A=
 *=0A=
 * Here's an example of a binding in a privileged context:=0A=
 *=0A=
 * ```=0A=
 * &lt;input ng-model=3D"userHtml"&gt;=0A=
 * &lt;div ng-bind-html=3D"userHtml"&gt;&lt;/div&gt;=0A=
 * ```=0A=
 *=0A=
 * Notice that `ng-bind-html` is bound to `userHtml` controlled by the =
user.  With SCE=0A=
 * disabled, this application allows the user to render arbitrary HTML =
into the DIV.=0A=
 * In a more realistic example, one may be rendering user comments, blog =
articles, etc. via=0A=
 * bindings.  (HTML is just one example of a context where rendering =
user controlled input creates=0A=
 * security vulnerabilities.)=0A=
 *=0A=
 * For the case of HTML, you might use a library, either on the client =
side, or on the server side,=0A=
 * to sanitize unsafe HTML before binding to the value and rendering it =
in the document.=0A=
 *=0A=
 * How would you ensure that every place that used these types of =
bindings was bound to a value that=0A=
 * was sanitized by your library (or returned as safe for rendering by =
your server?)  How can you=0A=
 * ensure that you didn't accidentally delete the line that sanitized =
the value, or renamed some=0A=
 * properties/fields and forgot to update the binding to the sanitized =
value?=0A=
 *=0A=
 * To be secure by default, you want to ensure that any such bindings =
are disallowed unless you can=0A=
 * determine that something explicitly says it's safe to use a value for =
binding in that=0A=
 * context.  You can then audit your code (a simple grep would do) to =
ensure that this is only done=0A=
 * for those values that you can easily tell are safe - because they =
were received from your server,=0A=
 * sanitized by your library, etc.  You can organize your codebase to =
help with this - perhaps=0A=
 * allowing only the files in a specific directory to do this.  Ensuring =
that the internal API=0A=
 * exposed by that code doesn't markup arbitrary values as safe then =
becomes a more manageable task.=0A=
 *=0A=
 * In the case of AngularJS' SCE service, one uses {@link =
ng.$sce#trustAs $sce.trustAs}=0A=
 * (and shorthand methods such as {@link ng.$sce#trustAsHtml =
$sce.trustAsHtml}, etc.) to=0A=
 * obtain values that will be accepted by SCE / privileged contexts.=0A=
 *=0A=
 *=0A=
 * ## How does it work?=0A=
 *=0A=
 * In privileged contexts, directives and code will bind to the result =
of {@link ng.$sce#getTrusted=0A=
 * $sce.getTrusted(context, value)} rather than to the value directly.  =
Directives use {@link=0A=
 * ng.$sce#parseAs $sce.parseAs} rather than `$parse` to watch attribute =
bindings, which performs the=0A=
 * {@link ng.$sce#getTrusted $sce.getTrusted} behind the scenes on =
non-constant literals.=0A=
 *=0A=
 * As an example, {@link ng.directive:ngBindHtml ngBindHtml} uses {@link=0A=
 * ng.$sce#parseAsHtml $sce.parseAsHtml(binding expression)}.  Here's =
the actual code (slightly=0A=
 * simplified):=0A=
 *=0A=
 * ```=0A=
 * var ngBindHtmlDirective =3D ['$sce', function($sce) {=0A=
 *   return function(scope, element, attr) {=0A=
 *     scope.$watch($sce.parseAsHtml(attr.ngBindHtml), function(value) {=0A=
 *       element.html(value || '');=0A=
 *     });=0A=
 *   };=0A=
 * }];=0A=
 * ```=0A=
 *=0A=
 * ## Impact on loading templates=0A=
 *=0A=
 * This applies both to the {@link ng.directive:ngInclude `ng-include`} =
directive as well as=0A=
 * `templateUrl`'s specified by {@link guide/directive directives}.=0A=
 *=0A=
 * By default, Angular only loads templates from the same domain and =
protocol as the application=0A=
 * document.  This is done by calling {@link =
ng.$sce#getTrustedResourceUrl=0A=
 * $sce.getTrustedResourceUrl} on the template URL.  To load templates =
from other domains and/or=0A=
 * protocols, you may either either {@link =
ng.$sceDelegateProvider#resourceUrlWhitelist whitelist=0A=
 * them} or {@link ng.$sce#trustAsResourceUrl wrap it} into a trusted =
value.=0A=
 *=0A=
 * *Please note*:=0A=
 * The browser's=0A=
 * [Same Origin =
Policy](https://code.google.com/p/browsersec/wiki/Part2#Same-origin_polic=
y_for_XMLHttpRequest)=0A=
 * and [Cross-Origin Resource Sharing (CORS)](http://www.w3.org/TR/cors/)=0A=
 * policy apply in addition to this and may further restrict whether the =
template is successfully=0A=
 * loaded.  This means that without the right CORS policy, loading =
templates from a different domain=0A=
 * won't work on all browsers.  Also, loading templates from `file://` =
URL does not work on some=0A=
 * browsers.=0A=
 *=0A=
 * ## This feels like too much overhead=0A=
 *=0A=
 * It's important to remember that SCE only applies to interpolation =
expressions.=0A=
 *=0A=
 * If your expressions are constant literals, they're automatically =
trusted and you don't need to=0A=
 * call `$sce.trustAs` on them (remember to include the `ngSanitize` =
module) (e.g.=0A=
 * `&lt;div ng-bind-html=3D"'&lt;b&gt;implicitly =
trusted&lt;/b&gt;'"&gt;&lt;/div&gt;`) just works.=0A=
 *=0A=
 * Additionally, `a[href]` and `img[src]` automatically sanitize their =
URLs and do not pass them=0A=
 * through {@link ng.$sce#getTrusted $sce.getTrusted}.  SCE doesn't play =
a role here.=0A=
 *=0A=
 * The included {@link ng.$sceDelegate $sceDelegate} comes with sane =
defaults to allow you to load=0A=
 * templates in `ng-include` from your application's domain without =
having to even know about SCE.=0A=
 * It blocks loading templates from other domains or loading templates =
over http from an https=0A=
 * served document.  You can change these by setting your own custom =
{@link=0A=
 * ng.$sceDelegateProvider#resourceUrlWhitelist whitelists} and {@link=0A=
 * ng.$sceDelegateProvider#resourceUrlBlacklist blacklists} for matching =
such URLs.=0A=
 *=0A=
 * This significantly reduces the overhead.  It is far easier to pay the =
small overhead and have an=0A=
 * application that's secure and can be audited to verify that with much =
more ease than bolting=0A=
 * security onto an application later.=0A=
 *=0A=
 * &lt;a name=3D"contexts"&gt;&lt;/a&gt;=0A=
 * ## What trusted context types are supported?=0A=
 *=0A=
 * | Context             | Notes          |=0A=
 * |---------------------|----------------|=0A=
 * | `$sce.HTML`         | For HTML that's safe to source into the =
application.  The {@link ng.directive:ngBindHtml ngBindHtml} directive =
uses this context for bindings. If an unsafe value is encountered and =
the {@link ngSanitize $sanitize} module is present this will sanitize =
the value instead of throwing an error. |=0A=
 * | `$sce.CSS`          | For CSS that's safe to source into the =
application.  Currently unused.  Feel free to use it in your own =
directives. |=0A=
 * | `$sce.URL`          | For URLs that are safe to follow as links.  =
Currently unused (`&lt;a href=3D` and `&lt;img src=3D` sanitize their =
urls and don't constitute an SCE context. |=0A=
 * | `$sce.RESOURCE_URL` | For URLs that are not only safe to follow as =
links, but whose contents are also safe to include in your application.  =
Examples include `ng-include`, `src` / `ngSrc` bindings for tags other =
than `IMG` (e.g. `IFRAME`, `OBJECT`, etc.)  &lt;br&gt;&lt;br&gt;Note =
that `$sce.RESOURCE_URL` makes a stronger statement about the URL than =
`$sce.URL` does and therefore contexts requiring values trusted for =
`$sce.RESOURCE_URL` can be used anywhere that values trusted for =
`$sce.URL` are required. |=0A=
 * | `$sce.JS`           | For JavaScript that is safe to execute in =
your application's context.  Currently unused.  Feel free to use it in =
your own directives. |=0A=
 *=0A=
 * ## Format of items in {@link =
ng.$sceDelegateProvider#resourceUrlWhitelist =
resourceUrlWhitelist}/{@link =
ng.$sceDelegateProvider#resourceUrlBlacklist Blacklist} &lt;a =
name=3D"resourceUrlPatternItem"&gt;&lt;/a&gt;=0A=
 *=0A=
 *  Each element in these arrays must be one of the following:=0A=
 *=0A=
 *  - **'self'**=0A=
 *    - The special **string**, `'self'`, can be used to match against =
all URLs of the **same=0A=
 *      domain** as the application document using the **same protocol**.=0A=
 *  - **String** (except the special value `'self'`)=0A=
 *    - The string is matched against the full *normalized / absolute =
URL* of the resource=0A=
 *      being tested (substring matches are not good enough.)=0A=
 *    - There are exactly **two wildcard sequences** - `*` and `**`.  =
All other characters=0A=
 *      match themselves.=0A=
 *    - `*`: matches zero or more occurrences of any character other =
than one of the following 6=0A=
 *      characters: '`:`', '`/`', '`.`', '`?`', '`&amp;`' and ';'.  It's =
a useful wildcard for use=0A=
 *      in a whitelist.=0A=
 *    - `**`: matches zero or more occurrences of *any* character.  As =
such, it's not=0A=
 *      not appropriate to use in for a scheme, domain, etc. as it would =
match too much.  (e.g.=0A=
 *      http://**.example.com/ would match =
http://evil.com/?ignore=3D.example.com/ and that might=0A=
 *      not have been the intention.)  Its usage at the very end of the =
path is ok.  (e.g.=0A=
 *      http://foo.example.com/templates/**).=0A=
 *  - **RegExp** (*see caveat below*)=0A=
 *    - *Caveat*:  While regular expressions are powerful and offer =
great flexibility,  their syntax=0A=
 *      (and all the inevitable escaping) makes them *harder to =
maintain*.  It's easy to=0A=
 *      accidentally introduce a bug when one updates a complex =
expression (imho, all regexes should=0A=
 *      have good test coverage.).  For instance, the use of `.` in the =
regex is correct only in a=0A=
 *      small number of cases.  A `.` character in the regex used when =
matching the scheme or a=0A=
 *      subdomain could be matched against a `:` or literal `.` that was =
likely not intended.   It=0A=
 *      is highly recommended to use the string patterns and only fall =
back to regular expressions=0A=
 *      if they as a last resort.=0A=
 *    - The regular expression must be an instance of RegExp (i.e. not a =
string.)  It is=0A=
 *      matched against the **entire** *normalized / absolute URL* of =
the resource being tested=0A=
 *      (even when the RegExp did not have the `^` and `$` codes.)  In =
addition, any flags=0A=
 *      present on the RegExp (such as multiline, global, ignoreCase) =
are ignored.=0A=
 *    - If you are generating your JavaScript from some other templating =
engine (not=0A=
 *      recommended, e.g. in issue =
[#4006](https://github.com/angular/angular.js/issues/4006)),=0A=
 *      remember to escape your regular expression (and be aware that =
you might need more than=0A=
 *      one level of escaping depending on your templating engine and =
the way you interpolated=0A=
 *      the value.)  Do make use of your platform's escaping mechanism =
as it might be good=0A=
 *      enough before coding your own.  e.g. Ruby has=0A=
 *      =
[Regexp.escape(str)](http://www.ruby-doc.org/core-2.0.0/Regexp.html#metho=
d-c-escape)=0A=
 *      and Python has =
[re.escape](http://docs.python.org/library/re.html#re.escape).=0A=
 *      Javascript lacks a similar built in function for escaping.  Take =
a look at Google=0A=
 *      Closure library's [goog.string.regExpEscape(s)](=0A=
 *      =
http://docs.closure-library.googlecode.com/git/closure_goog_string_string=
.js.source.html#line962).=0A=
 *=0A=
 * Refer {@link ng.$sceDelegateProvider $sceDelegateProvider} for an =
example.=0A=
 *=0A=
 * ## Show me an example using SCE.=0A=
 *=0A=
 * &lt;example module=3D"mySceApp" deps=3D"angular-sanitize.js"&gt;=0A=
 * &lt;file name=3D"todoList.html"&gt;=0A=
 *   &lt;div ng-controller=3D"AppController as myCtrl"&gt;=0A=
 *     &lt;i ng-bind-html=3D"myCtrl.explicitlyTrustedHtml" =
id=3D"explicitlyTrustedHtml"&gt;&lt;/i&gt;&lt;br&gt;&lt;br&gt;=0A=
 *     &lt;b&gt;User comments&lt;/b&gt;&lt;br&gt;=0A=
 *     By default, HTML that isn't explicitly trusted (e.g. Alice's =
comment) is sanitized when=0A=
 *     $sanitize is available.  If $sanitize isn't available, this =
results in an error instead of an=0A=
 *     exploit.=0A=
 *     &lt;div class=3D"well"&gt;=0A=
 *       &lt;div ng-repeat=3D"userComment in myCtrl.userComments"&gt;=0A=
 *         &lt;b&gt;{{userComment.name}}&lt;/b&gt;:=0A=
 *         &lt;span ng-bind-html=3D"userComment.htmlComment" =
class=3D"htmlComment"&gt;&lt;/span&gt;=0A=
 *         &lt;br&gt;=0A=
 *       &lt;/div&gt;=0A=
 *     &lt;/div&gt;=0A=
 *   &lt;/div&gt;=0A=
 * &lt;/file&gt;=0A=
 *=0A=
 * &lt;file name=3D"script.js"&gt;=0A=
 *   angular.module('mySceApp', ['ngSanitize'])=0A=
 *     .controller('AppController', ['$http', '$templateCache', '$sce',=0A=
 *       function($http, $templateCache, $sce) {=0A=
 *         var self =3D this;=0A=
 *         $http.get("test_data.json", {cache: =
$templateCache}).success(function(userComments) {=0A=
 *           self.userComments =3D userComments;=0A=
 *         });=0A=
 *         self.explicitlyTrustedHtml =3D $sce.trustAsHtml(=0A=
 *             '&lt;span =
onmouseover=3D"this.textContent=3D&amp;quot;Explicitly trusted HTML =
bypasses ' +=0A=
 *             'sanitization.&amp;quot;"&gt;Hover over this =
text.&lt;/span&gt;');=0A=
 *       }]);=0A=
 * &lt;/file&gt;=0A=
 *=0A=
 * &lt;file name=3D"test_data.json"&gt;=0A=
 * [=0A=
 *   { "name": "Alice",=0A=
 *     "htmlComment":=0A=
 *         "&lt;span onmouseover=3D'this.textContent=3D\"PWN3D!\"'&gt;Is =
&lt;i&gt;anyone&lt;/i&gt; reading this?&lt;/span&gt;"=0A=
 *   },=0A=
 *   { "name": "Bob",=0A=
 *     "htmlComment": "&lt;i&gt;Yes!&lt;/i&gt;  Am I the only other one?"=0A=
 *   }=0A=
 * ]=0A=
 * &lt;/file&gt;=0A=
 *=0A=
 * &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
 *   describe('SCE doc demo', function() {=0A=
 *     it('should sanitize untrusted values', function() {=0A=
 *       =
expect(element.all(by.css('.htmlComment')).first().getInnerHtml())=0A=
 *           .toBe('&lt;span&gt;Is &lt;i&gt;anyone&lt;/i&gt; reading =
this?&lt;/span&gt;');=0A=
 *     });=0A=
 *=0A=
 *     it('should NOT sanitize explicitly trusted values', function() {=0A=
 *       =
expect(element(by.id('explicitlyTrustedHtml')).getInnerHtml()).toBe(=0A=
 *           '&lt;span =
onmouseover=3D"this.textContent=3D&amp;quot;Explicitly trusted HTML =
bypasses ' +=0A=
 *           'sanitization.&amp;quot;"&gt;Hover over this =
text.&lt;/span&gt;');=0A=
 *     });=0A=
 *   });=0A=
 * &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 *=0A=
 *=0A=
 *=0A=
 * ## Can I disable SCE completely?=0A=
 *=0A=
 * Yes, you can.  However, this is strongly discouraged.  SCE gives you =
a lot of security benefits=0A=
 * for little coding overhead.  It will be much harder to take an SCE =
disabled application and=0A=
 * either secure it on your own or enable SCE at a later stage.  It =
might make sense to disable SCE=0A=
 * for cases where you have a lot of existing code that was written =
before SCE was introduced and=0A=
 * you're migrating them a module at a time.=0A=
 *=0A=
 * That said, here's how you can completely disable SCE:=0A=
 *=0A=
 * ```=0A=
 * angular.module('myAppWithSceDisabledmyApp', =
[]).config(function($sceProvider) {=0A=
 *   // Completely disable SCE.  For demonstration purposes only!=0A=
 *   // Do not use in new projects.=0A=
 *   $sceProvider.enabled(false);=0A=
 * });=0A=
 * ```=0A=
 *=0A=
 */=0A=
/* jshint maxlen: 100 */=0A=
=0A=
function $SceProvider() {=0A=
  var enabled =3D true;=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $sceProvider#enabled=0A=
   * @kind function=0A=
   *=0A=
   * @param {boolean=3D} value If provided, then enables/disables SCE.=0A=
   * @return {boolean} true if SCE is enabled, false otherwise.=0A=
   *=0A=
   * @description=0A=
   * Enables/disables SCE and returns the current value.=0A=
   */=0A=
  this.enabled =3D function (value) {=0A=
    if (arguments.length) {=0A=
      enabled =3D !!value;=0A=
    }=0A=
    return enabled;=0A=
  };=0A=
=0A=
=0A=
  /* Design notes on the default implementation for SCE.=0A=
   *=0A=
   * The API contract for the SCE delegate=0A=
   * -------------------------------------=0A=
   * The SCE delegate object must provide the following 3 methods:=0A=
   *=0A=
   * - trustAs(contextEnum, value)=0A=
   *     This method is used to tell the SCE service that the provided =
value is OK to use in the=0A=
   *     contexts specified by contextEnum.  It must return an object =
that will be accepted by=0A=
   *     getTrusted() for a compatible contextEnum and return this value.=0A=
   *=0A=
   * - valueOf(value)=0A=
   *     For values that were not produced by trustAs(), return them as =
is.  For values that were=0A=
   *     produced by trustAs(), return the corresponding input value to =
trustAs.  Basically, if=0A=
   *     trustAs is wrapping the given values into some type, this =
operation unwraps it when given=0A=
   *     such a value.=0A=
   *=0A=
   * - getTrusted(contextEnum, value)=0A=
   *     This function should return the a value that is safe to use in =
the context specified by=0A=
   *     contextEnum or throw and exception otherwise.=0A=
   *=0A=
   * NOTE: This contract deliberately does NOT state that values =
returned by trustAs() must be=0A=
   * opaque or wrapped in some holder object.  That happens to be an =
implementation detail.  For=0A=
   * instance, an implementation could maintain a registry of all =
trusted objects by context.  In=0A=
   * such a case, trustAs() would return the same object that was passed =
in.  getTrusted() would=0A=
   * return the same object passed in if it was found in the registry =
under a compatible context or=0A=
   * throw an exception otherwise.  An implementation might only wrap =
values some of the time based=0A=
   * on some criteria.  getTrusted() might return a value and not throw =
an exception for special=0A=
   * constants or objects even if not wrapped.  All such implementations =
fulfill this contract.=0A=
   *=0A=
   *=0A=
   * A note on the inheritance model for SCE contexts=0A=
   * ------------------------------------------------=0A=
   * I've used inheritance and made RESOURCE_URL wrapped types a subtype =
of URL wrapped types.  This=0A=
   * is purely an implementation details.=0A=
   *=0A=
   * The contract is simply this:=0A=
   *=0A=
   *     getTrusted($sce.RESOURCE_URL, value) succeeding implies that =
getTrusted($sce.URL, value)=0A=
   *     will also succeed.=0A=
   *=0A=
   * Inheritance happens to capture this in a natural way.  In some =
future, we=0A=
   * may not use inheritance anymore.  That is OK because no code =
outside of=0A=
   * sce.js and sceSpecs.js would need to be aware of this detail.=0A=
   */=0A=
=0A=
  this.$get =3D ['$document', '$parse', '$sceDelegate', function(=0A=
                $document,   $parse,   $sceDelegate) {=0A=
    // Prereq: Ensure that we're not running in IE&lt;11 quirks mode.  =
In that mode, IE &lt; 11 allow=0A=
    // the "expression(javascript expression)" syntax which is insecure.=0A=
    if (enabled &amp;&amp; $document[0].documentMode &lt; 8) {=0A=
      throw $sceMinErr('iequirks',=0A=
        'Strict Contextual Escaping does not support Internet Explorer =
version &lt; 11 in quirks ' +=0A=
        'mode.  You can fix this by adding the text &lt;!doctype =
html&gt; to the top of your HTML ' +=0A=
        'document.  See http://docs.angularjs.org/api/ng.$sce for more =
information.');=0A=
    }=0A=
=0A=
    var sce =3D shallowCopy(SCE_CONTEXTS);=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#isEnabled=0A=
     * @kind function=0A=
     *=0A=
     * @return {Boolean} true if SCE is enabled, false otherwise.  If =
you want to set the value, you=0A=
     * have to do it at module config time on {@link ng.$sceProvider =
$sceProvider}.=0A=
     *=0A=
     * @description=0A=
     * Returns a boolean indicating if SCE is enabled.=0A=
     */=0A=
    sce.isEnabled =3D function () {=0A=
      return enabled;=0A=
    };=0A=
    sce.trustAs =3D $sceDelegate.trustAs;=0A=
    sce.getTrusted =3D $sceDelegate.getTrusted;=0A=
    sce.valueOf =3D $sceDelegate.valueOf;=0A=
=0A=
    if (!enabled) {=0A=
      sce.trustAs =3D sce.getTrusted =3D function(type, value) { return =
value; };=0A=
      sce.valueOf =3D identity;=0A=
    }=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#parseAs=0A=
     *=0A=
     * @description=0A=
     * Converts Angular {@link guide/expression expression} into a =
function.  This is like {@link=0A=
     * ng.$parse $parse} and is identical when the expression is a =
literal constant.  Otherwise, it=0A=
     * wraps the expression in a call to {@link ng.$sce#getTrusted =
$sce.getTrusted(*type*,=0A=
     * *result*)}=0A=
     *=0A=
     * @param {string} type The kind of SCE context in which this result =
will be used.=0A=
     * @param {string} expression String expression to compile.=0A=
     * @returns {function(context, locals)} a function which represents =
the compiled expression:=0A=
     *=0A=
     *    * `context` =E2=80&#65533; `{object}` =E2=80&#65533; an object =
against which any expressions embedded in the strings=0A=
     *      are evaluated against (typically a scope object).=0A=
     *    * `locals` =E2=80&#65533; `{object=3D}` =E2=80&#65533; local =
variables context object, useful for overriding values in=0A=
     *      `context`.=0A=
     */=0A=
    sce.parseAs =3D function sceParseAs(type, expr) {=0A=
      var parsed =3D $parse(expr);=0A=
      if (parsed.literal &amp;&amp; parsed.constant) {=0A=
        return parsed;=0A=
      } else {=0A=
        return $parse(expr, function (value) {=0A=
          return sce.getTrusted(type, value);=0A=
        });=0A=
      }=0A=
    };=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#trustAs=0A=
     *=0A=
     * @description=0A=
     * Delegates to {@link ng.$sceDelegate#trustAs =
`$sceDelegate.trustAs`}.  As such,=0A=
     * returns an object that is trusted by angular for use in specified =
strict contextual=0A=
     * escaping contexts (such as ng-bind-html, ng-include, any src =
attribute=0A=
     * interpolation, any dom event binding attribute interpolation such =
as for onclick,  etc.)=0A=
     * that uses the provided value.  See * {@link ng.$sce $sce} for =
enabling strict contextual=0A=
     * escaping.=0A=
     *=0A=
     * @param {string} type The kind of context in which this value is =
safe for use.  e.g. url,=0A=
     *   resource_url, html, js and css.=0A=
     * @param {*} value The value that that should be considered =
trusted/safe.=0A=
     * @returns {*} A value that can be used to stand in for the =
provided `value` in places=0A=
     * where Angular expects a $sce.trustAs() return value.=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#trustAsHtml=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.trustAsHtml(value)` =E2=86&#65533;=0A=
     *     {@link ng.$sceDelegate#trustAs =
`$sceDelegate.trustAs($sce.HTML, value)`}=0A=
     *=0A=
     * @param {*} value The value to trustAs.=0A=
     * @returns {*} An object that can be passed to {@link =
ng.$sce#getTrustedHtml=0A=
     *     $sce.getTrustedHtml(value)} to obtain the original value.  =
(privileged directives=0A=
     *     only accept expressions that are either literal constants or =
are the=0A=
     *     return value of {@link ng.$sce#trustAs $sce.trustAs}.)=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#trustAsUrl=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.trustAsUrl(value)` =E2=86&#65533;=0A=
     *     {@link ng.$sceDelegate#trustAs =
`$sceDelegate.trustAs($sce.URL, value)`}=0A=
     *=0A=
     * @param {*} value The value to trustAs.=0A=
     * @returns {*} An object that can be passed to {@link =
ng.$sce#getTrustedUrl=0A=
     *     $sce.getTrustedUrl(value)} to obtain the original value.  =
(privileged directives=0A=
     *     only accept expressions that are either literal constants or =
are the=0A=
     *     return value of {@link ng.$sce#trustAs $sce.trustAs}.)=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#trustAsResourceUrl=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.trustAsResourceUrl(value)` =E2=86&#65533;=0A=
     *     {@link ng.$sceDelegate#trustAs =
`$sceDelegate.trustAs($sce.RESOURCE_URL, value)`}=0A=
     *=0A=
     * @param {*} value The value to trustAs.=0A=
     * @returns {*} An object that can be passed to {@link =
ng.$sce#getTrustedResourceUrl=0A=
     *     $sce.getTrustedResourceUrl(value)} to obtain the original =
value.  (privileged directives=0A=
     *     only accept expressions that are either literal constants or =
are the return=0A=
     *     value of {@link ng.$sce#trustAs $sce.trustAs}.)=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#trustAsJs=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.trustAsJs(value)` =E2=86&#65533;=0A=
     *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.JS, =
value)`}=0A=
     *=0A=
     * @param {*} value The value to trustAs.=0A=
     * @returns {*} An object that can be passed to {@link =
ng.$sce#getTrustedJs=0A=
     *     $sce.getTrustedJs(value)} to obtain the original value.  =
(privileged directives=0A=
     *     only accept expressions that are either literal constants or =
are the=0A=
     *     return value of {@link ng.$sce#trustAs $sce.trustAs}.)=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#getTrusted=0A=
     *=0A=
     * @description=0A=
     * Delegates to {@link ng.$sceDelegate#getTrusted =
`$sceDelegate.getTrusted`}.  As such,=0A=
     * takes the result of a {@link ng.$sce#trustAs `$sce.trustAs`}() =
call and returns the=0A=
     * originally supplied value if the queried context type is a =
supertype of the created type.=0A=
     * If this condition isn't satisfied, throws an exception.=0A=
     *=0A=
     * @param {string} type The kind of context in which this value is =
to be used.=0A=
     * @param {*} maybeTrusted The result of a prior {@link =
ng.$sce#trustAs `$sce.trustAs`}=0A=
     *                         call.=0A=
     * @returns {*} The value the was originally provided to=0A=
     *              {@link ng.$sce#trustAs `$sce.trustAs`} if valid in =
this context.=0A=
     *              Otherwise, throws an exception.=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#getTrustedHtml=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.getTrustedHtml(value)` =E2=86&#65533;=0A=
     *     {@link ng.$sceDelegate#getTrusted =
`$sceDelegate.getTrusted($sce.HTML, value)`}=0A=
     *=0A=
     * @param {*} value The value to pass to `$sce.getTrusted`.=0A=
     * @returns {*} The return value of `$sce.getTrusted($sce.HTML, =
value)`=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#getTrustedCss=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.getTrustedCss(value)` =E2=86&#65533;=0A=
     *     {@link ng.$sceDelegate#getTrusted =
`$sceDelegate.getTrusted($sce.CSS, value)`}=0A=
     *=0A=
     * @param {*} value The value to pass to `$sce.getTrusted`.=0A=
     * @returns {*} The return value of `$sce.getTrusted($sce.CSS, =
value)`=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#getTrustedUrl=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.getTrustedUrl(value)` =E2=86&#65533;=0A=
     *     {@link ng.$sceDelegate#getTrusted =
`$sceDelegate.getTrusted($sce.URL, value)`}=0A=
     *=0A=
     * @param {*} value The value to pass to `$sce.getTrusted`.=0A=
     * @returns {*} The return value of `$sce.getTrusted($sce.URL, =
value)`=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#getTrustedResourceUrl=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.getTrustedResourceUrl(value)` =
=E2=86&#65533;=0A=
     *     {@link ng.$sceDelegate#getTrusted =
`$sceDelegate.getTrusted($sce.RESOURCE_URL, value)`}=0A=
     *=0A=
     * @param {*} value The value to pass to `$sceDelegate.getTrusted`.=0A=
     * @returns {*} The return value of =
`$sce.getTrusted($sce.RESOURCE_URL, value)`=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#getTrustedJs=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.getTrustedJs(value)` =E2=86&#65533;=0A=
     *     {@link ng.$sceDelegate#getTrusted =
`$sceDelegate.getTrusted($sce.JS, value)`}=0A=
     *=0A=
     * @param {*} value The value to pass to `$sce.getTrusted`.=0A=
     * @returns {*} The return value of `$sce.getTrusted($sce.JS, value)`=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#parseAsHtml=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.parseAsHtml(expression string)` =
=E2=86&#65533;=0A=
     *     {@link ng.$sce#parseAs `$sce.parseAs($sce.HTML, value)`}=0A=
     *=0A=
     * @param {string} expression String expression to compile.=0A=
     * @returns {function(context, locals)} a function which represents =
the compiled expression:=0A=
     *=0A=
     *    * `context` =E2=80&#65533; `{object}` =E2=80&#65533; an object =
against which any expressions embedded in the strings=0A=
     *      are evaluated against (typically a scope object).=0A=
     *    * `locals` =E2=80&#65533; `{object=3D}` =E2=80&#65533; local =
variables context object, useful for overriding values in=0A=
     *      `context`.=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#parseAsCss=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.parseAsCss(value)` =E2=86&#65533;=0A=
     *     {@link ng.$sce#parseAs `$sce.parseAs($sce.CSS, value)`}=0A=
     *=0A=
     * @param {string} expression String expression to compile.=0A=
     * @returns {function(context, locals)} a function which represents =
the compiled expression:=0A=
     *=0A=
     *    * `context` =E2=80&#65533; `{object}` =E2=80&#65533; an object =
against which any expressions embedded in the strings=0A=
     *      are evaluated against (typically a scope object).=0A=
     *    * `locals` =E2=80&#65533; `{object=3D}` =E2=80&#65533; local =
variables context object, useful for overriding values in=0A=
     *      `context`.=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#parseAsUrl=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.parseAsUrl(value)` =E2=86&#65533;=0A=
     *     {@link ng.$sce#parseAs `$sce.parseAs($sce.URL, value)`}=0A=
     *=0A=
     * @param {string} expression String expression to compile.=0A=
     * @returns {function(context, locals)} a function which represents =
the compiled expression:=0A=
     *=0A=
     *    * `context` =E2=80&#65533; `{object}` =E2=80&#65533; an object =
against which any expressions embedded in the strings=0A=
     *      are evaluated against (typically a scope object).=0A=
     *    * `locals` =E2=80&#65533; `{object=3D}` =E2=80&#65533; local =
variables context object, useful for overriding values in=0A=
     *      `context`.=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#parseAsResourceUrl=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.parseAsResourceUrl(value)` =E2=86&#65533;=0A=
     *     {@link ng.$sce#parseAs `$sce.parseAs($sce.RESOURCE_URL, =
value)`}=0A=
     *=0A=
     * @param {string} expression String expression to compile.=0A=
     * @returns {function(context, locals)} a function which represents =
the compiled expression:=0A=
     *=0A=
     *    * `context` =E2=80&#65533; `{object}` =E2=80&#65533; an object =
against which any expressions embedded in the strings=0A=
     *      are evaluated against (typically a scope object).=0A=
     *    * `locals` =E2=80&#65533; `{object=3D}` =E2=80&#65533; local =
variables context object, useful for overriding values in=0A=
     *      `context`.=0A=
     */=0A=
=0A=
    /**=0A=
     * @ngdoc method=0A=
     * @name $sce#parseAsJs=0A=
     *=0A=
     * @description=0A=
     * Shorthand method.  `$sce.parseAsJs(value)` =E2=86&#65533;=0A=
     *     {@link ng.$sce#parseAs `$sce.parseAs($sce.JS, value)`}=0A=
     *=0A=
     * @param {string} expression String expression to compile.=0A=
     * @returns {function(context, locals)} a function which represents =
the compiled expression:=0A=
     *=0A=
     *    * `context` =E2=80&#65533; `{object}` =E2=80&#65533; an object =
against which any expressions embedded in the strings=0A=
     *      are evaluated against (typically a scope object).=0A=
     *    * `locals` =E2=80&#65533; `{object=3D}` =E2=80&#65533; local =
variables context object, useful for overriding values in=0A=
     *      `context`.=0A=
     */=0A=
=0A=
    // Shorthand delegations.=0A=
    var parse =3D sce.parseAs,=0A=
        getTrusted =3D sce.getTrusted,=0A=
        trustAs =3D sce.trustAs;=0A=
=0A=
    forEach(SCE_CONTEXTS, function (enumValue, name) {=0A=
      var lName =3D lowercase(name);=0A=
      sce[camelCase("parse_as_" + lName)] =3D function (expr) {=0A=
        return parse(enumValue, expr);=0A=
      };=0A=
      sce[camelCase("get_trusted_" + lName)] =3D function (value) {=0A=
        return getTrusted(enumValue, value);=0A=
      };=0A=
      sce[camelCase("trust_as_" + lName)] =3D function (value) {=0A=
        return trustAs(enumValue, value);=0A=
      };=0A=
    });=0A=
=0A=
    return sce;=0A=
  }];=0A=
}=0A=
=0A=
/**=0A=
 * !!! This is an undocumented "private" service !!!=0A=
 *=0A=
 * @name $sniffer=0A=
 * @requires $window=0A=
 * @requires $document=0A=
 *=0A=
 * @property {boolean} history Does the browser support html5 history =
api ?=0A=
 * @property {boolean} transitions Does the browser support CSS =
transition events ?=0A=
 * @property {boolean} animations Does the browser support CSS animation =
events ?=0A=
 *=0A=
 * @description=0A=
 * This is very simple implementation of testing browser's features.=0A=
 */=0A=
function $SnifferProvider() {=0A=
  this.$get =3D ['$window', '$document', function($window, $document) {=0A=
    var eventSupport =3D {},=0A=
        android =3D=0A=
          int((/android (\d+)/.exec(lowercase(($window.navigator || =
{}).userAgent)) || [])[1]),=0A=
        boxee =3D /Boxee/i.test(($window.navigator || {}).userAgent),=0A=
        document =3D $document[0] || {},=0A=
        vendorPrefix,=0A=
        vendorRegex =3D /^(Moz|webkit|O|ms)(?=3D[A-Z])/,=0A=
        bodyStyle =3D document.body &amp;&amp; document.body.style,=0A=
        transitions =3D false,=0A=
        animations =3D false,=0A=
        match;=0A=
=0A=
    if (bodyStyle) {=0A=
      for(var prop in bodyStyle) {=0A=
        if(match =3D vendorRegex.exec(prop)) {=0A=
          vendorPrefix =3D match[0];=0A=
          vendorPrefix =3D vendorPrefix.substr(0, 1).toUpperCase() + =
vendorPrefix.substr(1);=0A=
          break;=0A=
        }=0A=
      }=0A=
=0A=
      if(!vendorPrefix) {=0A=
        vendorPrefix =3D ('WebkitOpacity' in bodyStyle) &amp;&amp; =
'webkit';=0A=
      }=0A=
=0A=
      transitions =3D !!(('transition' in bodyStyle) || (vendorPrefix + =
'Transition' in bodyStyle));=0A=
      animations  =3D !!(('animation' in bodyStyle) || (vendorPrefix + =
'Animation' in bodyStyle));=0A=
=0A=
      if (android &amp;&amp; (!transitions||!animations)) {=0A=
        transitions =3D isString(document.body.style.webkitTransition);=0A=
        animations =3D isString(document.body.style.webkitAnimation);=0A=
      }=0A=
    }=0A=
=0A=
=0A=
    return {=0A=
      // Android has history.pushState, but it does not update location =
correctly=0A=
      // so let's not use the history API at all.=0A=
      // http://code.google.com/p/android/issues/detail?id=3D17471=0A=
      // https://github.com/angular/angular.js/issues/904=0A=
=0A=
      // older webkit browser (533.9) on Boxee box has exactly the same =
problem as Android has=0A=
      // so let's not use the history API also=0A=
      // We are purposefully using `!(android &lt; 4)` to cover the case =
when `android` is undefined=0A=
      // jshint -W018=0A=
      history: !!($window.history &amp;&amp; $window.history.pushState =
&amp;&amp; !(android &lt; 4) &amp;&amp; !boxee),=0A=
      // jshint +W018=0A=
      hasEvent: function(event) {=0A=
        // IE9 implements 'input' event it's so fubared that we rather =
pretend that it doesn't have=0A=
        // it. In particular the event is not fired when backspace or =
delete key are pressed or=0A=
        // when cut operation is performed.=0A=
        if (event =3D=3D 'input' &amp;&amp; msie =3D=3D 9) return false;=0A=
=0A=
        if (isUndefined(eventSupport[event])) {=0A=
          var divElm =3D document.createElement('div');=0A=
          eventSupport[event] =3D 'on' + event in divElm;=0A=
        }=0A=
=0A=
        return eventSupport[event];=0A=
      },=0A=
      csp: csp(),=0A=
      vendorPrefix: vendorPrefix,=0A=
      transitions : transitions,=0A=
      animations : animations,=0A=
      android: android=0A=
    };=0A=
  }];=0A=
}=0A=
=0A=
var $compileMinErr =3D minErr('$compile');=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $templateRequest=0A=
 *=0A=
 * @description=0A=
 * The `$templateRequest` service downloads the provided template using =
`$http` and, upon success,=0A=
 * stores the contents inside of `$templateCache`. If the HTTP request =
fails or the response data=0A=
 * of the HTTP request is empty then a `$compile` error will be thrown =
(the exception can be thwarted=0A=
 * by setting the 2nd parameter of the function to true).=0A=
 *=0A=
 * @param {string} tpl The HTTP request template URL=0A=
 * @param {boolean=3D} ignoreRequestError Whether or not to ignore the =
exception when the request fails or the template is empty=0A=
 *=0A=
 * @return {Promise} the HTTP Promise for the given.=0A=
 *=0A=
 * @property {number} totalPendingRequests total amount of pending =
template requests being downloaded.=0A=
 */=0A=
function $TemplateRequestProvider() {=0A=
  this.$get =3D ['$templateCache', '$http', '$q', =
function($templateCache, $http, $q) {=0A=
    function handleRequestFn(tpl, ignoreRequestError) {=0A=
      var self =3D handleRequestFn;=0A=
      self.totalPendingRequests++;=0A=
=0A=
      return $http.get(tpl, { cache : $templateCache })=0A=
        .then(function(response) {=0A=
          var html =3D response.data;=0A=
          if(!html || html.length =3D=3D=3D 0) {=0A=
            return handleError();=0A=
          }=0A=
=0A=
          self.totalPendingRequests--;=0A=
          $templateCache.put(tpl, html);=0A=
          return html;=0A=
        }, handleError);=0A=
=0A=
      function handleError() {=0A=
        self.totalPendingRequests--;=0A=
        if (!ignoreRequestError) {=0A=
          throw $compileMinErr('tpload', 'Failed to load template: {0}', =
tpl);=0A=
        }=0A=
        return $q.reject();=0A=
      }=0A=
    }=0A=
=0A=
    handleRequestFn.totalPendingRequests =3D 0;=0A=
=0A=
    return handleRequestFn;=0A=
  }];=0A=
}=0A=
=0A=
function $$TestabilityProvider() {=0A=
  this.$get =3D ['$rootScope', '$browser', '$location',=0A=
       function($rootScope,   $browser,   $location) {=0A=
=0A=
    /**=0A=
     * @name $testability=0A=
     *=0A=
     * @description=0A=
     * The private $$testability service provides a collection of =
methods for use when debugging=0A=
     * or by automated test and debugging tools.=0A=
     */=0A=
    var testability =3D {};=0A=
=0A=
    /**=0A=
     * @name $$testability#findBindings=0A=
     *=0A=
     * @description=0A=
     * Returns an array of elements that are bound (via ng-bind or {{}})=0A=
     * to expressions matching the input.=0A=
     *=0A=
     * @param {Element} element The element root to search from.=0A=
     * @param {string} expression The binding expression to match.=0A=
     * @param {boolean} opt_exactMatch If true, only returns exact =
matches=0A=
     *     for the expression. Filters and whitespace are ignored.=0A=
     */=0A=
    testability.findBindings =3D function(element, expression, =
opt_exactMatch) {=0A=
      var bindings =3D element.getElementsByClassName('ng-binding');=0A=
      var matches =3D [];=0A=
      forEach(bindings, function(binding) {=0A=
        var dataBinding =3D angular.element(binding).data('$binding');=0A=
        if (dataBinding) {=0A=
          forEach(dataBinding, function(bindingName) {=0A=
            if (opt_exactMatch) {=0A=
              var matcher =3D new RegExp('(^|\\s)' + expression + =
'(\\s|\\||$)');=0A=
              if (matcher.test(bindingName)) {=0A=
                matches.push(binding);=0A=
              }=0A=
            } else {=0A=
              if (bindingName.indexOf(expression) !=3D -1) {=0A=
                matches.push(binding);=0A=
              }=0A=
            }=0A=
          });=0A=
        }=0A=
      });=0A=
      return matches;=0A=
    };=0A=
=0A=
    /**=0A=
     * @name $$testability#findModels=0A=
     *=0A=
     * @description=0A=
     * Returns an array of elements that are two-way found via ng-model =
to=0A=
     * expressions matching the input.=0A=
     *=0A=
     * @param {Element} element The element root to search from.=0A=
     * @param {string} expression The model expression to match.=0A=
     * @param {boolean} opt_exactMatch If true, only returns exact =
matches=0A=
     *     for the expression.=0A=
     */=0A=
    testability.findModels =3D function(element, expression, =
opt_exactMatch) {=0A=
      var prefixes =3D ['ng-', 'data-ng-', 'ng\\:'];=0A=
      for (var p =3D 0; p &lt; prefixes.length; ++p) {=0A=
        var attributeEquals =3D opt_exactMatch ? '=3D' : '*=3D';=0A=
        var selector =3D '[' + prefixes[p] + 'model' + attributeEquals + =
'"' + expression + '"]';=0A=
        var elements =3D element.querySelectorAll(selector);=0A=
        if (elements.length) {=0A=
          return elements;=0A=
        }=0A=
      }=0A=
    };=0A=
=0A=
    /**=0A=
     * @name $$testability#getLocation=0A=
     *=0A=
     * @description=0A=
     * Shortcut for getting the location in a browser agnostic way. =
Returns=0A=
     *     the path, search, and hash. (e.g. /path?a=3Db#hash)=0A=
     */=0A=
    testability.getLocation =3D function() {=0A=
      return $location.url();=0A=
    };=0A=
=0A=
    /**=0A=
     * @name $$testability#setLocation=0A=
     *=0A=
     * @description=0A=
     * Shortcut for navigating to a location without doing a full page =
reload.=0A=
     *=0A=
     * @param {string} url The location url (path, search and hash,=0A=
     *     e.g. /path?a=3Db#hash) to go to.=0A=
     */=0A=
    testability.setLocation =3D function(url) {=0A=
      if (url !=3D=3D $location.url()) {=0A=
        $location.url(url);=0A=
        $rootScope.$digest();=0A=
      }=0A=
    };=0A=
=0A=
    /**=0A=
     * @name $$testability#whenStable=0A=
     *=0A=
     * @description=0A=
     * Calls the callback when $timeout and $http requests are completed.=0A=
     *=0A=
     * @param {function} callback=0A=
     */=0A=
    testability.whenStable =3D function(callback) {=0A=
      $browser.notifyWhenNoOutstandingRequests(callback);=0A=
    };=0A=
=0A=
    return testability;=0A=
  }];=0A=
}=0A=
=0A=
function $TimeoutProvider() {=0A=
  this.$get =3D ['$rootScope', '$browser', '$q', '$$q', =
'$exceptionHandler',=0A=
       function($rootScope,   $browser,   $q,   $$q,   =
$exceptionHandler) {=0A=
    var deferreds =3D {};=0A=
=0A=
=0A=
     /**=0A=
      * @ngdoc service=0A=
      * @name $timeout=0A=
      *=0A=
      * @description=0A=
      * Angular's wrapper for `window.setTimeout`. The `fn` function is =
wrapped into a try/catch=0A=
      * block and delegates any exceptions to=0A=
      * {@link ng.$exceptionHandler $exceptionHandler} service.=0A=
      *=0A=
      * The return value of registering a timeout function is a promise, =
which will be resolved when=0A=
      * the timeout is reached and the timeout function is executed.=0A=
      *=0A=
      * To cancel a timeout request, call `$timeout.cancel(promise)`.=0A=
      *=0A=
      * In tests you can use {@link ngMock.$timeout `$timeout.flush()`} =
to=0A=
      * synchronously flush the queue of deferred functions.=0A=
      *=0A=
      * @param {function()} fn A function, whose execution should be =
delayed.=0A=
      * @param {number=3D} [delay=3D0] Delay in milliseconds.=0A=
      * @param {boolean=3D} [invokeApply=3Dtrue] If set to `false` skips =
model dirty checking, otherwise=0A=
      *   will invoke `fn` within the {@link ng.$rootScope.Scope#$apply =
$apply} block.=0A=
      * @returns {Promise} Promise that will be resolved when the =
timeout is reached. The value this=0A=
      *   promise will be resolved with is the return value of the `fn` =
function.=0A=
      *=0A=
      */=0A=
    function timeout(fn, delay, invokeApply) {=0A=
      var skipApply =3D (isDefined(invokeApply) &amp;&amp; !invokeApply),=0A=
          deferred =3D (skipApply ? $$q : $q).defer(),=0A=
          promise =3D deferred.promise,=0A=
          timeoutId;=0A=
=0A=
      timeoutId =3D $browser.defer(function() {=0A=
        try {=0A=
          deferred.resolve(fn());=0A=
        } catch(e) {=0A=
          deferred.reject(e);=0A=
          $exceptionHandler(e);=0A=
        }=0A=
        finally {=0A=
          delete deferreds[promise.$$timeoutId];=0A=
        }=0A=
=0A=
        if (!skipApply) $rootScope.$apply();=0A=
      }, delay);=0A=
=0A=
      promise.$$timeoutId =3D timeoutId;=0A=
      deferreds[timeoutId] =3D deferred;=0A=
=0A=
      return promise;=0A=
    }=0A=
=0A=
=0A=
     /**=0A=
      * @ngdoc method=0A=
      * @name $timeout#cancel=0A=
      *=0A=
      * @description=0A=
      * Cancels a task associated with the `promise`. As a result of =
this, the promise will be=0A=
      * resolved with a rejection.=0A=
      *=0A=
      * @param {Promise=3D} promise Promise returned by the `$timeout` =
function.=0A=
      * @returns {boolean} Returns `true` if the task hasn't executed =
yet and was successfully=0A=
      *   canceled.=0A=
      */=0A=
    timeout.cancel =3D function(promise) {=0A=
      if (promise &amp;&amp; promise.$$timeoutId in deferreds) {=0A=
        deferreds[promise.$$timeoutId].reject('canceled');=0A=
        delete deferreds[promise.$$timeoutId];=0A=
        return $browser.defer.cancel(promise.$$timeoutId);=0A=
      }=0A=
      return false;=0A=
    };=0A=
=0A=
    return timeout;=0A=
  }];=0A=
}=0A=
=0A=
// NOTE:  The usage of window and document instead of $window and =
$document here is=0A=
// deliberate.  This service depends on the specific behavior of anchor =
nodes created by the=0A=
// browser (resolving and parsing URLs) that is unlikely to be provided =
by mock objects and=0A=
// cause us to break tests.  In addition, when the browser resolves a =
URL for XHR, it=0A=
// doesn't know about mocked locations and resolves URLs to the real =
document - which is=0A=
// exactly the behavior needed here.  There is little value is mocking =
these out for this=0A=
// service.=0A=
var urlParsingNode =3D document.createElement("a");=0A=
var originUrl =3D urlResolve(window.location.href, true);=0A=
=0A=
=0A=
/**=0A=
 *=0A=
 * Implementation Notes for non-IE browsers=0A=
 * ----------------------------------------=0A=
 * Assigning a URL to the href property of an anchor DOM node, even one =
attached to the DOM,=0A=
 * results both in the normalizing and parsing of the URL.  Normalizing =
means that a relative=0A=
 * URL will be resolved into an absolute URL in the context of the =
application document.=0A=
 * Parsing means that the anchor node's host, hostname, protocol, port, =
pathname and related=0A=
 * properties are all populated to reflect the normalized URL.  This =
approach has wide=0A=
 * compatibility - Safari 1+, Mozilla 1+, Opera 7+,e etc.  See=0A=
 * http://www.aptana.com/reference/html/api/HTMLAnchorElement.html=0A=
 *=0A=
 * Implementation Notes for IE=0A=
 * ---------------------------=0A=
 * IE &gt;=3D 8 and &lt;=3D 10 normalizes the URL when assigned to the =
anchor node similar to the other=0A=
 * browsers.  However, the parsed components will not be set if the URL =
assigned did not specify=0A=
 * them.  (e.g. if you assign a.href =3D "foo", then a.protocol, a.host, =
etc. will be empty.)  We=0A=
 * work around that by performing the parsing in a 2nd step by taking a =
previously normalized=0A=
 * URL (e.g. by assigning to a.href) and assigning it a.href again.  =
This correctly populates the=0A=
 * properties such as protocol, hostname, port, etc.=0A=
 *=0A=
 * IE7 does not normalize the URL when assigned to an anchor node.  =
(Apparently, it does, if one=0A=
 * uses the inner HTML approach to assign the URL as part of an HTML =
snippet -=0A=
 * http://stackoverflow.com/a/472729)  However, setting img[src] does =
normalize the URL.=0A=
 * Unfortunately, setting img[src] to something like "javascript:foo" on =
IE throws an exception.=0A=
 * Since the primary usage for normalizing URLs is to sanitize such =
URLs, we can't use that=0A=
 * method and IE &lt; 8 is unsupported.=0A=
 *=0A=
 * References:=0A=
 *   http://developer.mozilla.org/en-US/docs/Web/API/HTMLAnchorElement=0A=
 *   http://www.aptana.com/reference/html/api/HTMLAnchorElement.html=0A=
 *   http://url.spec.whatwg.org/#urlutils=0A=
 *   https://github.com/angular/angular.js/pull/2902=0A=
 *   http://james.padolsey.com/javascript/parsing-urls-with-the-dom/=0A=
 *=0A=
 * @kind function=0A=
 * @param {string} url The URL to be parsed.=0A=
 * @description Normalizes and parses a URL.=0A=
 * @returns {object} Returns the normalized URL as a dictionary.=0A=
 *=0A=
 *   | member name   | Description    |=0A=
 *   |---------------|----------------|=0A=
 *   | href          | A normalized version of the provided URL if it =
was not an absolute URL |=0A=
 *   | protocol      | The protocol including the trailing colon         =
                     |=0A=
 *   | host          | The host and port (if the port is non-default) of =
the normalizedUrl    |=0A=
 *   | search        | The search params, minus the question mark        =
                     |=0A=
 *   | hash          | The hash string, minus the hash symbol=0A=
 *   | hostname      | The hostname=0A=
 *   | port          | The port, without ":"=0A=
 *   | pathname      | The pathname, beginning with "/"=0A=
 *=0A=
 */=0A=
function urlResolve(url, base) {=0A=
  var href =3D url;=0A=
=0A=
  if (msie) {=0A=
    // Normalize before parse.  Refer Implementation Notes on why this is=0A=
    // done in two steps on IE.=0A=
    urlParsingNode.setAttribute("href", href);=0A=
    href =3D urlParsingNode.href;=0A=
  }=0A=
=0A=
  urlParsingNode.setAttribute('href', href);=0A=
=0A=
  // urlParsingNode provides the UrlUtils interface - =
http://url.spec.whatwg.org/#urlutils=0A=
  return {=0A=
    href: urlParsingNode.href,=0A=
    protocol: urlParsingNode.protocol ? =
urlParsingNode.protocol.replace(/:$/, '') : '',=0A=
    host: urlParsingNode.host,=0A=
    search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, =
'') : '',=0A=
    hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : =
'',=0A=
    hostname: urlParsingNode.hostname,=0A=
    port: urlParsingNode.port,=0A=
    pathname: (urlParsingNode.pathname.charAt(0) =3D=3D=3D '/')=0A=
      ? urlParsingNode.pathname=0A=
      : '/' + urlParsingNode.pathname=0A=
  };=0A=
}=0A=
=0A=
/**=0A=
 * Parse a request URL and determine whether this is a same-origin =
request as the application document.=0A=
 *=0A=
 * @param {string|object} requestUrl The url of the request as a string =
that will be resolved=0A=
 * or a parsed URL object.=0A=
 * @returns {boolean} Whether the request is for the same origin as the =
application document.=0A=
 */=0A=
function urlIsSameOrigin(requestUrl) {=0A=
  var parsed =3D (isString(requestUrl)) ? urlResolve(requestUrl) : =
requestUrl;=0A=
  return (parsed.protocol =3D=3D=3D originUrl.protocol &amp;&amp;=0A=
          parsed.host =3D=3D=3D originUrl.host);=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $window=0A=
 *=0A=
 * @description=0A=
 * A reference to the browser's `window` object. While `window`=0A=
 * is globally available in JavaScript, it causes testability problems, =
because=0A=
 * it is a global variable. In angular we always refer to it through the=0A=
 * `$window` service, so it may be overridden, removed or mocked for =
testing.=0A=
 *=0A=
 * Expressions, like the one defined for the `ngClick` directive in the =
example=0A=
 * below, are evaluated with respect to the current scope.  Therefore, =
there is=0A=
 * no risk of inadvertently coding in a dependency on a global value in =
such an=0A=
 * expression.=0A=
 *=0A=
 * @example=0A=
   &lt;example module=3D"windowExample"&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
       &lt;script&gt;=0A=
         angular.module('windowExample', [])=0A=
           .controller('ExampleController', ['$scope', '$window', =
function ($scope, $window) {=0A=
             $scope.greeting =3D 'Hello, World!';=0A=
             $scope.doGreeting =3D function(greeting) {=0A=
               $window.alert(greeting);=0A=
             };=0A=
           }]);=0A=
       &lt;/script&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
         &lt;input type=3D"text" ng-model=3D"greeting" /&gt;=0A=
         &lt;button =
ng-click=3D"doGreeting(greeting)"&gt;ALERT&lt;/button&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
      it('should display the greeting in the input box', function() {=0A=
       element(by.model('greeting')).sendKeys('Hello, E2E Tests');=0A=
       // If we click the button it will block the test runner=0A=
       // element(':button').click();=0A=
      });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
function $WindowProvider(){=0A=
  this.$get =3D valueFn(window);=0A=
}=0A=
=0A=
/* global currencyFilter: true,=0A=
 dateFilter: true,=0A=
 filterFilter: true,=0A=
 jsonFilter: true,=0A=
 limitToFilter: true,=0A=
 lowercaseFilter: true,=0A=
 numberFilter: true,=0A=
 orderByFilter: true,=0A=
 uppercaseFilter: true,=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc provider=0A=
 * @name $filterProvider=0A=
 * @description=0A=
 *=0A=
 * Filters are just functions which transform input to an output. =
However filters need to be=0A=
 * Dependency Injected. To achieve this a filter definition consists of =
a factory function which is=0A=
 * annotated with dependencies and is responsible for creating a filter =
function.=0A=
 *=0A=
 * ```js=0A=
 *   // Filter registration=0A=
 *   function MyModule($provide, $filterProvider) {=0A=
 *     // create a service to demonstrate injection (not always needed)=0A=
 *     $provide.value('greet', function(name){=0A=
 *       return 'Hello ' + name + '!';=0A=
 *     });=0A=
 *=0A=
 *     // register a filter factory which uses the=0A=
 *     // greet service to demonstrate DI.=0A=
 *     $filterProvider.register('greet', function(greet){=0A=
 *       // return the filter function which uses the greet service=0A=
 *       // to generate salutation=0A=
 *       return function(text) {=0A=
 *         // filters need to be forgiving so check input validity=0A=
 *         return text &amp;&amp; greet(text) || text;=0A=
 *       };=0A=
 *     });=0A=
 *   }=0A=
 * ```=0A=
 *=0A=
 * The filter function is registered with the `$injector` under the =
filter name suffix with=0A=
 * `Filter`.=0A=
 *=0A=
 * ```js=0A=
 *   it('should be the same instance', inject(=0A=
 *     function($filterProvider) {=0A=
 *       $filterProvider.register('reverse', function(){=0A=
 *         return ...;=0A=
 *       });=0A=
 *     },=0A=
 *     function($filter, reverseFilter) {=0A=
 *       expect($filter('reverse')).toBe(reverseFilter);=0A=
 *     });=0A=
 * ```=0A=
 *=0A=
 *=0A=
 * For more information about how angular filters work, and how to =
create your own filters, see=0A=
 * {@link guide/filter Filters} in the Angular Developer Guide.=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc service=0A=
 * @name $filter=0A=
 * @kind function=0A=
 * @description=0A=
 * Filters are used for formatting data displayed to the user.=0A=
 *=0A=
 * The general syntax in templates is as follows:=0A=
 *=0A=
 *         {{ expression [| filter_name[:parameter_value] ... ] }}=0A=
 *=0A=
 * @param {String} name Name of the filter function to retrieve=0A=
 * @return {Function} the filter function=0A=
 * @example=0A=
   &lt;example name=3D"$filter" module=3D"filterExample"&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
       &lt;div ng-controller=3D"MainCtrl"&gt;=0A=
        &lt;h3&gt;{{ originalText }}&lt;/h3&gt;=0A=
        &lt;h3&gt;{{ filteredText }}&lt;/h3&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
=0A=
     &lt;file name=3D"script.js"&gt;=0A=
      angular.module('filterExample', [])=0A=
      .controller('MainCtrl', function($scope, $filter) {=0A=
        $scope.originalText =3D 'hello';=0A=
        $scope.filteredText =3D =
$filter('uppercase')($scope.originalText);=0A=
      });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
  */=0A=
$FilterProvider.$inject =3D ['$provide'];=0A=
function $FilterProvider($provide) {=0A=
  var suffix =3D 'Filter';=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name $filterProvider#register=0A=
   * @param {string|Object} name Name of the filter function, or an =
object map of filters where=0A=
   *    the keys are the filter names and the values are the filter =
factories.=0A=
   * @returns {Object} Registered filter instance, or if a map of =
filters was provided then a map=0A=
   *    of the registered filter instances.=0A=
   */=0A=
  function register(name, factory) {=0A=
    if(isObject(name)) {=0A=
      var filters =3D {};=0A=
      forEach(name, function(filter, key) {=0A=
        filters[key] =3D register(key, filter);=0A=
      });=0A=
      return filters;=0A=
    } else {=0A=
      return $provide.factory(name + suffix, factory);=0A=
    }=0A=
  }=0A=
  this.register =3D register;=0A=
=0A=
  this.$get =3D ['$injector', function($injector) {=0A=
    return function(name) {=0A=
      return $injector.get(name + suffix);=0A=
    };=0A=
  }];=0A=
=0A=
  ////////////////////////////////////////=0A=
=0A=
  /* global=0A=
    currencyFilter: false,=0A=
    dateFilter: false,=0A=
    filterFilter: false,=0A=
    jsonFilter: false,=0A=
    limitToFilter: false,=0A=
    lowercaseFilter: false,=0A=
    numberFilter: false,=0A=
    orderByFilter: false,=0A=
    uppercaseFilter: false,=0A=
  */=0A=
=0A=
  register('currency', currencyFilter);=0A=
  register('date', dateFilter);=0A=
  register('filter', filterFilter);=0A=
  register('json', jsonFilter);=0A=
  register('limitTo', limitToFilter);=0A=
  register('lowercase', lowercaseFilter);=0A=
  register('number', numberFilter);=0A=
  register('orderBy', orderByFilter);=0A=
  register('uppercase', uppercaseFilter);=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc filter=0A=
 * @name filter=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Selects a subset of items from `array` and returns it as a new array.=0A=
 *=0A=
 * @param {Array} array The source array.=0A=
 * @param {string|Object|function()} expression The predicate to be used =
for selecting items from=0A=
 *   `array`.=0A=
 *=0A=
 *   Can be one of:=0A=
 *=0A=
 *   - `string`: The string is evaluated as an expression and the =
resulting value is used for substring match against=0A=
 *     the contents of the `array`. All strings or objects with string =
properties in `array` that contain this string=0A=
 *     will be returned. The predicate can be negated by prefixing the =
string with `!`.=0A=
 *=0A=
 *   - `Object`: A pattern object can be used to filter specific =
properties on objects contained=0A=
 *     by `array`. For example `{name:"M", phone:"1"}` predicate will =
return an array of items=0A=
 *     which have property `name` containing "M" and property `phone` =
containing "1". A special=0A=
 *     property name `$` can be used (as in `{$:"text"}`) to accept a =
match against any=0A=
 *     property of the object. That's equivalent to the simple substring =
match with a `string`=0A=
 *     as described above. The predicate can be negated by prefixing the =
string with `!`.=0A=
 *     For Example `{name: "!M"}` predicate will return an array of =
items which have property `name`=0A=
 *     not containing "M".=0A=
 *=0A=
 *   - `function(value, index)`: A predicate function can be used to =
write arbitrary filters. The=0A=
 *     function is called for each element of `array`. The final result =
is an array of those=0A=
 *     elements that the predicate returned true for.=0A=
 *=0A=
 * @param {function(actual, expected)|true|undefined} comparator =
Comparator which is used in=0A=
 *     determining if the expected value (from the filter expression) =
and actual value (from=0A=
 *     the object in the array) should be considered a match.=0A=
 *=0A=
 *   Can be one of:=0A=
 *=0A=
 *   - `function(actual, expected)`:=0A=
 *     The function will be given the object value and the predicate =
value to compare and=0A=
 *     should return true if the item should be included in filtered =
result.=0A=
 *=0A=
 *   - `true`: A shorthand for `function(actual, expected) { return =
angular.equals(expected, actual)}`.=0A=
 *     this is essentially strict comparison of expected and actual.=0A=
 *=0A=
 *   - `false|undefined`: A short hand for a function which will look =
for a substring match in case=0A=
 *     insensitive way.=0A=
 *=0A=
 * @example=0A=
   &lt;example&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
       &lt;div ng-init=3D"friends =3D [{name:'John', phone:'555-1276'},=0A=
                                {name:'Mary', phone:'800-BIG-MARY'},=0A=
                                {name:'Mike', phone:'555-4321'},=0A=
                                {name:'Adam', phone:'555-5678'},=0A=
                                {name:'Julie', phone:'555-8765'},=0A=
                                {name:'Juliette', =
phone:'555-5678'}]"&gt;&lt;/div&gt;=0A=
=0A=
       Search: &lt;input ng-model=3D"searchText"&gt;=0A=
       &lt;table id=3D"searchTextResults"&gt;=0A=
         =
&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Phone&lt;/th&gt;&lt;/tr&gt;=0A=
         &lt;tr ng-repeat=3D"friend in friends | filter:searchText"&gt;=0A=
           &lt;td&gt;{{friend.name}}&lt;/td&gt;=0A=
           &lt;td&gt;{{friend.phone}}&lt;/td&gt;=0A=
         &lt;/tr&gt;=0A=
       &lt;/table&gt;=0A=
       &lt;hr&gt;=0A=
       Any: &lt;input ng-model=3D"search.$"&gt; &lt;br&gt;=0A=
       Name only &lt;input ng-model=3D"search.name"&gt;&lt;br&gt;=0A=
       Phone only &lt;input ng-model=3D"search.phone"&gt;&lt;br&gt;=0A=
       Equality &lt;input type=3D"checkbox" =
ng-model=3D"strict"&gt;&lt;br&gt;=0A=
       &lt;table id=3D"searchObjResults"&gt;=0A=
         =
&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Phone&lt;/th&gt;&lt;/tr&gt;=0A=
         &lt;tr ng-repeat=3D"friendObj in friends | =
filter:search:strict"&gt;=0A=
           &lt;td&gt;{{friendObj.name}}&lt;/td&gt;=0A=
           &lt;td&gt;{{friendObj.phone}}&lt;/td&gt;=0A=
         &lt;/tr&gt;=0A=
       &lt;/table&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       var expectFriendNames =3D function(expectedNames, key) {=0A=
         element.all(by.repeater(key + ' in friends').column(key + =
'.name')).then(function(arr) {=0A=
           arr.forEach(function(wd, i) {=0A=
             expect(wd.getText()).toMatch(expectedNames[i]);=0A=
           });=0A=
         });=0A=
       };=0A=
=0A=
       it('should search across all fields when filtering with a =
string', function() {=0A=
         var searchText =3D element(by.model('searchText'));=0A=
         searchText.clear();=0A=
         searchText.sendKeys('m');=0A=
         expectFriendNames(['Mary', 'Mike', 'Adam'], 'friend');=0A=
=0A=
         searchText.clear();=0A=
         searchText.sendKeys('76');=0A=
         expectFriendNames(['John', 'Julie'], 'friend');=0A=
       });=0A=
=0A=
       it('should search in specific fields when filtering with a =
predicate object', function() {=0A=
         var searchAny =3D element(by.model('search.$'));=0A=
         searchAny.clear();=0A=
         searchAny.sendKeys('i');=0A=
         expectFriendNames(['Mary', 'Mike', 'Julie', 'Juliette'], =
'friendObj');=0A=
       });=0A=
       it('should use a equal comparison when comparator is true', =
function() {=0A=
         var searchName =3D element(by.model('search.name'));=0A=
         var strict =3D element(by.model('strict'));=0A=
         searchName.clear();=0A=
         searchName.sendKeys('Julie');=0A=
         strict.click();=0A=
         expectFriendNames(['Julie'], 'friendObj');=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
function filterFilter() {=0A=
  return function(array, expression, comparator) {=0A=
    if (!isArray(array)) return array;=0A=
=0A=
    var comparatorType =3D typeof(comparator),=0A=
        predicates =3D [];=0A=
=0A=
    predicates.check =3D function(value, index) {=0A=
      for (var j =3D 0; j &lt; predicates.length; j++) {=0A=
        if(!predicates[j](value, index)) {=0A=
          return false;=0A=
        }=0A=
      }=0A=
      return true;=0A=
    };=0A=
=0A=
    if (comparatorType !=3D=3D 'function') {=0A=
      if (comparatorType =3D=3D=3D 'boolean' &amp;&amp; comparator) {=0A=
        comparator =3D function(obj, text) {=0A=
          return angular.equals(obj, text);=0A=
        };=0A=
      } else {=0A=
        comparator =3D function(obj, text) {=0A=
          if (obj &amp;&amp; text &amp;&amp; typeof obj =3D=3D=3D =
'object' &amp;&amp; typeof text =3D=3D=3D 'object') {=0A=
            for (var objKey in obj) {=0A=
              if (objKey.charAt(0) !=3D=3D '$' &amp;&amp; =
hasOwnProperty.call(obj, objKey) &amp;&amp;=0A=
                  comparator(obj[objKey], text[objKey])) {=0A=
                return true;=0A=
              }=0A=
            }=0A=
            return false;=0A=
          }=0A=
          text =3D (''+text).toLowerCase();=0A=
          return (''+obj).toLowerCase().indexOf(text) &gt; -1;=0A=
        };=0A=
      }=0A=
    }=0A=
=0A=
    var search =3D function(obj, text){=0A=
      if (typeof text =3D=3D=3D 'string' &amp;&amp; text.charAt(0) =
=3D=3D=3D '!') {=0A=
        return !search(obj, text.substr(1));=0A=
      }=0A=
      switch (typeof obj) {=0A=
        case 'boolean':=0A=
        case 'number':=0A=
        case 'string':=0A=
          return comparator(obj, text);=0A=
        case 'object':=0A=
          switch (typeof text) {=0A=
            case 'object':=0A=
              return comparator(obj, text);=0A=
            default:=0A=
              for ( var objKey in obj) {=0A=
                if (objKey.charAt(0) !=3D=3D '$' &amp;&amp; =
search(obj[objKey], text)) {=0A=
                  return true;=0A=
                }=0A=
              }=0A=
              break;=0A=
          }=0A=
          return false;=0A=
        case 'array':=0A=
          for ( var i =3D 0; i &lt; obj.length; i++) {=0A=
            if (search(obj[i], text)) {=0A=
              return true;=0A=
            }=0A=
          }=0A=
          return false;=0A=
        default:=0A=
          return false;=0A=
      }=0A=
    };=0A=
    switch (typeof expression) {=0A=
      case 'boolean':=0A=
      case 'number':=0A=
      case 'string':=0A=
        // Set up expression object and fall through=0A=
        expression =3D {$:expression};=0A=
        // jshint -W086=0A=
      case 'object':=0A=
        // jshint +W086=0A=
        for (var key in expression) {=0A=
          (function(path) {=0A=
            if (typeof expression[path] =3D=3D=3D 'undefined') return;=0A=
            predicates.push(function(value) {=0A=
              return search(path =3D=3D '$' ? value : (value &amp;&amp; =
value[path]), expression[path]);=0A=
            });=0A=
          })(key);=0A=
        }=0A=
        break;=0A=
      case 'function':=0A=
        predicates.push(expression);=0A=
        break;=0A=
      default:=0A=
        return array;=0A=
    }=0A=
    var filtered =3D [];=0A=
    for ( var j =3D 0; j &lt; array.length; j++) {=0A=
      var value =3D array[j];=0A=
      if (predicates.check(value, j)) {=0A=
        filtered.push(value);=0A=
      }=0A=
    }=0A=
    return filtered;=0A=
  };=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc filter=0A=
 * @name currency=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Formats a number as a currency (ie $1,234.56). When no currency =
symbol is provided, default=0A=
 * symbol for current locale is used.=0A=
 *=0A=
 * @param {number} amount Input to filter.=0A=
 * @param {string=3D} symbol Currency symbol or identifier to be =
displayed.=0A=
 * @param {number=3D} fractionSize Number of decimal places to round the =
amount to.=0A=
 * @returns {string} Formatted number.=0A=
 *=0A=
 *=0A=
 * @example=0A=
   &lt;example module=3D"currencyExample"&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
       &lt;script&gt;=0A=
         angular.module('currencyExample', [])=0A=
           .controller('ExampleController', ['$scope', function($scope) {=0A=
             $scope.amount =3D 1234.56;=0A=
           }]);=0A=
       &lt;/script&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
         &lt;input type=3D"number" ng-model=3D"amount"&gt; &lt;br&gt;=0A=
         default currency symbol ($): &lt;span =
id=3D"currency-default"&gt;{{amount | currency}}&lt;/span&gt;&lt;br&gt;=0A=
         custom currency identifier (USD$): &lt;span =
id=3D"currency-custom"&gt;{{amount | currency:"USD$"}}&lt;/span&gt;=0A=
         no fractions (0): &lt;span =
id=3D"currency-no-fractions"&gt;{{amount | =
currency:"USD$":0}}&lt;/span&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should init with 1234.56', function() {=0A=
         =
expect(element(by.id('currency-default')).getText()).toBe('$1,234.56');=0A=
         =
expect(element(by.id('currency-custom')).getText()).toBe('USD$1,234.56');=0A=
         =
expect(element(by.id('currency-no-fractions')).getText()).toBe('USD$1,235=
');=0A=
       });=0A=
       it('should update', function() {=0A=
         if (browser.params.browser =3D=3D 'safari') {=0A=
           // Safari does not understand the minus key. See=0A=
           // https://github.com/angular/protractor/issues/481=0A=
           return;=0A=
         }=0A=
         element(by.model('amount')).clear();=0A=
         element(by.model('amount')).sendKeys('-1234');=0A=
         =
expect(element(by.id('currency-default')).getText()).toBe('($1,234.00)');=0A=
         =
expect(element(by.id('currency-custom')).getText()).toBe('(USD$1,234.00)'=
);=0A=
         =
expect(element(by.id('currency-no-fractions')).getText()).toBe('(USD$1,23=
4)');=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
currencyFilter.$inject =3D ['$locale'];=0A=
function currencyFilter($locale) {=0A=
  var formats =3D $locale.NUMBER_FORMATS;=0A=
  return function(amount, currencySymbol, fractionSize){=0A=
    if (isUndefined(currencySymbol)) {=0A=
      currencySymbol =3D formats.CURRENCY_SYM;=0A=
    }=0A=
=0A=
    if (isUndefined(fractionSize)) {=0A=
      // TODO: read the default value from the locale file=0A=
      fractionSize =3D 2;=0A=
    }=0A=
=0A=
    // if null or undefined pass it through=0A=
    return (amount =3D=3D null)=0A=
        ? amount=0A=
        : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, =
formats.DECIMAL_SEP, fractionSize).=0A=
            replace(/\u00A4/g, currencySymbol);=0A=
  };=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc filter=0A=
 * @name number=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Formats a number as text.=0A=
 *=0A=
 * If the input is not a number an empty string is returned.=0A=
 *=0A=
 * @param {number|string} number Number to format.=0A=
 * @param {(number|string)=3D} fractionSize Number of decimal places to =
round the number to.=0A=
 * If this is not provided then the fraction size is computed from the =
current locale's number=0A=
 * formatting pattern. In the case of the default locale, it will be 3.=0A=
 * @returns {string} Number rounded to decimalPlaces and places a =
=E2=80&#65533;,=E2=80&#65533; after each third digit.=0A=
 *=0A=
 * @example=0A=
   &lt;example module=3D"numberFilterExample"&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
       &lt;script&gt;=0A=
         angular.module('numberFilterExample', [])=0A=
           .controller('ExampleController', ['$scope', function($scope) {=0A=
             $scope.val =3D 1234.56789;=0A=
           }]);=0A=
       &lt;/script&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
         Enter number: &lt;input ng-model=3D'val'&gt;&lt;br&gt;=0A=
         Default formatting: &lt;span id=3D'number-default'&gt;{{val | =
number}}&lt;/span&gt;&lt;br&gt;=0A=
         No fractions: &lt;span&gt;{{val | =
number:0}}&lt;/span&gt;&lt;br&gt;=0A=
         Negative number: &lt;span&gt;{{-val | number:4}}&lt;/span&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should format numbers', function() {=0A=
         =
expect(element(by.id('number-default')).getText()).toBe('1,234.568');=0A=
         expect(element(by.binding('val | =
number:0')).getText()).toBe('1,235');=0A=
         expect(element(by.binding('-val | =
number:4')).getText()).toBe('-1,234.5679');=0A=
       });=0A=
=0A=
       it('should update', function() {=0A=
         element(by.model('val')).clear();=0A=
         element(by.model('val')).sendKeys('3374.333');=0A=
         =
expect(element(by.id('number-default')).getText()).toBe('3,374.333');=0A=
         expect(element(by.binding('val | =
number:0')).getText()).toBe('3,374');=0A=
         expect(element(by.binding('-val | =
number:4')).getText()).toBe('-3,374.3330');=0A=
      });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
=0A=
numberFilter.$inject =3D ['$locale'];=0A=
function numberFilter($locale) {=0A=
  var formats =3D $locale.NUMBER_FORMATS;=0A=
  return function(number, fractionSize) {=0A=
=0A=
    // if null or undefined pass it through=0A=
    return (number =3D=3D null)=0A=
        ? number=0A=
        : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, =
formats.DECIMAL_SEP,=0A=
                       fractionSize);=0A=
  };=0A=
}=0A=
=0A=
var DECIMAL_SEP =3D '.';=0A=
function formatNumber(number, pattern, groupSep, decimalSep, =
fractionSize) {=0A=
  if (!isFinite(number) || isObject(number)) return '';=0A=
=0A=
  var isNegative =3D number &lt; 0;=0A=
  number =3D Math.abs(number);=0A=
  var numStr =3D number + '',=0A=
      formatedText =3D '',=0A=
      parts =3D [];=0A=
=0A=
  var hasExponent =3D false;=0A=
  if (numStr.indexOf('e') !=3D=3D -1) {=0A=
    var match =3D numStr.match(/([\d\.]+)e(-?)(\d+)/);=0A=
    if (match &amp;&amp; match[2] =3D=3D '-' &amp;&amp; match[3] &gt; =
fractionSize + 1) {=0A=
      numStr =3D '0';=0A=
      number =3D 0;=0A=
    } else {=0A=
      formatedText =3D numStr;=0A=
      hasExponent =3D true;=0A=
    }=0A=
  }=0A=
=0A=
  if (!hasExponent) {=0A=
    var fractionLen =3D (numStr.split(DECIMAL_SEP)[1] || '').length;=0A=
=0A=
    // determine fractionSize if it is not specified=0A=
    if (isUndefined(fractionSize)) {=0A=
      fractionSize =3D Math.min(Math.max(pattern.minFrac, fractionLen), =
pattern.maxFrac);=0A=
    }=0A=
=0A=
    // safely round numbers in JS without hitting imprecisions of =
floating-point arithmetics=0A=
    // inspired by:=0A=
    // =
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_=
Objects/Math/round=0A=
    number =3D +(Math.round(+(number.toString() + 'e' + =
fractionSize)).toString() + 'e' + -fractionSize);=0A=
=0A=
    if (number =3D=3D=3D 0) {=0A=
      isNegative =3D false;=0A=
    }=0A=
=0A=
    var fraction =3D ('' + number).split(DECIMAL_SEP);=0A=
    var whole =3D fraction[0];=0A=
    fraction =3D fraction[1] || '';=0A=
=0A=
    var i, pos =3D 0,=0A=
        lgroup =3D pattern.lgSize,=0A=
        group =3D pattern.gSize;=0A=
=0A=
    if (whole.length &gt;=3D (lgroup + group)) {=0A=
      pos =3D whole.length - lgroup;=0A=
      for (i =3D 0; i &lt; pos; i++) {=0A=
        if ((pos - i)%group =3D=3D=3D 0 &amp;&amp; i !=3D=3D 0) {=0A=
          formatedText +=3D groupSep;=0A=
        }=0A=
        formatedText +=3D whole.charAt(i);=0A=
      }=0A=
    }=0A=
=0A=
    for (i =3D pos; i &lt; whole.length; i++) {=0A=
      if ((whole.length - i)%lgroup =3D=3D=3D 0 &amp;&amp; i !=3D=3D 0) {=0A=
        formatedText +=3D groupSep;=0A=
      }=0A=
      formatedText +=3D whole.charAt(i);=0A=
    }=0A=
=0A=
    // format fraction part.=0A=
    while(fraction.length &lt; fractionSize) {=0A=
      fraction +=3D '0';=0A=
    }=0A=
=0A=
    if (fractionSize &amp;&amp; fractionSize !=3D=3D "0") formatedText =
+=3D decimalSep + fraction.substr(0, fractionSize);=0A=
  } else {=0A=
=0A=
    if (fractionSize &gt; 0 &amp;&amp; number &gt; -1 &amp;&amp; number =
&lt; 1) {=0A=
      formatedText =3D number.toFixed(fractionSize);=0A=
    }=0A=
  }=0A=
=0A=
  parts.push(isNegative ? pattern.negPre : pattern.posPre);=0A=
  parts.push(formatedText);=0A=
  parts.push(isNegative ? pattern.negSuf : pattern.posSuf);=0A=
  return parts.join('');=0A=
}=0A=
=0A=
function padNumber(num, digits, trim) {=0A=
  var neg =3D '';=0A=
  if (num &lt; 0) {=0A=
    neg =3D  '-';=0A=
    num =3D -num;=0A=
  }=0A=
  num =3D '' + num;=0A=
  while(num.length &lt; digits) num =3D '0' + num;=0A=
  if (trim)=0A=
    num =3D num.substr(num.length - digits);=0A=
  return neg + num;=0A=
}=0A=
=0A=
=0A=
function dateGetter(name, size, offset, trim) {=0A=
  offset =3D offset || 0;=0A=
  return function(date) {=0A=
    var value =3D date['get' + name]();=0A=
    if (offset &gt; 0 || value &gt; -offset)=0A=
      value +=3D offset;=0A=
    if (value =3D=3D=3D 0 &amp;&amp; offset =3D=3D -12 ) value =3D 12;=0A=
    return padNumber(value, size, trim);=0A=
  };=0A=
}=0A=
=0A=
function dateStrGetter(name, shortForm) {=0A=
  return function(date, formats) {=0A=
    var value =3D date['get' + name]();=0A=
    var get =3D uppercase(shortForm ? ('SHORT' + name) : name);=0A=
=0A=
    return formats[get][value];=0A=
  };=0A=
}=0A=
=0A=
function timeZoneGetter(date) {=0A=
  var zone =3D -1 * date.getTimezoneOffset();=0A=
  var paddedZone =3D (zone &gt;=3D 0) ? "+" : "";=0A=
=0A=
  paddedZone +=3D padNumber(Math[zone &gt; 0 ? 'floor' : 'ceil'](zone / =
60), 2) +=0A=
                padNumber(Math.abs(zone % 60), 2);=0A=
=0A=
  return paddedZone;=0A=
}=0A=
=0A=
function getFirstThursdayOfYear(year) {=0A=
    // 0 =3D index of January=0A=
    var dayOfWeekOnFirst =3D (new Date(year, 0, 1)).getDay();=0A=
    // 4 =3D index of Thursday (+1 to account for 1st =3D 5)=0A=
    // 11 =3D index of *next* Thursday (+1 account for 1st =3D 12)=0A=
    return new Date(year, 0, ((dayOfWeekOnFirst &lt;=3D 4) ? 5 : 12) - =
dayOfWeekOnFirst);=0A=
}=0A=
=0A=
function getThursdayThisWeek(datetime) {=0A=
    return new Date(datetime.getFullYear(), datetime.getMonth(),=0A=
      // 4 =3D index of Thursday=0A=
      datetime.getDate() + (4 - datetime.getDay()));=0A=
}=0A=
=0A=
function weekGetter(size) {=0A=
   return function(date) {=0A=
      var firstThurs =3D getFirstThursdayOfYear(date.getFullYear()),=0A=
         thisThurs =3D getThursdayThisWeek(date);=0A=
=0A=
      var diff =3D +thisThurs - +firstThurs,=0A=
         result =3D 1 + Math.round(diff / 6.048e8); // 6.048e8 ms per =
week=0A=
=0A=
      return padNumber(result, size);=0A=
   };=0A=
}=0A=
=0A=
function ampmGetter(date, formats) {=0A=
  return date.getHours() &lt; 12 ? formats.AMPMS[0] : formats.AMPMS[1];=0A=
}=0A=
=0A=
var DATE_FORMATS =3D {=0A=
  yyyy: dateGetter('FullYear', 4),=0A=
    yy: dateGetter('FullYear', 2, 0, true),=0A=
     y: dateGetter('FullYear', 1),=0A=
  MMMM: dateStrGetter('Month'),=0A=
   MMM: dateStrGetter('Month', true),=0A=
    MM: dateGetter('Month', 2, 1),=0A=
     M: dateGetter('Month', 1, 1),=0A=
    dd: dateGetter('Date', 2),=0A=
     d: dateGetter('Date', 1),=0A=
    HH: dateGetter('Hours', 2),=0A=
     H: dateGetter('Hours', 1),=0A=
    hh: dateGetter('Hours', 2, -12),=0A=
     h: dateGetter('Hours', 1, -12),=0A=
    mm: dateGetter('Minutes', 2),=0A=
     m: dateGetter('Minutes', 1),=0A=
    ss: dateGetter('Seconds', 2),=0A=
     s: dateGetter('Seconds', 1),=0A=
     // while ISO 8601 requires fractions to be prefixed with `.` or `,`=0A=
     // we can be just safely rely on using `sss` since we currently =
don't support single or two digit fractions=0A=
   sss: dateGetter('Milliseconds', 3),=0A=
  EEEE: dateStrGetter('Day'),=0A=
   EEE: dateStrGetter('Day', true),=0A=
     a: ampmGetter,=0A=
     Z: timeZoneGetter,=0A=
    ww: weekGetter(2),=0A=
     w: weekGetter(1)=0A=
};=0A=
=0A=
var DATE_FORMATS_SPLIT =3D =
/((?:[^yMdHhmsaZEw']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|=
w+))(.*)/,=0A=
    NUMBER_STRING =3D /^\-?\d+$/;=0A=
=0A=
/**=0A=
 * @ngdoc filter=0A=
 * @name date=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 *   Formats `date` to a string based on the requested `format`.=0A=
 *=0A=
 *   `format` string can be composed of the following elements:=0A=
 *=0A=
 *   * `'yyyy'`: 4 digit representation of year (e.g. AD 1 =3D&gt; 0001, =
AD 2010 =3D&gt; 2010)=0A=
 *   * `'yy'`: 2 digit representation of year, padded (00-99). (e.g. AD =
2001 =3D&gt; 01, AD 2010 =3D&gt; 10)=0A=
 *   * `'y'`: 1 digit representation of year, e.g. (AD 1 =3D&gt; 1, AD =
199 =3D&gt; 199)=0A=
 *   * `'MMMM'`: Month in year (January-December)=0A=
 *   * `'MMM'`: Month in year (Jan-Dec)=0A=
 *   * `'MM'`: Month in year, padded (01-12)=0A=
 *   * `'M'`: Month in year (1-12)=0A=
 *   * `'dd'`: Day in month, padded (01-31)=0A=
 *   * `'d'`: Day in month (1-31)=0A=
 *   * `'EEEE'`: Day in Week,(Sunday-Saturday)=0A=
 *   * `'EEE'`: Day in Week, (Sun-Sat)=0A=
 *   * `'HH'`: Hour in day, padded (00-23)=0A=
 *   * `'H'`: Hour in day (0-23)=0A=
 *   * `'hh'`: Hour in AM/PM, padded (01-12)=0A=
 *   * `'h'`: Hour in AM/PM, (1-12)=0A=
 *   * `'mm'`: Minute in hour, padded (00-59)=0A=
 *   * `'m'`: Minute in hour (0-59)=0A=
 *   * `'ss'`: Second in minute, padded (00-59)=0A=
 *   * `'s'`: Second in minute (0-59)=0A=
 *   * `'.sss' or ',sss'`: Millisecond in second, padded (000-999)=0A=
 *   * `'a'`: AM/PM marker=0A=
 *   * `'Z'`: 4 digit (+sign) representation of the timezone offset =
(-1200-+1200)=0A=
 *   * `'ww'`: ISO-8601 week of year (00-53)=0A=
 *   * `'w'`: ISO-8601 week of year (0-53)=0A=
 *=0A=
 *   `format` string can also be one of the following predefined=0A=
 *   {@link guide/i18n localizable formats}:=0A=
 *=0A=
 *   * `'medium'`: equivalent to `'MMM d, y h:mm:ss a'` for en_US locale=0A=
 *     (e.g. Sep 3, 2010 12:05:08 PM)=0A=
 *   * `'short'`: equivalent to `'M/d/yy h:mm a'` for en_US  locale =
(e.g. 9/3/10 12:05 PM)=0A=
 *   * `'fullDate'`: equivalent to `'EEEE, MMMM d, y'` for en_US  locale=0A=
 *     (e.g. Friday, September 3, 2010)=0A=
 *   * `'longDate'`: equivalent to `'MMMM d, y'` for en_US  locale (e.g. =
September 3, 2010)=0A=
 *   * `'mediumDate'`: equivalent to `'MMM d, y'` for en_US  locale =
(e.g. Sep 3, 2010)=0A=
 *   * `'shortDate'`: equivalent to `'M/d/yy'` for en_US locale (e.g. =
9/3/10)=0A=
 *   * `'mediumTime'`: equivalent to `'h:mm:ss a'` for en_US locale =
(e.g. 12:05:08 PM)=0A=
 *   * `'shortTime'`: equivalent to `'h:mm a'` for en_US locale (e.g. =
12:05 PM)=0A=
 *=0A=
 *   `format` string can contain literal values. These need to be =
escaped by surrounding with single quotes (e.g.=0A=
 *   `"h 'in the morning'"`). In order to output a single quote, escape =
it - i.e., two single quotes in a sequence=0A=
 *   (e.g. `"h 'o''clock'"`).=0A=
 *=0A=
 * @param {(Date|number|string)} date Date to format either as Date =
object, milliseconds (string or=0A=
 *    number) or various ISO 8601 datetime string formats (e.g. =
yyyy-MM-ddTHH:mm:ss.sssZ and its=0A=
 *    shorter versions like yyyy-MM-ddTHH:mmZ, yyyy-MM-dd or =
yyyyMMddTHHmmssZ). If no timezone is=0A=
 *    specified in the string input, the time is considered to be in the =
local timezone.=0A=
 * @param {string=3D} format Formatting rules (see Description). If not =
specified,=0A=
 *    `mediumDate` is used.=0A=
 * @param {string=3D} timezone Timezone to be used for formatting. Right =
now, only `'UTC'` is supported.=0A=
 *    If not specified, the timezone of the browser will be used.=0A=
 * @returns {string} Formatted string or the input if input is not =
recognized as date/millis.=0A=
 *=0A=
 * @example=0A=
   &lt;example&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
       &lt;span ng-non-bindable&gt;{{1288323623006 | =
date:'medium'}}&lt;/span&gt;:=0A=
           &lt;span&gt;{{1288323623006 | =
date:'medium'}}&lt;/span&gt;&lt;br&gt;=0A=
       &lt;span ng-non-bindable&gt;{{1288323623006 | date:'yyyy-MM-dd =
HH:mm:ss Z'}}&lt;/span&gt;:=0A=
          &lt;span&gt;{{1288323623006 | date:'yyyy-MM-dd HH:mm:ss =
Z'}}&lt;/span&gt;&lt;br&gt;=0A=
       &lt;span ng-non-bindable&gt;{{1288323623006 | date:'MM/dd/yyyy @ =
h:mma'}}&lt;/span&gt;:=0A=
          &lt;span&gt;{{'1288323623006' | date:'MM/dd/yyyy @ =
h:mma'}}&lt;/span&gt;&lt;br&gt;=0A=
       &lt;span ng-non-bindable&gt;{{1288323623006 | date:"MM/dd/yyyy =
'at' h:mma"}}&lt;/span&gt;:=0A=
          &lt;span&gt;{{'1288323623006' | date:"MM/dd/yyyy 'at' =
h:mma"}}&lt;/span&gt;&lt;br&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should format date', function() {=0A=
         expect(element(by.binding("1288323623006 | =
date:'medium'")).getText()).=0A=
            toMatch(/Oct 2\d, 2010 \d{1,2}:\d{2}:\d{2} (AM|PM)/);=0A=
         expect(element(by.binding("1288323623006 | date:'yyyy-MM-dd =
HH:mm:ss Z'")).getText()).=0A=
            toMatch(/2010\-10\-2\d \d{2}:\d{2}:\d{2} (\-|\+)?\d{4}/);=0A=
         expect(element(by.binding("'1288323623006' | date:'MM/dd/yyyy @ =
h:mma'")).getText()).=0A=
            toMatch(/10\/2\d\/2010 @ \d{1,2}:\d{2}(AM|PM)/);=0A=
         expect(element(by.binding("'1288323623006' | date:\"MM/dd/yyyy =
'at' h:mma\"")).getText()).=0A=
            toMatch(/10\/2\d\/2010 at \d{1,2}:\d{2}(AM|PM)/);=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
dateFilter.$inject =3D ['$locale'];=0A=
function dateFilter($locale) {=0A=
=0A=
=0A=
  var R_ISO8601_STR =3D =
/^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?=
(Z|([+-])(\d\d):?(\d\d))?)?$/;=0A=
                     // 1        2       3         4          5          =
6          7          8  9     10      11=0A=
  function jsonStringToDate(string) {=0A=
    var match;=0A=
    if (match =3D string.match(R_ISO8601_STR)) {=0A=
      var date =3D new Date(0),=0A=
          tzHour =3D 0,=0A=
          tzMin  =3D 0,=0A=
          dateSetter =3D match[8] ? date.setUTCFullYear : =
date.setFullYear,=0A=
          timeSetter =3D match[8] ? date.setUTCHours : date.setHours;=0A=
=0A=
      if (match[9]) {=0A=
        tzHour =3D int(match[9] + match[10]);=0A=
        tzMin =3D int(match[9] + match[11]);=0A=
      }=0A=
      dateSetter.call(date, int(match[1]), int(match[2]) - 1, =
int(match[3]));=0A=
      var h =3D int(match[4]||0) - tzHour;=0A=
      var m =3D int(match[5]||0) - tzMin;=0A=
      var s =3D int(match[6]||0);=0A=
      var ms =3D Math.round(parseFloat('0.' + (match[7]||0)) * 1000);=0A=
      timeSetter.call(date, h, m, s, ms);=0A=
      return date;=0A=
    }=0A=
    return string;=0A=
  }=0A=
=0A=
=0A=
  return function(date, format, timezone) {=0A=
    var text =3D '',=0A=
        parts =3D [],=0A=
        fn, match;=0A=
=0A=
    format =3D format || 'mediumDate';=0A=
    format =3D $locale.DATETIME_FORMATS[format] || format;=0A=
    if (isString(date)) {=0A=
      date =3D NUMBER_STRING.test(date) ? int(date) : =
jsonStringToDate(date);=0A=
    }=0A=
=0A=
    if (isNumber(date)) {=0A=
      date =3D new Date(date);=0A=
    }=0A=
=0A=
    if (!isDate(date)) {=0A=
      return date;=0A=
    }=0A=
=0A=
    while(format) {=0A=
      match =3D DATE_FORMATS_SPLIT.exec(format);=0A=
      if (match) {=0A=
        parts =3D concat(parts, match, 1);=0A=
        format =3D parts.pop();=0A=
      } else {=0A=
        parts.push(format);=0A=
        format =3D null;=0A=
      }=0A=
    }=0A=
=0A=
    if (timezone &amp;&amp; timezone =3D=3D=3D 'UTC') {=0A=
      date =3D new Date(date.getTime());=0A=
      date.setMinutes(date.getMinutes() + date.getTimezoneOffset());=0A=
    }=0A=
    forEach(parts, function(value){=0A=
      fn =3D DATE_FORMATS[value];=0A=
      text +=3D fn ? fn(date, $locale.DATETIME_FORMATS)=0A=
                 : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");=0A=
    });=0A=
=0A=
    return text;=0A=
  };=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc filter=0A=
 * @name json=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 *   Allows you to convert a JavaScript object into JSON string.=0A=
 *=0A=
 *   This filter is mostly useful for debugging. When using the double =
curly {{value}} notation=0A=
 *   the binding is automatically converted to JSON.=0A=
 *=0A=
 * @param {*} object Any JavaScript object (including arrays and =
primitive types) to filter.=0A=
 * @returns {string} JSON string.=0A=
 *=0A=
 *=0A=
 * @example=0A=
   &lt;example&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
       &lt;pre&gt;{{ {'name':'value'} | json }}&lt;/pre&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should jsonify filtered objects', function() {=0A=
         =
expect(element(by.binding("{'name':'value'}")).getText()).toMatch(/\{\n  =
"name": ?"value"\n}/);=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 *=0A=
 */=0A=
function jsonFilter() {=0A=
  return function(object) {=0A=
    return toJson(object, true);=0A=
  };=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc filter=0A=
 * @name lowercase=0A=
 * @kind function=0A=
 * @description=0A=
 * Converts string to lowercase.=0A=
 * @see angular.lowercase=0A=
 */=0A=
var lowercaseFilter =3D valueFn(lowercase);=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc filter=0A=
 * @name uppercase=0A=
 * @kind function=0A=
 * @description=0A=
 * Converts string to uppercase.=0A=
 * @see angular.uppercase=0A=
 */=0A=
var uppercaseFilter =3D valueFn(uppercase);=0A=
=0A=
/**=0A=
 * @ngdoc filter=0A=
 * @name limitTo=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Creates a new array or string containing only a specified number of =
elements. The elements=0A=
 * are taken from either the beginning or the end of the source array, =
string or number, as specified by=0A=
 * the value and sign (positive or negative) of `limit`. If a number is =
used as input, it is=0A=
 * converted to a string.=0A=
 *=0A=
 * @param {Array|string|number} input Source array, string or number to =
be limited.=0A=
 * @param {string|number} limit The length of the returned array or =
string. If the `limit` number=0A=
 *     is positive, `limit` number of items from the beginning of the =
source array/string are copied.=0A=
 *     If the number is negative, `limit` number  of items from the end =
of the source array/string=0A=
 *     are copied. The `limit` will be trimmed if it exceeds =
`array.length`=0A=
 * @returns {Array|string} A new sub-array or substring of length =
`limit` or less if input array=0A=
 *     had less than `limit` elements.=0A=
 *=0A=
 * @example=0A=
   &lt;example module=3D"limitToExample"&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
       &lt;script&gt;=0A=
         angular.module('limitToExample', [])=0A=
           .controller('ExampleController', ['$scope', function($scope) {=0A=
             $scope.numbers =3D [1,2,3,4,5,6,7,8,9];=0A=
             $scope.letters =3D "abcdefghi";=0A=
             $scope.longNumber =3D 2345432342;=0A=
             $scope.numLimit =3D 3;=0A=
             $scope.letterLimit =3D 3;=0A=
             $scope.longNumberLimit =3D 3;=0A=
           }]);=0A=
       &lt;/script&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
         Limit {{numbers}} to: &lt;input type=3D"number" step=3D"1" =
ng-model=3D"numLimit"&gt;=0A=
         &lt;p&gt;Output numbers: {{ numbers | limitTo:numLimit =
}}&lt;/p&gt;=0A=
         Limit {{letters}} to: &lt;input type=3D"number" step=3D"1" =
ng-model=3D"letterLimit"&gt;=0A=
         &lt;p&gt;Output letters: {{ letters | limitTo:letterLimit =
}}&lt;/p&gt;=0A=
         Limit {{longNumber}} to: &lt;input type=3D"number" step=3D"1" =
ng-model=3D"longNumberLimit"&gt;=0A=
         &lt;p&gt;Output long number: {{ longNumber | =
limitTo:longNumberLimit }}&lt;/p&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       var numLimitInput =3D element(by.model('numLimit'));=0A=
       var letterLimitInput =3D element(by.model('letterLimit'));=0A=
       var longNumberLimitInput =3D element(by.model('longNumberLimit'));=0A=
       var limitedNumbers =3D element(by.binding('numbers | =
limitTo:numLimit'));=0A=
       var limitedLetters =3D element(by.binding('letters | =
limitTo:letterLimit'));=0A=
       var limitedLongNumber =3D element(by.binding('longNumber | =
limitTo:longNumberLimit'));=0A=
=0A=
       it('should limit the number array to first three items', =
function() {=0A=
         expect(numLimitInput.getAttribute('value')).toBe('3');=0A=
         expect(letterLimitInput.getAttribute('value')).toBe('3');=0A=
         expect(longNumberLimitInput.getAttribute('value')).toBe('3');=0A=
         expect(limitedNumbers.getText()).toEqual('Output numbers: =
[1,2,3]');=0A=
         expect(limitedLetters.getText()).toEqual('Output letters: abc');=0A=
         expect(limitedLongNumber.getText()).toEqual('Output long =
number: 234');=0A=
       });=0A=
=0A=
       // There is a bug in safari and protractor that doesn't like the =
minus key=0A=
       // it('should update the output when -3 is entered', function() {=0A=
       //   numLimitInput.clear();=0A=
       //   numLimitInput.sendKeys('-3');=0A=
       //   letterLimitInput.clear();=0A=
       //   letterLimitInput.sendKeys('-3');=0A=
       //   longNumberLimitInput.clear();=0A=
       //   longNumberLimitInput.sendKeys('-3');=0A=
       //   expect(limitedNumbers.getText()).toEqual('Output numbers: =
[7,8,9]');=0A=
       //   expect(limitedLetters.getText()).toEqual('Output letters: =
ghi');=0A=
       //   expect(limitedLongNumber.getText()).toEqual('Output long =
number: 342');=0A=
       // });=0A=
=0A=
       it('should not exceed the maximum size of input array', =
function() {=0A=
         numLimitInput.clear();=0A=
         numLimitInput.sendKeys('100');=0A=
         letterLimitInput.clear();=0A=
         letterLimitInput.sendKeys('100');=0A=
         longNumberLimitInput.clear();=0A=
         longNumberLimitInput.sendKeys('100');=0A=
         expect(limitedNumbers.getText()).toEqual('Output numbers: =
[1,2,3,4,5,6,7,8,9]');=0A=
         expect(limitedLetters.getText()).toEqual('Output letters: =
abcdefghi');=0A=
         expect(limitedLongNumber.getText()).toEqual('Output long =
number: 2345432342');=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
*/=0A=
function limitToFilter(){=0A=
  return function(input, limit) {=0A=
    if (isNumber(input)) input =3D input.toString();=0A=
    if (!isArray(input) &amp;&amp; !isString(input)) return input;=0A=
=0A=
    if (Math.abs(Number(limit)) =3D=3D=3D Infinity) {=0A=
      limit =3D Number(limit);=0A=
    } else {=0A=
      limit =3D int(limit);=0A=
    }=0A=
=0A=
    if (isString(input)) {=0A=
      //NaN check on limit=0A=
      if (limit) {=0A=
        return limit &gt;=3D 0 ? input.slice(0, limit) : =
input.slice(limit, input.length);=0A=
      } else {=0A=
        return "";=0A=
      }=0A=
    }=0A=
=0A=
    var out =3D [],=0A=
      i, n;=0A=
=0A=
    // if abs(limit) exceeds maximum length, trim it=0A=
    if (limit &gt; input.length)=0A=
      limit =3D input.length;=0A=
    else if (limit &lt; -input.length)=0A=
      limit =3D -input.length;=0A=
=0A=
    if (limit &gt; 0) {=0A=
      i =3D 0;=0A=
      n =3D limit;=0A=
    } else {=0A=
      i =3D input.length + limit;=0A=
      n =3D input.length;=0A=
    }=0A=
=0A=
    for (; i&lt;n; i++) {=0A=
      out.push(input[i]);=0A=
    }=0A=
=0A=
    return out;=0A=
  };=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc filter=0A=
 * @name orderBy=0A=
 * @kind function=0A=
 *=0A=
 * @description=0A=
 * Orders a specified `array` by the `expression` predicate. It is =
ordered alphabetically=0A=
 * for strings and numerically for numbers. Note: if you notice numbers =
are not being sorted=0A=
 * correctly, make sure they are actually being saved as numbers and not =
strings.=0A=
 *=0A=
 * @param {Array} array The array to sort.=0A=
 * @param {function(*)|string|Array.&lt;(function(*)|string)&gt;=3D} =
expression A predicate to be=0A=
 *    used by the comparator to determine the order of elements.=0A=
 *=0A=
 *    Can be one of:=0A=
 *=0A=
 *    - `function`: Getter function. The result of this function will be =
sorted using the=0A=
 *      `&lt;`, `=3D`, `&gt;` operator.=0A=
 *    - `string`: An Angular expression. The result of this expression =
is used to compare elements=0A=
 *      (for example `name` to sort by a property called `name` or =
`name.substr(0, 3)` to sort by=0A=
 *      3 first characters of a property called `name`). The result of a =
constant expression=0A=
 *      is interpreted as a property name to be used in comparisons (for =
example `"special name"`=0A=
 *      to sort object by the value of their `special name` property). =
An expression can be=0A=
 *      optionally prefixed with `+` or `-` to control ascending or =
descending sort order=0A=
 *      (for example, `+name` or `-name`). If no property is provided, =
(e.g. `'+'`) then the array=0A=
 *      element itself is used to compare where sorting.=0A=
 *    - `Array`: An array of function or string predicates. The first =
predicate in the array=0A=
 *      is used for sorting, but when two items are equivalent, the next =
predicate is used.=0A=
 *=0A=
 *    If the predicate is missing or empty then it defaults to `'+'`.=0A=
 *=0A=
 * @param {boolean=3D} reverse Reverse the order of the array.=0A=
 * @returns {Array} Sorted copy of the source array.=0A=
 *=0A=
 * @example=0A=
   &lt;example module=3D"orderByExample"&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
       &lt;script&gt;=0A=
         angular.module('orderByExample', [])=0A=
           .controller('ExampleController', ['$scope', function($scope) {=0A=
             $scope.friends =3D=0A=
                 [{name:'John', phone:'555-1212', age:10},=0A=
                  {name:'Mary', phone:'555-9876', age:19},=0A=
                  {name:'Mike', phone:'555-4321', age:21},=0A=
                  {name:'Adam', phone:'555-5678', age:35},=0A=
                  {name:'Julie', phone:'555-8765', age:29}];=0A=
             $scope.predicate =3D '-age';=0A=
           }]);=0A=
       &lt;/script&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
         &lt;pre&gt;Sorting predicate =3D {{predicate}}; reverse =3D =
{{reverse}}&lt;/pre&gt;=0A=
         &lt;hr/&gt;=0A=
         [ &lt;a href=3D"" =
ng-click=3D"predicate=3D''"&gt;unsorted&lt;/a&gt; ]=0A=
         &lt;table class=3D"friend"&gt;=0A=
           &lt;tr&gt;=0A=
             &lt;th&gt;&lt;a href=3D"" ng-click=3D"predicate =3D 'name'; =
reverse=3Dfalse"&gt;Name&lt;/a&gt;=0A=
                 (&lt;a href=3D"" ng-click=3D"predicate =3D '-name'; =
reverse=3Dfalse"&gt;^&lt;/a&gt;)&lt;/th&gt;=0A=
             &lt;th&gt;&lt;a href=3D"" ng-click=3D"predicate =3D =
'phone'; reverse=3D!reverse"&gt;Phone Number&lt;/a&gt;&lt;/th&gt;=0A=
             &lt;th&gt;&lt;a href=3D"" ng-click=3D"predicate =3D 'age'; =
reverse=3D!reverse"&gt;Age&lt;/a&gt;&lt;/th&gt;=0A=
           &lt;/tr&gt;=0A=
           &lt;tr ng-repeat=3D"friend in friends | =
orderBy:predicate:reverse"&gt;=0A=
             &lt;td&gt;{{friend.name}}&lt;/td&gt;=0A=
             &lt;td&gt;{{friend.phone}}&lt;/td&gt;=0A=
             &lt;td&gt;{{friend.age}}&lt;/td&gt;=0A=
           &lt;/tr&gt;=0A=
         &lt;/table&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 *=0A=
 * It's also possible to call the orderBy filter manually, by injecting =
`$filter`, retrieving the=0A=
 * filter routine with `$filter('orderBy')`, and calling the returned =
filter routine with the=0A=
 * desired parameters.=0A=
 *=0A=
 * Example:=0A=
 *=0A=
 * @example=0A=
  &lt;example module=3D"orderByExample"&gt;=0A=
    &lt;file name=3D"todoList.html"&gt;=0A=
      &lt;div ng-controller=3D"ExampleController"&gt;=0A=
        &lt;table class=3D"friend"&gt;=0A=
          &lt;tr&gt;=0A=
            &lt;th&gt;&lt;a href=3D"" =
ng-click=3D"reverse=3Dfalse;order('name', false)"&gt;Name&lt;/a&gt;=0A=
              (&lt;a href=3D"" =
ng-click=3D"order('-name',false)"&gt;^&lt;/a&gt;)&lt;/th&gt;=0A=
            &lt;th&gt;&lt;a href=3D"" =
ng-click=3D"reverse=3D!reverse;order('phone', reverse)"&gt;Phone =
Number&lt;/a&gt;&lt;/th&gt;=0A=
            &lt;th&gt;&lt;a href=3D"" =
ng-click=3D"reverse=3D!reverse;order('age',reverse)"&gt;Age&lt;/a&gt;&lt;=
/th&gt;=0A=
          &lt;/tr&gt;=0A=
          &lt;tr ng-repeat=3D"friend in friends"&gt;=0A=
            &lt;td&gt;{{friend.name}}&lt;/td&gt;=0A=
            &lt;td&gt;{{friend.phone}}&lt;/td&gt;=0A=
            &lt;td&gt;{{friend.age}}&lt;/td&gt;=0A=
          &lt;/tr&gt;=0A=
        &lt;/table&gt;=0A=
      &lt;/div&gt;=0A=
    &lt;/file&gt;=0A=
=0A=
    &lt;file name=3D"script.js"&gt;=0A=
      angular.module('orderByExample', [])=0A=
        .controller('ExampleController', ['$scope', '$filter', =
function($scope, $filter) {=0A=
          var orderBy =3D $filter('orderBy');=0A=
          $scope.friends =3D [=0A=
            { name: 'John',    phone: '555-1212',    age: 10 },=0A=
            { name: 'Mary',    phone: '555-9876',    age: 19 },=0A=
            { name: 'Mike',    phone: '555-4321',    age: 21 },=0A=
            { name: 'Adam',    phone: '555-5678',    age: 35 },=0A=
            { name: 'Julie',   phone: '555-8765',    age: 29 }=0A=
          ];=0A=
          $scope.order =3D function(predicate, reverse) {=0A=
            $scope.friends =3D orderBy($scope.friends, predicate, =
reverse);=0A=
          };=0A=
          $scope.order('-age',false);=0A=
        }]);=0A=
    &lt;/file&gt;=0A=
&lt;/example&gt;=0A=
 */=0A=
orderByFilter.$inject =3D ['$parse'];=0A=
function orderByFilter($parse){=0A=
  return function(array, sortPredicate, reverseOrder) {=0A=
    if (!(isArrayLike(array))) return array;=0A=
    sortPredicate =3D isArray(sortPredicate) ? sortPredicate: =
[sortPredicate];=0A=
    if (sortPredicate.length =3D=3D=3D 0) { sortPredicate =3D ['+']; }=0A=
    sortPredicate =3D sortPredicate.map(function(predicate){=0A=
      var descending =3D false, get =3D predicate || identity;=0A=
      if (isString(predicate)) {=0A=
        if ((predicate.charAt(0) =3D=3D '+' || predicate.charAt(0) =
=3D=3D '-')) {=0A=
          descending =3D predicate.charAt(0) =3D=3D '-';=0A=
          predicate =3D predicate.substring(1);=0A=
        }=0A=
        if ( predicate =3D=3D=3D '' ) {=0A=
          // Effectively no predicate was passed so we compare identity=0A=
          return reverseComparator(function(a,b) {=0A=
            return compare(a, b);=0A=
          }, descending);=0A=
        }=0A=
        get =3D $parse(predicate);=0A=
        if (get.constant) {=0A=
          var key =3D get();=0A=
          return reverseComparator(function(a,b) {=0A=
            return compare(a[key], b[key]);=0A=
          }, descending);=0A=
        }=0A=
      }=0A=
      return reverseComparator(function(a,b){=0A=
        return compare(get(a),get(b));=0A=
      }, descending);=0A=
    });=0A=
    var arrayCopy =3D [];=0A=
    for ( var i =3D 0; i &lt; array.length; i++) { =
arrayCopy.push(array[i]); }=0A=
    return arrayCopy.sort(reverseComparator(comparator, reverseOrder));=0A=
=0A=
    function comparator(o1, o2){=0A=
      for ( var i =3D 0; i &lt; sortPredicate.length; i++) {=0A=
        var comp =3D sortPredicate[i](o1, o2);=0A=
        if (comp !=3D=3D 0) return comp;=0A=
      }=0A=
      return 0;=0A=
    }=0A=
    function reverseComparator(comp, descending) {=0A=
      return descending=0A=
          ? function(a,b){return comp(b,a);}=0A=
          : comp;=0A=
    }=0A=
    function compare(v1, v2){=0A=
      var t1 =3D typeof v1;=0A=
      var t2 =3D typeof v2;=0A=
      if (t1 =3D=3D t2) {=0A=
        if (isDate(v1) &amp;&amp; isDate(v2)) {=0A=
          v1 =3D v1.valueOf();=0A=
          v2 =3D v2.valueOf();=0A=
        }=0A=
        if (t1 =3D=3D "string") {=0A=
           v1 =3D v1.toLowerCase();=0A=
           v2 =3D v2.toLowerCase();=0A=
        }=0A=
        if (v1 =3D=3D=3D v2) return 0;=0A=
        return v1 &lt; v2 ? -1 : 1;=0A=
      } else {=0A=
        return t1 &lt; t2 ? -1 : 1;=0A=
      }=0A=
    }=0A=
  };=0A=
}=0A=
=0A=
function ngDirective(directive) {=0A=
  if (isFunction(directive)) {=0A=
    directive =3D {=0A=
      link: directive=0A=
    };=0A=
  }=0A=
  directive.restrict =3D directive.restrict || 'AC';=0A=
  return valueFn(directive);=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name a=0A=
 * @restrict E=0A=
 *=0A=
 * @description=0A=
 * Modifies the default behavior of the html A tag so that the default =
action is prevented when=0A=
 * the href attribute is empty.=0A=
 *=0A=
 * This change permits the easy creation of action links with the =
`ngClick` directive=0A=
 * without changing the location or causing page reloads, e.g.:=0A=
 * `&lt;a href=3D"" ng-click=3D"list.addItem()"&gt;Add Item&lt;/a&gt;`=0A=
 */=0A=
var htmlAnchorDirective =3D valueFn({=0A=
  restrict: 'E',=0A=
  compile: function(element, attr) {=0A=
    if (!attr.href &amp;&amp; !attr.xlinkHref &amp;&amp; !attr.name) {=0A=
      return function(scope, element) {=0A=
        // SVGAElement does not use the href attribute, but rather the =
'xlinkHref' attribute.=0A=
        var href =3D toString.call(element.prop('href')) =3D=3D=3D =
'[object SVGAnimatedString]' ?=0A=
                   'xlink:href' : 'href';=0A=
        element.on('click', function(event){=0A=
          // if we have no href url, then don't navigate anywhere.=0A=
          if (!element.attr(href)) {=0A=
            event.preventDefault();=0A=
          }=0A=
        });=0A=
      };=0A=
    }=0A=
  }=0A=
});=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngHref=0A=
 * @restrict A=0A=
 * @priority 99=0A=
 *=0A=
 * @description=0A=
 * Using Angular markup like `{{hash}}` in an href attribute will=0A=
 * make the link go to the wrong URL if the user clicks it before=0A=
 * Angular has a chance to replace the `{{hash}}` markup with its=0A=
 * value. Until Angular replaces the markup the link will be broken=0A=
 * and will most likely return a 404 error.=0A=
 *=0A=
 * The `ngHref` directive solves this problem.=0A=
 *=0A=
 * The wrong way to write it:=0A=
 * ```html=0A=
 * &lt;a =
href=3D"http://www.gravatar.com/avatar/{{hash}}"&gt;link1&lt;/a&gt;=0A=
 * ```=0A=
 *=0A=
 * The correct way to write it:=0A=
 * ```html=0A=
 * &lt;a =
ng-href=3D"http://www.gravatar.com/avatar/{{hash}}"&gt;link1&lt;/a&gt;=0A=
 * ```=0A=
 *=0A=
 * @element A=0A=
 * @param {template} ngHref any string which can contain `{{}}` markup.=0A=
 *=0A=
 * @example=0A=
 * This example shows various combinations of `href`, `ng-href` and =
`ng-click` attributes=0A=
 * in links and their different behaviors:=0A=
    &lt;example&gt;=0A=
      &lt;file name=3D"todoList.html"&gt;=0A=
        &lt;input ng-model=3D"value" /&gt;&lt;br /&gt;=0A=
        &lt;a id=3D"link-1" href ng-click=3D"value =3D 1"&gt;link =
1&lt;/a&gt; (link, don't reload)&lt;br /&gt;=0A=
        &lt;a id=3D"link-2" href=3D"" ng-click=3D"value =3D 2"&gt;link =
2&lt;/a&gt; (link, don't reload)&lt;br /&gt;=0A=
        &lt;a id=3D"link-3" ng-href=3D"/{{'123'}}"&gt;link 3&lt;/a&gt; =
(link, reload!)&lt;br /&gt;=0A=
        &lt;a id=3D"link-4" href=3D"" name=3D"xx" ng-click=3D"value =3D =
4"&gt;anchor&lt;/a&gt; (link, don't reload)&lt;br /&gt;=0A=
        &lt;a id=3D"link-5" name=3D"xxx" ng-click=3D"value =3D =
5"&gt;anchor&lt;/a&gt; (no link)&lt;br /&gt;=0A=
        &lt;a id=3D"link-6" ng-href=3D"{{value}}"&gt;link&lt;/a&gt; =
(link, change location)=0A=
      &lt;/file&gt;=0A=
      &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
        it('should execute ng-click but not reload when href without =
value', function() {=0A=
          element(by.id('link-1')).click();=0A=
          =
expect(element(by.model('value')).getAttribute('value')).toEqual('1');=0A=
          expect(element(by.id('link-1')).getAttribute('href')).toBe('');=0A=
        });=0A=
=0A=
        it('should execute ng-click but not reload when href empty =
string', function() {=0A=
          element(by.id('link-2')).click();=0A=
          =
expect(element(by.model('value')).getAttribute('value')).toEqual('2');=0A=
          expect(element(by.id('link-2')).getAttribute('href')).toBe('');=0A=
        });=0A=
=0A=
        it('should execute ng-click and change url when ng-href =
specified', function() {=0A=
          =
expect(element(by.id('link-3')).getAttribute('href')).toMatch(/\/123$/);=0A=
=0A=
          element(by.id('link-3')).click();=0A=
=0A=
          // At this point, we navigate away from an Angular page, so we =
need=0A=
          // to use browser.driver to get the base webdriver.=0A=
=0A=
          browser.wait(function() {=0A=
            return browser.driver.getCurrentUrl().then(function(url) {=0A=
              return url.match(/\/123$/);=0A=
            });=0A=
          }, 5000, 'page should navigate to /123');=0A=
        });=0A=
=0A=
        xit('should execute ng-click but not reload when href empty =
string and name specified', function() {=0A=
          element(by.id('link-4')).click();=0A=
          =
expect(element(by.model('value')).getAttribute('value')).toEqual('4');=0A=
          expect(element(by.id('link-4')).getAttribute('href')).toBe('');=0A=
        });=0A=
=0A=
        it('should execute ng-click but not reload when no href but name =
specified', function() {=0A=
          element(by.id('link-5')).click();=0A=
          =
expect(element(by.model('value')).getAttribute('value')).toEqual('5');=0A=
          =
expect(element(by.id('link-5')).getAttribute('href')).toBe(null);=0A=
        });=0A=
=0A=
        it('should only change url when only ng-href', function() {=0A=
          element(by.model('value')).clear();=0A=
          element(by.model('value')).sendKeys('6');=0A=
          =
expect(element(by.id('link-6')).getAttribute('href')).toMatch(/\/6$/);=0A=
=0A=
          element(by.id('link-6')).click();=0A=
=0A=
          // At this point, we navigate away from an Angular page, so we =
need=0A=
          // to use browser.driver to get the base webdriver.=0A=
          browser.wait(function() {=0A=
            return browser.driver.getCurrentUrl().then(function(url) {=0A=
              return url.match(/\/6$/);=0A=
            });=0A=
          }, 5000, 'page should navigate to /6');=0A=
        });=0A=
      &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngSrc=0A=
 * @restrict A=0A=
 * @priority 99=0A=
 *=0A=
 * @description=0A=
 * Using Angular markup like `{{hash}}` in a `src` attribute doesn't=0A=
 * work right: The browser will fetch from the URL with the literal=0A=
 * text `{{hash}}` until Angular replaces the expression inside=0A=
 * `{{hash}}`. The `ngSrc` directive solves this problem.=0A=
 *=0A=
 * The buggy way to write it:=0A=
 * ```html=0A=
 * &lt;img src=3D"http://www.gravatar.com/avatar/{{hash}}"/&gt;=0A=
 * ```=0A=
 *=0A=
 * The correct way to write it:=0A=
 * ```html=0A=
 * &lt;img ng-src=3D"http://www.gravatar.com/avatar/{{hash}}"/&gt;=0A=
 * ```=0A=
 *=0A=
 * @element IMG=0A=
 * @param {template} ngSrc any string which can contain `{{}}` markup.=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngSrcset=0A=
 * @restrict A=0A=
 * @priority 99=0A=
 *=0A=
 * @description=0A=
 * Using Angular markup like `{{hash}}` in a `srcset` attribute doesn't=0A=
 * work right: The browser will fetch from the URL with the literal=0A=
 * text `{{hash}}` until Angular replaces the expression inside=0A=
 * `{{hash}}`. The `ngSrcset` directive solves this problem.=0A=
 *=0A=
 * The buggy way to write it:=0A=
 * ```html=0A=
 * &lt;img srcset=3D"http://www.gravatar.com/avatar/{{hash}} 2x"/&gt;=0A=
 * ```=0A=
 *=0A=
 * The correct way to write it:=0A=
 * ```html=0A=
 * &lt;img ng-srcset=3D"http://www.gravatar.com/avatar/{{hash}} 2x"/&gt;=0A=
 * ```=0A=
 *=0A=
 * @element IMG=0A=
 * @param {template} ngSrcset any string which can contain `{{}}` markup.=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngDisabled=0A=
 * @restrict A=0A=
 * @priority 100=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * We shouldn't do this, because it will make the button enabled on =
Chrome/Firefox but not on IE8 and older IEs:=0A=
 * ```html=0A=
 * &lt;div ng-init=3D"scope =3D { isDisabled: false }"&gt;=0A=
 *  &lt;button =
disabled=3D"{{scope.isDisabled}}"&gt;Disabled&lt;/button&gt;=0A=
 * &lt;/div&gt;=0A=
 * ```=0A=
 *=0A=
 * The HTML specification does not require browsers to preserve the =
values of boolean attributes=0A=
 * such as disabled. (Their presence means true and their absence means =
false.)=0A=
 * If we put an Angular interpolation expression into such an attribute =
then the=0A=
 * binding information would be lost when the browser removes the =
attribute.=0A=
 * The `ngDisabled` directive solves this problem for the `disabled` =
attribute.=0A=
 * This complementary directive is not removed by the browser and so =
provides=0A=
 * a permanent reliable place to store the binding information.=0A=
 *=0A=
 * @example=0A=
    &lt;example&gt;=0A=
      &lt;file name=3D"todoList.html"&gt;=0A=
        Click me to toggle: &lt;input type=3D"checkbox" =
ng-model=3D"checked"&gt;&lt;br/&gt;=0A=
        &lt;button ng-model=3D"button" =
ng-disabled=3D"checked"&gt;Button&lt;/button&gt;=0A=
      &lt;/file&gt;=0A=
      &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
        it('should toggle button', function() {=0A=
          =
expect(element(by.css('button')).getAttribute('disabled')).toBeFalsy();=0A=
          element(by.model('checked')).click();=0A=
          =
expect(element(by.css('button')).getAttribute('disabled')).toBeTruthy();=0A=
        });=0A=
      &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
 *=0A=
 * @element INPUT=0A=
 * @param {expression} ngDisabled If the {@link guide/expression =
expression} is truthy,=0A=
 *     then special attribute "disabled" will be set on the element=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngChecked=0A=
 * @restrict A=0A=
 * @priority 100=0A=
 *=0A=
 * @description=0A=
 * The HTML specification does not require browsers to preserve the =
values of boolean attributes=0A=
 * such as checked. (Their presence means true and their absence means =
false.)=0A=
 * If we put an Angular interpolation expression into such an attribute =
then the=0A=
 * binding information would be lost when the browser removes the =
attribute.=0A=
 * The `ngChecked` directive solves this problem for the `checked` =
attribute.=0A=
 * This complementary directive is not removed by the browser and so =
provides=0A=
 * a permanent reliable place to store the binding information.=0A=
 * @example=0A=
    &lt;example&gt;=0A=
      &lt;file name=3D"todoList.html"&gt;=0A=
        Check me to check both: &lt;input type=3D"checkbox" =
ng-model=3D"master"&gt;&lt;br/&gt;=0A=
        &lt;input id=3D"checkSlave" type=3D"checkbox" =
ng-checked=3D"master"&gt;=0A=
      &lt;/file&gt;=0A=
      &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
        it('should check both checkBoxes', function() {=0A=
          =
expect(element(by.id('checkSlave')).getAttribute('checked')).toBeFalsy();=0A=
          element(by.model('master')).click();=0A=
          =
expect(element(by.id('checkSlave')).getAttribute('checked')).toBeTruthy()=
;=0A=
        });=0A=
      &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
 *=0A=
 * @element INPUT=0A=
 * @param {expression} ngChecked If the {@link guide/expression =
expression} is truthy,=0A=
 *     then special attribute "checked" will be set on the element=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngReadonly=0A=
 * @restrict A=0A=
 * @priority 100=0A=
 *=0A=
 * @description=0A=
 * The HTML specification does not require browsers to preserve the =
values of boolean attributes=0A=
 * such as readonly. (Their presence means true and their absence means =
false.)=0A=
 * If we put an Angular interpolation expression into such an attribute =
then the=0A=
 * binding information would be lost when the browser removes the =
attribute.=0A=
 * The `ngReadonly` directive solves this problem for the `readonly` =
attribute.=0A=
 * This complementary directive is not removed by the browser and so =
provides=0A=
 * a permanent reliable place to store the binding information.=0A=
 * @example=0A=
    &lt;example&gt;=0A=
      &lt;file name=3D"todoList.html"&gt;=0A=
        Check me to make text readonly: &lt;input type=3D"checkbox" =
ng-model=3D"checked"&gt;&lt;br/&gt;=0A=
        &lt;input type=3D"text" ng-readonly=3D"checked" value=3D"I'm =
Angular"/&gt;=0A=
      &lt;/file&gt;=0A=
      &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
        it('should toggle readonly attr', function() {=0A=
          =
expect(element(by.css('[type=3D"text"]')).getAttribute('readonly')).toBeF=
alsy();=0A=
          element(by.model('checked')).click();=0A=
          =
expect(element(by.css('[type=3D"text"]')).getAttribute('readonly')).toBeT=
ruthy();=0A=
        });=0A=
      &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
 *=0A=
 * @element INPUT=0A=
 * @param {expression} ngReadonly If the {@link guide/expression =
expression} is truthy,=0A=
 *     then special attribute "readonly" will be set on the element=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngSelected=0A=
 * @restrict A=0A=
 * @priority 100=0A=
 *=0A=
 * @description=0A=
 * The HTML specification does not require browsers to preserve the =
values of boolean attributes=0A=
 * such as selected. (Their presence means true and their absence means =
false.)=0A=
 * If we put an Angular interpolation expression into such an attribute =
then the=0A=
 * binding information would be lost when the browser removes the =
attribute.=0A=
 * The `ngSelected` directive solves this problem for the `selected` =
attribute.=0A=
 * This complementary directive is not removed by the browser and so =
provides=0A=
 * a permanent reliable place to store the binding information.=0A=
 *=0A=
 * @example=0A=
    &lt;example&gt;=0A=
      &lt;file name=3D"todoList.html"&gt;=0A=
        Check me to select: &lt;input type=3D"checkbox" =
ng-model=3D"selected"&gt;&lt;br/&gt;=0A=
        &lt;select&gt;=0A=
          &lt;option&gt;Hello!&lt;/option&gt;=0A=
          &lt;option id=3D"greet" =
ng-selected=3D"selected"&gt;Greetings!&lt;/option&gt;=0A=
        &lt;/select&gt;=0A=
      &lt;/file&gt;=0A=
      &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
        it('should select Greetings!', function() {=0A=
          =
expect(element(by.id('greet')).getAttribute('selected')).toBeFalsy();=0A=
          element(by.model('selected')).click();=0A=
          =
expect(element(by.id('greet')).getAttribute('selected')).toBeTruthy();=0A=
        });=0A=
      &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
 *=0A=
 * @element OPTION=0A=
 * @param {expression} ngSelected If the {@link guide/expression =
expression} is truthy,=0A=
 *     then special attribute "selected" will be set on the element=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngOpen=0A=
 * @restrict A=0A=
 * @priority 100=0A=
 *=0A=
 * @description=0A=
 * The HTML specification does not require browsers to preserve the =
values of boolean attributes=0A=
 * such as open. (Their presence means true and their absence means =
false.)=0A=
 * If we put an Angular interpolation expression into such an attribute =
then the=0A=
 * binding information would be lost when the browser removes the =
attribute.=0A=
 * The `ngOpen` directive solves this problem for the `open` attribute.=0A=
 * This complementary directive is not removed by the browser and so =
provides=0A=
 * a permanent reliable place to store the binding information.=0A=
 * @example=0A=
     &lt;example&gt;=0A=
       &lt;file name=3D"todoList.html"&gt;=0A=
         Check me check multiple: &lt;input type=3D"checkbox" =
ng-model=3D"open"&gt;&lt;br/&gt;=0A=
         &lt;details id=3D"details" ng-open=3D"open"&gt;=0A=
            &lt;summary&gt;Show/Hide me&lt;/summary&gt;=0A=
         &lt;/details&gt;=0A=
       &lt;/file&gt;=0A=
       &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
         it('should toggle open', function() {=0A=
           =
expect(element(by.id('details')).getAttribute('open')).toBeFalsy();=0A=
           element(by.model('open')).click();=0A=
           =
expect(element(by.id('details')).getAttribute('open')).toBeTruthy();=0A=
         });=0A=
       &lt;/file&gt;=0A=
     &lt;/example&gt;=0A=
 *=0A=
 * @element DETAILS=0A=
 * @param {expression} ngOpen If the {@link guide/expression expression} =
is truthy,=0A=
 *     then special attribute "open" will be set on the element=0A=
 */=0A=
=0A=
var ngAttributeAliasDirectives =3D {};=0A=
=0A=
=0A=
// boolean attrs are evaluated=0A=
forEach(BOOLEAN_ATTR, function(propName, attrName) {=0A=
  // binding to multiple is not supported=0A=
  if (propName =3D=3D "multiple") return;=0A=
=0A=
  var normalized =3D directiveNormalize('ng-' + attrName);=0A=
  ngAttributeAliasDirectives[normalized] =3D function() {=0A=
    return {=0A=
      restrict: 'A',=0A=
      priority: 100,=0A=
      link: function(scope, element, attr) {=0A=
        scope.$watch(attr[normalized], function =
ngBooleanAttrWatchAction(value) {=0A=
          attr.$set(attrName, !!value);=0A=
        });=0A=
      }=0A=
    };=0A=
  };=0A=
});=0A=
=0A=
// aliased input attrs are evaluated=0A=
forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {=0A=
  ngAttributeAliasDirectives[ngAttr] =3D function() {=0A=
    return {=0A=
      priority: 100,=0A=
      link: function(scope, element, attr) {=0A=
        //special case ngPattern when a literal regular expression value=0A=
        //is used as the expression (this way we don't have to watch =
anything).=0A=
        if (ngAttr =3D=3D=3D "ngPattern" &amp;&amp; =
attr.ngPattern.charAt(0) =3D=3D "/") {=0A=
          var match =3D attr.ngPattern.match(REGEX_STRING_REGEXP);=0A=
          if (match) {=0A=
            attr.$set("ngPattern", new RegExp(match[1], match[2]));=0A=
            return;=0A=
          }=0A=
        }=0A=
=0A=
        scope.$watch(attr[ngAttr], function =
ngAttrAliasWatchAction(value) {=0A=
          attr.$set(ngAttr, value);=0A=
        });=0A=
      }=0A=
    };=0A=
  };=0A=
});=0A=
=0A=
// ng-src, ng-srcset, ng-href are interpolated=0A=
forEach(['src', 'srcset', 'href'], function(attrName) {=0A=
  var normalized =3D directiveNormalize('ng-' + attrName);=0A=
  ngAttributeAliasDirectives[normalized] =3D function() {=0A=
    return {=0A=
      priority: 99, // it needs to run after the attributes are =
interpolated=0A=
      link: function(scope, element, attr) {=0A=
        var propName =3D attrName,=0A=
            name =3D attrName;=0A=
=0A=
        if (attrName =3D=3D=3D 'href' &amp;&amp;=0A=
            toString.call(element.prop('href')) =3D=3D=3D '[object =
SVGAnimatedString]') {=0A=
          name =3D 'xlinkHref';=0A=
          attr.$attr[name] =3D 'xlink:href';=0A=
          propName =3D null;=0A=
        }=0A=
=0A=
        attr.$observe(normalized, function(value) {=0A=
          if (!value) {=0A=
            if (attrName =3D=3D=3D 'href') {=0A=
              attr.$set(name, null);=0A=
            }=0A=
            return;=0A=
          }=0A=
=0A=
          attr.$set(name, value);=0A=
=0A=
          // on IE, if "ng:src" directive declaration is used and "src" =
attribute doesn't exist=0A=
          // then calling element.setAttribute('src', 'foo') doesn't do =
anything, so we need=0A=
          // to set the property as well to achieve the desired effect.=0A=
          // we use attr[attrName] value since $set can sanitize the url.=0A=
          if (msie &amp;&amp; propName) element.prop(propName, =
attr[name]);=0A=
        });=0A=
      }=0A=
    };=0A=
  };=0A=
});=0A=
=0A=
/* global -nullFormCtrl, -SUBMITTED_CLASS, addSetValidityMethod: true=0A=
 */=0A=
var nullFormCtrl =3D {=0A=
  $addControl: noop,=0A=
  $$renameControl: nullFormRenameControl,=0A=
  $removeControl: noop,=0A=
  $setValidity: noop,=0A=
  $setDirty: noop,=0A=
  $setPristine: noop,=0A=
  $setSubmitted: noop=0A=
},=0A=
SUBMITTED_CLASS =3D 'ng-submitted';=0A=
=0A=
function nullFormRenameControl(control, name) {=0A=
  control.$name =3D name;=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc type=0A=
 * @name form.FormController=0A=
 *=0A=
 * @property {boolean} $pristine True if user has not interacted with =
the form yet.=0A=
 * @property {boolean} $dirty True if user has already interacted with =
the form.=0A=
 * @property {boolean} $valid True if all of the containing forms and =
controls are valid.=0A=
 * @property {boolean} $invalid True if at least one containing control =
or form is invalid.=0A=
 * @property {boolean} $submitted True if user has submitted the form =
even if its invalid.=0A=
 *=0A=
 * @property {Object} $error Is an object hash, containing references to =
controls or=0A=
 *  forms with failing validators, where:=0A=
 *=0A=
 *  - keys are validation tokens (error names),=0A=
 *  - values are arrays of controls or forms that have a failing =
validator for given error name.=0A=
 *=0A=
 *  Built-in validation tokens:=0A=
 *=0A=
 *  - `email`=0A=
 *  - `max`=0A=
 *  - `maxlength`=0A=
 *  - `min`=0A=
 *  - `minlength`=0A=
 *  - `number`=0A=
 *  - `pattern`=0A=
 *  - `required`=0A=
 *  - `url`=0A=
 *=0A=
 * @description=0A=
 * `FormController` keeps track of all its controls and nested forms as =
well as the state of them,=0A=
 * such as being valid/invalid or dirty/pristine.=0A=
 *=0A=
 * Each {@link ng.directive:form form} directive creates an instance=0A=
 * of `FormController`.=0A=
 *=0A=
 */=0A=
//asks for $scope to fool the BC controller module=0A=
FormController.$inject =3D ['$element', '$attrs', '$scope', '$animate', =
'$interpolate'];=0A=
function FormController(element, attrs, $scope, $animate, $interpolate) {=0A=
  var form =3D this,=0A=
      controls =3D [];=0A=
=0A=
  var parentForm =3D form.$$parentForm =3D =
element.parent().controller('form') || nullFormCtrl;=0A=
=0A=
  // init state=0A=
  form.$error =3D {};=0A=
  form.$$success =3D {};=0A=
  form.$pending =3D undefined;=0A=
  form.$name =3D $interpolate(attrs.name || attrs.ngForm || '')($scope);=0A=
  form.$dirty =3D false;=0A=
  form.$pristine =3D true;=0A=
  form.$valid =3D true;=0A=
  form.$invalid =3D false;=0A=
  form.$submitted =3D false;=0A=
=0A=
  parentForm.$addControl(form);=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name form.FormController#$rollbackViewValue=0A=
   *=0A=
   * @description=0A=
   * Rollback all form controls pending updates to the `$modelValue`.=0A=
   *=0A=
   * Updates may be pending by a debounced event or because the input is =
waiting for a some future=0A=
   * event defined in `ng-model-options`. This method is typically =
needed by the reset button of=0A=
   * a form that uses `ng-model-options` to pend updates.=0A=
   */=0A=
  form.$rollbackViewValue =3D function() {=0A=
    forEach(controls, function(control) {=0A=
      control.$rollbackViewValue();=0A=
    });=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name form.FormController#$commitViewValue=0A=
   *=0A=
   * @description=0A=
   * Commit all form controls pending updates to the `$modelValue`.=0A=
   *=0A=
   * Updates may be pending by a debounced event or because the input is =
waiting for a some future=0A=
   * event defined in `ng-model-options`. This method is rarely needed =
as `NgModelController`=0A=
   * usually handles calling this in response to input events.=0A=
   */=0A=
  form.$commitViewValue =3D function() {=0A=
    forEach(controls, function(control) {=0A=
      control.$commitViewValue();=0A=
    });=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name form.FormController#$addControl=0A=
   *=0A=
   * @description=0A=
   * Register a control with the form.=0A=
   *=0A=
   * Input elements using ngModelController do this automatically when =
they are linked.=0A=
   */=0A=
  form.$addControl =3D function(control) {=0A=
    // Breaking change - before, inputs whose name was "hasOwnProperty" =
were quietly ignored=0A=
    // and not added to the scope.  Now we throw an error.=0A=
    assertNotHasOwnProperty(control.$name, 'input');=0A=
    controls.push(control);=0A=
=0A=
    if (control.$name) {=0A=
      form[control.$name] =3D control;=0A=
    }=0A=
  };=0A=
=0A=
  // Private API: rename a form control=0A=
  form.$$renameControl =3D function(control, newName) {=0A=
    var oldName =3D control.$name;=0A=
=0A=
    if (form[oldName] =3D=3D=3D control) {=0A=
      delete form[oldName];=0A=
    }=0A=
    form[newName] =3D control;=0A=
    control.$name =3D newName;=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name form.FormController#$removeControl=0A=
   *=0A=
   * @description=0A=
   * Deregister a control from the form.=0A=
   *=0A=
   * Input elements using ngModelController do this automatically when =
they are destroyed.=0A=
   */=0A=
  form.$removeControl =3D function(control) {=0A=
    if (control.$name &amp;&amp; form[control.$name] =3D=3D=3D control) {=0A=
      delete form[control.$name];=0A=
    }=0A=
    forEach(form.$pending, function(value, name) {=0A=
      form.$setValidity(name, null, control);=0A=
    });=0A=
    forEach(form.$error, function(value, name) {=0A=
      form.$setValidity(name, null, control);=0A=
    });=0A=
=0A=
    arrayRemove(controls, control);=0A=
  };=0A=
=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name form.FormController#$setValidity=0A=
   *=0A=
   * @description=0A=
   * Sets the validity of a form control.=0A=
   *=0A=
   * This method will also propagate to parent forms.=0A=
   */=0A=
  addSetValidityMethod({=0A=
    ctrl: this,=0A=
    $element: element,=0A=
    set: function(object, property, control) {=0A=
      var list =3D object[property];=0A=
      if (!list) {=0A=
        object[property] =3D [control];=0A=
      } else {=0A=
        var index =3D list.indexOf(control);=0A=
        if (index =3D=3D=3D -1) {=0A=
          list.push(control);=0A=
        }=0A=
      }=0A=
    },=0A=
    unset: function(object, property, control) {=0A=
      var list =3D object[property];=0A=
      if (!list) {=0A=
        return;=0A=
      }=0A=
      arrayRemove(list, control);=0A=
      if (list.length =3D=3D=3D 0) {=0A=
        delete object[property];=0A=
      }=0A=
    },=0A=
    parentForm: parentForm,=0A=
    $animate: $animate=0A=
  });=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name form.FormController#$setDirty=0A=
   *=0A=
   * @description=0A=
   * Sets the form to a dirty state.=0A=
   *=0A=
   * This method can be called to add the 'ng-dirty' class and set the =
form to a dirty=0A=
   * state (ng-dirty class). This method will also propagate to parent =
forms.=0A=
   */=0A=
  form.$setDirty =3D function() {=0A=
    $animate.removeClass(element, PRISTINE_CLASS);=0A=
    $animate.addClass(element, DIRTY_CLASS);=0A=
    form.$dirty =3D true;=0A=
    form.$pristine =3D false;=0A=
    parentForm.$setDirty();=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name form.FormController#$setPristine=0A=
   *=0A=
   * @description=0A=
   * Sets the form to its pristine state.=0A=
   *=0A=
   * This method can be called to remove the 'ng-dirty' class and set =
the form to its pristine=0A=
   * state (ng-pristine class). This method will also propagate to all =
the controls contained=0A=
   * in this form.=0A=
   *=0A=
   * Setting a form back to a pristine state is often useful when we =
want to 'reuse' a form after=0A=
   * saving or resetting it.=0A=
   */=0A=
  form.$setPristine =3D function () {=0A=
    $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + =
SUBMITTED_CLASS);=0A=
    form.$dirty =3D false;=0A=
    form.$pristine =3D true;=0A=
    form.$submitted =3D false;=0A=
    forEach(controls, function(control) {=0A=
      control.$setPristine();=0A=
    });=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name form.FormController#$setUntouched=0A=
   *=0A=
   * @description=0A=
   * Sets the form to its untouched state.=0A=
   *=0A=
   * This method can be called to remove the 'ng-touched' class and set =
the form controls to their=0A=
   * untouched state (ng-untouched class).=0A=
   *=0A=
   * Setting a form controls back to their untouched state is often =
useful when setting the form=0A=
   * back to its pristine state.=0A=
   */=0A=
  form.$setUntouched =3D function () {=0A=
    forEach(controls, function(control) {=0A=
      control.$setUntouched();=0A=
    });=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name form.FormController#$setSubmitted=0A=
   *=0A=
   * @description=0A=
   * Sets the form to its submitted state.=0A=
   */=0A=
  form.$setSubmitted =3D function () {=0A=
    $animate.addClass(element, SUBMITTED_CLASS);=0A=
    form.$submitted =3D true;=0A=
    parentForm.$setSubmitted();=0A=
  };=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngForm=0A=
 * @restrict EAC=0A=
 *=0A=
 * @description=0A=
 * Nestable alias of {@link ng.directive:form `form`} directive. HTML=0A=
 * does not allow nesting of form elements. It is useful to nest forms, =
for example if the validity of a=0A=
 * sub-group of controls needs to be determined.=0A=
 *=0A=
 * Note: the purpose of `ngForm` is to group controls,=0A=
 * but not to be a replacement for the `&lt;form&gt;` tag with all of =
its capabilities=0A=
 * (e.g. posting to the server, ...).=0A=
 *=0A=
 * @param {string=3D} ngForm|name Name of the form. If specified, the =
form controller will be published into=0A=
 *                       related scope, under this name.=0A=
 *=0A=
 */=0A=
=0A=
 /**=0A=
 * @ngdoc directive=0A=
 * @name form=0A=
 * @restrict E=0A=
 *=0A=
 * @description=0A=
 * Directive that instantiates=0A=
 * {@link form.FormController FormController}.=0A=
 *=0A=
 * If the `name` attribute is specified, the form controller is =
published onto the current scope under=0A=
 * this name.=0A=
 *=0A=
 * # Alias: {@link ng.directive:ngForm `ngForm`}=0A=
 *=0A=
 * In Angular forms can be nested. This means that the outer form is =
valid when all of the child=0A=
 * forms are valid as well. However, browsers do not allow nesting of =
`&lt;form&gt;` elements, so=0A=
 * Angular provides the {@link ng.directive:ngForm `ngForm`} directive =
which behaves identically to=0A=
 * `&lt;form&gt;` but can be nested.  This allows you to have nested =
forms, which is very useful when=0A=
 * using Angular validation directives in forms that are dynamically =
generated using the=0A=
 * {@link ng.directive:ngRepeat `ngRepeat`} directive. Since you cannot =
dynamically generate the `name`=0A=
 * attribute of input elements using interpolation, you have to wrap =
each set of repeated inputs in an=0A=
 * `ngForm` directive and nest these in an outer `form` element.=0A=
 *=0A=
 *=0A=
 * # CSS classes=0A=
 *  - `ng-valid` is set if the form is valid.=0A=
 *  - `ng-invalid` is set if the form is invalid.=0A=
 *  - `ng-pristine` is set if the form is pristine.=0A=
 *  - `ng-dirty` is set if the form is dirty.=0A=
 *  - `ng-submitted` is set if the form was submitted.=0A=
 *=0A=
 * Keep in mind that ngAnimate can detect each of these classes when =
added and removed.=0A=
 *=0A=
 *=0A=
 * # Submitting a form and preventing the default action=0A=
 *=0A=
 * Since the role of forms in client-side Angular applications is =
different than in classical=0A=
 * roundtrip apps, it is desirable for the browser not to translate the =
form submission into a full=0A=
 * page reload that sends the data to the server. Instead some =
javascript logic should be triggered=0A=
 * to handle the form submission in an application-specific way.=0A=
 *=0A=
 * For this reason, Angular prevents the default action (form submission =
to the server) unless the=0A=
 * `&lt;form&gt;` element has an `action` attribute specified.=0A=
 *=0A=
 * You can use one of the following two ways to specify what javascript =
method should be called when=0A=
 * a form is submitted:=0A=
 *=0A=
 * - {@link ng.directive:ngSubmit ngSubmit} directive on the form element=0A=
 * - {@link ng.directive:ngClick ngClick} directive on the first=0A=
  *  button or input field of type submit (input[type=3Dsubmit])=0A=
 *=0A=
 * To prevent double execution of the handler, use only one of the =
{@link ng.directive:ngSubmit ngSubmit}=0A=
 * or {@link ng.directive:ngClick ngClick} directives.=0A=
 * This is because of the following form submission rules in the HTML =
specification:=0A=
 *=0A=
 * - If a form has only one input field then hitting enter in this field =
triggers form submit=0A=
 * (`ngSubmit`)=0A=
 * - if a form has 2+ input fields and no buttons or =
input[type=3Dsubmit] then hitting enter=0A=
 * doesn't trigger submit=0A=
 * - if a form has one or more input fields and one or more buttons or =
input[type=3Dsubmit] then=0A=
 * hitting enter in any of the input fields will trigger the click =
handler on the *first* button or=0A=
 * input[type=3Dsubmit] (`ngClick`) *and* a submit handler on the =
enclosing form (`ngSubmit`)=0A=
 *=0A=
 * Any pending `ngModelOptions` changes will take place immediately when =
an enclosing form is=0A=
 * submitted. Note that `ngClick` events will occur before the model is =
updated. Use `ngSubmit`=0A=
 * to have access to the updated model.=0A=
 *=0A=
 * ## Animation Hooks=0A=
 *=0A=
 * Animations in ngForm are triggered when any of the associated CSS =
classes are added and removed.=0A=
 * These classes are: `.ng-pristine`, `.ng-dirty`, `.ng-invalid` and =
`.ng-valid` as well as any=0A=
 * other validations that are performed within the form. Animations in =
ngForm are similar to how=0A=
 * they work in ngClass and animations can be hooked into using CSS =
transitions, keyframes as well=0A=
 * as JS animations.=0A=
 *=0A=
 * The following example shows a simple way to utilize CSS transitions =
to style a form element=0A=
 * that has been rendered as invalid after it has been validated:=0A=
 *=0A=
 * &lt;pre&gt;=0A=
 * //be sure to include ngAnimate as a module to hook into more=0A=
 * //advanced animations=0A=
 * .my-form {=0A=
 *   transition:0.5s linear all;=0A=
 *   background: white;=0A=
 * }=0A=
 * .my-form.ng-invalid {=0A=
 *   background: red;=0A=
 *   color:white;=0A=
 * }=0A=
 * &lt;/pre&gt;=0A=
 *=0A=
 * @example=0A=
    &lt;example deps=3D"angular-animate.js" animations=3D"true" =
fixBase=3D"true" module=3D"formExample"&gt;=0A=
      &lt;file name=3D"todoList.html"&gt;=0A=
       &lt;script&gt;=0A=
         angular.module('formExample', [])=0A=
           .controller('FormController', ['$scope', function($scope) {=0A=
             $scope.userType =3D 'guest';=0A=
           }]);=0A=
       &lt;/script&gt;=0A=
       &lt;style&gt;=0A=
        .my-form {=0A=
          -webkit-transition:all linear 0.5s;=0A=
          transition:all linear 0.5s;=0A=
          background: transparent;=0A=
        }=0A=
        .my-form.ng-invalid {=0A=
          background: red;=0A=
        }=0A=
       &lt;/style&gt;=0A=
       &lt;form name=3D"myForm" ng-controller=3D"FormController" =
class=3D"my-form"&gt;=0A=
         userType: &lt;input name=3D"input" ng-model=3D"userType" =
required&gt;=0A=
         &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.required"&gt;Required!&lt;/span&gt;&lt;br&=
gt;=0A=
         &lt;tt&gt;userType =3D {{userType}}&lt;/tt&gt;&lt;br&gt;=0A=
         &lt;tt&gt;myForm.input.$valid =3D =
{{myForm.input.$valid}}&lt;/tt&gt;&lt;br&gt;=0A=
         &lt;tt&gt;myForm.input.$error =3D =
{{myForm.input.$error}}&lt;/tt&gt;&lt;br&gt;=0A=
         &lt;tt&gt;myForm.$valid =3D =
{{myForm.$valid}}&lt;/tt&gt;&lt;br&gt;=0A=
         &lt;tt&gt;myForm.$error.required =3D =
{{!!myForm.$error.required}}&lt;/tt&gt;&lt;br&gt;=0A=
        &lt;/form&gt;=0A=
      &lt;/file&gt;=0A=
      &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
        it('should initialize to model', function() {=0A=
          var userType =3D element(by.binding('userType'));=0A=
          var valid =3D element(by.binding('myForm.input.$valid'));=0A=
=0A=
          expect(userType.getText()).toContain('guest');=0A=
          expect(valid.getText()).toContain('true');=0A=
        });=0A=
=0A=
        it('should be invalid if empty', function() {=0A=
          var userType =3D element(by.binding('userType'));=0A=
          var valid =3D element(by.binding('myForm.input.$valid'));=0A=
          var userInput =3D element(by.model('userType'));=0A=
=0A=
          userInput.clear();=0A=
          userInput.sendKeys('');=0A=
=0A=
          expect(userType.getText()).toEqual('userType =3D');=0A=
          expect(valid.getText()).toContain('false');=0A=
        });=0A=
      &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
 *=0A=
 * @param {string=3D} name Name of the form. If specified, the form =
controller will be published into=0A=
 *                       related scope, under this name.=0A=
 */=0A=
var formDirectiveFactory =3D function(isNgForm) {=0A=
  return ['$timeout', function($timeout) {=0A=
    var formDirective =3D {=0A=
      name: 'form',=0A=
      restrict: isNgForm ? 'EAC' : 'E',=0A=
      controller: FormController,=0A=
      compile: function ngFormCompile(formElement) {=0A=
        // Setup initial state of the control=0A=
        formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);=0A=
=0A=
        return {=0A=
          pre: function ngFormPreLink(scope, formElement, attr, =
controller) {=0A=
            // if `action` attr is not present on the form, prevent the =
default action (submission)=0A=
            if (!('action' in attr)) {=0A=
              // we can't use jq events because if a form is destroyed =
during submission the default=0A=
              // action is not prevented. see #1238=0A=
              //=0A=
              // IE 9 is not affected because it doesn't fire a submit =
event and try to do a full=0A=
              // page reload if the form was destroyed by submission of =
the form via a click handler=0A=
              // on a button in the form. Looks like an IE9 specific bug.=0A=
              var handleFormSubmission =3D function(event) {=0A=
                scope.$apply(function() {=0A=
                  controller.$commitViewValue();=0A=
                  controller.$setSubmitted();=0A=
                });=0A=
=0A=
                event.preventDefault=0A=
                  ? event.preventDefault()=0A=
                  : event.returnValue =3D false; // IE=0A=
              };=0A=
=0A=
              addEventListenerFn(formElement[0], 'submit', =
handleFormSubmission);=0A=
=0A=
              // unregister the preventDefault listener so that we don't =
not leak memory but in a=0A=
              // way that will achieve the prevention of the default =
action.=0A=
              formElement.on('$destroy', function() {=0A=
                $timeout(function() {=0A=
                  removeEventListenerFn(formElement[0], 'submit', =
handleFormSubmission);=0A=
                }, 0, false);=0A=
              });=0A=
            }=0A=
=0A=
            var parentFormCtrl =3D controller.$$parentForm,=0A=
                alias =3D controller.$name;=0A=
=0A=
            if (alias) {=0A=
              setter(scope, alias, controller, alias);=0A=
              attr.$observe(attr.name ? 'name' : 'ngForm', =
function(newValue) {=0A=
                if (alias =3D=3D=3D newValue) return;=0A=
                setter(scope, alias, undefined, alias);=0A=
                alias =3D newValue;=0A=
                setter(scope, alias, controller, alias);=0A=
                parentFormCtrl.$$renameControl(controller, alias);=0A=
              });=0A=
            }=0A=
            formElement.on('$destroy', function() {=0A=
              parentFormCtrl.$removeControl(controller);=0A=
              if (alias) {=0A=
                setter(scope, alias, undefined, alias);=0A=
              }=0A=
              extend(controller, nullFormCtrl); //stop propagating child =
destruction handlers upwards=0A=
            });=0A=
          }=0A=
        };=0A=
      }=0A=
    };=0A=
=0A=
    return formDirective;=0A=
  }];=0A=
};=0A=
=0A=
var formDirective =3D formDirectiveFactory();=0A=
var ngFormDirective =3D formDirectiveFactory(true);=0A=
=0A=
/* global VALID_CLASS: true,=0A=
  INVALID_CLASS: true,=0A=
  PRISTINE_CLASS: true,=0A=
  DIRTY_CLASS: true,=0A=
  UNTOUCHED_CLASS: true,=0A=
  TOUCHED_CLASS: true,=0A=
*/=0A=
=0A=
// Regex code is obtained from SO: =
https://stackoverflow.com/questions/3143070/javascript-regex-iso-datetime=
#answer-3143231=0A=
var ISO_DATE_REGEXP =3D =
/\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)=
/;=0A=
var URL_REGEXP =3D =
/^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=3D=
&amp;%@!\-\/]))?$/;=0A=
var EMAIL_REGEXP =3D =
/^[a-z0-9!#$%&amp;'*+\/=3D?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a=
-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;=0A=
var NUMBER_REGEXP =3D /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/;=0A=
var DATE_REGEXP =3D /^(\d{4})-(\d{2})-(\d{2})$/;=0A=
var DATETIMELOCAL_REGEXP =3D =
/^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;=0A=
var WEEK_REGEXP =3D /^(\d{4})-W(\d\d)$/;=0A=
var MONTH_REGEXP =3D /^(\d{4})-(\d\d)$/;=0A=
var TIME_REGEXP =3D /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;=0A=
var DEFAULT_REGEXP =3D /(\s+|^)default(\s+|$)/;=0A=
=0A=
var $ngModelMinErr =3D new minErr('ngModel');=0A=
=0A=
var inputType =3D {=0A=
=0A=
  /**=0A=
   * @ngdoc input=0A=
   * @name input[text]=0A=
   *=0A=
   * @description=0A=
   * Standard HTML text input with angular data binding, inherited by =
most of the `input` elements.=0A=
   *=0A=
   * *NOTE* Not every feature offered is available for all input types.=0A=
   *=0A=
   * @param {string} ngModel Assignable angular expression to data-bind =
to.=0A=
   * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
   * @param {string=3D} required Adds `required` validation error key if =
the value is not entered.=0A=
   * @param {string=3D} ngRequired Adds `required` attribute and =
`required` validation constraint to=0A=
   *    the element when the ngRequired expression evaluates to true. =
Use `ngRequired` instead of=0A=
   *    `required` when you want to data-bind to the `required` =
attribute.=0A=
   * @param {number=3D} ngMinlength Sets `minlength` validation error =
key if the value is shorter than=0A=
   *    minlength.=0A=
   * @param {number=3D} ngMaxlength Sets `maxlength` validation error =
key if the value is longer than=0A=
   *    maxlength.=0A=
   * @param {string=3D} ngPattern Sets `pattern` validation error key if =
the value does not match the=0A=
   *    RegExp pattern expression. Expected value is `/regexp/` for =
inline patterns or `regexp` for=0A=
   *    patterns defined as scope expressions.=0A=
   * @param {string=3D} ngChange Angular expression to be executed when =
input changes due to user=0A=
   *    interaction with the input element.=0A=
   * @param {boolean=3D} [ngTrim=3Dtrue] If set to false Angular will =
not automatically trim the input.=0A=
   *    This parameter is ignored for input[type=3Dpassword] controls, =
which will never trim the=0A=
   *    input.=0A=
   *=0A=
   * @example=0A=
      &lt;example name=3D"text-input-directive" =
module=3D"textInputExample"&gt;=0A=
        &lt;file name=3D"todoList.html"&gt;=0A=
         &lt;script&gt;=0A=
           angular.module('textInputExample', [])=0A=
             .controller('ExampleController', ['$scope', =
function($scope) {=0A=
               $scope.text =3D 'guest';=0A=
               $scope.word =3D /^\s*\w*\s*$/;=0A=
             }]);=0A=
         &lt;/script&gt;=0A=
         &lt;form name=3D"myForm" ng-controller=3D"ExampleController"&gt;=0A=
           Single word: &lt;input type=3D"text" name=3D"input" =
ng-model=3D"text"=0A=
                               ng-pattern=3D"word" required =
ng-trim=3D"false"&gt;=0A=
           &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.required"&gt;=0A=
             Required!&lt;/span&gt;=0A=
           &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.pattern"&gt;=0A=
             Single word only!&lt;/span&gt;=0A=
=0A=
           &lt;tt&gt;text =3D {{text}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.input.$valid =3D =
{{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.input.$error =3D =
{{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.$valid =3D =
{{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.$error.required =3D =
{{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;=0A=
          &lt;/form&gt;=0A=
        &lt;/file&gt;=0A=
        &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
          var text =3D element(by.binding('text'));=0A=
          var valid =3D element(by.binding('myForm.input.$valid'));=0A=
          var input =3D element(by.model('text'));=0A=
=0A=
          it('should initialize to model', function() {=0A=
            expect(text.getText()).toContain('guest');=0A=
            expect(valid.getText()).toContain('true');=0A=
          });=0A=
=0A=
          it('should be invalid if empty', function() {=0A=
            input.clear();=0A=
            input.sendKeys('');=0A=
=0A=
            expect(text.getText()).toEqual('text =3D');=0A=
            expect(valid.getText()).toContain('false');=0A=
          });=0A=
=0A=
          it('should be invalid if multi word', function() {=0A=
            input.clear();=0A=
            input.sendKeys('hello world');=0A=
=0A=
            expect(valid.getText()).toContain('false');=0A=
          });=0A=
        &lt;/file&gt;=0A=
      &lt;/example&gt;=0A=
   */=0A=
  'text': textInputType,=0A=
=0A=
    /**=0A=
     * @ngdoc input=0A=
     * @name input[date]=0A=
     *=0A=
     * @description=0A=
     * Input with date validation and transformation. In browsers that =
do not yet support=0A=
     * the HTML5 date input, a text element will be used. In that case, =
text must be entered in a valid ISO-8601=0A=
     * date format (yyyy-MM-dd), for example: `2009-01-06`. Since many=0A=
     * modern browsers do not yet support this input type, it is =
important to provide cues to users on the=0A=
     * expected input format via a placeholder or label. The model must =
always be a Date object.=0A=
     *=0A=
     * The timezone to be used to read/write the `Date` instance in the =
model can be defined using=0A=
     * {@link ng.directive:ngModelOptions ngModelOptions}. By default, =
this is the timezone of the browser.=0A=
     *=0A=
     * @param {string} ngModel Assignable angular expression to =
data-bind to.=0A=
     * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
     * @param {string=3D} min Sets the `min` validation error key if the =
value entered is less than `min`. This must be a=0A=
     * valid ISO date string (yyyy-MM-dd).=0A=
     * @param {string=3D} max Sets the `max` validation error key if the =
value entered is greater than `max`. This must be=0A=
     * a valid ISO date string (yyyy-MM-dd).=0A=
     * @param {string=3D} required Sets `required` validation error key =
if the value is not entered.=0A=
     * @param {string=3D} ngRequired Adds `required` attribute and =
`required` validation constraint to=0A=
     *    the element when the ngRequired expression evaluates to true. =
Use `ngRequired` instead of=0A=
     *    `required` when you want to data-bind to the `required` =
attribute.=0A=
     * @param {string=3D} ngChange Angular expression to be executed =
when input changes due to user=0A=
     *    interaction with the input element.=0A=
     *=0A=
     * @example=0A=
     &lt;example name=3D"date-input-directive" =
module=3D"dateInputExample"&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
       &lt;script&gt;=0A=
          angular.module('dateInputExample', [])=0A=
            .controller('DateController', ['$scope', function($scope) {=0A=
              $scope.value =3D new Date(2013, 9, 22);=0A=
            }]);=0A=
       &lt;/script&gt;=0A=
       &lt;form name=3D"myForm" ng-controller=3D"DateController as =
dateCtrl"&gt;=0A=
          Pick a date in 2013:=0A=
          &lt;input type=3D"date" id=3D"exampleInput" name=3D"input" =
ng-model=3D"value"=0A=
              placeholder=3D"yyyy-MM-dd" min=3D"2013-01-01" =
max=3D"2013-12-31" required /&gt;=0A=
          &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.required"&gt;=0A=
              Required!&lt;/span&gt;=0A=
          &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.date"&gt;=0A=
              Not a valid date!&lt;/span&gt;=0A=
           &lt;tt&gt;value =3D {{value | date: =
"yyyy-MM-dd"}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.input.$valid =3D =
{{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.input.$error =3D =
{{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.$valid =3D =
{{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.$error.required =3D =
{{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;=0A=
       &lt;/form&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
        var value =3D element(by.binding('value | date: "yyyy-MM-dd"'));=0A=
        var valid =3D element(by.binding('myForm.input.$valid'));=0A=
        var input =3D element(by.model('value'));=0A=
=0A=
        // currently protractor/webdriver does not support=0A=
        // sending keys to all known HTML5 input controls=0A=
        // for various browsers (see =
https://github.com/angular/protractor/issues/562).=0A=
        function setInput(val) {=0A=
          // set the value of the element and force validation.=0A=
          var scr =3D "var ipt =3D =
document.getElementById('exampleInput'); " +=0A=
          "ipt.value =3D '" + val + "';" +=0A=
          "angular.element(ipt).scope().$apply(function(s) { =
s.myForm[ipt.name].$setViewValue('" + val + "'); });";=0A=
          browser.executeScript(scr);=0A=
        }=0A=
=0A=
        it('should initialize to model', function() {=0A=
          expect(value.getText()).toContain('2013-10-22');=0A=
          expect(valid.getText()).toContain('myForm.input.$valid =3D =
true');=0A=
        });=0A=
=0A=
        it('should be invalid if empty', function() {=0A=
          setInput('');=0A=
          expect(value.getText()).toEqual('value =3D');=0A=
          expect(valid.getText()).toContain('myForm.input.$valid =3D =
false');=0A=
        });=0A=
=0A=
        it('should be invalid if over max', function() {=0A=
          setInput('2015-01-01');=0A=
          expect(value.getText()).toContain('');=0A=
          expect(valid.getText()).toContain('myForm.input.$valid =3D =
false');=0A=
        });=0A=
     &lt;/file&gt;=0A=
     &lt;/example&gt;=0A=
     */=0A=
  'date': createDateInputType('date', DATE_REGEXP,=0A=
         createDateParser(DATE_REGEXP, ['yyyy', 'MM', 'dd']),=0A=
         'yyyy-MM-dd'),=0A=
=0A=
   /**=0A=
    * @ngdoc input=0A=
    * @name input[dateTimeLocal]=0A=
    *=0A=
    * @description=0A=
    * Input with datetime validation and transformation. In browsers =
that do not yet support=0A=
    * the HTML5 date input, a text element will be used. In that case, =
the text must be entered in a valid ISO-8601=0A=
    * local datetime format (yyyy-MM-ddTHH:mm:ss), for example: =
`2010-12-28T14:57:00`. The model must be a Date object.=0A=
    *=0A=
    * The timezone to be used to read/write the `Date` instance in the =
model can be defined using=0A=
    * {@link ng.directive:ngModelOptions ngModelOptions}. By default, =
this is the timezone of the browser.=0A=
    *=0A=
    * @param {string} ngModel Assignable angular expression to data-bind =
to.=0A=
    * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
    * @param {string=3D} min Sets the `min` validation error key if the =
value entered is less than `min`. This must be a=0A=
    * valid ISO datetime format (yyyy-MM-ddTHH:mm:ss).=0A=
    * @param {string=3D} max Sets the `max` validation error key if the =
value entered is greater than `max`. This must be=0A=
    * a valid ISO datetime format (yyyy-MM-ddTHH:mm:ss).=0A=
    * @param {string=3D} required Sets `required` validation error key =
if the value is not entered.=0A=
    * @param {string=3D} ngRequired Adds `required` attribute and =
`required` validation constraint to=0A=
    *    the element when the ngRequired expression evaluates to true. =
Use `ngRequired` instead of=0A=
    *    `required` when you want to data-bind to the `required` =
attribute.=0A=
    * @param {string=3D} ngChange Angular expression to be executed when =
input changes due to user=0A=
    *    interaction with the input element.=0A=
    *=0A=
    * @example=0A=
    &lt;example name=3D"datetimelocal-input-directive" =
module=3D"dateExample"&gt;=0A=
    &lt;file name=3D"todoList.html"&gt;=0A=
      &lt;script&gt;=0A=
        angular.module('dateExample', [])=0A=
          .controller('DateController', ['$scope', function($scope) {=0A=
            $scope.value =3D new Date(2010, 11, 28, 14, 57);=0A=
          }]);=0A=
      &lt;/script&gt;=0A=
      &lt;form name=3D"myForm" ng-controller=3D"DateController as =
dateCtrl"&gt;=0A=
        Pick a date between in 2013:=0A=
        &lt;input type=3D"datetime-local" id=3D"exampleInput" =
name=3D"input" ng-model=3D"value"=0A=
            placeholder=3D"yyyy-MM-ddTHH:mm:ss" =
min=3D"2001-01-01T00:00:00" max=3D"2013-12-31T00:00:00" required /&gt;=0A=
        &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.required"&gt;=0A=
            Required!&lt;/span&gt;=0A=
        &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.datetimelocal"&gt;=0A=
            Not a valid date!&lt;/span&gt;=0A=
        &lt;tt&gt;value =3D {{value | date: =
"yyyy-MM-ddTHH:mm:ss"}}&lt;/tt&gt;&lt;br/&gt;=0A=
        &lt;tt&gt;myForm.input.$valid =3D =
{{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
        &lt;tt&gt;myForm.input.$error =3D =
{{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;=0A=
        &lt;tt&gt;myForm.$valid =3D =
{{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
        &lt;tt&gt;myForm.$error.required =3D =
{{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;=0A=
      &lt;/form&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
      var value =3D element(by.binding('value | date: =
"yyyy-MM-ddTHH:mm:ss"'));=0A=
      var valid =3D element(by.binding('myForm.input.$valid'));=0A=
      var input =3D element(by.model('value'));=0A=
=0A=
      // currently protractor/webdriver does not support=0A=
      // sending keys to all known HTML5 input controls=0A=
      // for various browsers =
(https://github.com/angular/protractor/issues/562).=0A=
      function setInput(val) {=0A=
        // set the value of the element and force validation.=0A=
        var scr =3D "var ipt =3D =
document.getElementById('exampleInput'); " +=0A=
        "ipt.value =3D '" + val + "';" +=0A=
        "angular.element(ipt).scope().$apply(function(s) { =
s.myForm[ipt.name].$setViewValue('" + val + "'); });";=0A=
        browser.executeScript(scr);=0A=
      }=0A=
=0A=
      it('should initialize to model', function() {=0A=
        expect(value.getText()).toContain('2010-12-28T14:57:00');=0A=
        expect(valid.getText()).toContain('myForm.input.$valid =3D =
true');=0A=
      });=0A=
=0A=
      it('should be invalid if empty', function() {=0A=
        setInput('');=0A=
        expect(value.getText()).toEqual('value =3D');=0A=
        expect(valid.getText()).toContain('myForm.input.$valid =3D =
false');=0A=
      });=0A=
=0A=
      it('should be invalid if over max', function() {=0A=
        setInput('2015-01-01T23:59:00');=0A=
        expect(value.getText()).toContain('');=0A=
        expect(valid.getText()).toContain('myForm.input.$valid =3D =
false');=0A=
      });=0A=
    &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
    */=0A=
  'datetime-local': createDateInputType('datetimelocal', =
DATETIMELOCAL_REGEXP,=0A=
      createDateParser(DATETIMELOCAL_REGEXP, ['yyyy', 'MM', 'dd', 'HH', =
'mm', 'ss', 'sss']),=0A=
      'yyyy-MM-ddTHH:mm:ss.sss'),=0A=
=0A=
  /**=0A=
   * @ngdoc input=0A=
   * @name input[time]=0A=
   *=0A=
   * @description=0A=
   * Input with time validation and transformation. In browsers that do =
not yet support=0A=
   * the HTML5 date input, a text element will be used. In that case, =
the text must be entered in a valid ISO-8601=0A=
   * local time format (HH:mm:ss), for example: `14:57:00`. Model must =
be a Date object. This binding will always output a=0A=
   * Date object to the model of January 1, 1970, or local date `new =
Date(1970, 0, 1, HH, mm, ss)`.=0A=
   *=0A=
   * The timezone to be used to read/write the `Date` instance in the =
model can be defined using=0A=
   * {@link ng.directive:ngModelOptions ngModelOptions}. By default, =
this is the timezone of the browser.=0A=
   *=0A=
   * @param {string} ngModel Assignable angular expression to data-bind =
to.=0A=
   * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
   * @param {string=3D} min Sets the `min` validation error key if the =
value entered is less than `min`. This must be a=0A=
   * valid ISO time format (HH:mm:ss).=0A=
   * @param {string=3D} max Sets the `max` validation error key if the =
value entered is greater than `max`. This must be a=0A=
   * valid ISO time format (HH:mm:ss).=0A=
   * @param {string=3D} required Sets `required` validation error key if =
the value is not entered.=0A=
   * @param {string=3D} ngRequired Adds `required` attribute and =
`required` validation constraint to=0A=
   *    the element when the ngRequired expression evaluates to true. =
Use `ngRequired` instead of=0A=
   *    `required` when you want to data-bind to the `required` =
attribute.=0A=
   * @param {string=3D} ngChange Angular expression to be executed when =
input changes due to user=0A=
   *    interaction with the input element.=0A=
   *=0A=
   * @example=0A=
   &lt;example name=3D"time-input-directive" module=3D"timeExample"&gt;=0A=
   &lt;file name=3D"todoList.html"&gt;=0A=
     &lt;script&gt;=0A=
      angular.module('timeExample', [])=0A=
        .controller('DateController', ['$scope', function($scope) {=0A=
          $scope.value =3D new Date(1970, 0, 1, 14, 57, 0);=0A=
        }]);=0A=
     &lt;/script&gt;=0A=
     &lt;form name=3D"myForm" ng-controller=3D"DateController as =
dateCtrl"&gt;=0A=
        Pick a between 8am and 5pm:=0A=
        &lt;input type=3D"time" id=3D"exampleInput" name=3D"input" =
ng-model=3D"value"=0A=
            placeholder=3D"HH:mm:ss" min=3D"08:00:00" max=3D"17:00:00" =
required /&gt;=0A=
        &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.required"&gt;=0A=
            Required!&lt;/span&gt;=0A=
        &lt;span class=3D"error" ng-show=3D"myForm.input.$error.time"&gt;=0A=
            Not a valid date!&lt;/span&gt;=0A=
        &lt;tt&gt;value =3D {{value | date: =
"HH:mm:ss"}}&lt;/tt&gt;&lt;br/&gt;=0A=
        &lt;tt&gt;myForm.input.$valid =3D =
{{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
        &lt;tt&gt;myForm.input.$error =3D =
{{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;=0A=
        &lt;tt&gt;myForm.$valid =3D =
{{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
        &lt;tt&gt;myForm.$error.required =3D =
{{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;=0A=
     &lt;/form&gt;=0A=
   &lt;/file&gt;=0A=
   &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
      var value =3D element(by.binding('value | date: "HH:mm:ss"'));=0A=
      var valid =3D element(by.binding('myForm.input.$valid'));=0A=
      var input =3D element(by.model('value'));=0A=
=0A=
      // currently protractor/webdriver does not support=0A=
      // sending keys to all known HTML5 input controls=0A=
      // for various browsers =
(https://github.com/angular/protractor/issues/562).=0A=
      function setInput(val) {=0A=
        // set the value of the element and force validation.=0A=
        var scr =3D "var ipt =3D =
document.getElementById('exampleInput'); " +=0A=
        "ipt.value =3D '" + val + "';" +=0A=
        "angular.element(ipt).scope().$apply(function(s) { =
s.myForm[ipt.name].$setViewValue('" + val + "'); });";=0A=
        browser.executeScript(scr);=0A=
      }=0A=
=0A=
      it('should initialize to model', function() {=0A=
        expect(value.getText()).toContain('14:57:00');=0A=
        expect(valid.getText()).toContain('myForm.input.$valid =3D =
true');=0A=
      });=0A=
=0A=
      it('should be invalid if empty', function() {=0A=
        setInput('');=0A=
        expect(value.getText()).toEqual('value =3D');=0A=
        expect(valid.getText()).toContain('myForm.input.$valid =3D =
false');=0A=
      });=0A=
=0A=
      it('should be invalid if over max', function() {=0A=
        setInput('23:59:00');=0A=
        expect(value.getText()).toContain('');=0A=
        expect(valid.getText()).toContain('myForm.input.$valid =3D =
false');=0A=
      });=0A=
   &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
   */=0A=
  'time': createDateInputType('time', TIME_REGEXP,=0A=
      createDateParser(TIME_REGEXP, ['HH', 'mm', 'ss', 'sss']),=0A=
     'HH:mm:ss.sss'),=0A=
=0A=
   /**=0A=
    * @ngdoc input=0A=
    * @name input[week]=0A=
    *=0A=
    * @description=0A=
    * Input with week-of-the-year validation and transformation to Date. =
In browsers that do not yet support=0A=
    * the HTML5 week input, a text element will be used. In that case, =
the text must be entered in a valid ISO-8601=0A=
    * week format (yyyy-W##), for example: `2013-W02`. The model must =
always be a Date object.=0A=
    *=0A=
    * The timezone to be used to read/write the `Date` instance in the =
model can be defined using=0A=
    * {@link ng.directive:ngModelOptions ngModelOptions}. By default, =
this is the timezone of the browser.=0A=
    *=0A=
    * @param {string} ngModel Assignable angular expression to data-bind =
to.=0A=
    * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
    * @param {string=3D} min Sets the `min` validation error key if the =
value entered is less than `min`. This must be a=0A=
    * valid ISO week format (yyyy-W##).=0A=
    * @param {string=3D} max Sets the `max` validation error key if the =
value entered is greater than `max`. This must be=0A=
    * a valid ISO week format (yyyy-W##).=0A=
    * @param {string=3D} required Sets `required` validation error key =
if the value is not entered.=0A=
    * @param {string=3D} ngRequired Adds `required` attribute and =
`required` validation constraint to=0A=
    *    the element when the ngRequired expression evaluates to true. =
Use `ngRequired` instead of=0A=
    *    `required` when you want to data-bind to the `required` =
attribute.=0A=
    * @param {string=3D} ngChange Angular expression to be executed when =
input changes due to user=0A=
    *    interaction with the input element.=0A=
    *=0A=
    * @example=0A=
    &lt;example name=3D"week-input-directive" module=3D"weekExample"&gt;=0A=
    &lt;file name=3D"todoList.html"&gt;=0A=
      &lt;script&gt;=0A=
      angular.module('weekExample', [])=0A=
        .controller('DateController', ['$scope', function($scope) {=0A=
          $scope.value =3D new Date(2013, 0, 3);=0A=
        }]);=0A=
      &lt;/script&gt;=0A=
      &lt;form name=3D"myForm" ng-controller=3D"DateController as =
dateCtrl"&gt;=0A=
        Pick a date between in 2013:=0A=
        &lt;input id=3D"exampleInput" type=3D"week" name=3D"input" =
ng-model=3D"value"=0A=
            placeholder=3D"YYYY-W##" min=3D"2012-W32" max=3D"2013-W52" =
required /&gt;=0A=
        &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.required"&gt;=0A=
            Required!&lt;/span&gt;=0A=
        &lt;span class=3D"error" ng-show=3D"myForm.input.$error.week"&gt;=0A=
            Not a valid date!&lt;/span&gt;=0A=
        &lt;tt&gt;value =3D {{value | date: =
"yyyy-Www"}}&lt;/tt&gt;&lt;br/&gt;=0A=
        &lt;tt&gt;myForm.input.$valid =3D =
{{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
        &lt;tt&gt;myForm.input.$error =3D =
{{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;=0A=
        &lt;tt&gt;myForm.$valid =3D =
{{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
        &lt;tt&gt;myForm.$error.required =3D =
{{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;=0A=
      &lt;/form&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
      var value =3D element(by.binding('value | date: "yyyy-Www"'));=0A=
      var valid =3D element(by.binding('myForm.input.$valid'));=0A=
      var input =3D element(by.model('value'));=0A=
=0A=
      // currently protractor/webdriver does not support=0A=
      // sending keys to all known HTML5 input controls=0A=
      // for various browsers =
(https://github.com/angular/protractor/issues/562).=0A=
      function setInput(val) {=0A=
        // set the value of the element and force validation.=0A=
        var scr =3D "var ipt =3D =
document.getElementById('exampleInput'); " +=0A=
        "ipt.value =3D '" + val + "';" +=0A=
        "angular.element(ipt).scope().$apply(function(s) { =
s.myForm[ipt.name].$setViewValue('" + val + "'); });";=0A=
        browser.executeScript(scr);=0A=
      }=0A=
=0A=
      it('should initialize to model', function() {=0A=
        expect(value.getText()).toContain('2013-W01');=0A=
        expect(valid.getText()).toContain('myForm.input.$valid =3D =
true');=0A=
      });=0A=
=0A=
      it('should be invalid if empty', function() {=0A=
        setInput('');=0A=
        expect(value.getText()).toEqual('value =3D');=0A=
        expect(valid.getText()).toContain('myForm.input.$valid =3D =
false');=0A=
      });=0A=
=0A=
      it('should be invalid if over max', function() {=0A=
        setInput('2015-W01');=0A=
        expect(value.getText()).toContain('');=0A=
        expect(valid.getText()).toContain('myForm.input.$valid =3D =
false');=0A=
      });=0A=
    &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
    */=0A=
  'week': createDateInputType('week', WEEK_REGEXP, weekParser, =
'yyyy-Www'),=0A=
=0A=
  /**=0A=
   * @ngdoc input=0A=
   * @name input[month]=0A=
   *=0A=
   * @description=0A=
   * Input with month validation and transformation. In browsers that do =
not yet support=0A=
   * the HTML5 month input, a text element will be used. In that case, =
the text must be entered in a valid ISO-8601=0A=
   * month format (yyyy-MM), for example: `2009-01`. The model must =
always be a Date object. In the event the model is=0A=
   * not set to the first of the month, the first of that model's month =
is assumed.=0A=
   *=0A=
   * The timezone to be used to read/write the `Date` instance in the =
model can be defined using=0A=
   * {@link ng.directive:ngModelOptions ngModelOptions}. By default, =
this is the timezone of the browser.=0A=
   *=0A=
   * @param {string} ngModel Assignable angular expression to data-bind =
to.=0A=
   * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
   * @param {string=3D} min Sets the `min` validation error key if the =
value entered is less than `min`. This must be=0A=
   * a valid ISO month format (yyyy-MM).=0A=
   * @param {string=3D} max Sets the `max` validation error key if the =
value entered is greater than `max`. This must=0A=
   * be a valid ISO month format (yyyy-MM).=0A=
   * @param {string=3D} required Sets `required` validation error key if =
the value is not entered.=0A=
   * @param {string=3D} ngRequired Adds `required` attribute and =
`required` validation constraint to=0A=
   *    the element when the ngRequired expression evaluates to true. =
Use `ngRequired` instead of=0A=
   *    `required` when you want to data-bind to the `required` =
attribute.=0A=
   * @param {string=3D} ngChange Angular expression to be executed when =
input changes due to user=0A=
   *    interaction with the input element.=0A=
   *=0A=
   * @example=0A=
   &lt;example name=3D"month-input-directive" module=3D"monthExample"&gt;=0A=
   &lt;file name=3D"todoList.html"&gt;=0A=
     &lt;script&gt;=0A=
      angular.module('monthExample', [])=0A=
        .controller('DateController', ['$scope', function($scope) {=0A=
          $scope.value =3D new Date(2013, 9, 1);=0A=
        }]);=0A=
     &lt;/script&gt;=0A=
     &lt;form name=3D"myForm" ng-controller=3D"DateController as =
dateCtrl"&gt;=0A=
       Pick a month int 2013:=0A=
       &lt;input id=3D"exampleInput" type=3D"month" name=3D"input" =
ng-model=3D"value"=0A=
          placeholder=3D"yyyy-MM" min=3D"2013-01" max=3D"2013-12" =
required /&gt;=0A=
       &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.required"&gt;=0A=
          Required!&lt;/span&gt;=0A=
       &lt;span class=3D"error" ng-show=3D"myForm.input.$error.month"&gt;=0A=
          Not a valid month!&lt;/span&gt;=0A=
       &lt;tt&gt;value =3D {{value | date: =
"yyyy-MM"}}&lt;/tt&gt;&lt;br/&gt;=0A=
       &lt;tt&gt;myForm.input.$valid =3D =
{{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
       &lt;tt&gt;myForm.input.$error =3D =
{{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;=0A=
       &lt;tt&gt;myForm.$valid =3D =
{{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
       &lt;tt&gt;myForm.$error.required =3D =
{{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;=0A=
     &lt;/form&gt;=0A=
   &lt;/file&gt;=0A=
   &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
      var value =3D element(by.binding('value | date: "yyyy-MM"'));=0A=
      var valid =3D element(by.binding('myForm.input.$valid'));=0A=
      var input =3D element(by.model('value'));=0A=
=0A=
      // currently protractor/webdriver does not support=0A=
      // sending keys to all known HTML5 input controls=0A=
      // for various browsers =
(https://github.com/angular/protractor/issues/562).=0A=
      function setInput(val) {=0A=
        // set the value of the element and force validation.=0A=
        var scr =3D "var ipt =3D =
document.getElementById('exampleInput'); " +=0A=
        "ipt.value =3D '" + val + "';" +=0A=
        "angular.element(ipt).scope().$apply(function(s) { =
s.myForm[ipt.name].$setViewValue('" + val + "'); });";=0A=
        browser.executeScript(scr);=0A=
      }=0A=
=0A=
      it('should initialize to model', function() {=0A=
        expect(value.getText()).toContain('2013-10');=0A=
        expect(valid.getText()).toContain('myForm.input.$valid =3D =
true');=0A=
      });=0A=
=0A=
      it('should be invalid if empty', function() {=0A=
        setInput('');=0A=
        expect(value.getText()).toEqual('value =3D');=0A=
        expect(valid.getText()).toContain('myForm.input.$valid =3D =
false');=0A=
      });=0A=
=0A=
      it('should be invalid if over max', function() {=0A=
        setInput('2015-01');=0A=
        expect(value.getText()).toContain('');=0A=
        expect(valid.getText()).toContain('myForm.input.$valid =3D =
false');=0A=
      });=0A=
   &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
   */=0A=
  'month': createDateInputType('month', MONTH_REGEXP,=0A=
     createDateParser(MONTH_REGEXP, ['yyyy', 'MM']),=0A=
     'yyyy-MM'),=0A=
=0A=
  /**=0A=
   * @ngdoc input=0A=
   * @name input[number]=0A=
   *=0A=
   * @description=0A=
   * Text input with number validation and transformation. Sets the =
`number` validation=0A=
   * error if not a valid number.=0A=
   *=0A=
   * @param {string} ngModel Assignable angular expression to data-bind =
to.=0A=
   * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
   * @param {string=3D} min Sets the `min` validation error key if the =
value entered is less than `min`.=0A=
   * @param {string=3D} max Sets the `max` validation error key if the =
value entered is greater than `max`.=0A=
   * @param {string=3D} required Sets `required` validation error key if =
the value is not entered.=0A=
   * @param {string=3D} ngRequired Adds `required` attribute and =
`required` validation constraint to=0A=
   *    the element when the ngRequired expression evaluates to true. =
Use `ngRequired` instead of=0A=
   *    `required` when you want to data-bind to the `required` =
attribute.=0A=
   * @param {number=3D} ngMinlength Sets `minlength` validation error =
key if the value is shorter than=0A=
   *    minlength.=0A=
   * @param {number=3D} ngMaxlength Sets `maxlength` validation error =
key if the value is longer than=0A=
   *    maxlength.=0A=
   * @param {string=3D} ngPattern Sets `pattern` validation error key if =
the value does not match the=0A=
   *    RegExp pattern expression. Expected value is `/regexp/` for =
inline patterns or `regexp` for=0A=
   *    patterns defined as scope expressions.=0A=
   * @param {string=3D} ngChange Angular expression to be executed when =
input changes due to user=0A=
   *    interaction with the input element.=0A=
   *=0A=
   * @example=0A=
      &lt;example name=3D"number-input-directive" =
module=3D"numberExample"&gt;=0A=
        &lt;file name=3D"todoList.html"&gt;=0A=
         &lt;script&gt;=0A=
           angular.module('numberExample', [])=0A=
             .controller('ExampleController', ['$scope', =
function($scope) {=0A=
               $scope.value =3D 12;=0A=
             }]);=0A=
         &lt;/script&gt;=0A=
         &lt;form name=3D"myForm" ng-controller=3D"ExampleController"&gt;=0A=
           Number: &lt;input type=3D"number" name=3D"input" =
ng-model=3D"value"=0A=
                          min=3D"0" max=3D"99" required&gt;=0A=
           &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.required"&gt;=0A=
             Required!&lt;/span&gt;=0A=
           &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.number"&gt;=0A=
             Not valid number!&lt;/span&gt;=0A=
           &lt;tt&gt;value =3D {{value}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.input.$valid =3D =
{{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.input.$error =3D =
{{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.$valid =3D =
{{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.$error.required =3D =
{{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;=0A=
          &lt;/form&gt;=0A=
        &lt;/file&gt;=0A=
        &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
          var value =3D element(by.binding('value'));=0A=
          var valid =3D element(by.binding('myForm.input.$valid'));=0A=
          var input =3D element(by.model('value'));=0A=
=0A=
          it('should initialize to model', function() {=0A=
            expect(value.getText()).toContain('12');=0A=
            expect(valid.getText()).toContain('true');=0A=
          });=0A=
=0A=
          it('should be invalid if empty', function() {=0A=
            input.clear();=0A=
            input.sendKeys('');=0A=
            expect(value.getText()).toEqual('value =3D');=0A=
            expect(valid.getText()).toContain('false');=0A=
          });=0A=
=0A=
          it('should be invalid if over max', function() {=0A=
            input.clear();=0A=
            input.sendKeys('123');=0A=
            expect(value.getText()).toEqual('value =3D');=0A=
            expect(valid.getText()).toContain('false');=0A=
          });=0A=
        &lt;/file&gt;=0A=
      &lt;/example&gt;=0A=
   */=0A=
  'number': numberInputType,=0A=
=0A=
=0A=
  /**=0A=
   * @ngdoc input=0A=
   * @name input[url]=0A=
   *=0A=
   * @description=0A=
   * Text input with URL validation. Sets the `url` validation error key =
if the content is not a=0A=
   * valid URL.=0A=
   *=0A=
   * @param {string} ngModel Assignable angular expression to data-bind =
to.=0A=
   * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
   * @param {string=3D} required Sets `required` validation error key if =
the value is not entered.=0A=
   * @param {string=3D} ngRequired Adds `required` attribute and =
`required` validation constraint to=0A=
   *    the element when the ngRequired expression evaluates to true. =
Use `ngRequired` instead of=0A=
   *    `required` when you want to data-bind to the `required` =
attribute.=0A=
   * @param {number=3D} ngMinlength Sets `minlength` validation error =
key if the value is shorter than=0A=
   *    minlength.=0A=
   * @param {number=3D} ngMaxlength Sets `maxlength` validation error =
key if the value is longer than=0A=
   *    maxlength.=0A=
   * @param {string=3D} ngPattern Sets `pattern` validation error key if =
the value does not match the=0A=
   *    RegExp pattern expression. Expected value is `/regexp/` for =
inline patterns or `regexp` for=0A=
   *    patterns defined as scope expressions.=0A=
   * @param {string=3D} ngChange Angular expression to be executed when =
input changes due to user=0A=
   *    interaction with the input element.=0A=
   *=0A=
   * @example=0A=
      &lt;example name=3D"url-input-directive" module=3D"urlExample"&gt;=0A=
        &lt;file name=3D"todoList.html"&gt;=0A=
         &lt;script&gt;=0A=
           angular.module('urlExample', [])=0A=
             .controller('ExampleController', ['$scope', =
function($scope) {=0A=
               $scope.text =3D 'http://google.com';=0A=
             }]);=0A=
         &lt;/script&gt;=0A=
         &lt;form name=3D"myForm" ng-controller=3D"ExampleController"&gt;=0A=
           URL: &lt;input type=3D"url" name=3D"input" ng-model=3D"text" =
required&gt;=0A=
           &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.required"&gt;=0A=
             Required!&lt;/span&gt;=0A=
           &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.url"&gt;=0A=
             Not valid url!&lt;/span&gt;=0A=
           &lt;tt&gt;text =3D {{text}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.input.$valid =3D =
{{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.input.$error =3D =
{{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.$valid =3D =
{{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.$error.required =3D =
{{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;myForm.$error.url =3D =
{{!!myForm.$error.url}}&lt;/tt&gt;&lt;br/&gt;=0A=
          &lt;/form&gt;=0A=
        &lt;/file&gt;=0A=
        &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
          var text =3D element(by.binding('text'));=0A=
          var valid =3D element(by.binding('myForm.input.$valid'));=0A=
          var input =3D element(by.model('text'));=0A=
=0A=
          it('should initialize to model', function() {=0A=
            expect(text.getText()).toContain('http://google.com');=0A=
            expect(valid.getText()).toContain('true');=0A=
          });=0A=
=0A=
          it('should be invalid if empty', function() {=0A=
            input.clear();=0A=
            input.sendKeys('');=0A=
=0A=
            expect(text.getText()).toEqual('text =3D');=0A=
            expect(valid.getText()).toContain('false');=0A=
          });=0A=
=0A=
          it('should be invalid if not url', function() {=0A=
            input.clear();=0A=
            input.sendKeys('box');=0A=
=0A=
            expect(valid.getText()).toContain('false');=0A=
          });=0A=
        &lt;/file&gt;=0A=
      &lt;/example&gt;=0A=
   */=0A=
  'url': urlInputType,=0A=
=0A=
=0A=
  /**=0A=
   * @ngdoc input=0A=
   * @name input[email]=0A=
   *=0A=
   * @description=0A=
   * Text input with email validation. Sets the `email` validation error =
key if not a valid email=0A=
   * address.=0A=
   *=0A=
   * @param {string} ngModel Assignable angular expression to data-bind =
to.=0A=
   * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
   * @param {string=3D} required Sets `required` validation error key if =
the value is not entered.=0A=
   * @param {string=3D} ngRequired Adds `required` attribute and =
`required` validation constraint to=0A=
   *    the element when the ngRequired expression evaluates to true. =
Use `ngRequired` instead of=0A=
   *    `required` when you want to data-bind to the `required` =
attribute.=0A=
   * @param {number=3D} ngMinlength Sets `minlength` validation error =
key if the value is shorter than=0A=
   *    minlength.=0A=
   * @param {number=3D} ngMaxlength Sets `maxlength` validation error =
key if the value is longer than=0A=
   *    maxlength.=0A=
   * @param {string=3D} ngPattern Sets `pattern` validation error key if =
the value does not match the=0A=
   *    RegExp pattern expression. Expected value is `/regexp/` for =
inline patterns or `regexp` for=0A=
   *    patterns defined as scope expressions.=0A=
   * @param {string=3D} ngChange Angular expression to be executed when =
input changes due to user=0A=
   *    interaction with the input element.=0A=
   *=0A=
   * @example=0A=
      &lt;example name=3D"email-input-directive" =
module=3D"emailExample"&gt;=0A=
        &lt;file name=3D"todoList.html"&gt;=0A=
         &lt;script&gt;=0A=
           angular.module('emailExample', [])=0A=
             .controller('ExampleController', ['$scope', =
function($scope) {=0A=
               $scope.text =3D 'me@example.com';=0A=
             }]);=0A=
         &lt;/script&gt;=0A=
           &lt;form name=3D"myForm" =
ng-controller=3D"ExampleController"&gt;=0A=
             Email: &lt;input type=3D"email" name=3D"input" =
ng-model=3D"text" required&gt;=0A=
             &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.required"&gt;=0A=
               Required!&lt;/span&gt;=0A=
             &lt;span class=3D"error" =
ng-show=3D"myForm.input.$error.email"&gt;=0A=
               Not valid email!&lt;/span&gt;=0A=
             &lt;tt&gt;text =3D {{text}}&lt;/tt&gt;&lt;br/&gt;=0A=
             &lt;tt&gt;myForm.input.$valid =3D =
{{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
             &lt;tt&gt;myForm.input.$error =3D =
{{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;=0A=
             &lt;tt&gt;myForm.$valid =3D =
{{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
             &lt;tt&gt;myForm.$error.required =3D =
{{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;=0A=
             &lt;tt&gt;myForm.$error.email =3D =
{{!!myForm.$error.email}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;/form&gt;=0A=
         &lt;/file&gt;=0A=
        &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
          var text =3D element(by.binding('text'));=0A=
          var valid =3D element(by.binding('myForm.input.$valid'));=0A=
          var input =3D element(by.model('text'));=0A=
=0A=
          it('should initialize to model', function() {=0A=
            expect(text.getText()).toContain('me@example.com');=0A=
            expect(valid.getText()).toContain('true');=0A=
          });=0A=
=0A=
          it('should be invalid if empty', function() {=0A=
            input.clear();=0A=
            input.sendKeys('');=0A=
            expect(text.getText()).toEqual('text =3D');=0A=
            expect(valid.getText()).toContain('false');=0A=
          });=0A=
=0A=
          it('should be invalid if not email', function() {=0A=
            input.clear();=0A=
            input.sendKeys('xxx');=0A=
=0A=
            expect(valid.getText()).toContain('false');=0A=
          });=0A=
        &lt;/file&gt;=0A=
      &lt;/example&gt;=0A=
   */=0A=
  'email': emailInputType,=0A=
=0A=
=0A=
  /**=0A=
   * @ngdoc input=0A=
   * @name input[radio]=0A=
   *=0A=
   * @description=0A=
   * HTML radio button.=0A=
   *=0A=
   * @param {string} ngModel Assignable angular expression to data-bind =
to.=0A=
   * @param {string} value The value to which the expression should be =
set when selected.=0A=
   * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
   * @param {string=3D} ngChange Angular expression to be executed when =
input changes due to user=0A=
   *    interaction with the input element.=0A=
   * @param {string} ngValue Angular expression which sets the value to =
which the expression should=0A=
   *    be set when selected.=0A=
   *=0A=
   * @example=0A=
      &lt;example name=3D"radio-input-directive" =
module=3D"radioExample"&gt;=0A=
        &lt;file name=3D"todoList.html"&gt;=0A=
         &lt;script&gt;=0A=
           angular.module('radioExample', [])=0A=
             .controller('ExampleController', ['$scope', =
function($scope) {=0A=
               $scope.color =3D 'blue';=0A=
               $scope.specialValue =3D {=0A=
                 "id": "12345",=0A=
                 "value": "green"=0A=
               };=0A=
             }]);=0A=
         &lt;/script&gt;=0A=
         &lt;form name=3D"myForm" ng-controller=3D"ExampleController"&gt;=0A=
           &lt;input type=3D"radio" ng-model=3D"color" value=3D"red"&gt; =
 Red &lt;br/&gt;=0A=
           &lt;input type=3D"radio" ng-model=3D"color" =
ng-value=3D"specialValue"&gt; Green &lt;br/&gt;=0A=
           &lt;input type=3D"radio" ng-model=3D"color" =
value=3D"blue"&gt; Blue &lt;br/&gt;=0A=
           &lt;tt&gt;color =3D {{color | json}}&lt;/tt&gt;&lt;br/&gt;=0A=
          &lt;/form&gt;=0A=
          Note that `ng-value=3D"specialValue"` sets radio item's value =
to be the value of `$scope.specialValue`.=0A=
        &lt;/file&gt;=0A=
        &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
          it('should change state', function() {=0A=
            var color =3D element(by.binding('color'));=0A=
=0A=
            expect(color.getText()).toContain('blue');=0A=
=0A=
            element.all(by.model('color')).get(0).click();=0A=
=0A=
            expect(color.getText()).toContain('red');=0A=
          });=0A=
        &lt;/file&gt;=0A=
      &lt;/example&gt;=0A=
   */=0A=
  'radio': radioInputType,=0A=
=0A=
=0A=
  /**=0A=
   * @ngdoc input=0A=
   * @name input[checkbox]=0A=
   *=0A=
   * @description=0A=
   * HTML checkbox.=0A=
   *=0A=
   * @param {string} ngModel Assignable angular expression to data-bind =
to.=0A=
   * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
   * @param {expression=3D} ngTrueValue The value to which the =
expression should be set when selected.=0A=
   * @param {expression=3D} ngFalseValue The value to which the =
expression should be set when not selected.=0A=
   * @param {string=3D} ngChange Angular expression to be executed when =
input changes due to user=0A=
   *    interaction with the input element.=0A=
   *=0A=
   * @example=0A=
      &lt;example name=3D"checkbox-input-directive" =
module=3D"checkboxExample"&gt;=0A=
        &lt;file name=3D"todoList.html"&gt;=0A=
         &lt;script&gt;=0A=
           angular.module('checkboxExample', [])=0A=
             .controller('ExampleController', ['$scope', =
function($scope) {=0A=
               $scope.value1 =3D true;=0A=
               $scope.value2 =3D 'YES'=0A=
             }]);=0A=
         &lt;/script&gt;=0A=
         &lt;form name=3D"myForm" ng-controller=3D"ExampleController"&gt;=0A=
           Value1: &lt;input type=3D"checkbox" ng-model=3D"value1"&gt; =
&lt;br/&gt;=0A=
           Value2: &lt;input type=3D"checkbox" ng-model=3D"value2"=0A=
                          ng-true-value=3D"'YES'" =
ng-false-value=3D"'NO'"&gt; &lt;br/&gt;=0A=
           &lt;tt&gt;value1 =3D {{value1}}&lt;/tt&gt;&lt;br/&gt;=0A=
           &lt;tt&gt;value2 =3D {{value2}}&lt;/tt&gt;&lt;br/&gt;=0A=
          &lt;/form&gt;=0A=
        &lt;/file&gt;=0A=
        &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
          it('should change state', function() {=0A=
            var value1 =3D element(by.binding('value1'));=0A=
            var value2 =3D element(by.binding('value2'));=0A=
=0A=
            expect(value1.getText()).toContain('true');=0A=
            expect(value2.getText()).toContain('YES');=0A=
=0A=
            element(by.model('value1')).click();=0A=
            element(by.model('value2')).click();=0A=
=0A=
            expect(value1.getText()).toContain('false');=0A=
            expect(value2.getText()).toContain('NO');=0A=
          });=0A=
        &lt;/file&gt;=0A=
      &lt;/example&gt;=0A=
   */=0A=
  'checkbox': checkboxInputType,=0A=
=0A=
  'hidden': noop,=0A=
  'button': noop,=0A=
  'submit': noop,=0A=
  'reset': noop,=0A=
  'file': noop=0A=
};=0A=
=0A=
function testFlags(validity, flags) {=0A=
  var i, flag;=0A=
  if (flags) {=0A=
    for (i=3D0; i&lt;flags.length; ++i) {=0A=
      flag =3D flags[i];=0A=
      if (validity[flag]) {=0A=
        return true;=0A=
      }=0A=
    }=0A=
  }=0A=
  return false;=0A=
}=0A=
=0A=
function stringBasedInputType(ctrl) {=0A=
  ctrl.$formatters.push(function(value) {=0A=
    return ctrl.$isEmpty(value) ? value : value.toString();=0A=
  });=0A=
}=0A=
=0A=
function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {=0A=
  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);=0A=
  stringBasedInputType(ctrl);=0A=
}=0A=
=0A=
function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {=0A=
  var validity =3D element.prop(VALIDITY_STATE_PROPERTY);=0A=
  var placeholder =3D element[0].placeholder, noevent =3D {};=0A=
  var type =3D lowercase(element[0].type);=0A=
=0A=
  // In composition mode, users are still inputing intermediate text =
buffer,=0A=
  // hold the listener until composition is done.=0A=
  // More about composition events: =
https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent=0A=
  if (!$sniffer.android) {=0A=
    var composing =3D false;=0A=
=0A=
    element.on('compositionstart', function(data) {=0A=
      composing =3D true;=0A=
    });=0A=
=0A=
    element.on('compositionend', function() {=0A=
      composing =3D false;=0A=
      listener();=0A=
    });=0A=
  }=0A=
=0A=
  var listener =3D function(ev) {=0A=
    if (composing) return;=0A=
    var value =3D element.val(),=0A=
        event =3D ev &amp;&amp; ev.type;=0A=
=0A=
    // IE (11 and under) seem to emit an 'input' event if the =
placeholder value changes.=0A=
    // We don't want to dirty the value when this happens, so we abort =
here. Unfortunately,=0A=
    // IE also sends input events for other non-input-related things, =
(such as focusing on a=0A=
    // form control), so this change is not entirely enough to solve =
this.=0A=
    if (msie &amp;&amp; (ev || noevent).type =3D=3D=3D 'input' =
&amp;&amp; element[0].placeholder !=3D=3D placeholder) {=0A=
      placeholder =3D element[0].placeholder;=0A=
      return;=0A=
    }=0A=
=0A=
    // By default we will trim the value=0A=
    // If the attribute ng-trim exists we will avoid trimming=0A=
    // If input type is 'password', the value is never trimmed=0A=
    if (type !=3D=3D 'password' &amp;&amp; (!attr.ngTrim || attr.ngTrim =
!=3D=3D 'false')) {=0A=
      value =3D trim(value);=0A=
    }=0A=
=0A=
    // If a control is suffering from bad input (due to native =
validators), browsers discard its=0A=
    // value, so it may be necessary to revalidate (by calling =
$setViewValue again) even if the=0A=
    // control's value is the same empty value twice in a row.=0A=
    if (ctrl.$viewValue !=3D=3D value || (value =3D=3D=3D '' &amp;&amp; =
ctrl.$$hasNativeValidators)) {=0A=
      ctrl.$setViewValue(value, event);=0A=
    }=0A=
  };=0A=
=0A=
  // if the browser does support "input" event, we are fine - except on =
IE9 which doesn't fire the=0A=
  // input event on backspace, delete or cut=0A=
  if ($sniffer.hasEvent('input')) {=0A=
    element.on('input', listener);=0A=
  } else {=0A=
    var timeout;=0A=
=0A=
    var deferListener =3D function(ev) {=0A=
      if (!timeout) {=0A=
        timeout =3D $browser.defer(function() {=0A=
          listener(ev);=0A=
          timeout =3D null;=0A=
        });=0A=
      }=0A=
    };=0A=
=0A=
    element.on('keydown', function(event) {=0A=
      var key =3D event.keyCode;=0A=
=0A=
      // ignore=0A=
      //    command            modifiers                   arrows=0A=
      if (key =3D=3D=3D 91 || (15 &lt; key &amp;&amp; key &lt; 19) || =
(37 &lt;=3D key &amp;&amp; key &lt;=3D 40)) return;=0A=
=0A=
      deferListener(event);=0A=
    });=0A=
=0A=
    // if user modifies input value using context menu in IE, we need =
"paste" and "cut" events to catch it=0A=
    if ($sniffer.hasEvent('paste')) {=0A=
      element.on('paste cut', deferListener);=0A=
    }=0A=
  }=0A=
=0A=
  // if user paste into input using mouse on older browser=0A=
  // or form autocomplete on newer browser, we need "change" event to =
catch it=0A=
  element.on('change', listener);=0A=
=0A=
  ctrl.$render =3D function() {=0A=
    element.val(ctrl.$isEmpty(ctrl.$modelValue) ? '' : ctrl.$viewValue);=0A=
  };=0A=
}=0A=
=0A=
function weekParser(isoWeek, existingDate) {=0A=
  if (isDate(isoWeek)) {=0A=
    return isoWeek;=0A=
  }=0A=
=0A=
  if (isString(isoWeek)) {=0A=
    WEEK_REGEXP.lastIndex =3D 0;=0A=
    var parts =3D WEEK_REGEXP.exec(isoWeek);=0A=
    if (parts) {=0A=
      var year =3D +parts[1],=0A=
          week =3D +parts[2],=0A=
          hours =3D 0,=0A=
          minutes =3D 0,=0A=
          seconds =3D 0,=0A=
          milliseconds =3D 0,=0A=
          firstThurs =3D getFirstThursdayOfYear(year),=0A=
          addDays =3D (week - 1) * 7;=0A=
=0A=
      if (existingDate) {=0A=
        hours =3D existingDate.getHours();=0A=
        minutes =3D existingDate.getMinutes();=0A=
        seconds =3D existingDate.getSeconds();=0A=
        milliseconds =3D existingDate.getMilliseconds();=0A=
      }=0A=
=0A=
      return new Date(year, 0, firstThurs.getDate() + addDays, hours, =
minutes, seconds, milliseconds);=0A=
    }=0A=
  }=0A=
=0A=
  return NaN;=0A=
}=0A=
=0A=
function createDateParser(regexp, mapping) {=0A=
  return function(iso, date) {=0A=
    var parts, map;=0A=
=0A=
    if (isDate(iso)) {=0A=
      return iso;=0A=
    }=0A=
=0A=
    if (isString(iso)) {=0A=
      // When a date is JSON'ified to wraps itself inside of an extra=0A=
      // set of double quotes. This makes the date parsing code unable=0A=
      // to match the date string and parse it as a date.=0A=
      if (iso.charAt(0) =3D=3D '"' &amp;&amp; iso.charAt(iso.length-1) =
=3D=3D '"') {=0A=
        iso =3D iso.substring(1, iso.length-1);=0A=
      }=0A=
      if (ISO_DATE_REGEXP.test(iso)) {=0A=
        return new Date(iso);=0A=
      }=0A=
      regexp.lastIndex =3D 0;=0A=
      parts =3D regexp.exec(iso);=0A=
=0A=
      if (parts) {=0A=
        parts.shift();=0A=
        if (date) {=0A=
          map =3D {=0A=
            yyyy: date.getFullYear(),=0A=
            MM: date.getMonth() + 1,=0A=
            dd: date.getDate(),=0A=
            HH: date.getHours(),=0A=
            mm: date.getMinutes(),=0A=
            ss: date.getSeconds(),=0A=
            sss: date.getMilliseconds() / 1000=0A=
          };=0A=
        } else {=0A=
          map =3D { yyyy: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: =
0 };=0A=
        }=0A=
=0A=
        forEach(parts, function(part, index) {=0A=
          if (index &lt; mapping.length) {=0A=
            map[mapping[index]] =3D +part;=0A=
          }=0A=
        });=0A=
        return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, =
map.ss || 0, map.sss * 1000 || 0);=0A=
      }=0A=
    }=0A=
=0A=
    return NaN;=0A=
  };=0A=
}=0A=
=0A=
function createDateInputType(type, regexp, parseDate, format) {=0A=
  return function dynamicDateInputType(scope, element, attr, ctrl, =
$sniffer, $browser, $filter) {=0A=
    badInputChecker(scope, element, attr, ctrl);=0A=
    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);=0A=
    var timezone =3D ctrl &amp;&amp; ctrl.$options &amp;&amp; =
ctrl.$options.timezone;=0A=
    var previousDate;=0A=
=0A=
    ctrl.$$parserName =3D type;=0A=
    ctrl.$parsers.push(function(value) {=0A=
      if (ctrl.$isEmpty(value)) return null;=0A=
      if (regexp.test(value)) {=0A=
        // Note: We cannot read ctrl.$modelValue, as there might be a =
different=0A=
        // parser/formatter in the processing chain so that the model=0A=
        // contains some different data format!=0A=
        var parsedDate =3D parseDate(value, previousDate);=0A=
        if (timezone =3D=3D=3D 'UTC') {=0A=
          parsedDate.setMinutes(parsedDate.getMinutes() - =
parsedDate.getTimezoneOffset());=0A=
        }=0A=
        return parsedDate;=0A=
      }=0A=
      return undefined;=0A=
    });=0A=
=0A=
    ctrl.$formatters.push(function(value) {=0A=
      if (!ctrl.$isEmpty(value)) {=0A=
        if (!isDate(value)) {=0A=
          throw $ngModelMinErr('datefmt', 'Expected `{0}` to be a date', =
value);=0A=
        }=0A=
        previousDate =3D value;=0A=
        if (previousDate &amp;&amp; timezone =3D=3D=3D 'UTC') {=0A=
          var timezoneOffset =3D 60000 * =
previousDate.getTimezoneOffset();=0A=
          previousDate =3D new Date(previousDate.getTime() + =
timezoneOffset);=0A=
        }=0A=
        return $filter('date')(value, format, timezone);=0A=
      } else {=0A=
        previousDate =3D null;=0A=
      }=0A=
      return '';=0A=
    });=0A=
=0A=
    if (isDefined(attr.min) || attr.ngMin) {=0A=
      var minVal;=0A=
      ctrl.$validators.min =3D function(value) {=0A=
        return ctrl.$isEmpty(value) || isUndefined(minVal) || =
parseDate(value) &gt;=3D minVal;=0A=
      };=0A=
      attr.$observe('min', function(val) {=0A=
        minVal =3D parseObservedDateValue(val);=0A=
        ctrl.$validate();=0A=
      });=0A=
    }=0A=
=0A=
    if (isDefined(attr.max) || attr.ngMax) {=0A=
      var maxVal;=0A=
      ctrl.$validators.max =3D function(value) {=0A=
        return ctrl.$isEmpty(value) || isUndefined(maxVal) || =
parseDate(value) &lt;=3D maxVal;=0A=
      };=0A=
      attr.$observe('max', function(val) {=0A=
        maxVal =3D parseObservedDateValue(val);=0A=
        ctrl.$validate();=0A=
      });=0A=
    }=0A=
    // Override the standard $isEmpty to detect invalid dates as well=0A=
    ctrl.$isEmpty =3D function(value) {=0A=
      // Invalid Date: getTime() returns NaN=0A=
      return !value || (value.getTime &amp;&amp; value.getTime() !=3D=3D =
value.getTime());=0A=
    };=0A=
=0A=
    function parseObservedDateValue(val) {=0A=
      return isDefined(val) ? (isDate(val) ? val : parseDate(val)) : =
undefined;=0A=
    }=0A=
  };=0A=
}=0A=
=0A=
function badInputChecker(scope, element, attr, ctrl) {=0A=
  var node =3D element[0];=0A=
  var nativeValidation =3D ctrl.$$hasNativeValidators =3D =
isObject(node.validity);=0A=
  if (nativeValidation) {=0A=
    ctrl.$parsers.push(function(value) {=0A=
      var validity =3D element.prop(VALIDITY_STATE_PROPERTY) || {};=0A=
      // Detect bug in FF35 for input[email] =
(https://bugzilla.mozilla.org/show_bug.cgi?id=3D1064430):=0A=
      // - also sets validity.badInput (should only be =
validity.typeMismatch).=0A=
      // - see =
http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#e-=
mail-state-(type=3Demail)=0A=
      // - can ignore this case as we can still read out the erroneous =
email...=0A=
      return validity.badInput &amp;&amp; !validity.typeMismatch ? =
undefined : value;=0A=
    });=0A=
  }=0A=
}=0A=
=0A=
function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) =
{=0A=
  badInputChecker(scope, element, attr, ctrl);=0A=
  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);=0A=
=0A=
  ctrl.$$parserName =3D 'number';=0A=
  ctrl.$parsers.push(function(value) {=0A=
    if (ctrl.$isEmpty(value))      return null;=0A=
    if (NUMBER_REGEXP.test(value)) return parseFloat(value);=0A=
    return undefined;=0A=
  });=0A=
=0A=
  ctrl.$formatters.push(function(value) {=0A=
    if (!ctrl.$isEmpty(value)) {=0A=
      if (!isNumber(value)) {=0A=
        throw $ngModelMinErr('numfmt', 'Expected `{0}` to be a number', =
value);=0A=
      }=0A=
      value =3D value.toString();=0A=
    }=0A=
    return value;=0A=
  });=0A=
=0A=
  if (attr.min || attr.ngMin) {=0A=
    var minVal;=0A=
    ctrl.$validators.min =3D function(value) {=0A=
      return ctrl.$isEmpty(value) || isUndefined(minVal) || value =
&gt;=3D minVal;=0A=
    };=0A=
=0A=
    attr.$observe('min', function(val) {=0A=
      if (isDefined(val) &amp;&amp; !isNumber(val)) {=0A=
        val =3D parseFloat(val, 10);=0A=
      }=0A=
      minVal =3D isNumber(val) &amp;&amp; !isNaN(val) ? val : undefined;=0A=
      // TODO(matsko): implement validateLater to reduce number of =
validations=0A=
      ctrl.$validate();=0A=
    });=0A=
  }=0A=
=0A=
  if (attr.max || attr.ngMax) {=0A=
    var maxVal;=0A=
    ctrl.$validators.max =3D function(value) {=0A=
      return ctrl.$isEmpty(value) || isUndefined(maxVal) || value =
&lt;=3D maxVal;=0A=
    };=0A=
=0A=
    attr.$observe('max', function(val) {=0A=
      if (isDefined(val) &amp;&amp; !isNumber(val)) {=0A=
        val =3D parseFloat(val, 10);=0A=
      }=0A=
      maxVal =3D isNumber(val) &amp;&amp; !isNaN(val) ? val : undefined;=0A=
      // TODO(matsko): implement validateLater to reduce number of =
validations=0A=
      ctrl.$validate();=0A=
    });=0A=
  }=0A=
}=0A=
=0A=
function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {=0A=
  // Note: no badInputChecker here by purpose as `url` is only a =
validation=0A=
  // in browsers, i.e. we can always read out input.value even if it is =
not valid!=0A=
  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);=0A=
  stringBasedInputType(ctrl);=0A=
=0A=
  ctrl.$$parserName =3D 'url';=0A=
  ctrl.$validators.url =3D function(value) {=0A=
    return ctrl.$isEmpty(value) || URL_REGEXP.test(value);=0A=
  };=0A=
}=0A=
=0A=
function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {=0A=
  // Note: no badInputChecker here by purpose as `url` is only a =
validation=0A=
  // in browsers, i.e. we can always read out input.value even if it is =
not valid!=0A=
  baseInputType(scope, element, attr, ctrl, $sniffer, $browser);=0A=
  stringBasedInputType(ctrl);=0A=
=0A=
  ctrl.$$parserName =3D 'email';=0A=
  ctrl.$validators.email =3D function(value) {=0A=
    return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);=0A=
  };=0A=
}=0A=
=0A=
function radioInputType(scope, element, attr, ctrl) {=0A=
  // make the name unique, if not defined=0A=
  if (isUndefined(attr.name)) {=0A=
    element.attr('name', nextUid());=0A=
  }=0A=
=0A=
  var listener =3D function(ev) {=0A=
    if (element[0].checked) {=0A=
      ctrl.$setViewValue(attr.value, ev &amp;&amp; ev.type);=0A=
    }=0A=
  };=0A=
=0A=
  element.on('click', listener);=0A=
=0A=
  ctrl.$render =3D function() {=0A=
    var value =3D attr.value;=0A=
    element[0].checked =3D (value =3D=3D ctrl.$viewValue);=0A=
  };=0A=
=0A=
  attr.$observe('value', ctrl.$render);=0A=
}=0A=
=0A=
function parseConstantExpr($parse, context, name, expression, fallback) {=0A=
  var parseFn;=0A=
  if (isDefined(expression)) {=0A=
    parseFn =3D $parse(expression);=0A=
    if (!parseFn.constant) {=0A=
      throw minErr('ngModel')('constexpr', 'Expected constant expression =
for `{0}`, but saw ' +=0A=
                                   '`{1}`.', name, expression);=0A=
    }=0A=
    return parseFn(context);=0A=
  }=0A=
  return fallback;=0A=
}=0A=
=0A=
function checkboxInputType(scope, element, attr, ctrl, $sniffer, =
$browser, $filter, $parse) {=0A=
  var trueValue =3D parseConstantExpr($parse, scope, 'ngTrueValue', =
attr.ngTrueValue, true);=0A=
  var falseValue =3D parseConstantExpr($parse, scope, 'ngFalseValue', =
attr.ngFalseValue, false);=0A=
=0A=
  var listener =3D function(ev) {=0A=
    ctrl.$setViewValue(element[0].checked, ev &amp;&amp; ev.type);=0A=
  };=0A=
=0A=
  element.on('click', listener);=0A=
=0A=
  ctrl.$render =3D function() {=0A=
    element[0].checked =3D ctrl.$viewValue;=0A=
  };=0A=
=0A=
  // Override the standard `$isEmpty` because an empty checkbox is never =
equal to the trueValue=0A=
  ctrl.$isEmpty =3D function(value) {=0A=
    return value !=3D=3D trueValue;=0A=
  };=0A=
=0A=
  ctrl.$formatters.push(function(value) {=0A=
    return equals(value, trueValue);=0A=
  });=0A=
=0A=
  ctrl.$parsers.push(function(value) {=0A=
    return value ? trueValue : falseValue;=0A=
  });=0A=
}=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name textarea=0A=
 * @restrict E=0A=
 *=0A=
 * @description=0A=
 * HTML textarea element control with angular data-binding. The =
data-binding and validation=0A=
 * properties of this element are exactly the same as those of the=0A=
 * {@link ng.directive:input input element}.=0A=
 *=0A=
 * @param {string} ngModel Assignable angular expression to data-bind to.=0A=
 * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
 * @param {string=3D} required Sets `required` validation error key if =
the value is not entered.=0A=
 * @param {string=3D} ngRequired Adds `required` attribute and =
`required` validation constraint to=0A=
 *    the element when the ngRequired expression evaluates to true. Use =
`ngRequired` instead of=0A=
 *    `required` when you want to data-bind to the `required` attribute.=0A=
 * @param {number=3D} ngMinlength Sets `minlength` validation error key =
if the value is shorter than=0A=
 *    minlength.=0A=
 * @param {number=3D} ngMaxlength Sets `maxlength` validation error key =
if the value is longer than=0A=
 *    maxlength.=0A=
 * @param {string=3D} ngPattern Sets `pattern` validation error key if =
the value does not match the=0A=
 *    RegExp pattern expression. Expected value is `/regexp/` for inline =
patterns or `regexp` for=0A=
 *    patterns defined as scope expressions.=0A=
 * @param {string=3D} ngChange Angular expression to be executed when =
input changes due to user=0A=
 *    interaction with the input element.=0A=
 * @param {boolean=3D} [ngTrim=3Dtrue] If set to false Angular will not =
automatically trim the input.=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name input=0A=
 * @restrict E=0A=
 *=0A=
 * @description=0A=
 * HTML input element control with angular data-binding. Input control =
follows HTML5 input types=0A=
 * and polyfills the HTML5 validation behavior for older browsers.=0A=
 *=0A=
 * *NOTE* Not every feature offered is available for all input types.=0A=
 *=0A=
 * @param {string} ngModel Assignable angular expression to data-bind to.=0A=
 * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
 * @param {string=3D} required Sets `required` validation error key if =
the value is not entered.=0A=
 * @param {boolean=3D} ngRequired Sets `required` attribute if set to =
true=0A=
 * @param {number=3D} ngMinlength Sets `minlength` validation error key =
if the value is shorter than=0A=
 *    minlength.=0A=
 * @param {number=3D} ngMaxlength Sets `maxlength` validation error key =
if the value is longer than=0A=
 *    maxlength.=0A=
 * @param {string=3D} ngPattern Sets `pattern` validation error key if =
the value does not match the=0A=
 *    RegExp pattern expression. Expected value is `/regexp/` for inline =
patterns or `regexp` for=0A=
 *    patterns defined as scope expressions.=0A=
 * @param {string=3D} ngChange Angular expression to be executed when =
input changes due to user=0A=
 *    interaction with the input element.=0A=
 * @param {boolean=3D} [ngTrim=3Dtrue] If set to false Angular will not =
automatically trim the input.=0A=
 *    This parameter is ignored for input[type=3Dpassword] controls, =
which will never trim the=0A=
 *    input.=0A=
 *=0A=
 * @example=0A=
    &lt;example name=3D"input-directive" module=3D"inputExample"&gt;=0A=
      &lt;file name=3D"todoList.html"&gt;=0A=
       &lt;script&gt;=0A=
          angular.module('inputExample', [])=0A=
            .controller('ExampleController', ['$scope', function($scope) =
{=0A=
              $scope.user =3D {name: 'guest', last: 'visitor'};=0A=
            }]);=0A=
       &lt;/script&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
         &lt;form name=3D"myForm"&gt;=0A=
           User name: &lt;input type=3D"text" name=3D"userName" =
ng-model=3D"user.name" required&gt;=0A=
           &lt;span class=3D"error" =
ng-show=3D"myForm.userName.$error.required"&gt;=0A=
             Required!&lt;/span&gt;&lt;br&gt;=0A=
           Last name: &lt;input type=3D"text" name=3D"lastName" =
ng-model=3D"user.last"=0A=
             ng-minlength=3D"3" ng-maxlength=3D"10"&gt;=0A=
           &lt;span class=3D"error" =
ng-show=3D"myForm.lastName.$error.minlength"&gt;=0A=
             Too short!&lt;/span&gt;=0A=
           &lt;span class=3D"error" =
ng-show=3D"myForm.lastName.$error.maxlength"&gt;=0A=
             Too long!&lt;/span&gt;&lt;br&gt;=0A=
         &lt;/form&gt;=0A=
         &lt;hr&gt;=0A=
         &lt;tt&gt;user =3D {{user}}&lt;/tt&gt;&lt;br/&gt;=0A=
         &lt;tt&gt;myForm.userName.$valid =3D =
{{myForm.userName.$valid}}&lt;/tt&gt;&lt;br&gt;=0A=
         &lt;tt&gt;myForm.userName.$error =3D =
{{myForm.userName.$error}}&lt;/tt&gt;&lt;br&gt;=0A=
         &lt;tt&gt;myForm.lastName.$valid =3D =
{{myForm.lastName.$valid}}&lt;/tt&gt;&lt;br&gt;=0A=
         &lt;tt&gt;myForm.lastName.$error =3D =
{{myForm.lastName.$error}}&lt;/tt&gt;&lt;br&gt;=0A=
         &lt;tt&gt;myForm.$valid =3D =
{{myForm.$valid}}&lt;/tt&gt;&lt;br&gt;=0A=
         &lt;tt&gt;myForm.$error.required =3D =
{{!!myForm.$error.required}}&lt;/tt&gt;&lt;br&gt;=0A=
         &lt;tt&gt;myForm.$error.minlength =3D =
{{!!myForm.$error.minlength}}&lt;/tt&gt;&lt;br&gt;=0A=
         &lt;tt&gt;myForm.$error.maxlength =3D =
{{!!myForm.$error.maxlength}}&lt;/tt&gt;&lt;br&gt;=0A=
       &lt;/div&gt;=0A=
      &lt;/file&gt;=0A=
      &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
        var user =3D element(by.exactBinding('user'));=0A=
        var userNameValid =3D =
element(by.binding('myForm.userName.$valid'));=0A=
        var lastNameValid =3D =
element(by.binding('myForm.lastName.$valid'));=0A=
        var lastNameError =3D =
element(by.binding('myForm.lastName.$error'));=0A=
        var formValid =3D element(by.binding('myForm.$valid'));=0A=
        var userNameInput =3D element(by.model('user.name'));=0A=
        var userLastInput =3D element(by.model('user.last'));=0A=
=0A=
        it('should initialize to model', function() {=0A=
          =
expect(user.getText()).toContain('{"name":"guest","last":"visitor"}');=0A=
          expect(userNameValid.getText()).toContain('true');=0A=
          expect(formValid.getText()).toContain('true');=0A=
        });=0A=
=0A=
        it('should be invalid if empty when required', function() {=0A=
          userNameInput.clear();=0A=
          userNameInput.sendKeys('');=0A=
=0A=
          expect(user.getText()).toContain('{"last":"visitor"}');=0A=
          expect(userNameValid.getText()).toContain('false');=0A=
          expect(formValid.getText()).toContain('false');=0A=
        });=0A=
=0A=
        it('should be valid if empty when min length is set', function() =
{=0A=
          userLastInput.clear();=0A=
          userLastInput.sendKeys('');=0A=
=0A=
          expect(user.getText()).toContain('{"name":"guest","last":""}');=0A=
          expect(lastNameValid.getText()).toContain('true');=0A=
          expect(formValid.getText()).toContain('true');=0A=
        });=0A=
=0A=
        it('should be invalid if less than required min length', =
function() {=0A=
          userLastInput.clear();=0A=
          userLastInput.sendKeys('xx');=0A=
=0A=
          expect(user.getText()).toContain('{"name":"guest"}');=0A=
          expect(lastNameValid.getText()).toContain('false');=0A=
          expect(lastNameError.getText()).toContain('minlength');=0A=
          expect(formValid.getText()).toContain('false');=0A=
        });=0A=
=0A=
        it('should be invalid if longer than max length', function() {=0A=
          userLastInput.clear();=0A=
          userLastInput.sendKeys('some ridiculously long name');=0A=
=0A=
          expect(user.getText()).toContain('{"name":"guest"}');=0A=
          expect(lastNameValid.getText()).toContain('false');=0A=
          expect(lastNameError.getText()).toContain('maxlength');=0A=
          expect(formValid.getText()).toContain('false');=0A=
        });=0A=
      &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
 */=0A=
var inputDirective =3D ['$browser', '$sniffer', '$filter', '$parse',=0A=
    function($browser, $sniffer, $filter, $parse) {=0A=
  return {=0A=
    restrict: 'E',=0A=
    require: ['?ngModel'],=0A=
    link: {=0A=
      pre: function(scope, element, attr, ctrls) {=0A=
        if (ctrls[0]) {=0A=
          (inputType[lowercase(attr.type)] || inputType.text)(scope, =
element, attr, ctrls[0], $sniffer,=0A=
                                                              $browser, =
$filter, $parse);=0A=
        }=0A=
      }=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
var VALID_CLASS =3D 'ng-valid',=0A=
    INVALID_CLASS =3D 'ng-invalid',=0A=
    PRISTINE_CLASS =3D 'ng-pristine',=0A=
    DIRTY_CLASS =3D 'ng-dirty',=0A=
    UNTOUCHED_CLASS =3D 'ng-untouched',=0A=
    TOUCHED_CLASS =3D 'ng-touched',=0A=
    PENDING_CLASS =3D 'ng-pending';=0A=
=0A=
/**=0A=
 * @ngdoc type=0A=
 * @name ngModel.NgModelController=0A=
 *=0A=
 * @property {string} $viewValue Actual string value in the view.=0A=
 * @property {*} $modelValue The value in the model, that the control is =
bound to.=0A=
 * @property {Array.&lt;Function&gt;} $parsers Array of functions to =
execute, as a pipeline, whenever=0A=
       the control reads value from the DOM.  Each function is called, =
in turn, passing the value=0A=
       through to the next. The last return value is used to populate =
the model.=0A=
       Used to sanitize / convert the value as well as validation. For =
validation,=0A=
       the parsers should update the validity state using=0A=
       {@link ngModel.NgModelController#$setValidity $setValidity()},=0A=
       and return `undefined` for invalid values.=0A=
=0A=
 *=0A=
 * @property {Array.&lt;Function&gt;} $formatters Array of functions to =
execute, as a pipeline, whenever=0A=
       the model value changes. Each function is called, in turn, =
passing the value through to the=0A=
       next. Used to format / convert values for display in the control =
and validation.=0A=
 * ```js=0A=
 * function formatter(value) {=0A=
 *   if (value) {=0A=
 *     return value.toUpperCase();=0A=
 *   }=0A=
 * }=0A=
 * ngModel.$formatters.push(formatter);=0A=
 * ```=0A=
 *=0A=
 * @property {Object.&lt;string, function&gt;} $validators A collection =
of validators that are applied=0A=
 *      whenever the model value changes. The key value within the =
object refers to the name of the=0A=
 *      validator while the function refers to the validation operation. =
The validation operation is=0A=
 *      provided with the model value as an argument and must return a =
true or false value depending=0A=
 *      on the response of that validation.=0A=
 *=0A=
 * ```js=0A=
 * ngModel.$validators.validCharacters =3D function(modelValue, =
viewValue) {=0A=
 *   var value =3D modelValue || viewValue;=0A=
 *   return /[0-9]+/.test(value) &amp;&amp;=0A=
 *          /[a-z]+/.test(value) &amp;&amp;=0A=
 *          /[A-Z]+/.test(value) &amp;&amp;=0A=
 *          /\W+/.test(value);=0A=
 * };=0A=
 * ```=0A=
 *=0A=
 * @property {Object.&lt;string, function&gt;} $asyncValidators A =
collection of validations that are expected to=0A=
 *      perform an asynchronous validation (e.g. a HTTP request). The =
validation function that is provided=0A=
 *      is expected to return a promise when it is run during the model =
validation process. Once the promise=0A=
 *      is delivered then the validation status will be set to true when =
fulfilled and false when rejected.=0A=
 *      When the asynchronous validators are triggered, each of the =
validators will run in parallel and the model=0A=
 *      value will only be updated once all validators have been =
fulfilled. Also, keep in mind that all=0A=
 *      asynchronous validators will only run once all synchronous =
validators have passed.=0A=
 *=0A=
 * Please note that if $http is used then it is important that the =
server returns a success HTTP response code=0A=
 * in order to fulfill the validation and a status level of `4xx` in =
order to reject the validation.=0A=
 *=0A=
 * ```js=0A=
 * ngModel.$asyncValidators.uniqueUsername =3D function(modelValue, =
viewValue) {=0A=
 *   var value =3D modelValue || viewValue;=0A=
 *=0A=
 *   // Lookup user by username=0A=
 *   return $http.get('/api/users/' + value).=0A=
 *      then(function resolved() {=0A=
 *        //username exists, this means validation fails=0A=
 *        return $q.reject('exists');=0A=
 *      }, function rejected() {=0A=
 *        //username does not exist, therefore this validation passes=0A=
 *        return true;=0A=
 *      });=0A=
 * };=0A=
 * ```=0A=
 *=0A=
 * @param {string} name The name of the validator.=0A=
 * @param {Function} validationFn The validation function that will be =
run.=0A=
 *=0A=
 * @property {Array.&lt;Function&gt;} $viewChangeListeners Array of =
functions to execute whenever the=0A=
 *     view value has changed. It is called with no arguments, and its =
return value is ignored.=0A=
 *     This can be used in place of additional $watches against the =
model value.=0A=
 *=0A=
 * @property {Object} $error An object hash with all failing validator =
ids as keys.=0A=
 * @property {Object} $pending An object hash with all pending validator =
ids as keys.=0A=
 *=0A=
 * @property {boolean} $untouched True if control has not lost focus yet.=0A=
 * @property {boolean} $touched True if control has lost focus.=0A=
 * @property {boolean} $pristine True if user has not interacted with =
the control yet.=0A=
 * @property {boolean} $dirty True if user has already interacted with =
the control.=0A=
 * @property {boolean} $valid True if there is no error.=0A=
 * @property {boolean} $invalid True if at least one error on the =
control.=0A=
 *=0A=
 * @description=0A=
 *=0A=
 * `NgModelController` provides API for the `ng-model` directive. The =
controller contains=0A=
 * services for data-binding, validation, CSS updates, and value =
formatting and parsing. It=0A=
 * purposefully does not contain any logic which deals with DOM =
rendering or listening to=0A=
 * DOM events. Such DOM related logic should be provided by other =
directives which make use of=0A=
 * `NgModelController` for data-binding.=0A=
 *=0A=
 * ## Custom Control Example=0A=
 * This example shows how to use `NgModelController` with a custom =
control to achieve=0A=
 * data-binding. Notice how different directives (`contenteditable`, =
`ng-model`, and `required`)=0A=
 * collaborate together to achieve the desired result.=0A=
 *=0A=
 * Note that `contenteditable` is an HTML5 attribute, which tells the =
browser to let the element=0A=
 * contents be edited in place by the user.  This will not work on older =
browsers.=0A=
 *=0A=
 * We are using the {@link ng.service:$sce $sce} service here and =
include the {@link ngSanitize $sanitize}=0A=
 * module to automatically remove "bad" content like inline event =
listener (e.g. `&lt;span onclick=3D"..."&gt;`).=0A=
 * However, as we are using `$sce` the model can still decide to to =
provide unsafe content if it marks=0A=
 * that content using the `$sce` service.=0A=
 *=0A=
 * &lt;example name=3D"NgModelController" module=3D"customControl" =
deps=3D"angular-sanitize.js"&gt;=0A=
    &lt;file name=3D"style.css"&gt;=0A=
      [contenteditable] {=0A=
        border: 1px solid black;=0A=
        background-color: white;=0A=
        min-height: 20px;=0A=
      }=0A=
=0A=
      .ng-invalid {=0A=
        border: 1px solid red;=0A=
      }=0A=
=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"script.js"&gt;=0A=
      angular.module('customControl', ['ngSanitize']).=0A=
        directive('contenteditable', ['$sce', function($sce) {=0A=
          return {=0A=
            restrict: 'A', // only activate on element attribute=0A=
            require: '?ngModel', // get a hold of NgModelController=0A=
            link: function(scope, element, attrs, ngModel) {=0A=
              if (!ngModel) return; // do nothing if no ng-model=0A=
=0A=
              // Specify how UI should be updated=0A=
              ngModel.$render =3D function() {=0A=
                element.html($sce.getTrustedHtml(ngModel.$viewValue || =
''));=0A=
              };=0A=
=0A=
              // Listen for change events to enable binding=0A=
              element.on('blur keyup change', function() {=0A=
                scope.$apply(read);=0A=
              });=0A=
              read(); // initialize=0A=
=0A=
              // Write data to the model=0A=
              function read() {=0A=
                var html =3D element.html();=0A=
                // When we clear the content editable the browser leaves =
a &lt;br&gt; behind=0A=
                // If strip-br attribute is provided then we strip this =
out=0A=
                if ( attrs.stripBr &amp;&amp; html =3D=3D '&lt;br&gt;' ) =
{=0A=
                  html =3D '';=0A=
                }=0A=
                ngModel.$setViewValue(html);=0A=
              }=0A=
            }=0A=
          };=0A=
        }]);=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"todoList.html"&gt;=0A=
      &lt;form name=3D"myForm"&gt;=0A=
       &lt;div contenteditable=0A=
            name=3D"myWidget" ng-model=3D"userContent"=0A=
            strip-br=3D"true"=0A=
            required&gt;Change me!&lt;/div&gt;=0A=
        &lt;span =
ng-show=3D"myForm.myWidget.$error.required"&gt;Required!&lt;/span&gt;=0A=
       &lt;hr&gt;=0A=
       &lt;textarea ng-model=3D"userContent"&gt;&lt;/textarea&gt;=0A=
      &lt;/form&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
    it('should data-bind and become invalid', function() {=0A=
      if (browser.params.browser =3D=3D 'safari' || =
browser.params.browser =3D=3D 'firefox') {=0A=
        // SafariDriver can't handle contenteditable=0A=
        // and Firefox driver can't clear contenteditables very well=0A=
        return;=0A=
      }=0A=
      var contentEditable =3D element(by.css('[contenteditable]'));=0A=
      var content =3D 'Change me!';=0A=
=0A=
      expect(contentEditable.getText()).toEqual(content);=0A=
=0A=
      contentEditable.clear();=0A=
      contentEditable.sendKeys(protractor.Key.BACK_SPACE);=0A=
      expect(contentEditable.getText()).toEqual('');=0A=
      =
expect(contentEditable.getAttribute('class')).toMatch(/ng-invalid-require=
d/);=0A=
    });=0A=
    &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 *=0A=
 *=0A=
 */=0A=
var NgModelController =3D ['$scope', '$exceptionHandler', '$attrs', =
'$element', '$parse', '$animate', '$timeout', '$rootScope', '$q', =
'$interpolate',=0A=
    function($scope, $exceptionHandler, $attr, $element, $parse, =
$animate, $timeout, $rootScope, $q, $interpolate) {=0A=
  this.$viewValue =3D Number.NaN;=0A=
  this.$modelValue =3D Number.NaN;=0A=
  this.$validators =3D {};=0A=
  this.$asyncValidators =3D {};=0A=
  this.$parsers =3D [];=0A=
  this.$formatters =3D [];=0A=
  this.$viewChangeListeners =3D [];=0A=
  this.$untouched =3D true;=0A=
  this.$touched =3D false;=0A=
  this.$pristine =3D true;=0A=
  this.$dirty =3D false;=0A=
  this.$valid =3D true;=0A=
  this.$invalid =3D false;=0A=
  this.$error =3D {}; // keep invalid keys here=0A=
  this.$$success =3D {}; // keep valid keys here=0A=
  this.$pending =3D undefined; // keep pending keys here=0A=
  this.$name =3D $interpolate($attr.name || '', false)($scope);=0A=
=0A=
=0A=
  var parsedNgModel =3D $parse($attr.ngModel),=0A=
      pendingDebounce =3D null,=0A=
      ctrl =3D this;=0A=
=0A=
  var ngModelGet =3D function ngModelGet() {=0A=
    var modelValue =3D parsedNgModel($scope);=0A=
    if (ctrl.$options &amp;&amp; ctrl.$options.getterSetter &amp;&amp; =
isFunction(modelValue)) {=0A=
      modelValue =3D modelValue();=0A=
    }=0A=
    return modelValue;=0A=
  };=0A=
=0A=
  var ngModelSet =3D function ngModelSet(newValue) {=0A=
    var getterSetter;=0A=
    if (ctrl.$options &amp;&amp; ctrl.$options.getterSetter &amp;&amp;=0A=
        isFunction(getterSetter =3D parsedNgModel($scope))) {=0A=
=0A=
      getterSetter(ctrl.$modelValue);=0A=
    } else {=0A=
      parsedNgModel.assign($scope, ctrl.$modelValue);=0A=
    }=0A=
  };=0A=
=0A=
  this.$$setOptions =3D function(options) {=0A=
    ctrl.$options =3D options;=0A=
=0A=
    if (!parsedNgModel.assign &amp;&amp; (!options || =
!options.getterSetter)) {=0A=
      throw $ngModelMinErr('nonassign', "Expression '{0}' is =
non-assignable. Element: {1}",=0A=
          $attr.ngModel, startingTag($element));=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name ngModel.NgModelController#$render=0A=
   *=0A=
   * @description=0A=
   * Called when the view needs to be updated. It is expected that the =
user of the ng-model=0A=
   * directive will implement this method.=0A=
   *=0A=
   * The `$render()` method is invoked in the following situations:=0A=
   *=0A=
   * * `$rollbackViewValue()` is called.  If we are rolling back the =
view value to the last=0A=
   *   committed value then `$render()` is called to update the input =
control.=0A=
   * * The value referenced by `ng-model` is changed programmatically =
and both the `$modelValue` and=0A=
   *   the `$viewValue` are different to last time.=0A=
   *=0A=
   * Since `ng-model` does not do a deep watch, `$render()` is only =
invoked if the values of=0A=
   * `$modelValue` and `$viewValue` are actually different to their =
previous value. If `$modelValue`=0A=
   * or `$viewValue` are objects (rather than a string or number) then =
`$render()` will not be=0A=
   * invoked if you only change a property on the objects.=0A=
   */=0A=
  this.$render =3D noop;=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name ngModel.NgModelController#$isEmpty=0A=
   *=0A=
   * @description=0A=
   * This is called when we need to determine if the value of the input =
is empty.=0A=
   *=0A=
   * For instance, the required directive does this to work out if the =
input has data or not.=0A=
   * The default `$isEmpty` function checks whether the value is =
`undefined`, `''`, `null` or `NaN`.=0A=
   *=0A=
   * You can override this for input directives whose concept of being =
empty is different to the=0A=
   * default. The `checkboxInputType` directive does this because in its =
case a value of `false`=0A=
   * implies empty.=0A=
   *=0A=
   * @param {*} value Model value to check.=0A=
   * @returns {boolean} True if `value` is empty.=0A=
   */=0A=
  this.$isEmpty =3D function(value) {=0A=
    return isUndefined(value) || value =3D=3D=3D '' || value =3D=3D=3D =
null || value !=3D=3D value;=0A=
  };=0A=
=0A=
  var parentForm =3D $element.inheritedData('$formController') || =
nullFormCtrl,=0A=
      currentValidationRunId =3D 0;=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name ngModel.NgModelController#$setValidity=0A=
   *=0A=
   * @description=0A=
   * Change the validity state, and notifies the form.=0A=
   *=0A=
   * This method can be called within $parsers/$formatters. However, if =
possible, please use the=0A=
   *        `ngModel.$validators` pipeline which is designed to call =
this method automatically.=0A=
   *=0A=
   * @param {string} validationErrorKey Name of the validator. the =
`validationErrorKey` will assign=0A=
   *        to `$error[validationErrorKey]` and =
`$pending[validationErrorKey]`=0A=
   *        so that it is available for data-binding.=0A=
   *        The `validationErrorKey` should be in camelCase and will get =
converted into dash-case=0A=
   *        for class name. Example: `myError` will result in =
`ng-valid-my-error` and `ng-invalid-my-error`=0A=
   *        class and can be bound to as  =
`{{someForm.someControl.$error.myError}}` .=0A=
   * @param {boolean} isValid Whether the current state is valid (true), =
invalid (false), pending (undefined),=0A=
   *                          or skipped (null).=0A=
   */=0A=
  addSetValidityMethod({=0A=
    ctrl: this,=0A=
    $element: $element,=0A=
    set: function(object, property) {=0A=
      object[property] =3D true;=0A=
    },=0A=
    unset: function(object, property) {=0A=
      delete object[property];=0A=
    },=0A=
    parentForm: parentForm,=0A=
    $animate: $animate=0A=
  });=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name ngModel.NgModelController#$setPristine=0A=
   *=0A=
   * @description=0A=
   * Sets the control to its pristine state.=0A=
   *=0A=
   * This method can be called to remove the 'ng-dirty' class and set =
the control to its pristine=0A=
   * state (ng-pristine class). A model is considered to be pristine =
when the model has not been changed=0A=
   * from when first compiled within then form.=0A=
   */=0A=
  this.$setPristine =3D function () {=0A=
    ctrl.$dirty =3D false;=0A=
    ctrl.$pristine =3D true;=0A=
    $animate.removeClass($element, DIRTY_CLASS);=0A=
    $animate.addClass($element, PRISTINE_CLASS);=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name ngModel.NgModelController#$setUntouched=0A=
   *=0A=
   * @description=0A=
   * Sets the control to its untouched state.=0A=
   *=0A=
   * This method can be called to remove the 'ng-touched' class and set =
the control to its=0A=
   * untouched state (ng-untouched class). Upon compilation, a model is =
set as untouched=0A=
   * by default, however this function can be used to restore that state =
if the model has=0A=
   * already been touched by the user.=0A=
   */=0A=
  this.$setUntouched =3D function() {=0A=
    ctrl.$touched =3D false;=0A=
    ctrl.$untouched =3D true;=0A=
    $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name ngModel.NgModelController#$setTouched=0A=
   *=0A=
   * @description=0A=
   * Sets the control to its touched state.=0A=
   *=0A=
   * This method can be called to remove the 'ng-untouched' class and =
set the control to its=0A=
   * touched state (ng-touched class). A model is considered to be =
touched when the user has=0A=
   * first interacted (focussed) on the model input element and then =
shifted focus away (blurred)=0A=
   * from the input element.=0A=
   */=0A=
  this.$setTouched =3D function() {=0A=
    ctrl.$touched =3D true;=0A=
    ctrl.$untouched =3D false;=0A=
    $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name ngModel.NgModelController#$rollbackViewValue=0A=
   *=0A=
   * @description=0A=
   * Cancel an update and reset the input element's value to prevent an =
update to the `$modelValue`,=0A=
   * which may be caused by a pending debounced event or because the =
input is waiting for a some=0A=
   * future event.=0A=
   *=0A=
   * If you have an input that uses `ng-model-options` to set up =
debounced events or events such=0A=
   * as blur you can have a situation where there is a period when the =
`$viewValue`=0A=
   * is out of synch with the ngModel's `$modelValue`.=0A=
   *=0A=
   * In this case, you can run into difficulties if you try to update =
the ngModel's `$modelValue`=0A=
   * programmatically before these debounced/future events have =
resolved/occurred, because Angular's=0A=
   * dirty checking mechanism is not able to tell whether the model has =
actually changed or not.=0A=
   *=0A=
   * The `$rollbackViewValue()` method should be called before =
programmatically changing the model of an=0A=
   * input which may have such events pending. This is important in =
order to make sure that the=0A=
   * input field will be updated with the new model value and any =
pending operations are cancelled.=0A=
   *=0A=
   * &lt;example name=3D"ng-model-cancel-update" =
module=3D"cancel-update-example"&gt;=0A=
   *   &lt;file name=3D"app.js"&gt;=0A=
   *     angular.module('cancel-update-example', [])=0A=
   *=0A=
   *     .controller('CancelUpdateController', ['$scope', =
function($scope) {=0A=
   *       $scope.resetWithCancel =3D function (e) {=0A=
   *         if (e.keyCode =3D=3D 27) {=0A=
   *           $scope.myForm.myInput1.$rollbackViewValue();=0A=
   *           $scope.myValue =3D '';=0A=
   *         }=0A=
   *       };=0A=
   *       $scope.resetWithoutCancel =3D function (e) {=0A=
   *         if (e.keyCode =3D=3D 27) {=0A=
   *           $scope.myValue =3D '';=0A=
   *         }=0A=
   *       };=0A=
   *     }]);=0A=
   *   &lt;/file&gt;=0A=
   *   &lt;file name=3D"todoList.html"&gt;=0A=
   *     &lt;div ng-controller=3D"CancelUpdateController"&gt;=0A=
   *       &lt;p&gt;Try typing something in each input.  See that the =
model only updates when you=0A=
   *          blur off the input.=0A=
   *        &lt;/p&gt;=0A=
   *        &lt;p&gt;Now see what happens if you start typing then press =
the Escape key&lt;/p&gt;=0A=
   *=0A=
   *       &lt;form name=3D"myForm" ng-model-options=3D"{ updateOn: =
'blur' }"&gt;=0A=
   *         &lt;p&gt;With $rollbackViewValue()&lt;/p&gt;=0A=
   *         &lt;input name=3D"myInput1" ng-model=3D"myValue" =
ng-keydown=3D"resetWithCancel($event)"&gt;&lt;br/&gt;=0A=
   *         myValue: "{{ myValue }}"=0A=
   *=0A=
   *         &lt;p&gt;Without $rollbackViewValue()&lt;/p&gt;=0A=
   *         &lt;input name=3D"myInput2" ng-model=3D"myValue" =
ng-keydown=3D"resetWithoutCancel($event)"&gt;&lt;br/&gt;=0A=
   *         myValue: "{{ myValue }}"=0A=
   *       &lt;/form&gt;=0A=
   *     &lt;/div&gt;=0A=
   *   &lt;/file&gt;=0A=
   * &lt;/example&gt;=0A=
   */=0A=
  this.$rollbackViewValue =3D function() {=0A=
    $timeout.cancel(pendingDebounce);=0A=
    ctrl.$viewValue =3D ctrl.$$lastCommittedViewValue;=0A=
    ctrl.$render();=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name ngModel.NgModelController#$validate=0A=
   *=0A=
   * @description=0A=
   * Runs each of the registered validators (first synchronous =
validators and then asynchronous validators).=0A=
   */=0A=
  this.$validate =3D function() {=0A=
    // ignore $validate before model is initialized=0A=
    if (isNumber(ctrl.$modelValue) &amp;&amp; isNaN(ctrl.$modelValue)) {=0A=
      return;=0A=
    }=0A=
    this.$$parseAndValidate();=0A=
  };=0A=
=0A=
  this.$$runValidators =3D function(parseValid, modelValue, viewValue, =
doneCallback) {=0A=
    currentValidationRunId++;=0A=
    var localValidationRunId =3D currentValidationRunId;=0A=
=0A=
    // check parser error=0A=
    if (!processParseErrors(parseValid)) {=0A=
      validationDone(false);=0A=
      return;=0A=
    }=0A=
    if (!processSyncValidators()) {=0A=
      validationDone(false);=0A=
      return;=0A=
    }=0A=
    processAsyncValidators();=0A=
=0A=
    function processParseErrors(parseValid) {=0A=
      var errorKey =3D ctrl.$$parserName || 'parse';=0A=
      if (parseValid =3D=3D=3D undefined) {=0A=
        setValidity(errorKey, null);=0A=
      } else {=0A=
        setValidity(errorKey, parseValid);=0A=
        if (!parseValid) {=0A=
          forEach(ctrl.$validators, function(v, name) {=0A=
            setValidity(name, null);=0A=
          });=0A=
          forEach(ctrl.$asyncValidators, function(v, name) {=0A=
            setValidity(name, null);=0A=
          });=0A=
          return false;=0A=
        }=0A=
      }=0A=
      return true;=0A=
    }=0A=
=0A=
    function processSyncValidators() {=0A=
      var syncValidatorsValid =3D true;=0A=
      forEach(ctrl.$validators, function(validator, name) {=0A=
        var result =3D validator(modelValue, viewValue);=0A=
        syncValidatorsValid =3D syncValidatorsValid &amp;&amp; result;=0A=
        setValidity(name, result);=0A=
      });=0A=
      if (!syncValidatorsValid) {=0A=
        forEach(ctrl.$asyncValidators, function(v, name) {=0A=
          setValidity(name, null);=0A=
        });=0A=
        return false;=0A=
      }=0A=
      return true;=0A=
    }=0A=
=0A=
    function processAsyncValidators() {=0A=
      var validatorPromises =3D [];=0A=
      var allValid =3D true;=0A=
      forEach(ctrl.$asyncValidators, function(validator, name) {=0A=
        var promise =3D validator(modelValue, viewValue);=0A=
        if (!isPromiseLike(promise)) {=0A=
          throw $ngModelMinErr("$asyncValidators",=0A=
            "Expected asynchronous validator to return a promise but got =
'{0}' instead.", promise);=0A=
        }=0A=
        setValidity(name, undefined);=0A=
        validatorPromises.push(promise.then(function() {=0A=
          setValidity(name, true);=0A=
        }, function(error) {=0A=
          allValid =3D false;=0A=
          setValidity(name, false);=0A=
        }));=0A=
      });=0A=
      if (!validatorPromises.length) {=0A=
        validationDone(true);=0A=
      } else {=0A=
        $q.all(validatorPromises).then(function() {=0A=
          validationDone(allValid);=0A=
        }, noop);=0A=
      }=0A=
    }=0A=
=0A=
    function setValidity(name, isValid) {=0A=
      if (localValidationRunId =3D=3D=3D currentValidationRunId) {=0A=
        ctrl.$setValidity(name, isValid);=0A=
      }=0A=
    }=0A=
=0A=
    function validationDone(allValid) {=0A=
      if (localValidationRunId =3D=3D=3D currentValidationRunId) {=0A=
=0A=
        doneCallback(allValid);=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name ngModel.NgModelController#$commitViewValue=0A=
   *=0A=
   * @description=0A=
   * Commit a pending update to the `$modelValue`.=0A=
   *=0A=
   * Updates may be pending by a debounced event or because the input is =
waiting for a some future=0A=
   * event defined in `ng-model-options`. this method is rarely needed =
as `NgModelController`=0A=
   * usually handles calling this in response to input events.=0A=
   */=0A=
  this.$commitViewValue =3D function() {=0A=
    var viewValue =3D ctrl.$viewValue;=0A=
=0A=
    $timeout.cancel(pendingDebounce);=0A=
=0A=
    // If the view value has not changed then we should just exit, =
except in the case where there is=0A=
    // a native validator on the element. In this case the validation =
state may have changed even though=0A=
    // the viewValue has stayed empty.=0A=
    if (ctrl.$$lastCommittedViewValue =3D=3D=3D viewValue &amp;&amp; =
(viewValue !=3D=3D '' || !ctrl.$$hasNativeValidators)) {=0A=
      return;=0A=
    }=0A=
    ctrl.$$lastCommittedViewValue =3D viewValue;=0A=
=0A=
    // change to dirty=0A=
    if (ctrl.$pristine) {=0A=
      ctrl.$dirty =3D true;=0A=
      ctrl.$pristine =3D false;=0A=
      $animate.removeClass($element, PRISTINE_CLASS);=0A=
      $animate.addClass($element, DIRTY_CLASS);=0A=
      parentForm.$setDirty();=0A=
    }=0A=
    this.$$parseAndValidate();=0A=
  };=0A=
=0A=
  this.$$parseAndValidate =3D function() {=0A=
    var viewValue =3D ctrl.$$lastCommittedViewValue;=0A=
    var modelValue =3D viewValue;=0A=
    var parserValid =3D isUndefined(modelValue) ? undefined : true;=0A=
=0A=
    if (parserValid) {=0A=
      for(var i =3D 0; i &lt; ctrl.$parsers.length; i++) {=0A=
        modelValue =3D ctrl.$parsers[i](modelValue);=0A=
        if (isUndefined(modelValue)) {=0A=
          parserValid =3D false;=0A=
          break;=0A=
        }=0A=
      }=0A=
    }=0A=
    if (isNumber(ctrl.$modelValue) &amp;&amp; isNaN(ctrl.$modelValue)) {=0A=
      // ctrl.$modelValue has not been touched yet...=0A=
      ctrl.$modelValue =3D ngModelGet();=0A=
    }=0A=
    var prevModelValue =3D ctrl.$modelValue;=0A=
    var allowInvalid =3D ctrl.$options &amp;&amp; =
ctrl.$options.allowInvalid;=0A=
    if (allowInvalid) {=0A=
      ctrl.$modelValue =3D modelValue;=0A=
      writeToModelIfNeeded();=0A=
    }=0A=
    ctrl.$$runValidators(parserValid, modelValue, viewValue, =
function(allValid) {=0A=
      if (!allowInvalid) {=0A=
        // Note: Don't check ctrl.$valid here, as we could have=0A=
        // external validators (e.g. calculated on the server),=0A=
        // that just call $setValidity and need the model value=0A=
        // to calculate their validity.=0A=
        ctrl.$modelValue =3D allValid ? modelValue : undefined;=0A=
        writeToModelIfNeeded();=0A=
      }=0A=
    });=0A=
=0A=
    function writeToModelIfNeeded() {=0A=
      if (ctrl.$modelValue !=3D=3D prevModelValue) {=0A=
        ctrl.$$writeModelToScope();=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  this.$$writeModelToScope =3D function() {=0A=
    ngModelSet(ctrl.$modelValue);=0A=
    forEach(ctrl.$viewChangeListeners, function(listener) {=0A=
      try {=0A=
        listener();=0A=
      } catch(e) {=0A=
        $exceptionHandler(e);=0A=
      }=0A=
    });=0A=
  };=0A=
=0A=
  /**=0A=
   * @ngdoc method=0A=
   * @name ngModel.NgModelController#$setViewValue=0A=
   *=0A=
   * @description=0A=
   * Update the view value.=0A=
   *=0A=
   * This method should be called when an input directive want to change =
the view value; typically,=0A=
   * this is done from within a DOM event handler.=0A=
   *=0A=
   * For example {@link ng.directive:input input} calls it when the =
value of the input changes and=0A=
   * {@link ng.directive:select select} calls it when an option is =
selected.=0A=
   *=0A=
   * If the new `value` is an object (rather than a string or a number), =
we should make a copy of the=0A=
   * object before passing it to `$setViewValue`.  This is because =
`ngModel` does not perform a deep=0A=
   * watch of objects, it only looks for a change of identity. If you =
only change the property of=0A=
   * the object then ngModel will not realise that the object has =
changed and will not invoke the=0A=
   * `$parsers` and `$validators` pipelines.=0A=
   *=0A=
   * For this reason, you should not change properties of the copy once =
it has been passed to=0A=
   * `$setViewValue`. Otherwise you may cause the model value on the =
scope to change incorrectly.=0A=
   *=0A=
   * When this method is called, the new `value` will be staged for =
committing through the `$parsers`=0A=
   * and `$validators` pipelines. If there are no special {@link =
ngModelOptions} specified then the staged=0A=
   * value sent directly for processing, finally to be applied to =
`$modelValue` and then the=0A=
   * **expression** specified in the `ng-model` attribute.=0A=
   *=0A=
   * Lastly, all the registered change listeners, in the =
`$viewChangeListeners` list, are called.=0A=
   *=0A=
   * In case the {@link ng.directive:ngModelOptions ngModelOptions} =
directive is used with `updateOn`=0A=
   * and the `default` trigger is not listed, all those actions will =
remain pending until one of the=0A=
   * `updateOn` events is triggered on the DOM element.=0A=
   * All these actions will be debounced if the {@link =
ng.directive:ngModelOptions ngModelOptions}=0A=
   * directive is used with a custom debounce for this particular event.=0A=
   *=0A=
   * Note that calling this function does not trigger a `$digest`.=0A=
   *=0A=
   * @param {string} value Value from the view.=0A=
   * @param {string} trigger Event that triggered the update.=0A=
   */=0A=
  this.$setViewValue =3D function(value, trigger) {=0A=
    ctrl.$viewValue =3D value;=0A=
    if (!ctrl.$options || ctrl.$options.updateOnDefault) {=0A=
      ctrl.$$debounceViewValueCommit(trigger);=0A=
    }=0A=
  };=0A=
=0A=
  this.$$debounceViewValueCommit =3D function(trigger) {=0A=
    var debounceDelay =3D 0,=0A=
        options =3D ctrl.$options,=0A=
        debounce;=0A=
=0A=
    if (options &amp;&amp; isDefined(options.debounce)) {=0A=
      debounce =3D options.debounce;=0A=
      if (isNumber(debounce)) {=0A=
        debounceDelay =3D debounce;=0A=
      } else if (isNumber(debounce[trigger])) {=0A=
        debounceDelay =3D debounce[trigger];=0A=
      } else if (isNumber(debounce['default'])) {=0A=
        debounceDelay =3D debounce['default'];=0A=
      }=0A=
    }=0A=
=0A=
    $timeout.cancel(pendingDebounce);=0A=
    if (debounceDelay) {=0A=
      pendingDebounce =3D $timeout(function() {=0A=
        ctrl.$commitViewValue();=0A=
      }, debounceDelay);=0A=
    } else if ($rootScope.$$phase) {=0A=
      ctrl.$commitViewValue();=0A=
    } else {=0A=
      $scope.$apply(function() {=0A=
        ctrl.$commitViewValue();=0A=
      });=0A=
    }=0A=
  };=0A=
=0A=
  // model -&gt; value=0A=
  // Note: we cannot use a normal scope.$watch as we want to detect the =
following:=0A=
  // 1. scope value is 'a'=0A=
  // 2. user enters 'b'=0A=
  // 3. ng-change kicks in and reverts scope value to 'a'=0A=
  //    -&gt; scope value did not change since the last digest as=0A=
  //       ng-change executes in apply phase=0A=
  // 4. view should be changed back to 'a'=0A=
  $scope.$watch(function ngModelWatch() {=0A=
    var modelValue =3D ngModelGet();=0A=
=0A=
    // if scope model value and ngModel value are out of sync=0A=
    // TODO(perf): why not move this to the action fn?=0A=
    if (modelValue !=3D=3D ctrl.$modelValue) {=0A=
      ctrl.$modelValue =3D modelValue;=0A=
=0A=
      var formatters =3D ctrl.$formatters,=0A=
          idx =3D formatters.length;=0A=
=0A=
      var viewValue =3D modelValue;=0A=
      while(idx--) {=0A=
        viewValue =3D formatters[idx](viewValue);=0A=
      }=0A=
      if (ctrl.$viewValue !=3D=3D viewValue) {=0A=
        ctrl.$viewValue =3D ctrl.$$lastCommittedViewValue =3D viewValue;=0A=
        ctrl.$render();=0A=
=0A=
        ctrl.$$runValidators(undefined, modelValue, viewValue, noop);=0A=
      }=0A=
    }=0A=
=0A=
    return modelValue;=0A=
  });=0A=
}];=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngModel=0A=
 *=0A=
 * @element input=0A=
 *=0A=
 * @description=0A=
 * The `ngModel` directive binds an `input`,`select`, `textarea` (or =
custom form control) to a=0A=
 * property on the scope using {@link ngModel.NgModelController =
NgModelController},=0A=
 * which is created and exposed by this directive.=0A=
 *=0A=
 * `ngModel` is responsible for:=0A=
 *=0A=
 * - Binding the view into the model, which other directives such as =
`input`, `textarea` or `select`=0A=
 *   require.=0A=
 * - Providing validation behavior (i.e. required, number, email, url).=0A=
 * - Keeping the state of the control (valid/invalid, dirty/pristine, =
touched/untouched, validation errors).=0A=
 * - Setting related css classes on the element (`ng-valid`, =
`ng-invalid`, `ng-dirty`, `ng-pristine`, `ng-touched`, `ng-untouched`) =
including animations.=0A=
 * - Registering the control with its parent {@link ng.directive:form =
form}.=0A=
 *=0A=
 * Note: `ngModel` will try to bind to the property given by evaluating =
the expression on the=0A=
 * current scope. If the property doesn't already exist on this scope, =
it will be created=0A=
 * implicitly and added to the scope.=0A=
 *=0A=
 * For best practices on using `ngModel`, see:=0A=
 *=0A=
 *  - [https://github.com/angular/angular.js/wiki/Understanding-Scopes]=0A=
 *=0A=
 * For basic examples, how to use `ngModel`, see:=0A=
 *=0A=
 *  - {@link ng.directive:input input}=0A=
 *    - {@link input[text] text}=0A=
 *    - {@link input[checkbox] checkbox}=0A=
 *    - {@link input[radio] radio}=0A=
 *    - {@link input[number] number}=0A=
 *    - {@link input[email] email}=0A=
 *    - {@link input[url] url}=0A=
 *    - {@link input[date] date}=0A=
 *    - {@link input[dateTimeLocal] dateTimeLocal}=0A=
 *    - {@link input[time] time}=0A=
 *    - {@link input[month] month}=0A=
 *    - {@link input[week] week}=0A=
 *  - {@link ng.directive:select select}=0A=
 *  - {@link ng.directive:textarea textarea}=0A=
 *=0A=
 * # CSS classes=0A=
 * The following CSS classes are added and removed on the associated =
input/select/textarea element=0A=
 * depending on the validity of the model.=0A=
 *=0A=
 *  - `ng-valid` is set if the model is valid.=0A=
 *  - `ng-invalid` is set if the model is invalid.=0A=
 *  - `ng-pristine` is set if the model is pristine.=0A=
 *  - `ng-dirty` is set if the model is dirty.=0A=
 *=0A=
 * Keep in mind that ngAnimate can detect each of these classes when =
added and removed.=0A=
 *=0A=
 * ## Animation Hooks=0A=
 *=0A=
 * Animations within models are triggered when any of the associated CSS =
classes are added and removed=0A=
 * on the input element which is attached to the model. These classes =
are: `.ng-pristine`, `.ng-dirty`,=0A=
 * `.ng-invalid` and `.ng-valid` as well as any other validations that =
are performed on the model itself.=0A=
 * The animations that are triggered within ngModel are similar to how =
they work in ngClass and=0A=
 * animations can be hooked into using CSS transitions, keyframes as =
well as JS animations.=0A=
 *=0A=
 * The following example shows a simple way to utilize CSS transitions =
to style an input element=0A=
 * that has been rendered as invalid after it has been validated:=0A=
 *=0A=
 * &lt;pre&gt;=0A=
 * //be sure to include ngAnimate as a module to hook into more=0A=
 * //advanced animations=0A=
 * .my-input {=0A=
 *   transition:0.5s linear all;=0A=
 *   background: white;=0A=
 * }=0A=
 * .my-input.ng-invalid {=0A=
 *   background: red;=0A=
 *   color:white;=0A=
 * }=0A=
 * &lt;/pre&gt;=0A=
 *=0A=
 * @example=0A=
 * &lt;example deps=3D"angular-animate.js" animations=3D"true" =
fixBase=3D"true" module=3D"inputExample"&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
       &lt;script&gt;=0A=
        angular.module('inputExample', [])=0A=
          .controller('ExampleController', ['$scope', function($scope) {=0A=
            $scope.val =3D '1';=0A=
          }]);=0A=
       &lt;/script&gt;=0A=
       &lt;style&gt;=0A=
         .my-input {=0A=
           -webkit-transition:all linear 0.5s;=0A=
           transition:all linear 0.5s;=0A=
           background: transparent;=0A=
         }=0A=
         .my-input.ng-invalid {=0A=
           color:white;=0A=
           background: red;=0A=
         }=0A=
       &lt;/style&gt;=0A=
       Update input to see transitions when valid/invalid.=0A=
       Integer is a valid value.=0A=
       &lt;form name=3D"testForm" ng-controller=3D"ExampleController"&gt;=0A=
         &lt;input ng-model=3D"val" ng-pattern=3D"/^\d+$/" name=3D"anim" =
class=3D"my-input" /&gt;=0A=
       &lt;/form&gt;=0A=
     &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 *=0A=
 * ## Binding to a getter/setter=0A=
 *=0A=
 * Sometimes it's helpful to bind `ngModel` to a getter/setter function. =
 A getter/setter is a=0A=
 * function that returns a representation of the model when called with =
zero arguments, and sets=0A=
 * the internal state of a model when called with an argument. It's =
sometimes useful to use this=0A=
 * for models that have an internal representation that's different than =
what the model exposes=0A=
 * to the view.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-success"&gt;=0A=
 * **Best Practice:** It's best to keep getters fast because Angular is =
likely to call them more=0A=
 * frequently than other parts of your code.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * You use this behavior by adding `ng-model-options=3D"{ getterSetter: =
true }"` to an element that=0A=
 * has `ng-model` attached to it. You can also add =
`ng-model-options=3D"{ getterSetter: true }"` to=0A=
 * a `&lt;form&gt;`, which will enable this behavior for all =
`&lt;input&gt;`s within it. See=0A=
 * {@link ng.directive:ngModelOptions `ngModelOptions`} for more.=0A=
 *=0A=
 * The following example shows how to use `ngModel` with a getter/setter:=0A=
 *=0A=
 * @example=0A=
 * &lt;example name=3D"ngModel-getter-setter" =
module=3D"getterSetterExample"&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
         &lt;form name=3D"userForm"&gt;=0A=
           Name:=0A=
           &lt;input type=3D"text" name=3D"userName"=0A=
                  ng-model=3D"user.name"=0A=
                  ng-model-options=3D"{ getterSetter: true }" /&gt;=0A=
         &lt;/form&gt;=0A=
         &lt;pre&gt;user.name =3D &lt;span =
ng-bind=3D"user.name()"&gt;&lt;/span&gt;&lt;/pre&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"app.js"&gt;=0A=
       angular.module('getterSetterExample', [])=0A=
         .controller('ExampleController', ['$scope', function($scope) {=0A=
           var _name =3D 'Brian';=0A=
           $scope.user =3D {=0A=
             name: function (newName) {=0A=
               if (angular.isDefined(newName)) {=0A=
                 _name =3D newName;=0A=
               }=0A=
               return _name;=0A=
             }=0A=
           };=0A=
         }]);=0A=
     &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 */=0A=
var ngModelDirective =3D function() {=0A=
  return {=0A=
    restrict: 'A',=0A=
    require: ['ngModel', '^?form', '^?ngModelOptions'],=0A=
    controller: NgModelController,=0A=
    // Prelink needs to run before any input directive=0A=
    // so that we can set the NgModelOptions in NgModelController=0A=
    // before anyone else uses it.=0A=
    priority: 1,=0A=
    compile: function ngModelCompile(element) {=0A=
      // Setup initial state of the control=0A=
      =
element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID=
_CLASS);=0A=
=0A=
      return {=0A=
        pre: function ngModelPreLink(scope, element, attr, ctrls) {=0A=
          var modelCtrl =3D ctrls[0],=0A=
              formCtrl =3D ctrls[1] || nullFormCtrl;=0A=
=0A=
          modelCtrl.$$setOptions(ctrls[2] &amp;&amp; ctrls[2].$options);=0A=
=0A=
          // notify others, especially parent forms=0A=
          formCtrl.$addControl(modelCtrl);=0A=
=0A=
          attr.$observe('name', function(newValue) {=0A=
            if (modelCtrl.$name !=3D=3D newValue) {=0A=
              formCtrl.$$renameControl(modelCtrl, newValue);=0A=
            }=0A=
          });=0A=
=0A=
          scope.$on('$destroy', function() {=0A=
            formCtrl.$removeControl(modelCtrl);=0A=
          });=0A=
        },=0A=
        post: function ngModelPostLink(scope, element, attr, ctrls) {=0A=
          var modelCtrl =3D ctrls[0];=0A=
          if (modelCtrl.$options &amp;&amp; modelCtrl.$options.updateOn) =
{=0A=
            element.on(modelCtrl.$options.updateOn, function(ev) {=0A=
              modelCtrl.$$debounceViewValueCommit(ev &amp;&amp; ev.type);=0A=
            });=0A=
          }=0A=
=0A=
          element.on('blur', function(ev) {=0A=
            if (modelCtrl.$touched) return;=0A=
=0A=
            scope.$apply(function() {=0A=
              modelCtrl.$setTouched();=0A=
            });=0A=
          });=0A=
        }=0A=
      };=0A=
    }=0A=
  };=0A=
};=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngChange=0A=
 *=0A=
 * @description=0A=
 * Evaluate the given expression when the user changes the input.=0A=
 * The expression is evaluated immediately, unlike the JavaScript =
onchange event=0A=
 * which only triggers at the end of a change (usually, when the user =
leaves the=0A=
 * form element or presses the return key).=0A=
 *=0A=
 * The `ngChange` expression is only evaluated when a change in the =
input value causes=0A=
 * a new value to be committed to the model.=0A=
 *=0A=
 * It will not be evaluated:=0A=
 * * if the value returned from the `$parsers` transformation pipeline =
has not changed=0A=
 * * if the input has continued to be invalid since the model will stay =
`null`=0A=
 * * if the model is changed programmatically and not by a change to the =
input value=0A=
 *=0A=
 *=0A=
 * Note, this directive requires `ngModel` to be present.=0A=
 *=0A=
 * @element input=0A=
 * @param {expression} ngChange {@link guide/expression Expression} to =
evaluate upon change=0A=
 * in input value.=0A=
 *=0A=
 * @example=0A=
 * &lt;example name=3D"ngChange-directive" module=3D"changeExample"&gt;=0A=
 *   &lt;file name=3D"todoList.html"&gt;=0A=
 *     &lt;script&gt;=0A=
 *       angular.module('changeExample', [])=0A=
 *         .controller('ExampleController', ['$scope', function($scope) {=0A=
 *           $scope.counter =3D 0;=0A=
 *           $scope.change =3D function() {=0A=
 *             $scope.counter++;=0A=
 *           };=0A=
 *         }]);=0A=
 *     &lt;/script&gt;=0A=
 *     &lt;div ng-controller=3D"ExampleController"&gt;=0A=
 *       &lt;input type=3D"checkbox" ng-model=3D"confirmed" =
ng-change=3D"change()" id=3D"ng-change-example1" /&gt;=0A=
 *       &lt;input type=3D"checkbox" ng-model=3D"confirmed" =
id=3D"ng-change-example2" /&gt;=0A=
 *       &lt;label =
for=3D"ng-change-example2"&gt;Confirmed&lt;/label&gt;&lt;br /&gt;=0A=
 *       &lt;tt&gt;debug =3D {{confirmed}}&lt;/tt&gt;&lt;br/&gt;=0A=
 *       &lt;tt&gt;counter =3D {{counter}}&lt;/tt&gt;&lt;br/&gt;=0A=
 *     &lt;/div&gt;=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
 *     var counter =3D element(by.binding('counter'));=0A=
 *     var debug =3D element(by.binding('confirmed'));=0A=
 *=0A=
 *     it('should evaluate the expression if changing from view', =
function() {=0A=
 *       expect(counter.getText()).toContain('0');=0A=
 *=0A=
 *       element(by.id('ng-change-example1')).click();=0A=
 *=0A=
 *       expect(counter.getText()).toContain('1');=0A=
 *       expect(debug.getText()).toContain('true');=0A=
 *     });=0A=
 *=0A=
 *     it('should not evaluate the expression if changing from model', =
function() {=0A=
 *       element(by.id('ng-change-example2')).click();=0A=
=0A=
 *       expect(counter.getText()).toContain('0');=0A=
 *       expect(debug.getText()).toContain('true');=0A=
 *     });=0A=
 *   &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 */=0A=
var ngChangeDirective =3D valueFn({=0A=
  restrict: 'A',=0A=
  require: 'ngModel',=0A=
  link: function(scope, element, attr, ctrl) {=0A=
    ctrl.$viewChangeListeners.push(function() {=0A=
      scope.$eval(attr.ngChange);=0A=
    });=0A=
  }=0A=
});=0A=
=0A=
=0A=
var requiredDirective =3D function() {=0A=
  return {=0A=
    restrict: 'A',=0A=
    require: '?ngModel',=0A=
    link: function(scope, elm, attr, ctrl) {=0A=
      if (!ctrl) return;=0A=
      attr.required =3D true; // force truthy in case we are on non =
input element=0A=
=0A=
      ctrl.$validators.required =3D function(value) {=0A=
        return !attr.required || !ctrl.$isEmpty(value);=0A=
      };=0A=
=0A=
      attr.$observe('required', function() {=0A=
        ctrl.$validate();=0A=
      });=0A=
    }=0A=
  };=0A=
};=0A=
=0A=
=0A=
var patternDirective =3D function() {=0A=
  return {=0A=
    restrict: 'A',=0A=
    require: '?ngModel',=0A=
    link: function(scope, elm, attr, ctrl) {=0A=
      if (!ctrl) return;=0A=
=0A=
      var regexp, patternExp =3D attr.ngPattern || attr.pattern;=0A=
      attr.$observe('pattern', function(regex) {=0A=
        if (isString(regex) &amp;&amp; regex.length &gt; 0) {=0A=
          regex =3D new RegExp(regex);=0A=
        }=0A=
=0A=
        if (regex &amp;&amp; !regex.test) {=0A=
          throw minErr('ngPattern')('noregexp',=0A=
            'Expected {0} to be a RegExp but was {1}. Element: {2}', =
patternExp,=0A=
            regex, startingTag(elm));=0A=
        }=0A=
=0A=
        regexp =3D regex || undefined;=0A=
        ctrl.$validate();=0A=
      });=0A=
=0A=
      ctrl.$validators.pattern =3D function(value) {=0A=
        return ctrl.$isEmpty(value) || isUndefined(regexp) || =
regexp.test(value);=0A=
      };=0A=
    }=0A=
  };=0A=
};=0A=
=0A=
=0A=
var maxlengthDirective =3D function() {=0A=
  return {=0A=
    restrict: 'A',=0A=
    require: '?ngModel',=0A=
    link: function(scope, elm, attr, ctrl) {=0A=
      if (!ctrl) return;=0A=
=0A=
      var maxlength =3D 0;=0A=
      attr.$observe('maxlength', function(value) {=0A=
        maxlength =3D int(value) || 0;=0A=
        ctrl.$validate();=0A=
      });=0A=
      ctrl.$validators.maxlength =3D function(modelValue, viewValue) {=0A=
        return ctrl.$isEmpty(modelValue) || viewValue.length &lt;=3D =
maxlength;=0A=
      };=0A=
    }=0A=
  };=0A=
};=0A=
=0A=
var minlengthDirective =3D function() {=0A=
  return {=0A=
    restrict: 'A',=0A=
    require: '?ngModel',=0A=
    link: function(scope, elm, attr, ctrl) {=0A=
      if (!ctrl) return;=0A=
=0A=
      var minlength =3D 0;=0A=
      attr.$observe('minlength', function(value) {=0A=
        minlength =3D int(value) || 0;=0A=
        ctrl.$validate();=0A=
      });=0A=
      ctrl.$validators.minlength =3D function(modelValue, viewValue) {=0A=
        return ctrl.$isEmpty(modelValue) || viewValue.length &gt;=3D =
minlength;=0A=
      };=0A=
    }=0A=
  };=0A=
};=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngList=0A=
 *=0A=
 * @description=0A=
 * Text input that converts between a delimited string and an array of =
strings. The default=0A=
 * delimiter is a comma followed by a space - equivalent to =
`ng-list=3D", "`. You can specify a custom=0A=
 * delimiter as the value of the `ngList` attribute - for example, =
`ng-list=3D" | "`.=0A=
 *=0A=
 * The behaviour of the directive is affected by the use of the `ngTrim` =
attribute.=0A=
 * * If `ngTrim` is set to `"false"` then whitespace around both the =
separator and each=0A=
 *   list item is respected. This implies that the user of the directive =
is responsible for=0A=
 *   dealing with whitespace but also allows you to use whitespace as a =
delimiter, such as a=0A=
 *   tab or newline character.=0A=
 * * Otherwise whitespace around the delimiter is ignored when splitting =
(although it is respected=0A=
 *   when joining the list items back together) and whitespace around =
each list item is stripped=0A=
 *   before it is added to the model.=0A=
 *=0A=
 * ### Example with Validation=0A=
 *=0A=
 * &lt;example name=3D"ngList-directive" module=3D"listExample"&gt;=0A=
 *   &lt;file name=3D"app.js"&gt;=0A=
 *      angular.module('listExample', [])=0A=
 *        .controller('ExampleController', ['$scope', function($scope) {=0A=
 *          $scope.names =3D ['morpheus', 'neo', 'trinity'];=0A=
 *        }]);=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"todoList.html"&gt;=0A=
 *    &lt;form name=3D"myForm" ng-controller=3D"ExampleController"&gt;=0A=
 *      List: &lt;input name=3D"namesInput" ng-model=3D"names" ng-list =
required&gt;=0A=
 *      &lt;span class=3D"error" =
ng-show=3D"myForm.namesInput.$error.required"&gt;=0A=
 *        Required!&lt;/span&gt;=0A=
 *      &lt;br&gt;=0A=
 *      &lt;tt&gt;names =3D {{names}}&lt;/tt&gt;&lt;br/&gt;=0A=
 *      &lt;tt&gt;myForm.namesInput.$valid =3D =
{{myForm.namesInput.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
 *      &lt;tt&gt;myForm.namesInput.$error =3D =
{{myForm.namesInput.$error}}&lt;/tt&gt;&lt;br/&gt;=0A=
 *      &lt;tt&gt;myForm.$valid =3D =
{{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;=0A=
 *      &lt;tt&gt;myForm.$error.required =3D =
{{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;=0A=
 *     &lt;/form&gt;=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
 *     var listInput =3D element(by.model('names'));=0A=
 *     var names =3D element(by.exactBinding('names'));=0A=
 *     var valid =3D element(by.binding('myForm.namesInput.$valid'));=0A=
 *     var error =3D element(by.css('span.error'));=0A=
 *=0A=
 *     it('should initialize to model', function() {=0A=
 *       =
expect(names.getText()).toContain('["morpheus","neo","trinity"]');=0A=
 *       expect(valid.getText()).toContain('true');=0A=
 *       expect(error.getCssValue('display')).toBe('none');=0A=
 *     });=0A=
 *=0A=
 *     it('should be invalid if empty', function() {=0A=
 *       listInput.clear();=0A=
 *       listInput.sendKeys('');=0A=
 *=0A=
 *       expect(names.getText()).toContain('');=0A=
 *       expect(valid.getText()).toContain('false');=0A=
 *       expect(error.getCssValue('display')).not.toBe('none');=0A=
 *     });=0A=
 *   &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 *=0A=
 * ### Example - splitting on whitespace=0A=
 * &lt;example name=3D"ngList-directive-newlines"&gt;=0A=
 *   &lt;file name=3D"todoList.html"&gt;=0A=
 *    &lt;textarea ng-model=3D"list" ng-list=3D"&amp;#10;" =
ng-trim=3D"false"&gt;&lt;/textarea&gt;=0A=
 *    &lt;pre&gt;{{ list | json }}&lt;/pre&gt;=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
 *     it("should split the text by newlines", function() {=0A=
 *       var listInput =3D element(by.model('list'));=0A=
 *       var output =3D element(by.binding('list | json'));=0A=
 *       listInput.sendKeys('abc\ndef\nghi');=0A=
 *       expect(output.getText()).toContain('[\n  "abc",\n  "def",\n  =
"ghi"\n]');=0A=
 *     });=0A=
 *   &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 *=0A=
 * @element input=0A=
 * @param {string=3D} ngList optional delimiter that should be used to =
split the value.=0A=
 */=0A=
var ngListDirective =3D function() {=0A=
  return {=0A=
    restrict: 'A',=0A=
    priority: 100,=0A=
    require: 'ngModel',=0A=
    link: function(scope, element, attr, ctrl) {=0A=
      // We want to control whitespace trimming so we use this =
convoluted approach=0A=
      // to access the ngList attribute, which doesn't pre-trim the =
attribute=0A=
      var ngList =3D element.attr(attr.$attr.ngList) || ', ';=0A=
      var trimValues =3D attr.ngTrim !=3D=3D 'false';=0A=
      var separator =3D trimValues ? trim(ngList) : ngList;=0A=
=0A=
      var parse =3D function(viewValue) {=0A=
        // If the viewValue is invalid (say required but empty) it will =
be `undefined`=0A=
        if (isUndefined(viewValue)) return;=0A=
=0A=
        var list =3D [];=0A=
=0A=
        if (viewValue) {=0A=
          forEach(viewValue.split(separator), function(value) {=0A=
            if (value) list.push(trimValues ? trim(value) : value);=0A=
          });=0A=
        }=0A=
=0A=
        return list;=0A=
      };=0A=
=0A=
      ctrl.$parsers.push(parse);=0A=
      ctrl.$formatters.push(function(value) {=0A=
        if (isArray(value)) {=0A=
          return value.join(ngList);=0A=
        }=0A=
=0A=
        return undefined;=0A=
      });=0A=
=0A=
      // Override the standard $isEmpty because an empty array means the =
input is empty.=0A=
      ctrl.$isEmpty =3D function(value) {=0A=
        return !value || !value.length;=0A=
      };=0A=
    }=0A=
  };=0A=
};=0A=
=0A=
=0A=
var CONSTANT_VALUE_REGEXP =3D /^(true|false|\d+)$/;=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngValue=0A=
 *=0A=
 * @description=0A=
 * Binds the given expression to the value of `input[select]` or =
`input[radio]`, so=0A=
 * that when the element is selected, the `ngModel` of that element is =
set to the=0A=
 * bound value.=0A=
 *=0A=
 * `ngValue` is useful when dynamically generating lists of radio =
buttons using `ng-repeat`, as=0A=
 * shown below.=0A=
 *=0A=
 * @element input=0A=
 * @param {string=3D} ngValue angular expression, whose value will be =
bound to the `value` attribute=0A=
 *   of the `input` element=0A=
 *=0A=
 * @example=0A=
    &lt;example name=3D"ngValue-directive" module=3D"valueExample"&gt;=0A=
      &lt;file name=3D"todoList.html"&gt;=0A=
       &lt;script&gt;=0A=
          angular.module('valueExample', [])=0A=
            .controller('ExampleController', ['$scope', function($scope) =
{=0A=
              $scope.names =3D ['pizza', 'unicorns', 'robots'];=0A=
              $scope.my =3D { favorite: 'unicorns' };=0A=
            }]);=0A=
       &lt;/script&gt;=0A=
        &lt;form ng-controller=3D"ExampleController"&gt;=0A=
          &lt;h2&gt;Which is your favorite?&lt;/h2&gt;=0A=
            &lt;label ng-repeat=3D"name in names" for=3D"{{name}}"&gt;=0A=
              {{name}}=0A=
              &lt;input type=3D"radio"=0A=
                     ng-model=3D"my.favorite"=0A=
                     ng-value=3D"name"=0A=
                     id=3D"{{name}}"=0A=
                     name=3D"favorite"&gt;=0A=
            &lt;/label&gt;=0A=
          &lt;div&gt;You chose {{my.favorite}}&lt;/div&gt;=0A=
        &lt;/form&gt;=0A=
      &lt;/file&gt;=0A=
      &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
        var favorite =3D element(by.binding('my.favorite'));=0A=
=0A=
        it('should initialize to model', function() {=0A=
          expect(favorite.getText()).toContain('unicorns');=0A=
        });=0A=
        it('should bind the values to the inputs', function() {=0A=
          element.all(by.model('my.favorite')).get(0).click();=0A=
          expect(favorite.getText()).toContain('pizza');=0A=
        });=0A=
      &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
 */=0A=
var ngValueDirective =3D function() {=0A=
  return {=0A=
    restrict: 'A',=0A=
    priority: 100,=0A=
    compile: function(tpl, tplAttr) {=0A=
      if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {=0A=
        return function ngValueConstantLink(scope, elm, attr) {=0A=
          attr.$set('value', scope.$eval(attr.ngValue));=0A=
        };=0A=
      } else {=0A=
        return function ngValueLink(scope, elm, attr) {=0A=
          scope.$watch(attr.ngValue, function valueWatchAction(value) {=0A=
            attr.$set('value', value);=0A=
          });=0A=
        };=0A=
      }=0A=
    }=0A=
  };=0A=
};=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngModelOptions=0A=
 *=0A=
 * @description=0A=
 * Allows tuning how model updates are done. Using `ngModelOptions` you =
can specify a custom list of=0A=
 * events that will trigger a model update and/or a debouncing delay so =
that the actual update only=0A=
 * takes place when a timer expires; this timer will be reset after =
another change takes place.=0A=
 *=0A=
 * Given the nature of `ngModelOptions`, the value displayed inside =
input fields in the view might=0A=
 * be different than the value in the actual model. This means that if =
you update the model you=0A=
 * should also invoke {@link ngModel.NgModelController =
`$rollbackViewValue`} on the relevant input field in=0A=
 * order to make sure it is synchronized with the model and that any =
debounced action is canceled.=0A=
 *=0A=
 * The easiest way to reference the control's {@link =
ngModel.NgModelController `$rollbackViewValue`}=0A=
 * method is by making sure the input is placed inside a form that has a =
`name` attribute. This is=0A=
 * important because `form` controllers are published to the related =
scope under the name in their=0A=
 * `name` attribute.=0A=
 *=0A=
 * Any pending changes will take place immediately when an enclosing =
form is submitted via the=0A=
 * `submit` event. Note that `ngClick` events will occur before the =
model is updated. Use `ngSubmit`=0A=
 * to have access to the updated model.=0A=
 *=0A=
 * `ngModelOptions` has an effect on the element it's declared on and =
its descendants.=0A=
 *=0A=
 * @param {Object} ngModelOptions options to apply to the current model. =
Valid keys are:=0A=
 *   - `updateOn`: string specifying which event should be the input =
bound to. You can set several=0A=
 *     events using an space delimited list. There is a special event =
called `default` that=0A=
 *     matches the default events belonging of the control.=0A=
 *   - `debounce`: integer value which contains the debounce model =
update value in milliseconds. A=0A=
 *     value of 0 triggers an immediate update. If an object is supplied =
instead, you can specify a=0A=
 *     custom value for each event. For example:=0A=
 *     `ng-model-options=3D"{ updateOn: 'default blur', debounce: =
{'default': 500, 'blur': 0} }"`=0A=
 *   - `allowInvalid`: boolean value which indicates that the model can =
be set with values that did=0A=
 *     not validate correctly instead of the default behavior of setting =
the model to undefined.=0A=
 *   - `getterSetter`: boolean value which determines whether or not to =
treat functions bound to=0A=
       `ngModel` as getters/setters.=0A=
 *   - `timezone`: Defines the timezone to be used to read/write the =
`Date` instance in the model for=0A=
 *     `&lt;input type=3D"date"&gt;`, `&lt;input type=3D"time"&gt;`, ... =
. Right now, the only supported value is `'UTC'`,=0A=
 *     otherwise the default timezone of the browser will be used.=0A=
 *=0A=
 * @example=0A=
=0A=
  The following example shows how to override immediate updates. Changes =
on the inputs within the=0A=
  form will update the model only when the control loses focus (blur =
event). If `escape` key is=0A=
  pressed while the input field is focused, the value is reset to the =
value in the current model.=0A=
=0A=
  &lt;example name=3D"ngModelOptions-directive-blur" =
module=3D"optionsExample"&gt;=0A=
    &lt;file name=3D"todoList.html"&gt;=0A=
      &lt;div ng-controller=3D"ExampleController"&gt;=0A=
        &lt;form name=3D"userForm"&gt;=0A=
          Name:=0A=
          &lt;input type=3D"text" name=3D"userName"=0A=
                 ng-model=3D"user.name"=0A=
                 ng-model-options=3D"{ updateOn: 'blur' }"=0A=
                 ng-keyup=3D"cancel($event)" /&gt;&lt;br /&gt;=0A=
=0A=
          Other data:=0A=
          &lt;input type=3D"text" ng-model=3D"user.data" /&gt;&lt;br =
/&gt;=0A=
        &lt;/form&gt;=0A=
        &lt;pre&gt;user.name =3D &lt;span =
ng-bind=3D"user.name"&gt;&lt;/span&gt;&lt;/pre&gt;=0A=
      &lt;/div&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"app.js"&gt;=0A=
      angular.module('optionsExample', [])=0A=
        .controller('ExampleController', ['$scope', function($scope) {=0A=
          $scope.user =3D { name: 'say', data: '' };=0A=
=0A=
          $scope.cancel =3D function (e) {=0A=
            if (e.keyCode =3D=3D 27) {=0A=
              $scope.userForm.userName.$rollbackViewValue();=0A=
            }=0A=
          };=0A=
        }]);=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
      var model =3D element(by.binding('user.name'));=0A=
      var input =3D element(by.model('user.name'));=0A=
      var other =3D element(by.model('user.data'));=0A=
=0A=
      it('should allow custom events', function() {=0A=
        input.sendKeys(' hello');=0A=
        input.click();=0A=
        expect(model.getText()).toEqual('say');=0A=
        other.click();=0A=
        expect(model.getText()).toEqual('say hello');=0A=
      });=0A=
=0A=
      it('should $rollbackViewValue when model changes', function() {=0A=
        input.sendKeys(' hello');=0A=
        expect(input.getAttribute('value')).toEqual('say hello');=0A=
        input.sendKeys(protractor.Key.ESCAPE);=0A=
        expect(input.getAttribute('value')).toEqual('say');=0A=
        other.click();=0A=
        expect(model.getText()).toEqual('say');=0A=
      });=0A=
    &lt;/file&gt;=0A=
  &lt;/example&gt;=0A=
=0A=
  This one shows how to debounce model changes. Model will be updated =
only 1 sec after last change.=0A=
  If the `Clear` button is pressed, any debounced action is canceled and =
the value becomes empty.=0A=
=0A=
  &lt;example name=3D"ngModelOptions-directive-debounce" =
module=3D"optionsExample"&gt;=0A=
    &lt;file name=3D"todoList.html"&gt;=0A=
      &lt;div ng-controller=3D"ExampleController"&gt;=0A=
        &lt;form name=3D"userForm"&gt;=0A=
          Name:=0A=
          &lt;input type=3D"text" name=3D"userName"=0A=
                 ng-model=3D"user.name"=0A=
                 ng-model-options=3D"{ debounce: 1000 }" /&gt;=0A=
          &lt;button ng-click=3D"userForm.userName.$rollbackViewValue(); =
user.name=3D''"&gt;Clear&lt;/button&gt;&lt;br /&gt;=0A=
        &lt;/form&gt;=0A=
        &lt;pre&gt;user.name =3D &lt;span =
ng-bind=3D"user.name"&gt;&lt;/span&gt;&lt;/pre&gt;=0A=
      &lt;/div&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"app.js"&gt;=0A=
      angular.module('optionsExample', [])=0A=
        .controller('ExampleController', ['$scope', function($scope) {=0A=
          $scope.user =3D { name: 'say' };=0A=
        }]);=0A=
    &lt;/file&gt;=0A=
  &lt;/example&gt;=0A=
=0A=
  This one shows how to bind to getter/setters:=0A=
=0A=
  &lt;example name=3D"ngModelOptions-directive-getter-setter" =
module=3D"getterSetterExample"&gt;=0A=
    &lt;file name=3D"todoList.html"&gt;=0A=
      &lt;div ng-controller=3D"ExampleController"&gt;=0A=
        &lt;form name=3D"userForm"&gt;=0A=
          Name:=0A=
          &lt;input type=3D"text" name=3D"userName"=0A=
                 ng-model=3D"user.name"=0A=
                 ng-model-options=3D"{ getterSetter: true }" /&gt;=0A=
        &lt;/form&gt;=0A=
        &lt;pre&gt;user.name =3D &lt;span =
ng-bind=3D"user.name()"&gt;&lt;/span&gt;&lt;/pre&gt;=0A=
      &lt;/div&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"app.js"&gt;=0A=
      angular.module('getterSetterExample', [])=0A=
        .controller('ExampleController', ['$scope', function($scope) {=0A=
          var _name =3D 'Brian';=0A=
          $scope.user =3D {=0A=
            name: function (newName) {=0A=
              return angular.isDefined(newName) ? (_name =3D newName) : =
_name;=0A=
            }=0A=
          };=0A=
        }]);=0A=
    &lt;/file&gt;=0A=
  &lt;/example&gt;=0A=
 */=0A=
var ngModelOptionsDirective =3D function() {=0A=
  return {=0A=
    restrict: 'A',=0A=
    controller: ['$scope', '$attrs', function($scope, $attrs) {=0A=
      var that =3D this;=0A=
      this.$options =3D $scope.$eval($attrs.ngModelOptions);=0A=
      // Allow adding/overriding bound events=0A=
      if (this.$options.updateOn !=3D=3D undefined) {=0A=
        this.$options.updateOnDefault =3D false;=0A=
        // extract "default" pseudo-event from list of events that can =
trigger a model update=0A=
        this.$options.updateOn =3D =
trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {=0A=
          that.$options.updateOnDefault =3D true;=0A=
          return ' ';=0A=
        }));=0A=
      } else {=0A=
        this.$options.updateOnDefault =3D true;=0A=
      }=0A=
    }]=0A=
  };=0A=
};=0A=
=0A=
// helper methods=0A=
function addSetValidityMethod(context) {=0A=
  var ctrl =3D context.ctrl,=0A=
      $element =3D context.$element,=0A=
      classCache =3D {},=0A=
      set =3D context.set,=0A=
      unset =3D context.unset,=0A=
      parentForm =3D context.parentForm,=0A=
      $animate =3D context.$animate;=0A=
=0A=
  classCache[INVALID_CLASS] =3D !(classCache[VALID_CLASS] =3D =
$element.hasClass(VALID_CLASS));=0A=
=0A=
  ctrl.$setValidity =3D setValidity;=0A=
=0A=
  function setValidity(validationErrorKey, state, options) {=0A=
    if (state =3D=3D=3D undefined) {=0A=
      createAndSet('$pending', validationErrorKey, options);=0A=
    } else {=0A=
      unsetAndCleanup('$pending', validationErrorKey, options);=0A=
    }=0A=
    if (!isBoolean(state)) {=0A=
      unset(ctrl.$error, validationErrorKey, options);=0A=
      unset(ctrl.$$success, validationErrorKey, options);=0A=
    } else {=0A=
      if (state) {=0A=
        unset(ctrl.$error, validationErrorKey, options);=0A=
        set(ctrl.$$success, validationErrorKey, options);=0A=
      } else {=0A=
        set(ctrl.$error, validationErrorKey, options);=0A=
        unset(ctrl.$$success, validationErrorKey, options);=0A=
      }=0A=
    }=0A=
    if (ctrl.$pending) {=0A=
      cachedToggleClass(PENDING_CLASS, true);=0A=
      ctrl.$valid =3D ctrl.$invalid =3D undefined;=0A=
      toggleValidationCss('', null);=0A=
    } else {=0A=
      cachedToggleClass(PENDING_CLASS, false);=0A=
      ctrl.$valid =3D isObjectEmpty(ctrl.$error);=0A=
      ctrl.$invalid =3D !ctrl.$valid;=0A=
      toggleValidationCss('', ctrl.$valid);=0A=
    }=0A=
=0A=
    // re-read the state as the set/unset methods could have=0A=
    // combined state in ctrl.$error[validationError] (used for forms),=0A=
    // where setting/unsetting only increments/decrements the value,=0A=
    // and does not replace it.=0A=
    var combinedState;=0A=
    if (ctrl.$pending &amp;&amp; ctrl.$pending[validationErrorKey]) {=0A=
      combinedState =3D undefined;=0A=
    } else if (ctrl.$error[validationErrorKey]) {=0A=
      combinedState =3D false;=0A=
    } else if (ctrl.$$success[validationErrorKey]) {=0A=
      combinedState =3D true;=0A=
    } else {=0A=
      combinedState =3D null;=0A=
    }=0A=
    toggleValidationCss(validationErrorKey, combinedState);=0A=
    parentForm.$setValidity(validationErrorKey, combinedState, ctrl);=0A=
  }=0A=
=0A=
  function createAndSet(name, value, options) {=0A=
    if (!ctrl[name]) {=0A=
      ctrl[name] =3D {};=0A=
    }=0A=
    set(ctrl[name], value, options);=0A=
  }=0A=
=0A=
  function unsetAndCleanup(name, value, options) {=0A=
    if (ctrl[name]) {=0A=
      unset(ctrl[name], value, options);=0A=
    }=0A=
    if (isObjectEmpty(ctrl[name])) {=0A=
      ctrl[name] =3D undefined;=0A=
    }=0A=
  }=0A=
=0A=
  function cachedToggleClass(className, switchValue) {=0A=
    if (switchValue &amp;&amp; !classCache[className]) {=0A=
      $animate.addClass($element, className);=0A=
      classCache[className] =3D true;=0A=
    } else if (!switchValue &amp;&amp; classCache[className]) {=0A=
      $animate.removeClass($element, className);=0A=
      classCache[className] =3D false;=0A=
    }=0A=
  }=0A=
=0A=
  function toggleValidationCss(validationErrorKey, isValid) {=0A=
    validationErrorKey =3D validationErrorKey ? '-' + =
snake_case(validationErrorKey, '-') : '';=0A=
=0A=
    cachedToggleClass(VALID_CLASS + validationErrorKey, isValid =
=3D=3D=3D true);=0A=
    cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid =
=3D=3D=3D false);=0A=
  }=0A=
}=0A=
=0A=
function isObjectEmpty(obj) {=0A=
  if (obj) {=0A=
    for (var prop in obj) {=0A=
      return false;=0A=
    }=0A=
  }=0A=
  return true;=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngBind=0A=
 * @restrict AC=0A=
 *=0A=
 * @description=0A=
 * The `ngBind` attribute tells Angular to replace the text content of =
the specified HTML element=0A=
 * with the value of a given expression, and to update the text content =
when the value of that=0A=
 * expression changes.=0A=
 *=0A=
 * Typically, you don't use `ngBind` directly, but instead you use the =
double curly markup like=0A=
 * `{{ expression }}` which is similar but less verbose.=0A=
 *=0A=
 * It is preferable to use `ngBind` instead of `{{ expression }}` if a =
template is momentarily=0A=
 * displayed by the browser in its raw state before Angular compiles it. =
Since `ngBind` is an=0A=
 * element attribute, it makes the bindings invisible to the user while =
the page is loading.=0A=
 *=0A=
 * An alternative solution to this problem would be using the=0A=
 * {@link ng.directive:ngCloak ngCloak} directive.=0A=
 *=0A=
 *=0A=
 * @element ANY=0A=
 * @param {expression} ngBind {@link guide/expression Expression} to =
evaluate.=0A=
 *=0A=
 * @example=0A=
 * Enter a name in the Live Preview text box; the greeting below the =
text box changes instantly.=0A=
   &lt;example module=3D"bindExample"&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
       &lt;script&gt;=0A=
         angular.module('bindExample', [])=0A=
           .controller('ExampleController', ['$scope', function($scope) {=0A=
             $scope.name =3D 'Whirled';=0A=
           }]);=0A=
       &lt;/script&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
         Enter name: &lt;input type=3D"text" =
ng-model=3D"name"&gt;&lt;br&gt;=0A=
         Hello &lt;span ng-bind=3D"name"&gt;&lt;/span&gt;!=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should check ng-bind', function() {=0A=
         var nameInput =3D element(by.model('name'));=0A=
=0A=
         expect(element(by.binding('name')).getText()).toBe('Whirled');=0A=
         nameInput.clear();=0A=
         nameInput.sendKeys('world');=0A=
         expect(element(by.binding('name')).getText()).toBe('world');=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
var ngBindDirective =3D ['$compile', function($compile) {=0A=
  return {=0A=
    restrict: 'AC',=0A=
    compile: function ngBindCompile(templateElement) {=0A=
      $compile.$$addBindingClass(templateElement);=0A=
      return function ngBindLink(scope, element, attr) {=0A=
        $compile.$$addBindingInfo(element, attr.ngBind);=0A=
        element =3D element[0];=0A=
        scope.$watch(attr.ngBind, function ngBindWatchAction(value) {=0A=
          element.textContent =3D value =3D=3D=3D undefined ? '' : value;=0A=
        });=0A=
      };=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngBindTemplate=0A=
 *=0A=
 * @description=0A=
 * The `ngBindTemplate` directive specifies that the element=0A=
 * text content should be replaced with the interpolation of the template=0A=
 * in the `ngBindTemplate` attribute.=0A=
 * Unlike `ngBind`, the `ngBindTemplate` can contain multiple `{{` `}}`=0A=
 * expressions. This directive is needed since some HTML elements=0A=
 * (such as TITLE and OPTION) cannot contain SPAN elements.=0A=
 *=0A=
 * @element ANY=0A=
 * @param {string} ngBindTemplate template of form=0A=
 *   &lt;tt&gt;{{&lt;/tt&gt; &lt;tt&gt;expression&lt;/tt&gt; =
&lt;tt&gt;}}&lt;/tt&gt; to eval.=0A=
 *=0A=
 * @example=0A=
 * Try it here: enter text in text box and watch the greeting change.=0A=
   &lt;example module=3D"bindExample"&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
       &lt;script&gt;=0A=
         angular.module('bindExample', [])=0A=
           .controller('ExampleController', ['$scope', function ($scope) =
{=0A=
             $scope.salutation =3D 'Hello';=0A=
             $scope.name =3D 'World';=0A=
           }]);=0A=
       &lt;/script&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
        Salutation: &lt;input type=3D"text" =
ng-model=3D"salutation"&gt;&lt;br&gt;=0A=
        Name: &lt;input type=3D"text" ng-model=3D"name"&gt;&lt;br&gt;=0A=
        &lt;pre ng-bind-template=3D"{{salutation}} =
{{name}}!"&gt;&lt;/pre&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should check ng-bind', function() {=0A=
         var salutationElem =3D element(by.binding('salutation'));=0A=
         var salutationInput =3D element(by.model('salutation'));=0A=
         var nameInput =3D element(by.model('name'));=0A=
=0A=
         expect(salutationElem.getText()).toBe('Hello World!');=0A=
=0A=
         salutationInput.clear();=0A=
         salutationInput.sendKeys('Greetings');=0A=
         nameInput.clear();=0A=
         nameInput.sendKeys('user');=0A=
=0A=
         expect(salutationElem.getText()).toBe('Greetings user!');=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
var ngBindTemplateDirective =3D ['$interpolate', '$compile', =
function($interpolate, $compile) {=0A=
  return {=0A=
    compile: function ngBindTemplateCompile(templateElement) {=0A=
      $compile.$$addBindingClass(templateElement);=0A=
      return function ngBindTemplateLink(scope, element, attr) {=0A=
        var interpolateFn =3D =
$interpolate(element.attr(attr.$attr.ngBindTemplate));=0A=
        $compile.$$addBindingInfo(element, interpolateFn.expressions);=0A=
        element =3D element[0];=0A=
        attr.$observe('ngBindTemplate', function(value) {=0A=
          element.textContent =3D value =3D=3D=3D undefined ? '' : value;=0A=
        });=0A=
      };=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngBindHtml=0A=
 *=0A=
 * @description=0A=
 * Creates a binding that will innerHTML the result of evaluating the =
`expression` into the current=0A=
 * element in a secure way.  By default, the innerHTML-ed content will =
be sanitized using the {@link=0A=
 * ngSanitize.$sanitize $sanitize} service.  To utilize this =
functionality, ensure that `$sanitize`=0A=
 * is available, for example, by including {@link ngSanitize} in your =
module's dependencies (not in=0A=
 * core Angular). In order to use {@link ngSanitize} in your module's =
dependencies, you need to=0A=
 * include "angular-sanitize.js" in your application.=0A=
 *=0A=
 * You may also bypass sanitization for values you know are safe. To do =
so, bind to=0A=
 * an explicitly trusted value via {@link ng.$sce#trustAsHtml =
$sce.trustAsHtml}.  See the example=0A=
 * under {@link ng.$sce#show-me-an-example-using-sce- Strict Contextual =
Escaping (SCE)}.=0A=
 *=0A=
 * Note: If a `$sanitize` service is unavailable and the bound value =
isn't explicitly trusted, you=0A=
 * will have an exception (instead of an exploit.)=0A=
 *=0A=
 * @element ANY=0A=
 * @param {expression} ngBindHtml {@link guide/expression Expression} to =
evaluate.=0A=
 *=0A=
 * @example=0A=
=0A=
   &lt;example module=3D"bindHtmlExample" =
deps=3D"angular-sanitize.js"&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
        &lt;p ng-bind-html=3D"myHTML"&gt;&lt;/p&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
=0A=
     &lt;file name=3D"script.js"&gt;=0A=
       angular.module('bindHtmlExample', ['ngSanitize'])=0A=
         .controller('ExampleController', ['$scope', function($scope) {=0A=
           $scope.myHTML =3D=0A=
              'I am an &lt;code&gt;HTML&lt;/code&gt;string with ' +=0A=
              '&lt;a href=3D"#"&gt;links!&lt;/a&gt; and other =
&lt;em&gt;stuff&lt;/em&gt;';=0A=
         }]);=0A=
     &lt;/file&gt;=0A=
=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should check ng-bind-html', function() {=0A=
         expect(element(by.binding('myHTML')).getText()).toBe(=0A=
             'I am an HTMLstring with links! and other stuff');=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
var ngBindHtmlDirective =3D ['$sce', '$parse', '$compile', =
function($sce, $parse, $compile) {=0A=
  return {=0A=
    restrict: 'A',=0A=
    compile: function ngBindHtmlCompile(tElement, tAttrs) {=0A=
      var ngBindHtmlGetter =3D $parse(tAttrs.ngBindHtml);=0A=
      var ngBindHtmlWatch =3D $parse(tAttrs.ngBindHtml, function =
getStringValue(value) {=0A=
        return (value || '').toString();=0A=
      });=0A=
      $compile.$$addBindingClass(tElement);=0A=
=0A=
      return function ngBindHtmlLink(scope, element, attr) {=0A=
        $compile.$$addBindingInfo(element, attr.ngBindHtml);=0A=
=0A=
        scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {=0A=
          // we re-evaluate the expr because we want a =
TrustedValueHolderType=0A=
          // for $sce, not a string=0A=
          element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || =
'');=0A=
        });=0A=
      };=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
function classDirective(name, selector) {=0A=
  name =3D 'ngClass' + name;=0A=
  return ['$animate', function($animate) {=0A=
    return {=0A=
      restrict: 'AC',=0A=
      link: function(scope, element, attr) {=0A=
        var oldVal;=0A=
=0A=
        scope.$watch(attr[name], ngClassWatchAction, true);=0A=
=0A=
        attr.$observe('class', function(value) {=0A=
          ngClassWatchAction(scope.$eval(attr[name]));=0A=
        });=0A=
=0A=
=0A=
        if (name !=3D=3D 'ngClass') {=0A=
          scope.$watch('$index', function($index, old$index) {=0A=
            // jshint bitwise: false=0A=
            var mod =3D $index &amp; 1;=0A=
            if (mod !=3D=3D (old$index &amp; 1)) {=0A=
              var classes =3D arrayClasses(scope.$eval(attr[name]));=0A=
              mod =3D=3D=3D selector ?=0A=
                addClasses(classes) :=0A=
                removeClasses(classes);=0A=
            }=0A=
          });=0A=
        }=0A=
=0A=
        function addClasses(classes) {=0A=
          var newClasses =3D digestClassCounts(classes, 1);=0A=
          attr.$addClass(newClasses);=0A=
        }=0A=
=0A=
        function removeClasses(classes) {=0A=
          var newClasses =3D digestClassCounts(classes, -1);=0A=
          attr.$removeClass(newClasses);=0A=
        }=0A=
=0A=
        function digestClassCounts (classes, count) {=0A=
          var classCounts =3D element.data('$classCounts') || {};=0A=
          var classesToUpdate =3D [];=0A=
          forEach(classes, function (className) {=0A=
            if (count &gt; 0 || classCounts[className]) {=0A=
              classCounts[className] =3D (classCounts[className] || 0) + =
count;=0A=
              if (classCounts[className] =3D=3D=3D +(count &gt; 0)) {=0A=
                classesToUpdate.push(className);=0A=
              }=0A=
            }=0A=
          });=0A=
          element.data('$classCounts', classCounts);=0A=
          return classesToUpdate.join(' ');=0A=
        }=0A=
=0A=
        function updateClasses (oldClasses, newClasses) {=0A=
          var toAdd =3D arrayDifference(newClasses, oldClasses);=0A=
          var toRemove =3D arrayDifference(oldClasses, newClasses);=0A=
          toAdd =3D digestClassCounts(toAdd, 1);=0A=
          toRemove =3D digestClassCounts(toRemove, -1);=0A=
          if (toAdd &amp;&amp; toAdd.length) {=0A=
            $animate.addClass(element, toAdd);=0A=
          }=0A=
          if (toRemove &amp;&amp; toRemove.length) {=0A=
            $animate.removeClass(element, toRemove);=0A=
          }=0A=
        }=0A=
=0A=
        function ngClassWatchAction(newVal) {=0A=
          if (selector =3D=3D=3D true || scope.$index % 2 =3D=3D=3D =
selector) {=0A=
            var newClasses =3D arrayClasses(newVal || []);=0A=
            if (!oldVal) {=0A=
              addClasses(newClasses);=0A=
            } else if (!equals(newVal,oldVal)) {=0A=
              var oldClasses =3D arrayClasses(oldVal);=0A=
              updateClasses(oldClasses, newClasses);=0A=
            }=0A=
          }=0A=
          oldVal =3D shallowCopy(newVal);=0A=
        }=0A=
      }=0A=
    };=0A=
=0A=
    function arrayDifference(tokens1, tokens2) {=0A=
      var values =3D [];=0A=
=0A=
      outer:=0A=
      for(var i =3D 0; i &lt; tokens1.length; i++) {=0A=
        var token =3D tokens1[i];=0A=
        for(var j =3D 0; j &lt; tokens2.length; j++) {=0A=
          if(token =3D=3D tokens2[j]) continue outer;=0A=
        }=0A=
        values.push(token);=0A=
      }=0A=
      return values;=0A=
    }=0A=
=0A=
    function arrayClasses (classVal) {=0A=
      if (isArray(classVal)) {=0A=
        return classVal;=0A=
      } else if (isString(classVal)) {=0A=
        return classVal.split(' ');=0A=
      } else if (isObject(classVal)) {=0A=
        var classes =3D [], i =3D 0;=0A=
        forEach(classVal, function(v, k) {=0A=
          if (v) {=0A=
            classes =3D classes.concat(k.split(' '));=0A=
          }=0A=
        });=0A=
        return classes;=0A=
      }=0A=
      return classVal;=0A=
    }=0A=
  }];=0A=
}=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngClass=0A=
 * @restrict AC=0A=
 *=0A=
 * @description=0A=
 * The `ngClass` directive allows you to dynamically set CSS classes on =
an HTML element by databinding=0A=
 * an expression that represents all classes to be added.=0A=
 *=0A=
 * The directive operates in three different ways, depending on which of =
three types the expression=0A=
 * evaluates to:=0A=
 *=0A=
 * 1. If the expression evaluates to a string, the string should be one =
or more space-delimited class=0A=
 * names.=0A=
 *=0A=
 * 2. If the expression evaluates to an array, each element of the array =
should be a string that is=0A=
 * one or more space-delimited class names.=0A=
 *=0A=
 * 3. If the expression evaluates to an object, then for each key-value =
pair of the=0A=
 * object with a truthy value the corresponding key is used as a class =
name.=0A=
 *=0A=
 * The directive won't add duplicate classes if a particular class was =
already set.=0A=
 *=0A=
 * When the expression changes, the previously added classes are removed =
and only then the=0A=
 * new classes are added.=0A=
 *=0A=
 * @animations=0A=
 * add - happens just before the class is applied to the element=0A=
 * remove - happens just before the class is removed from the element=0A=
 *=0A=
 * @element ANY=0A=
 * @param {expression} ngClass {@link guide/expression Expression} to =
eval. The result=0A=
 *   of the evaluation can be a string representing space delimited class=0A=
 *   names, an array, or a map of class names to boolean values. In the =
case of a map, the=0A=
 *   names of the properties whose values are truthy will be added as =
css classes to the=0A=
 *   element.=0A=
 *=0A=
 * @example Example that demonstrates basic bindings via ngClass =
directive.=0A=
   &lt;example&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
       &lt;p ng-class=3D"{strike: deleted, bold: important, red: =
error}"&gt;Map Syntax Example&lt;/p&gt;=0A=
       &lt;input type=3D"checkbox" ng-model=3D"deleted"&gt; deleted =
(apply "strike" class)&lt;br&gt;=0A=
       &lt;input type=3D"checkbox" ng-model=3D"important"&gt; important =
(apply "bold" class)&lt;br&gt;=0A=
       &lt;input type=3D"checkbox" ng-model=3D"error"&gt; error (apply =
"red" class)=0A=
       &lt;hr&gt;=0A=
       &lt;p ng-class=3D"style"&gt;Using String Syntax&lt;/p&gt;=0A=
       &lt;input type=3D"text" ng-model=3D"style" placeholder=3D"Type: =
bold strike red"&gt;=0A=
       &lt;hr&gt;=0A=
       &lt;p ng-class=3D"[style1, style2, style3]"&gt;Using Array =
Syntax&lt;/p&gt;=0A=
       &lt;input ng-model=3D"style1" placeholder=3D"Type: bold, strike =
or red"&gt;&lt;br&gt;=0A=
       &lt;input ng-model=3D"style2" placeholder=3D"Type: bold, strike =
or red"&gt;&lt;br&gt;=0A=
       &lt;input ng-model=3D"style3" placeholder=3D"Type: bold, strike =
or red"&gt;&lt;br&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"style.css"&gt;=0A=
       .strike {=0A=
         text-decoration: line-through;=0A=
       }=0A=
       .bold {=0A=
           font-weight: bold;=0A=
       }=0A=
       .red {=0A=
           color: red;=0A=
       }=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       var ps =3D element.all(by.css('p'));=0A=
=0A=
       it('should let you toggle the class', function() {=0A=
=0A=
         expect(ps.first().getAttribute('class')).not.toMatch(/bold/);=0A=
         expect(ps.first().getAttribute('class')).not.toMatch(/red/);=0A=
=0A=
         element(by.model('important')).click();=0A=
         expect(ps.first().getAttribute('class')).toMatch(/bold/);=0A=
=0A=
         element(by.model('error')).click();=0A=
         expect(ps.first().getAttribute('class')).toMatch(/red/);=0A=
       });=0A=
=0A=
       it('should let you toggle string example', function() {=0A=
         expect(ps.get(1).getAttribute('class')).toBe('');=0A=
         element(by.model('style')).clear();=0A=
         element(by.model('style')).sendKeys('red');=0A=
         expect(ps.get(1).getAttribute('class')).toBe('red');=0A=
       });=0A=
=0A=
       it('array example should have 3 classes', function() {=0A=
         expect(ps.last().getAttribute('class')).toBe('');=0A=
         element(by.model('style1')).sendKeys('bold');=0A=
         element(by.model('style2')).sendKeys('strike');=0A=
         element(by.model('style3')).sendKeys('red');=0A=
         expect(ps.last().getAttribute('class')).toBe('bold strike red');=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
=0A=
   ## Animations=0A=
=0A=
   The example below demonstrates how to perform animations using =
ngClass.=0A=
=0A=
   &lt;example module=3D"ngAnimate" deps=3D"angular-animate.js" =
animations=3D"true"&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
      &lt;input id=3D"setbtn" type=3D"button" value=3D"set" =
ng-click=3D"myVar=3D'my-class'"&gt;=0A=
      &lt;input id=3D"clearbtn" type=3D"button" value=3D"clear" =
ng-click=3D"myVar=3D''"&gt;=0A=
      &lt;br&gt;=0A=
      &lt;span class=3D"base-class" ng-class=3D"myVar"&gt;Sample =
Text&lt;/span&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"style.css"&gt;=0A=
       .base-class {=0A=
         -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) =
0.5s;=0A=
         transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;=0A=
       }=0A=
=0A=
       .base-class.my-class {=0A=
         color: red;=0A=
         font-size:3em;=0A=
       }=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should check ng-class', function() {=0A=
         =
expect(element(by.css('.base-class')).getAttribute('class')).not.=0A=
           toMatch(/my-class/);=0A=
=0A=
         element(by.id('setbtn')).click();=0A=
=0A=
         expect(element(by.css('.base-class')).getAttribute('class')).=0A=
           toMatch(/my-class/);=0A=
=0A=
         element(by.id('clearbtn')).click();=0A=
=0A=
         =
expect(element(by.css('.base-class')).getAttribute('class')).not.=0A=
           toMatch(/my-class/);=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
=0A=
=0A=
   ## ngClass and pre-existing CSS3 Transitions/Animations=0A=
   The ngClass directive still supports CSS3 Transitions/Animations even =
if they do not follow the ngAnimate CSS naming structure.=0A=
   Upon animation ngAnimate will apply supplementary CSS classes to =
track the start and end of an animation, but this will not hinder=0A=
   any pre-existing CSS transitions already on the element. To get an =
idea of what happens during a class-based animation, be sure=0A=
   to view the step by step details of {@link ng.$animate#addClass =
$animate.addClass} and=0A=
   {@link ng.$animate#removeClass $animate.removeClass}.=0A=
 */=0A=
var ngClassDirective =3D classDirective('', true);=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngClassOdd=0A=
 * @restrict AC=0A=
 *=0A=
 * @description=0A=
 * The `ngClassOdd` and `ngClassEven` directives work exactly as=0A=
 * {@link ng.directive:ngClass ngClass}, except they work in=0A=
 * conjunction with `ngRepeat` and take effect only on odd (even) rows.=0A=
 *=0A=
 * This directive can be applied only within the scope of an=0A=
 * {@link ng.directive:ngRepeat ngRepeat}.=0A=
 *=0A=
 * @element ANY=0A=
 * @param {expression} ngClassOdd {@link guide/expression Expression} to =
eval. The result=0A=
 *   of the evaluation can be a string representing space delimited =
class names or an array.=0A=
 *=0A=
 * @example=0A=
   &lt;example&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
        &lt;ol ng-init=3D"names=3D['John', 'Mary', 'Cate', 'Suz']"&gt;=0A=
          &lt;li ng-repeat=3D"name in names"&gt;=0A=
           &lt;span ng-class-odd=3D"'odd'" ng-class-even=3D"'even'"&gt;=0A=
             {{name}}=0A=
           &lt;/span&gt;=0A=
          &lt;/li&gt;=0A=
        &lt;/ol&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"style.css"&gt;=0A=
       .odd {=0A=
         color: red;=0A=
       }=0A=
       .even {=0A=
         color: blue;=0A=
       }=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should check ng-class-odd and ng-class-even', function() {=0A=
         expect(element(by.repeater('name in =
names').row(0).column('name')).getAttribute('class')).=0A=
           toMatch(/odd/);=0A=
         expect(element(by.repeater('name in =
names').row(1).column('name')).getAttribute('class')).=0A=
           toMatch(/even/);=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
var ngClassOddDirective =3D classDirective('Odd', 0);=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngClassEven=0A=
 * @restrict AC=0A=
 *=0A=
 * @description=0A=
 * The `ngClassOdd` and `ngClassEven` directives work exactly as=0A=
 * {@link ng.directive:ngClass ngClass}, except they work in=0A=
 * conjunction with `ngRepeat` and take effect only on odd (even) rows.=0A=
 *=0A=
 * This directive can be applied only within the scope of an=0A=
 * {@link ng.directive:ngRepeat ngRepeat}.=0A=
 *=0A=
 * @element ANY=0A=
 * @param {expression} ngClassEven {@link guide/expression Expression} =
to eval. The=0A=
 *   result of the evaluation can be a string representing space =
delimited class names or an array.=0A=
 *=0A=
 * @example=0A=
   &lt;example&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
        &lt;ol ng-init=3D"names=3D['John', 'Mary', 'Cate', 'Suz']"&gt;=0A=
          &lt;li ng-repeat=3D"name in names"&gt;=0A=
           &lt;span ng-class-odd=3D"'odd'" ng-class-even=3D"'even'"&gt;=0A=
             {{name}} &amp;nbsp; &amp;nbsp; &amp;nbsp;=0A=
           &lt;/span&gt;=0A=
          &lt;/li&gt;=0A=
        &lt;/ol&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"style.css"&gt;=0A=
       .odd {=0A=
         color: red;=0A=
       }=0A=
       .even {=0A=
         color: blue;=0A=
       }=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should check ng-class-odd and ng-class-even', function() {=0A=
         expect(element(by.repeater('name in =
names').row(0).column('name')).getAttribute('class')).=0A=
           toMatch(/odd/);=0A=
         expect(element(by.repeater('name in =
names').row(1).column('name')).getAttribute('class')).=0A=
           toMatch(/even/);=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
var ngClassEvenDirective =3D classDirective('Even', 1);=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngCloak=0A=
 * @restrict AC=0A=
 *=0A=
 * @description=0A=
 * The `ngCloak` directive is used to prevent the Angular html template =
from being briefly=0A=
 * displayed by the browser in its raw (uncompiled) form while your =
application is loading. Use this=0A=
 * directive to avoid the undesirable flicker effect caused by the html =
template display.=0A=
 *=0A=
 * The directive can be applied to the `&lt;body&gt;` element, but the =
preferred usage is to apply=0A=
 * multiple `ngCloak` directives to small portions of the page to permit =
progressive rendering=0A=
 * of the browser view.=0A=
 *=0A=
 * `ngCloak` works in cooperation with the following css rule embedded =
within `angular.js` and=0A=
 * `angular.min.js`.=0A=
 * For CSP mode please add `angular-csp.css` to your html file (see =
{@link ng.directive:ngCsp ngCsp}).=0A=
 *=0A=
 * ```css=0A=
 * [ng\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, =
.x-ng-cloak {=0A=
 *   display: none !important;=0A=
 * }=0A=
 * ```=0A=
 *=0A=
 * When this css rule is loaded by the browser, all html elements =
(including their children) that=0A=
 * are tagged with the `ngCloak` directive are hidden. When Angular =
encounters this directive=0A=
 * during the compilation of the template it deletes the `ngCloak` =
element attribute, making=0A=
 * the compiled element visible.=0A=
 *=0A=
 * For the best result, the `angular.js` script must be loaded in the =
head section of the html=0A=
 * document; alternatively, the css rule above must be included in the =
external stylesheet of the=0A=
 * application.=0A=
 *=0A=
 * Legacy browsers, like IE7, do not provide attribute selector support =
(added in CSS 2.1) so they=0A=
 * cannot match the `[ng\:cloak]` selector. To work around this =
limitation, you must add the css=0A=
 * class `ng-cloak` in addition to the `ngCloak` directive as shown in =
the example below.=0A=
 *=0A=
 * @element ANY=0A=
 *=0A=
 * @example=0A=
   &lt;example&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
        &lt;div id=3D"template1" ng-cloak&gt;{{ 'hello' }}&lt;/div&gt;=0A=
        &lt;div id=3D"template2" ng-cloak class=3D"ng-cloak"&gt;{{ =
'hello IE7' }}&lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should remove the template directive and css class', =
function() {=0A=
         expect($('#template1').getAttribute('ng-cloak')).=0A=
           toBeNull();=0A=
         expect($('#template2').getAttribute('ng-cloak')).=0A=
           toBeNull();=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 *=0A=
 */=0A=
var ngCloakDirective =3D ngDirective({=0A=
  compile: function(element, attr) {=0A=
    attr.$set('ngCloak', undefined);=0A=
    element.removeClass('ng-cloak');=0A=
  }=0A=
});=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngController=0A=
 *=0A=
 * @description=0A=
 * The `ngController` directive attaches a controller class to the view. =
This is a key aspect of how angular=0A=
 * supports the principles behind the Model-View-Controller design =
pattern.=0A=
 *=0A=
 * MVC components in angular:=0A=
 *=0A=
 * * Model =E2=80&#65533; Models are the properties of a scope; scopes =
are attached to the DOM where scope properties=0A=
 *   are accessed through bindings.=0A=
 * * View =E2=80&#65533; The template (HTML with data bindings) that is =
rendered into the View.=0A=
 * * Controller =E2=80&#65533; The `ngController` directive specifies a =
Controller class; the class contains business=0A=
 *   logic behind the application to decorate the scope with functions =
and values=0A=
 *=0A=
 * Note that you can also attach controllers to the DOM by declaring it =
in a route definition=0A=
 * via the {@link ngRoute.$route $route} service. A common mistake is to =
declare the controller=0A=
 * again using `ng-controller` in the template itself.  This will cause =
the controller to be attached=0A=
 * and executed twice.=0A=
 *=0A=
 * @element ANY=0A=
 * @scope=0A=
 * @priority 500=0A=
 * @param {expression} ngController Name of a constructor function =
registered with the current=0A=
 * {@link ng.$controllerProvider $controllerProvider} or an {@link =
guide/expression expression}=0A=
 * that on the current scope evaluates to a constructor function.=0A=
 *=0A=
 * The controller instance can be published into a scope property by =
specifying=0A=
 * `ng-controller=3D"as propertyName"`.=0A=
 *=0A=
 * If the current `$controllerProvider` is configured to use globals (via=0A=
 * {@link ng.$controllerProvider#allowGlobals =
`$controllerProvider.allowGlobals()` }), this may=0A=
 * also be the name of a globally accessible constructor function (not =
recommended).=0A=
 *=0A=
 * @example=0A=
 * Here is a simple form for editing user contact information. Adding, =
removing, clearing, and=0A=
 * greeting are methods declared on the controller (see source tab). =
These methods can=0A=
 * easily be called from the angular markup. Any changes to the data are =
automatically reflected=0A=
 * in the View without the need for a manual update.=0A=
 *=0A=
 * Two different declaration styles are included below:=0A=
 *=0A=
 * * one binds methods and properties directly onto the controller using =
`this`:=0A=
 * `ng-controller=3D"SettingsController1 as settings"`=0A=
 * * one injects `$scope` into the controller:=0A=
 * `ng-controller=3D"SettingsController2"`=0A=
 *=0A=
 * The second option is more common in the Angular community, and is =
generally used in boilerplates=0A=
 * and in this guide. However, there are advantages to binding =
properties directly to the controller=0A=
 * and avoiding scope.=0A=
 *=0A=
 * * Using `controller as` makes it obvious which controller you are =
accessing in the template when=0A=
 * multiple controllers apply to an element.=0A=
 * * If you are writing your controllers as classes you have easier =
access to the properties and=0A=
 * methods, which will appear on the scope, from inside the controller =
code.=0A=
 * * Since there is always a `.` in the bindings, you don't have to =
worry about prototypal=0A=
 * inheritance masking primitives.=0A=
 *=0A=
 * This example demonstrates the `controller as` syntax.=0A=
 *=0A=
 * &lt;example name=3D"ngControllerAs" module=3D"controllerAsExample"&gt;=0A=
 *   &lt;file name=3D"todoList.html"&gt;=0A=
 *    &lt;div id=3D"ctrl-as-exmpl" ng-controller=3D"SettingsController1 =
as settings"&gt;=0A=
 *      Name: &lt;input type=3D"text" ng-model=3D"settings.name"/&gt;=0A=
 *      [ &lt;a href=3D"" =
ng-click=3D"settings.greet()"&gt;greet&lt;/a&gt; ]&lt;br/&gt;=0A=
 *      Contact:=0A=
 *      &lt;ul&gt;=0A=
 *        &lt;li ng-repeat=3D"contact in settings.contacts"&gt;=0A=
 *          &lt;select ng-model=3D"contact.type"&gt;=0A=
 *             &lt;option&gt;phone&lt;/option&gt;=0A=
 *             &lt;option&gt;email&lt;/option&gt;=0A=
 *          &lt;/select&gt;=0A=
 *          &lt;input type=3D"text" ng-model=3D"contact.value"/&gt;=0A=
 *          [ &lt;a href=3D"" =
ng-click=3D"settings.clearContact(contact)"&gt;clear&lt;/a&gt;=0A=
 *          | &lt;a href=3D"" =
ng-click=3D"settings.removeContact(contact)"&gt;X&lt;/a&gt; ]=0A=
 *        &lt;/li&gt;=0A=
 *        &lt;li&gt;[ &lt;a href=3D"" =
ng-click=3D"settings.addContact()"&gt;add&lt;/a&gt; ]&lt;/li&gt;=0A=
 *     &lt;/ul&gt;=0A=
 *    &lt;/div&gt;=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"app.js"&gt;=0A=
 *    angular.module('controllerAsExample', [])=0A=
 *      .controller('SettingsController1', SettingsController1);=0A=
 *=0A=
 *    function SettingsController1() {=0A=
 *      this.name =3D "John Smith";=0A=
 *      this.contacts =3D [=0A=
 *        {type: 'phone', value: '408 555 1212'},=0A=
 *        {type: 'email', value: 'john.smith@example.org'} ];=0A=
 *    }=0A=
 *=0A=
 *    SettingsController1.prototype.greet =3D function() {=0A=
 *      alert(this.name);=0A=
 *    };=0A=
 *=0A=
 *    SettingsController1.prototype.addContact =3D function() {=0A=
 *      this.contacts.push({type: 'email', value: =
'yourname@example.org'});=0A=
 *    };=0A=
 *=0A=
 *    SettingsController1.prototype.removeContact =3D =
function(contactToRemove) {=0A=
 *     var index =3D this.contacts.indexOf(contactToRemove);=0A=
 *      this.contacts.splice(index, 1);=0A=
 *    };=0A=
 *=0A=
 *    SettingsController1.prototype.clearContact =3D function(contact) {=0A=
 *      contact.type =3D 'phone';=0A=
 *      contact.value =3D '';=0A=
 *    };=0A=
 *   &lt;/file&gt;=0A=
 *   &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
 *     it('should check controller as', function() {=0A=
 *       var container =3D element(by.id('ctrl-as-exmpl'));=0A=
 *         expect(container.element(by.model('settings.name'))=0A=
 *           .getAttribute('value')).toBe('John Smith');=0A=
 *=0A=
 *       var firstRepeat =3D=0A=
 *           container.element(by.repeater('contact in =
settings.contacts').row(0));=0A=
 *       var secondRepeat =3D=0A=
 *           container.element(by.repeater('contact in =
settings.contacts').row(1));=0A=
 *=0A=
 *       =
expect(firstRepeat.element(by.model('contact.value')).getAttribute('value=
'))=0A=
 *           .toBe('408 555 1212');=0A=
 *=0A=
 *       =
expect(secondRepeat.element(by.model('contact.value')).getAttribute('valu=
e'))=0A=
 *           .toBe('john.smith@example.org');=0A=
 *=0A=
 *       firstRepeat.element(by.linkText('clear')).click();=0A=
 *=0A=
 *       =
expect(firstRepeat.element(by.model('contact.value')).getAttribute('value=
'))=0A=
 *           .toBe('');=0A=
 *=0A=
 *       container.element(by.linkText('add')).click();=0A=
 *=0A=
 *       expect(container.element(by.repeater('contact in =
settings.contacts').row(2))=0A=
 *           .element(by.model('contact.value'))=0A=
 *           .getAttribute('value'))=0A=
 *           .toBe('yourname@example.org');=0A=
 *     });=0A=
 *   &lt;/file&gt;=0A=
 * &lt;/example&gt;=0A=
 *=0A=
 * This example demonstrates the "attach to `$scope`" style of =
controller.=0A=
 *=0A=
 * &lt;example name=3D"ngController" module=3D"controllerExample"&gt;=0A=
 *  &lt;file name=3D"todoList.html"&gt;=0A=
 *   &lt;div id=3D"ctrl-exmpl" ng-controller=3D"SettingsController2"&gt;=0A=
 *     Name: &lt;input type=3D"text" ng-model=3D"name"/&gt;=0A=
 *     [ &lt;a href=3D"" ng-click=3D"greet()"&gt;greet&lt;/a&gt; =
]&lt;br/&gt;=0A=
 *     Contact:=0A=
 *     &lt;ul&gt;=0A=
 *       &lt;li ng-repeat=3D"contact in contacts"&gt;=0A=
 *         &lt;select ng-model=3D"contact.type"&gt;=0A=
 *            &lt;option&gt;phone&lt;/option&gt;=0A=
 *            &lt;option&gt;email&lt;/option&gt;=0A=
 *         &lt;/select&gt;=0A=
 *         &lt;input type=3D"text" ng-model=3D"contact.value"/&gt;=0A=
 *         [ &lt;a href=3D"" =
ng-click=3D"clearContact(contact)"&gt;clear&lt;/a&gt;=0A=
 *         | &lt;a href=3D"" =
ng-click=3D"removeContact(contact)"&gt;X&lt;/a&gt; ]=0A=
 *       &lt;/li&gt;=0A=
 *       &lt;li&gt;[ &lt;a href=3D"" =
ng-click=3D"addContact()"&gt;add&lt;/a&gt; ]&lt;/li&gt;=0A=
 *    &lt;/ul&gt;=0A=
 *   &lt;/div&gt;=0A=
 *  &lt;/file&gt;=0A=
 *  &lt;file name=3D"app.js"&gt;=0A=
 *   angular.module('controllerExample', [])=0A=
 *     .controller('SettingsController2', ['$scope', =
SettingsController2]);=0A=
 *=0A=
 *   function SettingsController2($scope) {=0A=
 *     $scope.name =3D "John Smith";=0A=
 *     $scope.contacts =3D [=0A=
 *       {type:'phone', value:'408 555 1212'},=0A=
 *       {type:'email', value:'john.smith@example.org'} ];=0A=
 *=0A=
 *     $scope.greet =3D function() {=0A=
 *       alert($scope.name);=0A=
 *     };=0A=
 *=0A=
 *     $scope.addContact =3D function() {=0A=
 *       $scope.contacts.push({type:'email', =
value:'yourname@example.org'});=0A=
 *     };=0A=
 *=0A=
 *     $scope.removeContact =3D function(contactToRemove) {=0A=
 *       var index =3D $scope.contacts.indexOf(contactToRemove);=0A=
 *       $scope.contacts.splice(index, 1);=0A=
 *     };=0A=
 *=0A=
 *     $scope.clearContact =3D function(contact) {=0A=
 *       contact.type =3D 'phone';=0A=
 *       contact.value =3D '';=0A=
 *     };=0A=
 *   }=0A=
 *  &lt;/file&gt;=0A=
 *  &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
 *    it('should check controller', function() {=0A=
 *      var container =3D element(by.id('ctrl-exmpl'));=0A=
 *=0A=
 *      expect(container.element(by.model('name'))=0A=
 *          .getAttribute('value')).toBe('John Smith');=0A=
 *=0A=
 *      var firstRepeat =3D=0A=
 *          container.element(by.repeater('contact in contacts').row(0));=0A=
 *      var secondRepeat =3D=0A=
 *          container.element(by.repeater('contact in contacts').row(1));=0A=
 *=0A=
 *      =
expect(firstRepeat.element(by.model('contact.value')).getAttribute('value=
'))=0A=
 *          .toBe('408 555 1212');=0A=
 *      =
expect(secondRepeat.element(by.model('contact.value')).getAttribute('valu=
e'))=0A=
 *          .toBe('john.smith@example.org');=0A=
 *=0A=
 *      firstRepeat.element(by.linkText('clear')).click();=0A=
 *=0A=
 *      =
expect(firstRepeat.element(by.model('contact.value')).getAttribute('value=
'))=0A=
 *          .toBe('');=0A=
 *=0A=
 *      container.element(by.linkText('add')).click();=0A=
 *=0A=
 *      expect(container.element(by.repeater('contact in =
contacts').row(2))=0A=
 *          .element(by.model('contact.value'))=0A=
 *          .getAttribute('value'))=0A=
 *          .toBe('yourname@example.org');=0A=
 *    });=0A=
 *  &lt;/file&gt;=0A=
 *&lt;/example&gt;=0A=
=0A=
 */=0A=
var ngControllerDirective =3D [function() {=0A=
  return {=0A=
    restrict: 'A',=0A=
    scope: true,=0A=
    controller: '@',=0A=
    priority: 500=0A=
  };=0A=
}];=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngCsp=0A=
 *=0A=
 * @element html=0A=
 * @description=0A=
 * Enables [CSP (Content Security =
Policy)](https://developer.mozilla.org/en/Security/CSP) support.=0A=
 *=0A=
 * This is necessary when developing things like Google Chrome =
Extensions or Universal Windows Apps.=0A=
 *=0A=
 * CSP forbids apps to use `eval` or `Function(string)` generated =
functions (among other things).=0A=
 * For Angular to be CSP compatible there are only two things that we =
need to do differently:=0A=
 *=0A=
 * - don't use `Function` constructor to generate optimized value getters=0A=
 * - don't inject custom stylesheet into the document=0A=
 *=0A=
 * AngularJS uses `Function(string)` generated functions as a speed =
optimization. Applying the `ngCsp`=0A=
 * directive will cause Angular to use CSP compatibility mode. When this =
mode is on AngularJS will=0A=
 * evaluate all expressions up to 30% slower than in non-CSP mode, but =
no security violations will=0A=
 * be raised.=0A=
 *=0A=
 * CSP forbids JavaScript to inline stylesheet rules. In non CSP mode =
Angular automatically=0A=
 * includes some CSS rules (e.g. {@link ng.directive:ngCloak ngCloak}).=0A=
 * To make those directives work in CSP mode, include the =
`angular-csp.css` manually.=0A=
 *=0A=
 * Angular tries to autodetect if CSP is active and automatically turn =
on the CSP-safe mode. This=0A=
 * autodetection however triggers a CSP error to be logged in the =
console:=0A=
 *=0A=
 * ```=0A=
 * Refused to evaluate a string as JavaScript because 'unsafe-eval' is =
not an allowed source of=0A=
 * script in the following Content Security Policy directive: =
"default-src 'self'". Note that=0A=
 * 'script-src' was not explicitly set, so 'default-src' is used as a =
fallback.=0A=
 * ```=0A=
 *=0A=
 * This error is harmless but annoying. To prevent the error from =
showing up, put the `ngCsp`=0A=
 * directive on the root element of the application or on the =
`angular.js` script tag, whichever=0A=
 * appears first in the html document.=0A=
 *=0A=
 * *Note: This directive is only available in the `ng-csp` and =
`data-ng-csp` attribute form.*=0A=
 *=0A=
 * @example=0A=
 * This example shows how to apply the `ngCsp` directive to the `html` =
tag.=0A=
   ```html=0A=
     &lt;!doctype html&gt;=0A=
     &lt;html ng-app ng-csp&gt;=0A=
     ...=0A=
     ...=0A=
     &lt;/html&gt;=0A=
   ```=0A=
  * @example=0A=
      // Note: the suffix `.csp` in the example name triggers=0A=
      // csp mode in our http server!=0A=
      &lt;example name=3D"example.csp" module=3D"cspExample" =
ng-csp=3D"true"&gt;=0A=
        &lt;file name=3D"todoList.html"&gt;=0A=
          &lt;div ng-controller=3D"MainController as ctrl"&gt;=0A=
            &lt;div&gt;=0A=
              &lt;button ng-click=3D"ctrl.inc()" =
id=3D"inc"&gt;Increment&lt;/button&gt;=0A=
              &lt;span id=3D"counter"&gt;=0A=
                {{ctrl.counter}}=0A=
              &lt;/span&gt;=0A=
            &lt;/div&gt;=0A=
=0A=
            &lt;div&gt;=0A=
              &lt;button ng-click=3D"ctrl.evil()" =
id=3D"evil"&gt;Evil&lt;/button&gt;=0A=
              &lt;span id=3D"evilError"&gt;=0A=
                {{ctrl.evilError}}=0A=
              &lt;/span&gt;=0A=
            &lt;/div&gt;=0A=
          &lt;/div&gt;=0A=
        &lt;/file&gt;=0A=
        &lt;file name=3D"script.js"&gt;=0A=
           angular.module('cspExample', [])=0A=
             .controller('MainController', function() {=0A=
                this.counter =3D 0;=0A=
                this.inc =3D function() {=0A=
                  this.counter++;=0A=
                };=0A=
                this.evil =3D function() {=0A=
                  // jshint evil:true=0A=
                  try {=0A=
                    eval('1+2');=0A=
                  } catch (e) {=0A=
                    this.evilError =3D e.message;=0A=
                  }=0A=
                };=0A=
              });=0A=
        &lt;/file&gt;=0A=
        &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
          var util, webdriver;=0A=
=0A=
          var incBtn =3D element(by.id('inc'));=0A=
          var counter =3D element(by.id('counter'));=0A=
          var evilBtn =3D element(by.id('evil'));=0A=
          var evilError =3D element(by.id('evilError'));=0A=
=0A=
          function getAndClearSevereErrors() {=0A=
            return =
browser.manage().logs().get('browser').then(function(browserLog) {=0A=
              return browserLog.filter(function(logEntry) {=0A=
                return logEntry.level.value &gt; =
webdriver.logging.Level.WARNING.value;=0A=
              });=0A=
            });=0A=
          }=0A=
=0A=
          function clearErrors() {=0A=
            getAndClearSevereErrors();=0A=
          }=0A=
=0A=
          function expectNoErrors() {=0A=
            getAndClearSevereErrors().then(function(filteredLog) {=0A=
              expect(filteredLog.length).toEqual(0);=0A=
              if (filteredLog.length) {=0A=
                console.log('browser console errors: ' + =
util.inspect(filteredLog));=0A=
              }=0A=
            });=0A=
          }=0A=
=0A=
          function expectError(regex) {=0A=
            getAndClearSevereErrors().then(function(filteredLog) {=0A=
              var found =3D false;=0A=
              filteredLog.forEach(function(log) {=0A=
                if (log.message.match(regex)) {=0A=
                  found =3D true;=0A=
                }=0A=
              });=0A=
              if (!found) {=0A=
                throw new Error('expected an error that matches ' + =
regex);=0A=
              }=0A=
            });=0A=
          }=0A=
=0A=
          beforeEach(function() {=0A=
            util =3D require('util');=0A=
            webdriver =3D =
require('protractor/node_modules/selenium-webdriver');=0A=
          });=0A=
=0A=
          // For now, we only test on Chrome,=0A=
          // as Safari does not load the page with Protractor's injected =
scripts,=0A=
          // and Firefox webdriver always disables content security =
policy (#6358)=0A=
          if (browser.params.browser !=3D=3D 'chrome') {=0A=
            return;=0A=
          }=0A=
=0A=
          it('should not report errors when the page is loaded', =
function() {=0A=
            // clear errors so we are not dependent on previous tests=0A=
            clearErrors();=0A=
            // Need to reload the page as the page is already loaded when=0A=
            // we come here=0A=
            browser.driver.getCurrentUrl().then(function(url) {=0A=
              browser.get(url);=0A=
            });=0A=
            expectNoErrors();=0A=
          });=0A=
=0A=
          it('should evaluate expressions', function() {=0A=
            expect(counter.getText()).toEqual('0');=0A=
            incBtn.click();=0A=
            expect(counter.getText()).toEqual('1');=0A=
            expectNoErrors();=0A=
          });=0A=
=0A=
          it('should throw and report an error when using "eval"', =
function() {=0A=
            evilBtn.click();=0A=
            expect(evilError.getText()).toMatch(/Content Security =
Policy/);=0A=
            expectError(/Content Security Policy/);=0A=
          });=0A=
        &lt;/file&gt;=0A=
      &lt;/example&gt;=0A=
  */=0A=
=0A=
// ngCsp is not implemented as a proper directive any more, because we =
need it be processed while we=0A=
// bootstrap the system (before $parse is instantiated), for this reason =
we just have=0A=
// the csp.isActive() fn that looks for ng-csp attribute anywhere in the =
current doc=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngClick=0A=
 *=0A=
 * @description=0A=
 * The ngClick directive allows you to specify custom behavior when=0A=
 * an element is clicked.=0A=
 *=0A=
 * @element ANY=0A=
 * @priority 0=0A=
 * @param {expression} ngClick {@link guide/expression Expression} to =
evaluate upon=0A=
 * click. ({@link guide/expression#-event- Event object is available as =
`$event`})=0A=
 *=0A=
 * @example=0A=
   &lt;example&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
      &lt;button ng-click=3D"count =3D count + 1" =
ng-init=3D"count=3D0"&gt;=0A=
        Increment=0A=
      &lt;/button&gt;=0A=
      &lt;span&gt;=0A=
        count: {{count}}=0A=
      &lt;/span&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should check ng-click', function() {=0A=
         expect(element(by.binding('count')).getText()).toMatch('0');=0A=
         element(by.css('button')).click();=0A=
         expect(element(by.binding('count')).getText()).toMatch('1');=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
/*=0A=
 * A directive that allows creation of custom onclick handlers that are =
defined as angular=0A=
 * expressions and are compiled and executed within the current scope.=0A=
 *=0A=
 * Events that are handled via these handler are always configured not =
to propagate further.=0A=
 */=0A=
var ngEventDirectives =3D {};=0A=
=0A=
// For events that might fire synchronously during DOM manipulation=0A=
// we need to execute their event handlers asynchronously using =
$evalAsync,=0A=
// so that they are not executed in an inconsistent state.=0A=
var forceAsyncEvents =3D {=0A=
  'blur': true,=0A=
  'focus': true=0A=
};=0A=
forEach(=0A=
  'click dblclick mousedown mouseup mouseover mouseout mousemove =
mouseenter mouseleave keydown keyup keypress submit focus blur copy cut =
paste'.split(' '),=0A=
  function(eventName) {=0A=
    var directiveName =3D directiveNormalize('ng-' + eventName);=0A=
    ngEventDirectives[directiveName] =3D ['$parse', '$rootScope', =
function($parse, $rootScope) {=0A=
      return {=0A=
        restrict: 'A',=0A=
        compile: function($element, attr) {=0A=
          var fn =3D $parse(attr[directiveName]);=0A=
          return function ngEventHandler(scope, element) {=0A=
            element.on(eventName, function(event) {=0A=
              var callback =3D function() {=0A=
                fn(scope, {$event:event});=0A=
              };=0A=
              if (forceAsyncEvents[eventName] &amp;&amp; =
$rootScope.$$phase) {=0A=
                scope.$evalAsync(callback);=0A=
              } else {=0A=
                scope.$apply(callback);=0A=
              }=0A=
            });=0A=
          };=0A=
        }=0A=
      };=0A=
    }];=0A=
  }=0A=
);=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngDblclick=0A=
 *=0A=
 * @description=0A=
 * The `ngDblclick` directive allows you to specify custom behavior on a =
dblclick event.=0A=
 *=0A=
 * @element ANY=0A=
 * @priority 0=0A=
 * @param {expression} ngDblclick {@link guide/expression Expression} to =
evaluate upon=0A=
 * a dblclick. (The Event object is available as `$event`)=0A=
 *=0A=
 * @example=0A=
   &lt;example&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
      &lt;button ng-dblclick=3D"count =3D count + 1" =
ng-init=3D"count=3D0"&gt;=0A=
        Increment (on double click)=0A=
      &lt;/button&gt;=0A=
      count: {{count}}=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngMousedown=0A=
 *=0A=
 * @description=0A=
 * The ngMousedown directive allows you to specify custom behavior on =
mousedown event.=0A=
 *=0A=
 * @element ANY=0A=
 * @priority 0=0A=
 * @param {expression} ngMousedown {@link guide/expression Expression} =
to evaluate upon=0A=
 * mousedown. ({@link guide/expression#-event- Event object is available =
as `$event`})=0A=
 *=0A=
 * @example=0A=
   &lt;example&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
      &lt;button ng-mousedown=3D"count =3D count + 1" =
ng-init=3D"count=3D0"&gt;=0A=
        Increment (on mouse down)=0A=
      &lt;/button&gt;=0A=
      count: {{count}}=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngMouseup=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on mouseup event.=0A=
 *=0A=
 * @element ANY=0A=
 * @priority 0=0A=
 * @param {expression} ngMouseup {@link guide/expression Expression} to =
evaluate upon=0A=
 * mouseup. ({@link guide/expression#-event- Event object is available =
as `$event`})=0A=
 *=0A=
 * @example=0A=
   &lt;example&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
      &lt;button ng-mouseup=3D"count =3D count + 1" =
ng-init=3D"count=3D0"&gt;=0A=
        Increment (on mouse up)=0A=
      &lt;/button&gt;=0A=
      count: {{count}}=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngMouseover=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on mouseover event.=0A=
 *=0A=
 * @element ANY=0A=
 * @priority 0=0A=
 * @param {expression} ngMouseover {@link guide/expression Expression} =
to evaluate upon=0A=
 * mouseover. ({@link guide/expression#-event- Event object is available =
as `$event`})=0A=
 *=0A=
 * @example=0A=
   &lt;example&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
      &lt;button ng-mouseover=3D"count =3D count + 1" =
ng-init=3D"count=3D0"&gt;=0A=
        Increment (when mouse is over)=0A=
      &lt;/button&gt;=0A=
      count: {{count}}=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngMouseenter=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on mouseenter event.=0A=
 *=0A=
 * @element ANY=0A=
 * @priority 0=0A=
 * @param {expression} ngMouseenter {@link guide/expression Expression} =
to evaluate upon=0A=
 * mouseenter. ({@link guide/expression#-event- Event object is =
available as `$event`})=0A=
 *=0A=
 * @example=0A=
   &lt;example&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
      &lt;button ng-mouseenter=3D"count =3D count + 1" =
ng-init=3D"count=3D0"&gt;=0A=
        Increment (when mouse enters)=0A=
      &lt;/button&gt;=0A=
      count: {{count}}=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngMouseleave=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on mouseleave event.=0A=
 *=0A=
 * @element ANY=0A=
 * @priority 0=0A=
 * @param {expression} ngMouseleave {@link guide/expression Expression} =
to evaluate upon=0A=
 * mouseleave. ({@link guide/expression#-event- Event object is =
available as `$event`})=0A=
 *=0A=
 * @example=0A=
   &lt;example&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
      &lt;button ng-mouseleave=3D"count =3D count + 1" =
ng-init=3D"count=3D0"&gt;=0A=
        Increment (when mouse leaves)=0A=
      &lt;/button&gt;=0A=
      count: {{count}}=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngMousemove=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on mousemove event.=0A=
 *=0A=
 * @element ANY=0A=
 * @priority 0=0A=
 * @param {expression} ngMousemove {@link guide/expression Expression} =
to evaluate upon=0A=
 * mousemove. ({@link guide/expression#-event- Event object is available =
as `$event`})=0A=
 *=0A=
 * @example=0A=
   &lt;example&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
      &lt;button ng-mousemove=3D"count =3D count + 1" =
ng-init=3D"count=3D0"&gt;=0A=
        Increment (when mouse moves)=0A=
      &lt;/button&gt;=0A=
      count: {{count}}=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngKeydown=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on keydown event.=0A=
 *=0A=
 * @element ANY=0A=
 * @priority 0=0A=
 * @param {expression} ngKeydown {@link guide/expression Expression} to =
evaluate upon=0A=
 * keydown. (Event object is available as `$event` and can be =
interrogated for keyCode, altKey, etc.)=0A=
 *=0A=
 * @example=0A=
   &lt;example&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
      &lt;input ng-keydown=3D"count =3D count + 1" =
ng-init=3D"count=3D0"&gt;=0A=
      key down count: {{count}}=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngKeyup=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on keyup event.=0A=
 *=0A=
 * @element ANY=0A=
 * @priority 0=0A=
 * @param {expression} ngKeyup {@link guide/expression Expression} to =
evaluate upon=0A=
 * keyup. (Event object is available as `$event` and can be interrogated =
for keyCode, altKey, etc.)=0A=
 *=0A=
 * @example=0A=
   &lt;example&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
       &lt;p&gt;Typing in the input box below updates the key =
count&lt;/p&gt;=0A=
       &lt;input ng-keyup=3D"count =3D count + 1" =
ng-init=3D"count=3D0"&gt; key up count: {{count}}=0A=
=0A=
       &lt;p&gt;Typing in the input box below updates the =
keycode&lt;/p&gt;=0A=
       &lt;input ng-keyup=3D"event=3D$event"&gt;=0A=
       &lt;p&gt;event keyCode: {{ event.keyCode }}&lt;/p&gt;=0A=
       &lt;p&gt;event altKey: {{ event.altKey }}&lt;/p&gt;=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngKeypress=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on keypress event.=0A=
 *=0A=
 * @element ANY=0A=
 * @param {expression} ngKeypress {@link guide/expression Expression} to =
evaluate upon=0A=
 * keypress. ({@link guide/expression#-event- Event object is available =
as `$event`}=0A=
 * and can be interrogated for keyCode, altKey, etc.)=0A=
 *=0A=
 * @example=0A=
   &lt;example&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
      &lt;input ng-keypress=3D"count =3D count + 1" =
ng-init=3D"count=3D0"&gt;=0A=
      key press count: {{count}}=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngSubmit=0A=
 *=0A=
 * @description=0A=
 * Enables binding angular expressions to onsubmit events.=0A=
 *=0A=
 * Additionally it prevents the default action (which for form means =
sending the request to the=0A=
 * server and reloading the current page), but only if the form does not =
contain `action`,=0A=
 * `data-action`, or `x-action` attributes.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * **Warning:** Be careful not to cause "double-submission" by using =
both the `ngClick` and=0A=
 * `ngSubmit` handlers together. See the=0A=
 * {@link form#submitting-a-form-and-preventing-the-default-action =
`form` directive documentation}=0A=
 * for a detailed discussion of when `ngSubmit` may be triggered.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * @element form=0A=
 * @priority 0=0A=
 * @param {expression} ngSubmit {@link guide/expression Expression} to =
eval.=0A=
 * ({@link guide/expression#-event- Event object is available as =
`$event`})=0A=
 *=0A=
 * @example=0A=
   &lt;example module=3D"submitExample"&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
      &lt;script&gt;=0A=
        angular.module('submitExample', [])=0A=
          .controller('ExampleController', ['$scope', function($scope) {=0A=
            $scope.list =3D [];=0A=
            $scope.text =3D 'hello';=0A=
            $scope.submit =3D function() {=0A=
              if ($scope.text) {=0A=
                $scope.list.push(this.text);=0A=
                $scope.text =3D '';=0A=
              }=0A=
            };=0A=
          }]);=0A=
      &lt;/script&gt;=0A=
      &lt;form ng-submit=3D"submit()" =
ng-controller=3D"ExampleController"&gt;=0A=
        Enter text and hit enter:=0A=
        &lt;input type=3D"text" ng-model=3D"text" name=3D"text" /&gt;=0A=
        &lt;input type=3D"submit" id=3D"submit" value=3D"Submit" /&gt;=0A=
        &lt;pre&gt;list=3D{{list}}&lt;/pre&gt;=0A=
      &lt;/form&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should check ng-submit', function() {=0A=
         expect(element(by.binding('list')).getText()).toBe('list=3D[]');=0A=
         element(by.css('#submit')).click();=0A=
         =
expect(element(by.binding('list')).getText()).toContain('hello');=0A=
         =
expect(element(by.model('text')).getAttribute('value')).toBe('');=0A=
       });=0A=
       it('should ignore empty strings', function() {=0A=
         expect(element(by.binding('list')).getText()).toBe('list=3D[]');=0A=
         element(by.css('#submit')).click();=0A=
         element(by.css('#submit')).click();=0A=
         =
expect(element(by.binding('list')).getText()).toContain('hello');=0A=
        });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngFocus=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on focus event.=0A=
 *=0A=
 * Note: As the `focus` event is executed synchronously when calling =
`input.focus()`=0A=
 * AngularJS executes the expression using `scope.$evalAsync` if the =
event is fired=0A=
 * during an `$apply` to ensure a consistent state.=0A=
 *=0A=
 * @element window, input, select, textarea, a=0A=
 * @priority 0=0A=
 * @param {expression} ngFocus {@link guide/expression Expression} to =
evaluate upon=0A=
 * focus. ({@link guide/expression#-event- Event object is available as =
`$event`})=0A=
 *=0A=
 * @example=0A=
 * See {@link ng.directive:ngClick ngClick}=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngBlur=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on blur event.=0A=
 *=0A=
 * A [blur =
event](https://developer.mozilla.org/en-US/docs/Web/Events/blur) fires =
when=0A=
 * an element has lost focus.=0A=
 *=0A=
 * Note: As the `blur` event is executed synchronously also during DOM =
manipulations=0A=
 * (e.g. removing a focussed input),=0A=
 * AngularJS executes the expression using `scope.$evalAsync` if the =
event is fired=0A=
 * during an `$apply` to ensure a consistent state.=0A=
 *=0A=
 * @element window, input, select, textarea, a=0A=
 * @priority 0=0A=
 * @param {expression} ngBlur {@link guide/expression Expression} to =
evaluate upon=0A=
 * blur. ({@link guide/expression#-event- Event object is available as =
`$event`})=0A=
 *=0A=
 * @example=0A=
 * See {@link ng.directive:ngClick ngClick}=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngCopy=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on copy event.=0A=
 *=0A=
 * @element window, input, select, textarea, a=0A=
 * @priority 0=0A=
 * @param {expression} ngCopy {@link guide/expression Expression} to =
evaluate upon=0A=
 * copy. ({@link guide/expression#-event- Event object is available as =
`$event`})=0A=
 *=0A=
 * @example=0A=
   &lt;example&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
      &lt;input ng-copy=3D"copied=3Dtrue" ng-init=3D"copied=3Dfalse; =
value=3D'copy me'" ng-model=3D"value"&gt;=0A=
      copied: {{copied}}=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngCut=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on cut event.=0A=
 *=0A=
 * @element window, input, select, textarea, a=0A=
 * @priority 0=0A=
 * @param {expression} ngCut {@link guide/expression Expression} to =
evaluate upon=0A=
 * cut. ({@link guide/expression#-event- Event object is available as =
`$event`})=0A=
 *=0A=
 * @example=0A=
   &lt;example&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
      &lt;input ng-cut=3D"cut=3Dtrue" ng-init=3D"cut=3Dfalse; =
value=3D'cut me'" ng-model=3D"value"&gt;=0A=
      cut: {{cut}}=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngPaste=0A=
 *=0A=
 * @description=0A=
 * Specify custom behavior on paste event.=0A=
 *=0A=
 * @element window, input, select, textarea, a=0A=
 * @priority 0=0A=
 * @param {expression} ngPaste {@link guide/expression Expression} to =
evaluate upon=0A=
 * paste. ({@link guide/expression#-event- Event object is available as =
`$event`})=0A=
 *=0A=
 * @example=0A=
   &lt;example&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
      &lt;input ng-paste=3D"paste=3Dtrue" ng-init=3D"paste=3Dfalse" =
placeholder=3D'paste here'&gt;=0A=
      pasted: {{paste}}=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngIf=0A=
 * @restrict A=0A=
 *=0A=
 * @description=0A=
 * The `ngIf` directive removes or recreates a portion of the DOM tree =
based on an=0A=
 * {expression}. If the expression assigned to `ngIf` evaluates to a =
false=0A=
 * value then the element is removed from the DOM, otherwise a clone of =
the=0A=
 * element is reinserted into the DOM.=0A=
 *=0A=
 * `ngIf` differs from `ngShow` and `ngHide` in that `ngIf` completely =
removes and recreates the=0A=
 * element in the DOM rather than changing its visibility via the =
`display` css property.  A common=0A=
 * case when this difference is significant is when using css selectors =
that rely on an element's=0A=
 * position within the DOM, such as the `:first-child` or `:last-child` =
pseudo-classes.=0A=
 *=0A=
 * Note that when an element is removed using `ngIf` its scope is =
destroyed and a new scope=0A=
 * is created when the element is restored.  The scope created within =
`ngIf` inherits from=0A=
 * its parent scope using=0A=
 * [prototypal =
inheritance](https://github.com/angular/angular.js/wiki/Understanding-Sco=
pes#javascript-prototypal-inheritance).=0A=
 * An important implication of this is if `ngModel` is used within =
`ngIf` to bind to=0A=
 * a javascript primitive defined in the parent scope. In this case any =
modifications made to the=0A=
 * variable within the child scope will override (hide) the value in the =
parent scope.=0A=
 *=0A=
 * Also, `ngIf` recreates elements using their compiled state. An =
example of this behavior=0A=
 * is if an element's class attribute is directly modified after it's =
compiled, using something like=0A=
 * jQuery's `.addClass()` method, and the element is later removed. When =
`ngIf` recreates the element=0A=
 * the added class will be lost because the original compiled state is =
used to regenerate the element.=0A=
 *=0A=
 * Additionally, you can provide animations via the `ngAnimate` module =
to animate the `enter`=0A=
 * and `leave` effects.=0A=
 *=0A=
 * @animations=0A=
 * enter - happens just after the `ngIf` contents change and a new DOM =
element is created and injected into the `ngIf` container=0A=
 * leave - happens just before the `ngIf` contents are removed from the =
DOM=0A=
 *=0A=
 * @element ANY=0A=
 * @scope=0A=
 * @priority 600=0A=
 * @param {expression} ngIf If the {@link guide/expression expression} =
is falsy then=0A=
 *     the element is removed from the DOM tree. If it is truthy a copy =
of the compiled=0A=
 *     element is added to the DOM tree.=0A=
 *=0A=
 * @example=0A=
  &lt;example module=3D"ngAnimate" deps=3D"angular-animate.js" =
animations=3D"true"&gt;=0A=
    &lt;file name=3D"todoList.html"&gt;=0A=
      Click me: &lt;input type=3D"checkbox" ng-model=3D"checked" =
ng-init=3D"checked=3Dtrue" /&gt;&lt;br/&gt;=0A=
      Show when checked:=0A=
      &lt;span ng-if=3D"checked" class=3D"animate-if"&gt;=0A=
        This is removed when the checkbox is unchecked.=0A=
      &lt;/span&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"animations.css"&gt;=0A=
      .animate-if {=0A=
        background:white;=0A=
        border:1px solid black;=0A=
        padding:10px;=0A=
      }=0A=
=0A=
      .animate-if.ng-enter, .animate-if.ng-leave {=0A=
        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) =
0.5s;=0A=
        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;=0A=
      }=0A=
=0A=
      .animate-if.ng-enter,=0A=
      .animate-if.ng-leave.ng-leave-active {=0A=
        opacity:0;=0A=
      }=0A=
=0A=
      .animate-if.ng-leave,=0A=
      .animate-if.ng-enter.ng-enter-active {=0A=
        opacity:1;=0A=
      }=0A=
    &lt;/file&gt;=0A=
  &lt;/example&gt;=0A=
 */=0A=
var ngIfDirective =3D ['$animate', function($animate) {=0A=
  return {=0A=
    multiElement: true,=0A=
    transclude: 'element',=0A=
    priority: 600,=0A=
    terminal: true,=0A=
    restrict: 'A',=0A=
    $$tlb: true,=0A=
    link: function ($scope, $element, $attr, ctrl, $transclude) {=0A=
        var block, childScope, previousElements;=0A=
        $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {=0A=
=0A=
          if (value) {=0A=
            if (!childScope) {=0A=
              $transclude(function (clone, newScope) {=0A=
                childScope =3D newScope;=0A=
                clone[clone.length++] =3D document.createComment(' end =
ngIf: ' + $attr.ngIf + ' ');=0A=
                // Note: We only need the first/last node of the cloned =
nodes.=0A=
                // However, we need to keep the reference to the jqlite =
wrapper as it might be changed later=0A=
                // by a directive with templateUrl when its template =
arrives.=0A=
                block =3D {=0A=
                  clone: clone=0A=
                };=0A=
                $animate.enter(clone, $element.parent(), $element);=0A=
              });=0A=
            }=0A=
          } else {=0A=
            if (previousElements) {=0A=
              previousElements.remove();=0A=
              previousElements =3D null;=0A=
            }=0A=
            if (childScope) {=0A=
              childScope.$destroy();=0A=
              childScope =3D null;=0A=
            }=0A=
            if (block) {=0A=
              previousElements =3D getBlockNodes(block.clone);=0A=
              $animate.leave(previousElements).then(function() {=0A=
                previousElements =3D null;=0A=
              });=0A=
              block =3D null;=0A=
            }=0A=
          }=0A=
        });=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngInclude=0A=
 * @restrict ECA=0A=
 *=0A=
 * @description=0A=
 * Fetches, compiles and includes an external HTML fragment.=0A=
 *=0A=
 * By default, the template URL is restricted to the same domain and =
protocol as the=0A=
 * application document. This is done by calling {@link =
$sce#getTrustedResourceUrl=0A=
 * $sce.getTrustedResourceUrl} on it. To load templates from other =
domains or protocols=0A=
 * you may either {@link ng.$sceDelegateProvider#resourceUrlWhitelist =
whitelist them} or=0A=
 * {@link $sce#trustAsResourceUrl wrap them} as trusted values. Refer to =
Angular's {@link=0A=
 * ng.$sce Strict Contextual Escaping}.=0A=
 *=0A=
 * In addition, the browser's=0A=
 * [Same Origin =
Policy](https://code.google.com/p/browsersec/wiki/Part2#Same-origin_polic=
y_for_XMLHttpRequest)=0A=
 * and [Cross-Origin Resource Sharing (CORS)](http://www.w3.org/TR/cors/)=0A=
 * policy may further restrict whether the template is successfully =
loaded.=0A=
 * For example, `ngInclude` won't work for cross-domain requests on all =
browsers and for `file://`=0A=
 * access on some browsers.=0A=
 *=0A=
 * @animations=0A=
 * enter - animation is used to bring new content into the browser.=0A=
 * leave - animation is used to animate existing content away.=0A=
 *=0A=
 * The enter and leave animation occur concurrently.=0A=
 *=0A=
 * @scope=0A=
 * @priority 400=0A=
 *=0A=
 * @param {string} ngInclude|src angular expression evaluating to URL. =
If the source is a string constant,=0A=
 *                 make sure you wrap it in **single** quotes, e.g. =
`src=3D"'myPartialTemplate.html'"`.=0A=
 * @param {string=3D} onload Expression to evaluate when a new partial =
is loaded.=0A=
 *=0A=
 * @param {string=3D} autoscroll Whether `ngInclude` should call {@link =
ng.$anchorScroll=0A=
 *                  $anchorScroll} to scroll the viewport after the =
content is loaded.=0A=
 *=0A=
 *                  - If the attribute is not set, disable scrolling.=0A=
 *                  - If the attribute is set without value, enable =
scrolling.=0A=
 *                  - Otherwise enable scrolling only if the expression =
evaluates to truthy value.=0A=
 *=0A=
 * @example=0A=
  &lt;example module=3D"includeExample" deps=3D"angular-animate.js" =
animations=3D"true"&gt;=0A=
    &lt;file name=3D"todoList.html"&gt;=0A=
     &lt;div ng-controller=3D"ExampleController"&gt;=0A=
       &lt;select ng-model=3D"template" ng-options=3D"t.name for t in =
templates"&gt;=0A=
        &lt;option value=3D""&gt;(blank)&lt;/option&gt;=0A=
       &lt;/select&gt;=0A=
       url of the template: &lt;tt&gt;{{template.url}}&lt;/tt&gt;=0A=
       &lt;hr/&gt;=0A=
       &lt;div class=3D"slide-animate-container"&gt;=0A=
         &lt;div class=3D"slide-animate" =
ng-include=3D"template.url"&gt;&lt;/div&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/div&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"script.js"&gt;=0A=
      angular.module('includeExample', ['ngAnimate'])=0A=
        .controller('ExampleController', ['$scope', function($scope) {=0A=
          $scope.templates =3D=0A=
            [ { name: 'template1.html', url: 'template1.html'},=0A=
              { name: 'template2.html', url: 'template2.html'} ];=0A=
          $scope.template =3D $scope.templates[0];=0A=
        }]);=0A=
     &lt;/file&gt;=0A=
    &lt;file name=3D"template1.html"&gt;=0A=
      Content of template1.html=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"template2.html"&gt;=0A=
      Content of template2.html=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"animations.css"&gt;=0A=
      .slide-animate-container {=0A=
        position:relative;=0A=
        background:white;=0A=
        border:1px solid black;=0A=
        height:40px;=0A=
        overflow:hidden;=0A=
      }=0A=
=0A=
      .slide-animate {=0A=
        padding:10px;=0A=
      }=0A=
=0A=
      .slide-animate.ng-enter, .slide-animate.ng-leave {=0A=
        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) =
0.5s;=0A=
        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;=0A=
=0A=
        position:absolute;=0A=
        top:0;=0A=
        left:0;=0A=
        right:0;=0A=
        bottom:0;=0A=
        display:block;=0A=
        padding:10px;=0A=
      }=0A=
=0A=
      .slide-animate.ng-enter {=0A=
        top:-50px;=0A=
      }=0A=
      .slide-animate.ng-enter.ng-enter-active {=0A=
        top:0;=0A=
      }=0A=
=0A=
      .slide-animate.ng-leave {=0A=
        top:0;=0A=
      }=0A=
      .slide-animate.ng-leave.ng-leave-active {=0A=
        top:50px;=0A=
      }=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
      var templateSelect =3D element(by.model('template'));=0A=
      var includeElem =3D element(by.css('[ng-include]'));=0A=
=0A=
      it('should load template1.html', function() {=0A=
        expect(includeElem.getText()).toMatch(/Content of =
template1.html/);=0A=
      });=0A=
=0A=
      it('should load template2.html', function() {=0A=
        if (browser.params.browser =3D=3D 'firefox') {=0A=
          // Firefox can't handle using selects=0A=
          // See https://github.com/angular/protractor/issues/480=0A=
          return;=0A=
        }=0A=
        templateSelect.click();=0A=
        templateSelect.all(by.css('option')).get(2).click();=0A=
        expect(includeElem.getText()).toMatch(/Content of =
template2.html/);=0A=
      });=0A=
=0A=
      it('should change to blank', function() {=0A=
        if (browser.params.browser =3D=3D 'firefox') {=0A=
          // Firefox can't handle using selects=0A=
          return;=0A=
        }=0A=
        templateSelect.click();=0A=
        templateSelect.all(by.css('option')).get(0).click();=0A=
        expect(includeElem.isPresent()).toBe(false);=0A=
      });=0A=
    &lt;/file&gt;=0A=
  &lt;/example&gt;=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc event=0A=
 * @name ngInclude#$includeContentRequested=0A=
 * @eventType emit on the scope ngInclude was declared in=0A=
 * @description=0A=
 * Emitted every time the ngInclude content is requested.=0A=
 *=0A=
 * @param {Object} angularEvent Synthetic event object.=0A=
 * @param {String} src URL of content to load.=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc event=0A=
 * @name ngInclude#$includeContentLoaded=0A=
 * @eventType emit on the current ngInclude scope=0A=
 * @description=0A=
 * Emitted every time the ngInclude content is reloaded.=0A=
 *=0A=
 * @param {Object} angularEvent Synthetic event object.=0A=
 * @param {String} src URL of content to load.=0A=
 */=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc event=0A=
 * @name ngInclude#$includeContentError=0A=
 * @eventType emit on the scope ngInclude was declared in=0A=
 * @description=0A=
 * Emitted when a template HTTP request yields an erronous response =
(status &lt; 200 || status &gt; 299)=0A=
 *=0A=
 * @param {Object} angularEvent Synthetic event object.=0A=
 * @param {String} src URL of content to load.=0A=
 */=0A=
var ngIncludeDirective =3D ['$templateRequest', '$anchorScroll', =
'$animate', '$sce',=0A=
                  function($templateRequest,   $anchorScroll,   =
$animate,   $sce) {=0A=
  return {=0A=
    restrict: 'ECA',=0A=
    priority: 400,=0A=
    terminal: true,=0A=
    transclude: 'element',=0A=
    controller: angular.noop,=0A=
    compile: function(element, attr) {=0A=
      var srcExp =3D attr.ngInclude || attr.src,=0A=
          onloadExp =3D attr.onload || '',=0A=
          autoScrollExp =3D attr.autoscroll;=0A=
=0A=
      return function(scope, $element, $attr, ctrl, $transclude) {=0A=
        var changeCounter =3D 0,=0A=
            currentScope,=0A=
            previousElement,=0A=
            currentElement;=0A=
=0A=
        var cleanupLastIncludeContent =3D function() {=0A=
          if(previousElement) {=0A=
            previousElement.remove();=0A=
            previousElement =3D null;=0A=
          }=0A=
          if(currentScope) {=0A=
            currentScope.$destroy();=0A=
            currentScope =3D null;=0A=
          }=0A=
          if(currentElement) {=0A=
            $animate.leave(currentElement).then(function() {=0A=
              previousElement =3D null;=0A=
            });=0A=
            previousElement =3D currentElement;=0A=
            currentElement =3D null;=0A=
          }=0A=
        };=0A=
=0A=
        scope.$watch($sce.parseAsResourceUrl(srcExp), function =
ngIncludeWatchAction(src) {=0A=
          var afterAnimation =3D function() {=0A=
            if (isDefined(autoScrollExp) &amp;&amp; (!autoScrollExp || =
scope.$eval(autoScrollExp))) {=0A=
              $anchorScroll();=0A=
            }=0A=
          };=0A=
          var thisChangeId =3D ++changeCounter;=0A=
=0A=
          if (src) {=0A=
            //set the 2nd param to true to ignore the template request =
error so that the inner=0A=
            //contents and scope can be cleaned up.=0A=
            $templateRequest(src, true).then(function(response) {=0A=
              if (thisChangeId !=3D=3D changeCounter) return;=0A=
              var newScope =3D scope.$new();=0A=
              ctrl.template =3D response;=0A=
=0A=
              // Note: This will also link all children of ng-include =
that were contained in the original=0A=
              // html. If that content contains controllers, ... they =
could pollute/change the scope.=0A=
              // However, using ng-include on an element with additional =
content does not make sense...=0A=
              // Note: We can't remove them in the cloneAttchFn of =
$transclude as that=0A=
              // function is called before linking the content, which =
would apply child=0A=
              // directives to non existing elements.=0A=
              var clone =3D $transclude(newScope, function(clone) {=0A=
                cleanupLastIncludeContent();=0A=
                $animate.enter(clone, null, =
$element).then(afterAnimation);=0A=
              });=0A=
=0A=
              currentScope =3D newScope;=0A=
              currentElement =3D clone;=0A=
=0A=
              currentScope.$emit('$includeContentLoaded', src);=0A=
              scope.$eval(onloadExp);=0A=
            }, function() {=0A=
              if (thisChangeId =3D=3D=3D changeCounter) {=0A=
                cleanupLastIncludeContent();=0A=
                scope.$emit('$includeContentError', src);=0A=
              }=0A=
            });=0A=
            scope.$emit('$includeContentRequested', src);=0A=
          } else {=0A=
            cleanupLastIncludeContent();=0A=
            ctrl.template =3D null;=0A=
          }=0A=
        });=0A=
      };=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
// This directive is called during the $transclude call of the first =
`ngInclude` directive.=0A=
// It will replace and compile the content of the element with the =
loaded template.=0A=
// We need this directive so that the element content is already filled =
when=0A=
// the link function of another directive on the same element as =
ngInclude=0A=
// is called.=0A=
var ngIncludeFillContentDirective =3D ['$compile',=0A=
  function($compile) {=0A=
    return {=0A=
      restrict: 'ECA',=0A=
      priority: -400,=0A=
      require: 'ngInclude',=0A=
      link: function(scope, $element, $attr, ctrl) {=0A=
        if (/SVG/.test($element[0].toString())) {=0A=
          // WebKit: https://bugs.webkit.org/show_bug.cgi?id=3D135698 =
--- SVG elements do not=0A=
          // support innerHTML, so detect this here and try to generate =
the contents=0A=
          // specially.=0A=
          $element.empty();=0A=
          $compile(jqLiteBuildFragment(ctrl.template, =
document).childNodes)(scope,=0A=
              function namespaceAdaptedClone(clone) {=0A=
            $element.append(clone);=0A=
          }, undefined, undefined, $element);=0A=
          return;=0A=
        }=0A=
=0A=
        $element.html(ctrl.template);=0A=
        $compile($element.contents())(scope);=0A=
      }=0A=
    };=0A=
  }];=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngInit=0A=
 * @restrict AC=0A=
 *=0A=
 * @description=0A=
 * The `ngInit` directive allows you to evaluate an expression in the=0A=
 * current scope.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-error"&gt;=0A=
 * The only appropriate use of `ngInit` is for aliasing special =
properties of=0A=
 * {@link ng.directive:ngRepeat `ngRepeat`}, as seen in the demo below. =
Besides this case, you=0A=
 * should use {@link guide/controller controllers} rather than `ngInit`=0A=
 * to initialize values on a scope.=0A=
 * &lt;/div&gt;=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * **Note**: If you have assignment in `ngInit` along with {@link =
ng.$filter `$filter`}, make=0A=
 * sure you have parenthesis for correct precedence:=0A=
 * &lt;pre class=3D"prettyprint"&gt;=0A=
 *   &lt;div ng-init=3D"test1 =3D (data | =
orderBy:'name')"&gt;&lt;/div&gt;=0A=
 * &lt;/pre&gt;=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * @priority 450=0A=
 *=0A=
 * @element ANY=0A=
 * @param {expression} ngInit {@link guide/expression Expression} to =
eval.=0A=
 *=0A=
 * @example=0A=
   &lt;example module=3D"initExample"&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
   &lt;script&gt;=0A=
     angular.module('initExample', [])=0A=
       .controller('ExampleController', ['$scope', function($scope) {=0A=
         $scope.list =3D [['a', 'b'], ['c', 'd']];=0A=
       }]);=0A=
   &lt;/script&gt;=0A=
   &lt;div ng-controller=3D"ExampleController"&gt;=0A=
     &lt;div ng-repeat=3D"innerList in list" ng-init=3D"outerIndex =3D =
$index"&gt;=0A=
       &lt;div ng-repeat=3D"value in innerList" ng-init=3D"innerIndex =
=3D $index"&gt;=0A=
          &lt;span class=3D"example-init"&gt;list[ {{outerIndex}} ][ =
{{innerIndex}} ] =3D {{value}};&lt;/span&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/div&gt;=0A=
   &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should alias index positions', function() {=0A=
         var elements =3D element.all(by.css('.example-init'));=0A=
         expect(elements.get(0).getText()).toBe('list[ 0 ][ 0 ] =3D a;');=0A=
         expect(elements.get(1).getText()).toBe('list[ 0 ][ 1 ] =3D b;');=0A=
         expect(elements.get(2).getText()).toBe('list[ 1 ][ 0 ] =3D c;');=0A=
         expect(elements.get(3).getText()).toBe('list[ 1 ][ 1 ] =3D d;');=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
var ngInitDirective =3D ngDirective({=0A=
  priority: 450,=0A=
  compile: function() {=0A=
    return {=0A=
      pre: function(scope, element, attrs) {=0A=
        scope.$eval(attrs.ngInit);=0A=
      }=0A=
    };=0A=
  }=0A=
});=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngNonBindable=0A=
 * @restrict AC=0A=
 * @priority 1000=0A=
 *=0A=
 * @description=0A=
 * The `ngNonBindable` directive tells Angular not to compile or bind =
the contents of the current=0A=
 * DOM element. This is useful if the element contains what appears to =
be Angular directives and=0A=
 * bindings but which should be ignored by Angular. This could be the =
case if you have a site that=0A=
 * displays snippets of code, for instance.=0A=
 *=0A=
 * @element ANY=0A=
 *=0A=
 * @example=0A=
 * In this example there are two locations where a simple interpolation =
binding (`{{}}`) is present,=0A=
 * but the one wrapped in `ngNonBindable` is left alone.=0A=
 *=0A=
 * @example=0A=
    &lt;example&gt;=0A=
      &lt;file name=3D"todoList.html"&gt;=0A=
        &lt;div&gt;Normal: {{1 + 2}}&lt;/div&gt;=0A=
        &lt;div ng-non-bindable&gt;Ignored: {{1 + 2}}&lt;/div&gt;=0A=
      &lt;/file&gt;=0A=
      &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       it('should check ng-non-bindable', function() {=0A=
         expect(element(by.binding('1 + 2')).getText()).toContain('3');=0A=
         expect(element.all(by.css('div')).last().getText()).toMatch(/1 =
\+ 2/);=0A=
       });=0A=
      &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
 */=0A=
var ngNonBindableDirective =3D ngDirective({ terminal: true, priority: =
1000 });=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngPluralize=0A=
 * @restrict EA=0A=
 *=0A=
 * @description=0A=
 * `ngPluralize` is a directive that displays messages according to =
en-US localization rules.=0A=
 * These rules are bundled with angular.js, but can be overridden=0A=
 * (see {@link guide/i18n Angular i18n} dev guide). You configure =
ngPluralize directive=0A=
 * by specifying the mappings between=0A=
 * [plural =
categories](http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/lan=
guage_plural_rules.html)=0A=
 * and the strings to be displayed.=0A=
 *=0A=
 * # Plural categories and explicit number rules=0A=
 * There are two=0A=
 * [plural =
categories](http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/lan=
guage_plural_rules.html)=0A=
 * in Angular's default en-US locale: "one" and "other".=0A=
 *=0A=
 * While a plural category may match many numbers (for example, in en-US =
locale, "other" can match=0A=
 * any number that is not 1), an explicit number rule can only match one =
number. For example, the=0A=
 * explicit number rule for "3" matches the number 3. There are examples =
of plural categories=0A=
 * and explicit number rules throughout the rest of this documentation.=0A=
 *=0A=
 * # Configuring ngPluralize=0A=
 * You configure ngPluralize by providing 2 attributes: `count` and =
`when`.=0A=
 * You can also provide an optional attribute, `offset`.=0A=
 *=0A=
 * The value of the `count` attribute can be either a string or an =
{@link guide/expression=0A=
 * Angular expression}; these are evaluated on the current scope for its =
bound value.=0A=
 *=0A=
 * The `when` attribute specifies the mappings between plural categories =
and the actual=0A=
 * string to be displayed. The value of the attribute should be a JSON =
object.=0A=
 *=0A=
 * The following example shows how to configure ngPluralize:=0A=
 *=0A=
 * ```html=0A=
 * &lt;ng-pluralize count=3D"personCount"=0A=
                 when=3D"{'0': 'Nobody is viewing.',=0A=
 *                      'one': '1 person is viewing.',=0A=
 *                      'other': '{} people are viewing.'}"&gt;=0A=
 * &lt;/ng-pluralize&gt;=0A=
 *```=0A=
 *=0A=
 * In the example, `"0: Nobody is viewing."` is an explicit number rule. =
If you did not=0A=
 * specify this rule, 0 would be matched to the "other" category and "0 =
people are viewing"=0A=
 * would be shown instead of "Nobody is viewing". You can specify an =
explicit number rule for=0A=
 * other numbers, for example 12, so that instead of showing "12 people =
are viewing", you can=0A=
 * show "a dozen people are viewing".=0A=
 *=0A=
 * You can use a set of closed braces (`{}`) as a placeholder for the =
number that you want substituted=0A=
 * into pluralized strings. In the previous example, Angular will =
replace `{}` with=0A=
 * &lt;span ng-non-bindable&gt;`{{personCount}}`&lt;/span&gt;. The =
closed braces `{}` is a placeholder=0A=
 * for &lt;span ng-non-bindable&gt;{{numberExpression}}&lt;/span&gt;.=0A=
 *=0A=
 * # Configuring ngPluralize with offset=0A=
 * The `offset` attribute allows further customization of pluralized =
text, which can result in=0A=
 * a better user experience. For example, instead of the message "4 =
people are viewing this document",=0A=
 * you might display "John, Kate and 2 others are viewing this document".=0A=
 * The offset attribute allows you to offset a number by any desired =
value.=0A=
 * Let's take a look at an example:=0A=
 *=0A=
 * ```html=0A=
 * &lt;ng-pluralize count=3D"personCount" offset=3D2=0A=
 *               when=3D"{'0': 'Nobody is viewing.',=0A=
 *                      '1': '{{person1}} is viewing.',=0A=
 *                      '2': '{{person1}} and {{person2}} are viewing.',=0A=
 *                      'one': '{{person1}}, {{person2}} and one other =
person are viewing.',=0A=
 *                      'other': '{{person1}}, {{person2}} and {} other =
people are viewing.'}"&gt;=0A=
 * &lt;/ng-pluralize&gt;=0A=
 * ```=0A=
 *=0A=
 * Notice that we are still using two plural categories(one, other), but =
we added=0A=
 * three explicit number rules 0, 1 and 2.=0A=
 * When one person, perhaps John, views the document, "John is viewing" =
will be shown.=0A=
 * When three people view the document, no explicit number rule is =
found, so=0A=
 * an offset of 2 is taken off 3, and Angular uses 1 to decide the =
plural category.=0A=
 * In this case, plural category 'one' is matched and "John, Mary and =
one other person are viewing"=0A=
 * is shown.=0A=
 *=0A=
 * Note that when you specify offsets, you must provide explicit number =
rules for=0A=
 * numbers from 0 up to and including the offset. If you use an offset =
of 3, for example,=0A=
 * you must provide explicit number rules for 0, 1, 2 and 3. You must =
also provide plural strings for=0A=
 * plural categories "one" and "other".=0A=
 *=0A=
 * @param {string|expression} count The variable to be bound to.=0A=
 * @param {string} when The mapping between plural category to its =
corresponding strings.=0A=
 * @param {number=3D} offset Offset to deduct from the total number.=0A=
 *=0A=
 * @example=0A=
    &lt;example module=3D"pluralizeExample"&gt;=0A=
      &lt;file name=3D"todoList.html"&gt;=0A=
        &lt;script&gt;=0A=
          angular.module('pluralizeExample', [])=0A=
            .controller('ExampleController', ['$scope', function($scope) =
{=0A=
              $scope.person1 =3D 'Igor';=0A=
              $scope.person2 =3D 'Misko';=0A=
              $scope.personCount =3D 1;=0A=
            }]);=0A=
        &lt;/script&gt;=0A=
        &lt;div ng-controller=3D"ExampleController"&gt;=0A=
          Person 1:&lt;input type=3D"text" ng-model=3D"person1" =
value=3D"Igor" /&gt;&lt;br/&gt;=0A=
          Person 2:&lt;input type=3D"text" ng-model=3D"person2" =
value=3D"Misko" /&gt;&lt;br/&gt;=0A=
          Number of People:&lt;input type=3D"text" =
ng-model=3D"personCount" value=3D"1" /&gt;&lt;br/&gt;=0A=
=0A=
          &lt;!--- Example with simple pluralization rules for en locale =
---&gt;=0A=
          Without Offset:=0A=
          &lt;ng-pluralize count=3D"personCount"=0A=
                        when=3D"{'0': 'Nobody is viewing.',=0A=
                               'one': '1 person is viewing.',=0A=
                               'other': '{} people are viewing.'}"&gt;=0A=
          &lt;/ng-pluralize&gt;&lt;br&gt;=0A=
=0A=
          &lt;!--- Example with offset ---&gt;=0A=
          With Offset(2):=0A=
          &lt;ng-pluralize count=3D"personCount" offset=3D2=0A=
                        when=3D"{'0': 'Nobody is viewing.',=0A=
                               '1': '{{person1}} is viewing.',=0A=
                               '2': '{{person1}} and {{person2}} are =
viewing.',=0A=
                               'one': '{{person1}}, {{person2}} and one =
other person are viewing.',=0A=
                               'other': '{{person1}}, {{person2}} and {} =
other people are viewing.'}"&gt;=0A=
          &lt;/ng-pluralize&gt;=0A=
        &lt;/div&gt;=0A=
      &lt;/file&gt;=0A=
      &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
        it('should show correct pluralized string', function() {=0A=
          var withoutOffset =3D =
element.all(by.css('ng-pluralize')).get(0);=0A=
          var withOffset =3D element.all(by.css('ng-pluralize')).get(1);=0A=
          var countInput =3D element(by.model('personCount'));=0A=
=0A=
          expect(withoutOffset.getText()).toEqual('1 person is =
viewing.');=0A=
          expect(withOffset.getText()).toEqual('Igor is viewing.');=0A=
=0A=
          countInput.clear();=0A=
          countInput.sendKeys('0');=0A=
=0A=
          expect(withoutOffset.getText()).toEqual('Nobody is viewing.');=0A=
          expect(withOffset.getText()).toEqual('Nobody is viewing.');=0A=
=0A=
          countInput.clear();=0A=
          countInput.sendKeys('2');=0A=
=0A=
          expect(withoutOffset.getText()).toEqual('2 people are =
viewing.');=0A=
          expect(withOffset.getText()).toEqual('Igor and Misko are =
viewing.');=0A=
=0A=
          countInput.clear();=0A=
          countInput.sendKeys('3');=0A=
=0A=
          expect(withoutOffset.getText()).toEqual('3 people are =
viewing.');=0A=
          expect(withOffset.getText()).toEqual('Igor, Misko and one =
other person are viewing.');=0A=
=0A=
          countInput.clear();=0A=
          countInput.sendKeys('4');=0A=
=0A=
          expect(withoutOffset.getText()).toEqual('4 people are =
viewing.');=0A=
          expect(withOffset.getText()).toEqual('Igor, Misko and 2 other =
people are viewing.');=0A=
        });=0A=
        it('should show data-bound names', function() {=0A=
          var withOffset =3D element.all(by.css('ng-pluralize')).get(1);=0A=
          var personCount =3D element(by.model('personCount'));=0A=
          var person1 =3D element(by.model('person1'));=0A=
          var person2 =3D element(by.model('person2'));=0A=
          personCount.clear();=0A=
          personCount.sendKeys('4');=0A=
          person1.clear();=0A=
          person1.sendKeys('Di');=0A=
          person2.clear();=0A=
          person2.sendKeys('Vojta');=0A=
          expect(withOffset.getText()).toEqual('Di, Vojta and 2 other =
people are viewing.');=0A=
        });=0A=
      &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
 */=0A=
var ngPluralizeDirective =3D ['$locale', '$interpolate', =
function($locale, $interpolate) {=0A=
  var BRACE =3D /{}/g;=0A=
  return {=0A=
    restrict: 'EA',=0A=
    link: function(scope, element, attr) {=0A=
      var numberExp =3D attr.count,=0A=
          whenExp =3D attr.$attr.when &amp;&amp; =
element.attr(attr.$attr.when), // we have {{}} in attrs=0A=
          offset =3D attr.offset || 0,=0A=
          whens =3D scope.$eval(whenExp) || {},=0A=
          whensExpFns =3D {},=0A=
          startSymbol =3D $interpolate.startSymbol(),=0A=
          endSymbol =3D $interpolate.endSymbol(),=0A=
          isWhen =3D /^when(Minus)?(.+)$/;=0A=
=0A=
      forEach(attr, function(expression, attributeName) {=0A=
        if (isWhen.test(attributeName)) {=0A=
          whens[lowercase(attributeName.replace('when', =
'').replace('Minus', '-'))] =3D=0A=
            element.attr(attr.$attr[attributeName]);=0A=
        }=0A=
      });=0A=
      forEach(whens, function(expression, key) {=0A=
        whensExpFns[key] =3D=0A=
          $interpolate(expression.replace(BRACE, startSymbol + numberExp =
+ '-' +=0A=
            offset + endSymbol));=0A=
      });=0A=
=0A=
      scope.$watch(function ngPluralizeWatch() {=0A=
        var value =3D parseFloat(scope.$eval(numberExp));=0A=
=0A=
        if (!isNaN(value)) {=0A=
          //if explicit number rule such as 1, 2, 3... is defined, just =
use it. Otherwise,=0A=
          //check it against pluralization rules in $locale service=0A=
          if (!(value in whens)) value =3D $locale.pluralCat(value - =
offset);=0A=
           return whensExpFns[value](scope);=0A=
        } else {=0A=
          return '';=0A=
        }=0A=
      }, function ngPluralizeWatchAction(newVal) {=0A=
        element.text(newVal);=0A=
      });=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngRepeat=0A=
 *=0A=
 * @description=0A=
 * The `ngRepeat` directive instantiates a template once per item from a =
collection. Each template=0A=
 * instance gets its own scope, where the given loop variable is set to =
the current collection item,=0A=
 * and `$index` is set to the item index or key.=0A=
 *=0A=
 * Special properties are exposed on the local scope of each template =
instance, including:=0A=
 *=0A=
 * | Variable  | Type            | Details                               =
                                      |=0A=
 * =
|-----------|-----------------|------------------------------------------=
-----------------------------------|=0A=
 * | `$index`  | {@type number}  | iterator offset of the repeated =
element (0..length-1)                       |=0A=
 * | `$first`  | {@type boolean} | true if the repeated element is first =
in the iterator.                      |=0A=
 * | `$middle` | {@type boolean} | true if the repeated element is =
between the first and last in the iterator. |=0A=
 * | `$last`   | {@type boolean} | true if the repeated element is last =
in the iterator.                       |=0A=
 * | `$even`   | {@type boolean} | true if the iterator position =
`$index` is even (otherwise false).           |=0A=
 * | `$odd`    | {@type boolean} | true if the iterator position =
`$index` is odd (otherwise false).            |=0A=
 *=0A=
 * Creating aliases for these properties is possible with {@link =
ng.directive:ngInit `ngInit`}.=0A=
 * This may be useful when, for instance, nesting ngRepeats.=0A=
 *=0A=
 * # Special repeat start and end points=0A=
 * To repeat a series of elements instead of just one parent element, =
ngRepeat (as well as other ng directives) supports extending=0A=
 * the range of the repeater by defining explicit start and end points =
by using **ng-repeat-start** and **ng-repeat-end** respectively.=0A=
 * The **ng-repeat-start** directive works the same as **ng-repeat**, =
but will repeat all the HTML code (including the tag it's defined on)=0A=
 * up to and including the ending HTML tag where **ng-repeat-end** is =
placed.=0A=
 *=0A=
 * The example below makes use of this feature:=0A=
 * ```html=0A=
 *   &lt;header ng-repeat-start=3D"item in items"&gt;=0A=
 *     Header {{ item }}=0A=
 *   &lt;/header&gt;=0A=
 *   &lt;div class=3D"body"&gt;=0A=
 *     Body {{ item }}=0A=
 *   &lt;/div&gt;=0A=
 *   &lt;footer ng-repeat-end&gt;=0A=
 *     Footer {{ item }}=0A=
 *   &lt;/footer&gt;=0A=
 * ```=0A=
 *=0A=
 * And with an input of {@type ['A','B']} for the items variable in the =
example above, the output will evaluate to:=0A=
 * ```html=0A=
 *   &lt;header&gt;=0A=
 *     Header A=0A=
 *   &lt;/header&gt;=0A=
 *   &lt;div class=3D"body"&gt;=0A=
 *     Body A=0A=
 *   &lt;/div&gt;=0A=
 *   &lt;footer&gt;=0A=
 *     Footer A=0A=
 *   &lt;/footer&gt;=0A=
 *   &lt;header&gt;=0A=
 *     Header B=0A=
 *   &lt;/header&gt;=0A=
 *   &lt;div class=3D"body"&gt;=0A=
 *     Body B=0A=
 *   &lt;/div&gt;=0A=
 *   &lt;footer&gt;=0A=
 *     Footer B=0A=
 *   &lt;/footer&gt;=0A=
 * ```=0A=
 *=0A=
 * The custom start and end points for ngRepeat also support all other =
HTML directive syntax flavors provided in AngularJS (such=0A=
 * as **data-ng-repeat-start**, **x-ng-repeat-start** and =
**ng:repeat-start**).=0A=
 *=0A=
 * @animations=0A=
 * **.enter** - when a new item is added to the list or when an item is =
revealed after a filter=0A=
 *=0A=
 * **.leave** - when an item is removed from the list or when an item is =
filtered out=0A=
 *=0A=
 * **.move** - when an adjacent item is filtered out causing a reorder =
or when the item contents are reordered=0A=
 *=0A=
 * @element ANY=0A=
 * @scope=0A=
 * @priority 1000=0A=
 * @param {repeat_expression} ngRepeat The expression indicating how to =
enumerate a collection. These=0A=
 *   formats are currently supported:=0A=
 *=0A=
 *   * `variable in expression` =E2=80&#65533; where variable is the =
user defined loop variable and `expression`=0A=
 *     is a scope expression giving the collection to enumerate.=0A=
 *=0A=
 *     For example: `album in artist.albums`.=0A=
 *=0A=
 *   * `(key, value) in expression` =E2=80&#65533; where `key` and =
`value` can be any user defined identifiers,=0A=
 *     and `expression` is the scope expression giving the collection to =
enumerate.=0A=
 *=0A=
 *     For example: `(name, age) in {'adam':10, 'amalie':12}`.=0A=
 *=0A=
 *   * `variable in expression track by tracking_expression` =
=E2=80&#65533; You can also provide an optional tracking function=0A=
 *     which can be used to associate the objects in the collection with =
the DOM elements. If no tracking function=0A=
 *     is specified the ng-repeat associates elements by identity in the =
collection. It is an error to have=0A=
 *     more than one tracking function to resolve to the same key. (This =
would mean that two distinct objects are=0A=
 *     mapped to the same DOM element, which is not possible.)  Filters =
should be applied to the expression,=0A=
 *     before specifying a tracking expression.=0A=
 *=0A=
 *     For example: `item in items` is equivalent to `item in items =
track by $id(item)`. This implies that the DOM elements=0A=
 *     will be associated by item identity in the array.=0A=
 *=0A=
 *     For example: `item in items track by $id(item)`. A built in =
`$id()` function can be used to assign a unique=0A=
 *     `$$hashKey` property to each item in the array. This property is =
then used as a key to associated DOM elements=0A=
 *     with the corresponding item in the array by identity. Moving the =
same object in array would move the DOM=0A=
 *     element in the same way in the DOM.=0A=
 *=0A=
 *     For example: `item in items track by item.id` is a typical =
pattern when the items come from the database. In this=0A=
 *     case the object identity does not matter. Two objects are =
considered equivalent as long as their `id`=0A=
 *     property is same.=0A=
 *=0A=
 *     For example: `item in items | filter:searchText track by item.id` =
is a pattern that might be used to apply a filter=0A=
 *     to items in conjunction with a tracking expression.=0A=
 *=0A=
 *   * `variable in expression as alias_expression` =E2=80&#65533; You =
can also provide an optional alias expression which will then store the=0A=
 *     intermediate results of the repeater after the filters have been =
applied. Typically this is used to render a special message=0A=
 *     when a filter is active on the repeater, but the filtered result =
set is empty.=0A=
 *=0A=
 *     For example: `item in items | filter:x as results` will store the =
fragment of the repeated items as `results`, but only after=0A=
 *     the items have been processed through the filter.=0A=
 *=0A=
 * @example=0A=
 * This example initializes the scope to a list of names and=0A=
 * then uses `ngRepeat` to display every person:=0A=
  &lt;example module=3D"ngAnimate" deps=3D"angular-animate.js" =
animations=3D"true"&gt;=0A=
    &lt;file name=3D"todoList.html"&gt;=0A=
      &lt;div ng-init=3D"friends =3D [=0A=
        {name:'John', age:25, gender:'boy'},=0A=
        {name:'Jessie', age:30, gender:'girl'},=0A=
        {name:'Johanna', age:28, gender:'girl'},=0A=
        {name:'Joy', age:15, gender:'girl'},=0A=
        {name:'Mary', age:28, gender:'girl'},=0A=
        {name:'Peter', age:95, gender:'boy'},=0A=
        {name:'Sebastian', age:50, gender:'boy'},=0A=
        {name:'Erika', age:27, gender:'girl'},=0A=
        {name:'Patrick', age:40, gender:'boy'},=0A=
        {name:'Samantha', age:60, gender:'girl'}=0A=
      ]"&gt;=0A=
        I have {{friends.length}} friends. They are:=0A=
        &lt;input type=3D"search" ng-model=3D"q" placeholder=3D"filter =
friends..." /&gt;=0A=
        &lt;ul class=3D"example-animate-container"&gt;=0A=
          &lt;li class=3D"animate-repeat" ng-repeat=3D"friend in friends =
| filter:q as results"&gt;=0A=
            [{{$index + 1}}] {{friend.name}} who is {{friend.age}} years =
old.=0A=
          &lt;/li&gt;=0A=
          &lt;li class=3D"animate-repeat" ng-if=3D"results.length =3D=3D =
0"&gt;=0A=
            &lt;strong&gt;No results found...&lt;/strong&gt;=0A=
          &lt;/li&gt;=0A=
        &lt;/ul&gt;=0A=
      &lt;/div&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"animations.css"&gt;=0A=
      .example-animate-container {=0A=
        background:white;=0A=
        border:1px solid black;=0A=
        list-style:none;=0A=
        margin:0;=0A=
        padding:0 10px;=0A=
      }=0A=
=0A=
      .animate-repeat {=0A=
        line-height:40px;=0A=
        list-style:none;=0A=
        box-sizing:border-box;=0A=
      }=0A=
=0A=
      .animate-repeat.ng-move,=0A=
      .animate-repeat.ng-enter,=0A=
      .animate-repeat.ng-leave {=0A=
        -webkit-transition:all linear 0.5s;=0A=
        transition:all linear 0.5s;=0A=
      }=0A=
=0A=
      .animate-repeat.ng-leave.ng-leave-active,=0A=
      .animate-repeat.ng-move,=0A=
      .animate-repeat.ng-enter {=0A=
        opacity:0;=0A=
        max-height:0;=0A=
      }=0A=
=0A=
      .animate-repeat.ng-leave,=0A=
      .animate-repeat.ng-move.ng-move-active,=0A=
      .animate-repeat.ng-enter.ng-enter-active {=0A=
        opacity:1;=0A=
        max-height:40px;=0A=
      }=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
      var friends =3D element.all(by.repeater('friend in friends'));=0A=
=0A=
      it('should render initial data set', function() {=0A=
        expect(friends.count()).toBe(10);=0A=
        expect(friends.get(0).getText()).toEqual('[1] John who is 25 =
years old.');=0A=
        expect(friends.get(1).getText()).toEqual('[2] Jessie who is 30 =
years old.');=0A=
        expect(friends.last().getText()).toEqual('[10] Samantha who is =
60 years old.');=0A=
        expect(element(by.binding('friends.length')).getText())=0A=
            .toMatch("I have 10 friends. They are:");=0A=
      });=0A=
=0A=
       it('should update repeater when filter predicate changes', =
function() {=0A=
         expect(friends.count()).toBe(10);=0A=
=0A=
         element(by.model('q')).sendKeys('ma');=0A=
=0A=
         expect(friends.count()).toBe(2);=0A=
         expect(friends.get(0).getText()).toEqual('[1] Mary who is 28 =
years old.');=0A=
         expect(friends.last().getText()).toEqual('[2] Samantha who is =
60 years old.');=0A=
       });=0A=
      &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
 */=0A=
var ngRepeatDirective =3D ['$parse', '$animate', function($parse, =
$animate) {=0A=
  var NG_REMOVED =3D '$$NG_REMOVED';=0A=
  var ngRepeatMinErr =3D minErr('ngRepeat');=0A=
=0A=
  var updateScope =3D function(scope, index, valueIdentifier, value, =
keyIdentifier, key, arrayLength) {=0A=
    // TODO(perf): generate setters to shave off ~40ms or 1-1.5%=0A=
    scope[valueIdentifier] =3D value;=0A=
    if (keyIdentifier) scope[keyIdentifier] =3D key;=0A=
    scope.$index =3D index;=0A=
    scope.$first =3D (index =3D=3D=3D 0);=0A=
    scope.$last =3D (index =3D=3D=3D (arrayLength - 1));=0A=
    scope.$middle =3D !(scope.$first || scope.$last);=0A=
    // jshint bitwise: false=0A=
    scope.$odd =3D !(scope.$even =3D (index&amp;1) =3D=3D=3D 0);=0A=
    // jshint bitwise: true=0A=
  };=0A=
=0A=
  var getBlockStart =3D function(block) {=0A=
    return block.clone[0];=0A=
  };=0A=
=0A=
  var getBlockEnd =3D function(block) {=0A=
    return block.clone[block.clone.length - 1];=0A=
  };=0A=
=0A=
=0A=
  return {=0A=
    restrict: 'A',=0A=
    multiElement: true,=0A=
    transclude: 'element',=0A=
    priority: 1000,=0A=
    terminal: true,=0A=
    $$tlb: true,=0A=
    compile: function ngRepeatCompile($element, $attr) {=0A=
      var expression =3D $attr.ngRepeat;=0A=
      var ngRepeatEndComment =3D document.createComment(' end ngRepeat: =
' + expression + ' ');=0A=
=0A=
      var match =3D =
expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?=
(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);=0A=
=0A=
      if (!match) {=0A=
        throw ngRepeatMinErr('iexp', "Expected expression in form of =
'_item_ in _collection_[ track by _id_]' but got '{0}'.",=0A=
            expression);=0A=
      }=0A=
=0A=
      var lhs =3D match[1];=0A=
      var rhs =3D match[2];=0A=
      var aliasAs =3D match[3];=0A=
      var trackByExp =3D match[4];=0A=
=0A=
      match =3D =
lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/);=0A=
=0A=
      if (!match) {=0A=
        throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in =
_collection_' should be an identifier or '(_key_, _value_)' expression, =
but got '{0}'.",=0A=
            lhs);=0A=
      }=0A=
      var valueIdentifier =3D match[3] || match[1];=0A=
      var keyIdentifier =3D match[2];=0A=
=0A=
      if (aliasAs &amp;&amp; =
(!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) ||=0A=
          =
/^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$par=
ent)$/.test(aliasAs))) {=0A=
        throw ngRepeatMinErr('badident', "alias '{0}' is invalid --- =
must be a valid JS identifier which is not a reserved name.",=0A=
          aliasAs);=0A=
      }=0A=
=0A=
      var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, =
trackByIdObjFn;=0A=
      var hashFnLocals =3D {$id: hashKey};=0A=
=0A=
      if (trackByExp) {=0A=
        trackByExpGetter =3D $parse(trackByExp);=0A=
      } else {=0A=
        trackByIdArrayFn =3D function (key, value) {=0A=
          return hashKey(value);=0A=
        };=0A=
        trackByIdObjFn =3D function (key) {=0A=
          return key;=0A=
        };=0A=
      }=0A=
=0A=
      return function ngRepeatLink($scope, $element, $attr, ctrl, =
$transclude) {=0A=
=0A=
        if (trackByExpGetter) {=0A=
          trackByIdExpFn =3D function(key, value, index) {=0A=
            // assign key, value, and $index to the locals so that they =
can be used in hash functions=0A=
            if (keyIdentifier) hashFnLocals[keyIdentifier] =3D key;=0A=
            hashFnLocals[valueIdentifier] =3D value;=0A=
            hashFnLocals.$index =3D index;=0A=
            return trackByExpGetter($scope, hashFnLocals);=0A=
          };=0A=
        }=0A=
=0A=
        // Store a list of elements from previous run. This is a hash =
where key is the item from the=0A=
        // iterator, and the value is objects with following properties.=0A=
        //   - scope: bound scope=0A=
        //   - element: previous element.=0A=
        //   - index: position=0A=
        //=0A=
        // We are using no-proto object so that we don't need to guard =
against inherited props via=0A=
        // hasOwnProperty.=0A=
        var lastBlockMap =3D createMap();=0A=
=0A=
        //watch props=0A=
        $scope.$watchCollection(rhs, function ngRepeatAction(collection) =
{=0A=
          var index, length,=0A=
              previousNode =3D $element[0],     // node that cloned =
nodes should be inserted after=0A=
                                              // initialized to the =
comment node anchor=0A=
              nextNode,=0A=
              // Same as lastBlockMap but it has the current state. It =
will become the=0A=
              // lastBlockMap on the next iteration.=0A=
              nextBlockMap =3D createMap(),=0A=
              collectionLength,=0A=
              key, value, // key/value of iteration=0A=
              trackById,=0A=
              trackByIdFn,=0A=
              collectionKeys,=0A=
              block,       // last object information {scope, element, =
id}=0A=
              nextBlockOrder,=0A=
              elementsToRemove;=0A=
=0A=
          if (aliasAs) {=0A=
            $scope[aliasAs] =3D collection;=0A=
          }=0A=
=0A=
          if (isArrayLike(collection)) {=0A=
            collectionKeys =3D collection;=0A=
            trackByIdFn =3D trackByIdExpFn || trackByIdArrayFn;=0A=
          } else {=0A=
            trackByIdFn =3D trackByIdExpFn || trackByIdObjFn;=0A=
            // if object, extract keys, sort them and use to determine =
order of iteration over obj props=0A=
            collectionKeys =3D [];=0A=
            for (var itemKey in collection) {=0A=
              if (collection.hasOwnProperty(itemKey) &amp;&amp; =
itemKey.charAt(0) !=3D '$') {=0A=
                collectionKeys.push(itemKey);=0A=
              }=0A=
            }=0A=
            collectionKeys.sort();=0A=
          }=0A=
=0A=
          collectionLength =3D collectionKeys.length;=0A=
          nextBlockOrder =3D new Array(collectionLength);=0A=
=0A=
          // locate existing items=0A=
          for (index =3D 0; index &lt; collectionLength; index++) {=0A=
            key =3D (collection =3D=3D=3D collectionKeys) ? index : =
collectionKeys[index];=0A=
            value =3D collection[key];=0A=
            trackById =3D trackByIdFn(key, value, index);=0A=
            if (lastBlockMap[trackById]) {=0A=
              // found previously seen block=0A=
              block =3D lastBlockMap[trackById];=0A=
              delete lastBlockMap[trackById];=0A=
              nextBlockMap[trackById] =3D block;=0A=
              nextBlockOrder[index] =3D block;=0A=
            } else if (nextBlockMap[trackById]) {=0A=
              // if collision detected. restore lastBlockMap and throw =
an error=0A=
              forEach(nextBlockOrder, function (block) {=0A=
                if (block &amp;&amp; block.scope) lastBlockMap[block.id] =
=3D block;=0A=
              });=0A=
              throw ngRepeatMinErr('dupes',=0A=
                  "Duplicates in a repeater are not allowed. Use 'track =
by' expression to specify unique keys. Repeater: {0}, Duplicate key: =
{1}, Duplicate value: {2}",=0A=
                  expression, trackById, toJson(value));=0A=
            } else {=0A=
              // new never before seen block=0A=
              nextBlockOrder[index] =3D {id: trackById, scope: =
undefined, clone: undefined};=0A=
              nextBlockMap[trackById] =3D true;=0A=
            }=0A=
          }=0A=
=0A=
          // remove leftover items=0A=
          for (var blockKey in lastBlockMap) {=0A=
            block =3D lastBlockMap[blockKey];=0A=
            elementsToRemove =3D getBlockNodes(block.clone);=0A=
            $animate.leave(elementsToRemove);=0A=
            if (elementsToRemove[0].parentNode) {=0A=
              // if the element was not removed yet because of pending =
animation, mark it as deleted=0A=
              // so that we can ignore it later=0A=
              for (index =3D 0, length =3D elementsToRemove.length; =
index &lt; length; index++) {=0A=
                elementsToRemove[index][NG_REMOVED] =3D true;=0A=
              }=0A=
            }=0A=
            block.scope.$destroy();=0A=
          }=0A=
=0A=
          // we are not using forEach for perf reasons (trying to avoid =
#call)=0A=
          for (index =3D 0; index &lt; collectionLength; index++) {=0A=
            key =3D (collection =3D=3D=3D collectionKeys) ? index : =
collectionKeys[index];=0A=
            value =3D collection[key];=0A=
            block =3D nextBlockOrder[index];=0A=
=0A=
            if (block.scope) {=0A=
              // if we have already seen this object, then we need to =
reuse the=0A=
              // associated scope/element=0A=
=0A=
              nextNode =3D previousNode;=0A=
=0A=
              // skip nodes that are already pending removal via leave =
animation=0A=
              do {=0A=
                nextNode =3D nextNode.nextSibling;=0A=
              } while (nextNode &amp;&amp; nextNode[NG_REMOVED]);=0A=
=0A=
              if (getBlockStart(block) !=3D nextNode) {=0A=
                // existing item which got moved=0A=
                $animate.move(getBlockNodes(block.clone), null, =
jqLite(previousNode));=0A=
              }=0A=
              previousNode =3D getBlockEnd(block);=0A=
              updateScope(block.scope, index, valueIdentifier, value, =
keyIdentifier, key, collectionLength);=0A=
            } else {=0A=
              // new item which we don't know about=0A=
              $transclude(function ngRepeatTransclude(clone, scope) {=0A=
                block.scope =3D scope;=0A=
                // http://jsperf.com/clone-vs-createcomment=0A=
                var endNode =3D ngRepeatEndComment.cloneNode(false);=0A=
                clone[clone.length++] =3D endNode;=0A=
=0A=
                // TODO(perf): support naked previousNode in `enter` to =
avoid creation of jqLite wrapper?=0A=
                $animate.enter(clone, null, jqLite(previousNode));=0A=
                previousNode =3D endNode;=0A=
                // Note: We only need the first/last node of the cloned =
nodes.=0A=
                // However, we need to keep the reference to the jqlite =
wrapper as it might be changed later=0A=
                // by a directive with templateUrl when its template =
arrives.=0A=
                block.clone =3D clone;=0A=
                nextBlockMap[block.id] =3D block;=0A=
                updateScope(block.scope, index, valueIdentifier, value, =
keyIdentifier, key, collectionLength);=0A=
              });=0A=
            }=0A=
          }=0A=
          lastBlockMap =3D nextBlockMap;=0A=
        });=0A=
      };=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
var NG_HIDE_CLASS =3D 'ng-hide';=0A=
var NG_HIDE_IN_PROGRESS_CLASS =3D 'ng-hide-animate';=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngShow=0A=
 *=0A=
 * @description=0A=
 * The `ngShow` directive shows or hides the given HTML element based on =
the expression=0A=
 * provided to the `ngShow` attribute. The element is shown or hidden by =
removing or adding=0A=
 * the `.ng-hide` CSS class onto the element. The `.ng-hide` CSS class =
is predefined=0A=
 * in AngularJS and sets the display style to none (using an !important =
flag).=0A=
 * For CSP mode please add `angular-csp.css` to your html file (see =
{@link ng.directive:ngCsp ngCsp}).=0A=
 *=0A=
 * ```html=0A=
 * &lt;!-- when $scope.myValue is truthy (element is visible) --&gt;=0A=
 * &lt;div ng-show=3D"myValue"&gt;&lt;/div&gt;=0A=
 *=0A=
 * &lt;!-- when $scope.myValue is falsy (element is hidden) --&gt;=0A=
 * &lt;div ng-show=3D"myValue" class=3D"ng-hide"&gt;&lt;/div&gt;=0A=
 * ```=0A=
 *=0A=
 * When the `ngShow` expression evaluates to a falsy value then the =
`.ng-hide` CSS class is added to the class=0A=
 * attribute on the element causing it to become hidden. When truthy, =
the `.ng-hide` CSS class is removed=0A=
 * from the element causing the element not to appear hidden.=0A=
 *=0A=
 * ## Why is !important used?=0A=
 *=0A=
 * You may be wondering why !important is used for the `.ng-hide` CSS =
class. This is because the `.ng-hide` selector=0A=
 * can be easily overridden by heavier selectors. For example, something =
as simple=0A=
 * as changing the display style on a HTML list item would make hidden =
elements appear visible.=0A=
 * This also becomes a bigger issue when dealing with CSS frameworks.=0A=
 *=0A=
 * By using !important, the show and hide behavior will work as expected =
despite any clash between CSS selector=0A=
 * specificity (when !important isn't used with any conflicting styles). =
If a developer chooses to override the=0A=
 * styling to change how to hide an element then it is just a matter of =
using !important in their own CSS code.=0A=
 *=0A=
 * ### Overriding `.ng-hide`=0A=
 *=0A=
 * By default, the `.ng-hide` class will style the element with =
`display:none!important`. If you wish to change=0A=
 * the hide behavior with ngShow/ngHide then this can be achieved by =
restating the styles for the `.ng-hide`=0A=
 * class in CSS:=0A=
 *=0A=
 * ```css=0A=
 * .ng-hide {=0A=
 *   /&amp;#42; this is just another form of hiding an element &amp;#42;/=0A=
 *   display:block!important;=0A=
 *   position:absolute;=0A=
 *   top:-9999px;=0A=
 *   left:-9999px;=0A=
 * }=0A=
 * ```=0A=
 *=0A=
 * By default you don't need to override in CSS anything and the =
animations will work around the display style.=0A=
 *=0A=
 * ## A note about animations with `ngShow`=0A=
 *=0A=
 * Animations in ngShow/ngHide work with the show and hide events that =
are triggered when the directive expression=0A=
 * is true and false. This system works like the animation system =
present with ngClass except that=0A=
 * you must also include the !important flag to override the display =
property=0A=
 * so that you can perform an animation when the element is hidden =
during the time of the animation.=0A=
 *=0A=
 * ```css=0A=
 * //=0A=
 * //a working example can be found at the bottom of this page=0A=
 * //=0A=
 * .my-element.ng-hide-add, .my-element.ng-hide-remove {=0A=
 *   /&amp;#42; this is required as of 1.3x to properly=0A=
 *      apply all styling in a show/hide animation &amp;#42;/=0A=
 *   transition:0s linear all;=0A=
 * }=0A=
 *=0A=
 * .my-element.ng-hide-add-active,=0A=
 * .my-element.ng-hide-remove-active {=0A=
 *   /&amp;#42; the transition is defined in the active class &amp;#42;/=0A=
 *   transition:1s linear all;=0A=
 * }=0A=
 *=0A=
 * .my-element.ng-hide-add { ... }=0A=
 * .my-element.ng-hide-add.ng-hide-add-active { ... }=0A=
 * .my-element.ng-hide-remove { ... }=0A=
 * .my-element.ng-hide-remove.ng-hide-remove-active { ... }=0A=
 * ```=0A=
 *=0A=
 * Keep in mind that, as of AngularJS version 1.3.0-beta.11, there is no =
need to change the display=0A=
 * property to block during animation states--ngAnimate will handle the =
style toggling automatically for you.=0A=
 *=0A=
 * @animations=0A=
 * addClass: `.ng-hide` - happens after the `ngShow` expression =
evaluates to a truthy value and the just before contents are set to =
visible=0A=
 * removeClass: `.ng-hide` - happens after the `ngShow` expression =
evaluates to a non truthy value and just before the contents are set to =
hidden=0A=
 *=0A=
 * @element ANY=0A=
 * @param {expression} ngShow If the {@link guide/expression expression} =
is truthy=0A=
 *     then the element is shown or hidden respectively.=0A=
 *=0A=
 * @example=0A=
  &lt;example module=3D"ngAnimate" deps=3D"angular-animate.js" =
animations=3D"true"&gt;=0A=
    &lt;file name=3D"todoList.html"&gt;=0A=
      Click me: &lt;input type=3D"checkbox" =
ng-model=3D"checked"&gt;&lt;br/&gt;=0A=
      &lt;div&gt;=0A=
        Show:=0A=
        &lt;div class=3D"check-element animate-show" =
ng-show=3D"checked"&gt;=0A=
          &lt;span class=3D"glyphicon =
glyphicon-thumbs-up"&gt;&lt;/span&gt; I show up when your checkbox is =
checked.=0A=
        &lt;/div&gt;=0A=
      &lt;/div&gt;=0A=
      &lt;div&gt;=0A=
        Hide:=0A=
        &lt;div class=3D"check-element animate-show" =
ng-hide=3D"checked"&gt;=0A=
          &lt;span class=3D"glyphicon =
glyphicon-thumbs-down"&gt;&lt;/span&gt; I hide when your checkbox is =
checked.=0A=
        &lt;/div&gt;=0A=
      &lt;/div&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"glyphicons.css"&gt;=0A=
      @import =
url(//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-glyphicons.cs=
s);=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"animations.css"&gt;=0A=
      .animate-show {=0A=
        line-height:20px;=0A=
        opacity:1;=0A=
        padding:10px;=0A=
        border:1px solid black;=0A=
        background:white;=0A=
      }=0A=
=0A=
      .animate-show.ng-hide-add.ng-hide-add-active,=0A=
      .animate-show.ng-hide-remove.ng-hide-remove-active {=0A=
        -webkit-transition:all linear 0.5s;=0A=
        transition:all linear 0.5s;=0A=
      }=0A=
=0A=
      .animate-show.ng-hide {=0A=
        line-height:0;=0A=
        opacity:0;=0A=
        padding:0 10px;=0A=
      }=0A=
=0A=
      .check-element {=0A=
        padding:10px;=0A=
        border:1px solid black;=0A=
        background:white;=0A=
      }=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
      var thumbsUp =3D element(by.css('span.glyphicon-thumbs-up'));=0A=
      var thumbsDown =3D element(by.css('span.glyphicon-thumbs-down'));=0A=
=0A=
      it('should check ng-show / ng-hide', function() {=0A=
        expect(thumbsUp.isDisplayed()).toBeFalsy();=0A=
        expect(thumbsDown.isDisplayed()).toBeTruthy();=0A=
=0A=
        element(by.model('checked')).click();=0A=
=0A=
        expect(thumbsUp.isDisplayed()).toBeTruthy();=0A=
        expect(thumbsDown.isDisplayed()).toBeFalsy();=0A=
      });=0A=
    &lt;/file&gt;=0A=
  &lt;/example&gt;=0A=
 */=0A=
var ngShowDirective =3D ['$animate', function($animate) {=0A=
  return {=0A=
    restrict: 'A',=0A=
    multiElement: true,=0A=
    link: function(scope, element, attr) {=0A=
      scope.$watch(attr.ngShow, function ngShowWatchAction(value){=0A=
        // we're adding a temporary, animation-specific class for =
ng-hide since this way=0A=
        // we can control when the element is actually displayed on =
screen without having=0A=
        // to have a global/greedy CSS selector that breaks when other =
animations are run.=0A=
        // Read: =
https://github.com/angular/angular.js/issues/9103#issuecomment-58335845=0A=
        $animate[value ? 'removeClass' : 'addClass'](element, =
NG_HIDE_CLASS, {=0A=
          tempClasses : NG_HIDE_IN_PROGRESS_CLASS=0A=
        });=0A=
      });=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngHide=0A=
 *=0A=
 * @description=0A=
 * The `ngHide` directive shows or hides the given HTML element based on =
the expression=0A=
 * provided to the `ngHide` attribute. The element is shown or hidden by =
removing or adding=0A=
 * the `ng-hide` CSS class onto the element. The `.ng-hide` CSS class is =
predefined=0A=
 * in AngularJS and sets the display style to none (using an !important =
flag).=0A=
 * For CSP mode please add `angular-csp.css` to your html file (see =
{@link ng.directive:ngCsp ngCsp}).=0A=
 *=0A=
 * ```html=0A=
 * &lt;!-- when $scope.myValue is truthy (element is hidden) --&gt;=0A=
 * &lt;div ng-hide=3D"myValue" class=3D"ng-hide"&gt;&lt;/div&gt;=0A=
 *=0A=
 * &lt;!-- when $scope.myValue is falsy (element is visible) --&gt;=0A=
 * &lt;div ng-hide=3D"myValue"&gt;&lt;/div&gt;=0A=
 * ```=0A=
 *=0A=
 * When the `ngHide` expression evaluates to a truthy value then the =
`.ng-hide` CSS class is added to the class=0A=
 * attribute on the element causing it to become hidden. When falsy, the =
`.ng-hide` CSS class is removed=0A=
 * from the element causing the element not to appear hidden.=0A=
 *=0A=
 * ## Why is !important used?=0A=
 *=0A=
 * You may be wondering why !important is used for the `.ng-hide` CSS =
class. This is because the `.ng-hide` selector=0A=
 * can be easily overridden by heavier selectors. For example, something =
as simple=0A=
 * as changing the display style on a HTML list item would make hidden =
elements appear visible.=0A=
 * This also becomes a bigger issue when dealing with CSS frameworks.=0A=
 *=0A=
 * By using !important, the show and hide behavior will work as expected =
despite any clash between CSS selector=0A=
 * specificity (when !important isn't used with any conflicting styles). =
If a developer chooses to override the=0A=
 * styling to change how to hide an element then it is just a matter of =
using !important in their own CSS code.=0A=
 *=0A=
 * ### Overriding `.ng-hide`=0A=
 *=0A=
 * By default, the `.ng-hide` class will style the element with =
`display:none!important`. If you wish to change=0A=
 * the hide behavior with ngShow/ngHide then this can be achieved by =
restating the styles for the `.ng-hide`=0A=
 * class in CSS:=0A=
 *=0A=
 * ```css=0A=
 * .ng-hide {=0A=
 *   /&amp;#42; this is just another form of hiding an element &amp;#42;/=0A=
 *   display:block!important;=0A=
 *   position:absolute;=0A=
 *   top:-9999px;=0A=
 *   left:-9999px;=0A=
 * }=0A=
 * ```=0A=
 *=0A=
 * By default you don't need to override in CSS anything and the =
animations will work around the display style.=0A=
 *=0A=
 * ## A note about animations with `ngHide`=0A=
 *=0A=
 * Animations in ngShow/ngHide work with the show and hide events that =
are triggered when the directive expression=0A=
 * is true and false. This system works like the animation system =
present with ngClass, except that the `.ng-hide`=0A=
 * CSS class is added and removed for you instead of your own CSS class.=0A=
 *=0A=
 * ```css=0A=
 * //=0A=
 * //a working example can be found at the bottom of this page=0A=
 * //=0A=
 * .my-element.ng-hide-add, .my-element.ng-hide-remove {=0A=
 *   transition:0.5s linear all;=0A=
 * }=0A=
 *=0A=
 * .my-element.ng-hide-add { ... }=0A=
 * .my-element.ng-hide-add.ng-hide-add-active { ... }=0A=
 * .my-element.ng-hide-remove { ... }=0A=
 * .my-element.ng-hide-remove.ng-hide-remove-active { ... }=0A=
 * ```=0A=
 *=0A=
 * Keep in mind that, as of AngularJS version 1.3.0-beta.11, there is no =
need to change the display=0A=
 * property to block during animation states--ngAnimate will handle the =
style toggling automatically for you.=0A=
 *=0A=
 * @animations=0A=
 * removeClass: `.ng-hide` - happens after the `ngHide` expression =
evaluates to a truthy value and just before the contents are set to =
hidden=0A=
 * addClass: `.ng-hide` - happens after the `ngHide` expression =
evaluates to a non truthy value and just before the contents are set to =
visible=0A=
 *=0A=
 * @element ANY=0A=
 * @param {expression} ngHide If the {@link guide/expression expression} =
is truthy then=0A=
 *     the element is shown or hidden respectively.=0A=
 *=0A=
 * @example=0A=
  &lt;example module=3D"ngAnimate" deps=3D"angular-animate.js" =
animations=3D"true"&gt;=0A=
    &lt;file name=3D"todoList.html"&gt;=0A=
      Click me: &lt;input type=3D"checkbox" =
ng-model=3D"checked"&gt;&lt;br/&gt;=0A=
      &lt;div&gt;=0A=
        Show:=0A=
        &lt;div class=3D"check-element animate-hide" =
ng-show=3D"checked"&gt;=0A=
          &lt;span class=3D"glyphicon =
glyphicon-thumbs-up"&gt;&lt;/span&gt; I show up when your checkbox is =
checked.=0A=
        &lt;/div&gt;=0A=
      &lt;/div&gt;=0A=
      &lt;div&gt;=0A=
        Hide:=0A=
        &lt;div class=3D"check-element animate-hide" =
ng-hide=3D"checked"&gt;=0A=
          &lt;span class=3D"glyphicon =
glyphicon-thumbs-down"&gt;&lt;/span&gt; I hide when your checkbox is =
checked.=0A=
        &lt;/div&gt;=0A=
      &lt;/div&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"glyphicons.css"&gt;=0A=
      @import =
url(//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-glyphicons.cs=
s);=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"animations.css"&gt;=0A=
      .animate-hide {=0A=
        -webkit-transition:all linear 0.5s;=0A=
        transition:all linear 0.5s;=0A=
        line-height:20px;=0A=
        opacity:1;=0A=
        padding:10px;=0A=
        border:1px solid black;=0A=
        background:white;=0A=
      }=0A=
=0A=
      .animate-hide.ng-hide {=0A=
        line-height:0;=0A=
        opacity:0;=0A=
        padding:0 10px;=0A=
      }=0A=
=0A=
      .check-element {=0A=
        padding:10px;=0A=
        border:1px solid black;=0A=
        background:white;=0A=
      }=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
      var thumbsUp =3D element(by.css('span.glyphicon-thumbs-up'));=0A=
      var thumbsDown =3D element(by.css('span.glyphicon-thumbs-down'));=0A=
=0A=
      it('should check ng-show / ng-hide', function() {=0A=
        expect(thumbsUp.isDisplayed()).toBeFalsy();=0A=
        expect(thumbsDown.isDisplayed()).toBeTruthy();=0A=
=0A=
        element(by.model('checked')).click();=0A=
=0A=
        expect(thumbsUp.isDisplayed()).toBeTruthy();=0A=
        expect(thumbsDown.isDisplayed()).toBeFalsy();=0A=
      });=0A=
    &lt;/file&gt;=0A=
  &lt;/example&gt;=0A=
 */=0A=
var ngHideDirective =3D ['$animate', function($animate) {=0A=
  return {=0A=
    restrict: 'A',=0A=
    multiElement: true,=0A=
    link: function(scope, element, attr) {=0A=
      scope.$watch(attr.ngHide, function ngHideWatchAction(value){=0A=
        // The comment inside of the ngShowDirective explains why we add =
and=0A=
        // remove a temporary class for the show/hide animation=0A=
        $animate[value ? 'addClass' : =
'removeClass'](element,NG_HIDE_CLASS, {=0A=
          tempClasses : NG_HIDE_IN_PROGRESS_CLASS=0A=
        });=0A=
      });=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngStyle=0A=
 * @restrict AC=0A=
 *=0A=
 * @description=0A=
 * The `ngStyle` directive allows you to set CSS style on an HTML =
element conditionally.=0A=
 *=0A=
 * @element ANY=0A=
 * @param {expression} ngStyle=0A=
 *=0A=
 * {@link guide/expression Expression} which evals to an=0A=
 * object whose keys are CSS style names and values are corresponding =
values for those CSS=0A=
 * keys.=0A=
 *=0A=
 * Since some CSS style names are not valid keys for an object, they =
must be quoted.=0A=
 * See the 'background-color' style in the example below.=0A=
 *=0A=
 * @example=0A=
   &lt;example&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
        &lt;input type=3D"button" value=3D"set color" =
ng-click=3D"myStyle=3D{color:'red'}"&gt;=0A=
        &lt;input type=3D"button" value=3D"set background" =
ng-click=3D"myStyle=3D{'background-color':'blue'}"&gt;=0A=
        &lt;input type=3D"button" value=3D"clear" =
ng-click=3D"myStyle=3D{}"&gt;=0A=
        &lt;br/&gt;=0A=
        &lt;span ng-style=3D"myStyle"&gt;Sample Text&lt;/span&gt;=0A=
        &lt;pre&gt;myStyle=3D{{myStyle}}&lt;/pre&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"style.css"&gt;=0A=
       span {=0A=
         color: black;=0A=
       }=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
       var colorSpan =3D element(by.css('span'));=0A=
=0A=
       it('should check ng-style', function() {=0A=
         expect(colorSpan.getCssValue('color')).toBe('rgba(0, 0, 0, 1)');=0A=
         element(by.css('input[value=3D\'set color\']')).click();=0A=
         expect(colorSpan.getCssValue('color')).toBe('rgba(255, 0, 0, =
1)');=0A=
         element(by.css('input[value=3Dclear]')).click();=0A=
         expect(colorSpan.getCssValue('color')).toBe('rgba(0, 0, 0, 1)');=0A=
       });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 */=0A=
var ngStyleDirective =3D ngDirective(function(scope, element, attr) {=0A=
  scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, =
oldStyles) {=0A=
    if (oldStyles &amp;&amp; (newStyles !=3D=3D oldStyles)) {=0A=
      forEach(oldStyles, function(val, style) { element.css(style, =
'');});=0A=
    }=0A=
    if (newStyles) element.css(newStyles);=0A=
  }, true);=0A=
});=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngSwitch=0A=
 * @restrict EA=0A=
 *=0A=
 * @description=0A=
 * The `ngSwitch` directive is used to conditionally swap DOM structure =
on your template based on a scope expression.=0A=
 * Elements within `ngSwitch` but without `ngSwitchWhen` or =
`ngSwitchDefault` directives will be preserved at the location=0A=
 * as specified in the template.=0A=
 *=0A=
 * The directive itself works similar to ngInclude, however, instead of =
downloading template code (or loading it=0A=
 * from the template cache), `ngSwitch` simply chooses one of the nested =
elements and makes it visible based on which element=0A=
 * matches the value obtained from the evaluated expression. In other =
words, you define a container element=0A=
 * (where you place the directive), place an expression on the =
**`on=3D"..."` attribute**=0A=
 * (or the **`ng-switch=3D"..."` attribute**), define any inner elements =
inside of the directive and place=0A=
 * a when attribute per element. The when attribute is used to inform =
ngSwitch which element to display when the on=0A=
 * expression is evaluated. If a matching expression is not found via a =
when attribute then an element with the default=0A=
 * attribute is displayed.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-info"&gt;=0A=
 * Be aware that the attribute values to match against cannot be =
expressions. They are interpreted=0A=
 * as literal string values to match against.=0A=
 * For example, **`ng-switch-when=3D"someVal"`** will match against the =
string `"someVal"` not against the=0A=
 * value of the expression `$scope.someVal`.=0A=
 * &lt;/div&gt;=0A=
=0A=
 * @animations=0A=
 * enter - happens after the ngSwitch contents change and the matched =
child element is placed inside the container=0A=
 * leave - happens just after the ngSwitch contents change and just =
before the former contents are removed from the DOM=0A=
 *=0A=
 * @usage=0A=
 *=0A=
 * ```=0A=
 * &lt;ANY ng-switch=3D"expression"&gt;=0A=
 *   &lt;ANY ng-switch-when=3D"matchValue1"&gt;...&lt;/ANY&gt;=0A=
 *   &lt;ANY ng-switch-when=3D"matchValue2"&gt;...&lt;/ANY&gt;=0A=
 *   &lt;ANY ng-switch-default&gt;...&lt;/ANY&gt;=0A=
 * &lt;/ANY&gt;=0A=
 * ```=0A=
 *=0A=
 *=0A=
 * @scope=0A=
 * @priority 1200=0A=
 * @param {*} ngSwitch|on expression to match against =
&lt;tt&gt;ng-switch-when&lt;/tt&gt;.=0A=
 * On child elements add:=0A=
 *=0A=
 * * `ngSwitchWhen`: the case statement to match against. If match then =
this=0A=
 *   case will be displayed. If the same match appears multiple times, =
all the=0A=
 *   elements will be displayed.=0A=
 * * `ngSwitchDefault`: the default case when no other case match. If =
there=0A=
 *   are multiple default cases, all of them will be displayed when no =
other=0A=
 *   case match.=0A=
 *=0A=
 *=0A=
 * @example=0A=
  &lt;example module=3D"switchExample" deps=3D"angular-animate.js" =
animations=3D"true"&gt;=0A=
    &lt;file name=3D"todoList.html"&gt;=0A=
      &lt;div ng-controller=3D"ExampleController"&gt;=0A=
        &lt;select ng-model=3D"selection" ng-options=3D"item for item in =
items"&gt;=0A=
        &lt;/select&gt;=0A=
        &lt;tt&gt;selection=3D{{selection}}&lt;/tt&gt;=0A=
        &lt;hr/&gt;=0A=
        &lt;div class=3D"animate-switch-container"=0A=
          ng-switch on=3D"selection"&gt;=0A=
            &lt;div class=3D"animate-switch" =
ng-switch-when=3D"settings"&gt;Settings Div&lt;/div&gt;=0A=
            &lt;div class=3D"animate-switch" =
ng-switch-when=3D"home"&gt;Home Span&lt;/div&gt;=0A=
            &lt;div class=3D"animate-switch" =
ng-switch-default&gt;default&lt;/div&gt;=0A=
        &lt;/div&gt;=0A=
      &lt;/div&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"script.js"&gt;=0A=
      angular.module('switchExample', ['ngAnimate'])=0A=
        .controller('ExampleController', ['$scope', function($scope) {=0A=
          $scope.items =3D ['settings', 'home', 'other'];=0A=
          $scope.selection =3D $scope.items[0];=0A=
        }]);=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"animations.css"&gt;=0A=
      .animate-switch-container {=0A=
        position:relative;=0A=
        background:white;=0A=
        border:1px solid black;=0A=
        height:40px;=0A=
        overflow:hidden;=0A=
      }=0A=
=0A=
      .animate-switch {=0A=
        padding:10px;=0A=
      }=0A=
=0A=
      .animate-switch.ng-animate {=0A=
        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) =
0.5s;=0A=
        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;=0A=
=0A=
        position:absolute;=0A=
        top:0;=0A=
        left:0;=0A=
        right:0;=0A=
        bottom:0;=0A=
      }=0A=
=0A=
      .animate-switch.ng-leave.ng-leave-active,=0A=
      .animate-switch.ng-enter {=0A=
        top:-50px;=0A=
      }=0A=
      .animate-switch.ng-leave,=0A=
      .animate-switch.ng-enter.ng-enter-active {=0A=
        top:0;=0A=
      }=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
      var switchElem =3D element(by.css('[ng-switch]'));=0A=
      var select =3D element(by.model('selection'));=0A=
=0A=
      it('should start in settings', function() {=0A=
        expect(switchElem.getText()).toMatch(/Settings Div/);=0A=
      });=0A=
      it('should change to home', function() {=0A=
        select.all(by.css('option')).get(1).click();=0A=
        expect(switchElem.getText()).toMatch(/Home Span/);=0A=
      });=0A=
      it('should select default', function() {=0A=
        select.all(by.css('option')).get(2).click();=0A=
        expect(switchElem.getText()).toMatch(/default/);=0A=
      });=0A=
    &lt;/file&gt;=0A=
  &lt;/example&gt;=0A=
 */=0A=
var ngSwitchDirective =3D ['$animate', function($animate) {=0A=
  return {=0A=
    restrict: 'EA',=0A=
    require: 'ngSwitch',=0A=
=0A=
    // asks for $scope to fool the BC controller module=0A=
    controller: ['$scope', function ngSwitchController() {=0A=
     this.cases =3D {};=0A=
    }],=0A=
    link: function(scope, element, attr, ngSwitchController) {=0A=
      var watchExpr =3D attr.ngSwitch || attr.on,=0A=
          selectedTranscludes =3D [],=0A=
          selectedElements =3D [],=0A=
          previousLeaveAnimations =3D [],=0A=
          selectedScopes =3D [];=0A=
=0A=
      var spliceFactory =3D function(array, index) {=0A=
          return function() { array.splice(index, 1); };=0A=
      };=0A=
=0A=
      scope.$watch(watchExpr, function ngSwitchWatchAction(value) {=0A=
        var i, ii;=0A=
        for (i =3D 0, ii =3D previousLeaveAnimations.length; i &lt; ii; =
++i) {=0A=
          $animate.cancel(previousLeaveAnimations[i]);=0A=
        }=0A=
        previousLeaveAnimations.length =3D 0;=0A=
=0A=
        for (i =3D 0, ii =3D selectedScopes.length; i &lt; ii; ++i) {=0A=
          var selected =3D getBlockNodes(selectedElements[i].clone);=0A=
          selectedScopes[i].$destroy();=0A=
          var promise =3D previousLeaveAnimations[i] =3D =
$animate.leave(selected);=0A=
          promise.then(spliceFactory(previousLeaveAnimations, i));=0A=
        }=0A=
=0A=
        selectedElements.length =3D 0;=0A=
        selectedScopes.length =3D 0;=0A=
=0A=
        if ((selectedTranscludes =3D ngSwitchController.cases['!' + =
value] || ngSwitchController.cases['?'])) {=0A=
          forEach(selectedTranscludes, function(selectedTransclude) {=0A=
            selectedTransclude.transclude(function(caseElement, =
selectedScope) {=0A=
              selectedScopes.push(selectedScope);=0A=
              var anchor =3D selectedTransclude.element;=0A=
              caseElement[caseElement.length++] =3D =
document.createComment(' end ngSwitchWhen: ');=0A=
              var block =3D { clone: caseElement };=0A=
=0A=
              selectedElements.push(block);=0A=
              $animate.enter(caseElement, anchor.parent(), anchor);=0A=
            });=0A=
          });=0A=
        }=0A=
      });=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
var ngSwitchWhenDirective =3D ngDirective({=0A=
  transclude: 'element',=0A=
  priority: 1200,=0A=
  require: '^ngSwitch',=0A=
  multiElement: true,=0A=
  link: function(scope, element, attrs, ctrl, $transclude) {=0A=
    ctrl.cases['!' + attrs.ngSwitchWhen] =3D (ctrl.cases['!' + =
attrs.ngSwitchWhen] || []);=0A=
    ctrl.cases['!' + attrs.ngSwitchWhen].push({ transclude: $transclude, =
element: element });=0A=
  }=0A=
});=0A=
=0A=
var ngSwitchDefaultDirective =3D ngDirective({=0A=
  transclude: 'element',=0A=
  priority: 1200,=0A=
  require: '^ngSwitch',=0A=
  multiElement: true,=0A=
  link: function(scope, element, attr, ctrl, $transclude) {=0A=
    ctrl.cases['?'] =3D (ctrl.cases['?'] || []);=0A=
    ctrl.cases['?'].push({ transclude: $transclude, element: element });=0A=
   }=0A=
});=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name ngTransclude=0A=
 * @restrict EAC=0A=
 *=0A=
 * @description=0A=
 * Directive that marks the insertion point for the transcluded DOM of =
the nearest parent directive that uses transclusion.=0A=
 *=0A=
 * Any existing content of the element that this directive is placed on =
will be removed before the transcluded content is inserted.=0A=
 *=0A=
 * @element ANY=0A=
 *=0A=
 * @example=0A=
   &lt;example module=3D"transcludeExample"&gt;=0A=
     &lt;file name=3D"todoList.html"&gt;=0A=
       &lt;script&gt;=0A=
         angular.module('transcludeExample', [])=0A=
          .directive('pane', function(){=0A=
             return {=0A=
               restrict: 'E',=0A=
               transclude: true,=0A=
               scope: { title:'@' },=0A=
               template: '&lt;div style=3D"border: 1px solid =
black;"&gt;' +=0A=
                           '&lt;div style=3D"background-color: =
gray"&gt;{{title}}&lt;/div&gt;' +=0A=
                           '&lt;ng-transclude&gt;&lt;/ng-transclude&gt;' =
+=0A=
                         '&lt;/div&gt;'=0A=
             };=0A=
         })=0A=
         .controller('ExampleController', ['$scope', function($scope) {=0A=
           $scope.title =3D 'Lorem Ipsum';=0A=
           $scope.text =3D 'Neque porro quisquam est qui dolorem ipsum =
quia dolor...';=0A=
         }]);=0A=
       &lt;/script&gt;=0A=
       &lt;div ng-controller=3D"ExampleController"&gt;=0A=
         &lt;input ng-model=3D"title"&gt;&lt;br&gt;=0A=
         &lt;textarea ng-model=3D"text"&gt;&lt;/textarea&gt; &lt;br/&gt;=0A=
         &lt;pane title=3D"{{title}}"&gt;{{text}}&lt;/pane&gt;=0A=
       &lt;/div&gt;=0A=
     &lt;/file&gt;=0A=
     &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
        it('should have transcluded', function() {=0A=
          var titleElement =3D element(by.model('title'));=0A=
          titleElement.clear();=0A=
          titleElement.sendKeys('TITLE');=0A=
          var textElement =3D element(by.model('text'));=0A=
          textElement.clear();=0A=
          textElement.sendKeys('TEXT');=0A=
          =
expect(element(by.binding('title')).getText()).toEqual('TITLE');=0A=
          expect(element(by.binding('text')).getText()).toEqual('TEXT');=0A=
        });=0A=
     &lt;/file&gt;=0A=
   &lt;/example&gt;=0A=
 *=0A=
 */=0A=
var ngTranscludeDirective =3D ngDirective({=0A=
  restrict: 'EAC',=0A=
  link: function($scope, $element, $attrs, controller, $transclude) {=0A=
    if (!$transclude) {=0A=
      throw minErr('ngTransclude')('orphan',=0A=
       'Illegal use of ngTransclude directive in the template! ' +=0A=
       'No parent directive that requires a transclusion found. ' +=0A=
       'Element: {0}',=0A=
       startingTag($element));=0A=
    }=0A=
=0A=
    $transclude(function(clone) {=0A=
      $element.empty();=0A=
      $element.append(clone);=0A=
    });=0A=
  }=0A=
});=0A=
=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name script=0A=
 * @restrict E=0A=
 *=0A=
 * @description=0A=
 * Load the content of a `&lt;script&gt;` element into {@link =
ng.$templateCache `$templateCache`}, so that the=0A=
 * template can be used by {@link ng.directive:ngInclude `ngInclude`},=0A=
 * {@link ngRoute.directive:ngView `ngView`}, or {@link guide/directive =
directives}. The type of the=0A=
 * `&lt;script&gt;` element must be specified as `text/ng-template`, and =
a cache name for the template must be=0A=
 * assigned through the element's `id`, which can then be used as a =
directive's `templateUrl`.=0A=
 *=0A=
 * @param {string} type Must be set to `'text/ng-template'`.=0A=
 * @param {string} id Cache name of the template.=0A=
 *=0A=
 * @example=0A=
  &lt;example&gt;=0A=
    &lt;file name=3D"todoList.html"&gt;=0A=
      &lt;script type=3D"text/ng-template" id=3D"/tpl.html"&gt;=0A=
        Content of the template.=0A=
      &lt;/script&gt;=0A=
=0A=
      &lt;a ng-click=3D"currentTpl=3D'/tpl.html'" =
id=3D"tpl-link"&gt;Load inlined template&lt;/a&gt;=0A=
      &lt;div id=3D"tpl-content" ng-include =
src=3D"currentTpl"&gt;&lt;/div&gt;=0A=
    &lt;/file&gt;=0A=
    &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
      it('should load template defined inside script tag', function() {=0A=
        element(by.css('#tpl-link')).click();=0A=
        =
expect(element(by.css('#tpl-content')).getText()).toMatch(/Content of =
the template/);=0A=
      });=0A=
    &lt;/file&gt;=0A=
  &lt;/example&gt;=0A=
 */=0A=
var scriptDirective =3D ['$templateCache', function($templateCache) {=0A=
  return {=0A=
    restrict: 'E',=0A=
    terminal: true,=0A=
    compile: function(element, attr) {=0A=
      if (attr.type =3D=3D 'text/ng-template') {=0A=
        var templateUrl =3D attr.id,=0A=
            // IE is not consistent, in scripts we have to read .text =
but in other nodes we have to read .textContent=0A=
            text =3D element[0].text;=0A=
=0A=
        $templateCache.put(templateUrl, text);=0A=
      }=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
var ngOptionsMinErr =3D minErr('ngOptions');=0A=
/**=0A=
 * @ngdoc directive=0A=
 * @name select=0A=
 * @restrict E=0A=
 *=0A=
 * @description=0A=
 * HTML `SELECT` element with angular data-binding.=0A=
 *=0A=
 * # `ngOptions`=0A=
 *=0A=
 * The `ngOptions` attribute can be used to dynamically generate a list =
of `&lt;option&gt;`=0A=
 * elements for the `&lt;select&gt;` element using the array or object =
obtained by evaluating the=0A=
 * `ngOptions` comprehension_expression.=0A=
 *=0A=
 * When an item in the `&lt;select&gt;` menu is selected, the array =
element or object property=0A=
 * represented by the selected option will be bound to the model =
identified by the `ngModel`=0A=
 * directive.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * **Note:** `ngModel` compares by reference, not value. This is =
important when binding to an=0A=
 * array of objects. See an example [in this =
jsfiddle](http://jsfiddle.net/qWzTb/).=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * Optionally, a single hard-coded `&lt;option&gt;` element, with the =
value set to an empty string, can=0A=
 * be nested into the `&lt;select&gt;` element. This element will then =
represent the `null` or "not selected"=0A=
 * option. See example below for demonstration.=0A=
 *=0A=
 * &lt;div class=3D"alert alert-warning"&gt;=0A=
 * **Note:** `ngOptions` provides an iterator facility for the =
`&lt;option&gt;` element which should be used instead=0A=
 * of {@link ng.directive:ngRepeat ngRepeat} when you want the=0A=
 * `select` model to be bound to a non-string value. This is because an =
option element can only=0A=
 * be bound to string values at present.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * &lt;div class=3D"alert alert-info"&gt;=0A=
 * **Note:** Using `select as` will bind the result of the `select as` =
expression to the model, but=0A=
 * the value of the `&lt;select&gt;` and `&lt;option&gt;` html elements =
will be either the index (for array data sources)=0A=
 * or property name (for object data sources) of the value within the =
collection.=0A=
 * &lt;/div&gt;=0A=
 *=0A=
 * **Note:** Using `select as` together with `trackexpr` is not =
recommended.=0A=
 * Reasoning:=0A=
 * - Example: &amp;lt;select ng-options=3D"item.subItem as item.label =
for item in values track by item.id" ng-model=3D"selected"&amp;gt;=0A=
 *   values: [{id: 1, label: 'aLabel', subItem: {name: 'aSubItem'}}, =
{id: 2, label: 'bLabel', subItem: {name: 'bSubItem'}}],=0A=
 *   $scope.selected =3D {name: 'aSubItem'};=0A=
 * - track by is always applied to `value`, with the purpose of =
preserving the selection,=0A=
 *   (to `item` in this case)=0A=
 * - to calculate whether an item is selected we do the following:=0A=
 *   1. apply `track by` to the values in the array, e.g.=0A=
 *      In the example: [1,2]=0A=
 *   2. apply `track by` to the already selected value in `ngModel`:=0A=
 *      In the example: this is not possible, as `track by` refers to =
`item.id`, but the selected=0A=
 *      value from `ngModel` is `{name: aSubItem}`.=0A=
 *=0A=
 * @param {string} ngModel Assignable angular expression to data-bind to.=0A=
 * @param {string=3D} name Property name of the form under which the =
control is published.=0A=
 * @param {string=3D} required The control is considered valid only if =
value is entered.=0A=
 * @param {string=3D} ngRequired Adds `required` attribute and =
`required` validation constraint to=0A=
 *    the element when the ngRequired expression evaluates to true. Use =
`ngRequired` instead of=0A=
 *    `required` when you want to data-bind to the `required` attribute.=0A=
 * @param {comprehension_expression=3D} ngOptions in one of the =
following forms:=0A=
 *=0A=
 *   * for array data sources:=0A=
 *     * `label` **`for`** `value` **`in`** `array`=0A=
 *     * `select` **`as`** `label` **`for`** `value` **`in`** `array`=0A=
 *     * `label`  **`group by`** `group` **`for`** `value` **`in`** =
`array`=0A=
 *     * `select` **`as`** `label` **`group by`** `group` **`for`** =
`value` **`in`** `array` **`track by`** `trackexpr`=0A=
 *   * for object data sources:=0A=
 *     * `label` **`for (`**`key` **`,`** `value`**`) in`** `object`=0A=
 *     * `select` **`as`** `label` **`for (`**`key` **`,`** `value`**`) =
in`** `object`=0A=
 *     * `label` **`group by`** `group` **`for (`**`key`**`,`** =
`value`**`) in`** `object`=0A=
 *     * `select` **`as`** `label` **`group by`** `group`=0A=
 *         **`for` `(`**`key`**`,`** `value`**`) in`** `object`=0A=
 *=0A=
 * Where:=0A=
 *=0A=
 *   * `array` / `object`: an expression which evaluates to an array / =
object to iterate over.=0A=
 *   * `value`: local variable which will refer to each item in the =
`array` or each property value=0A=
 *      of `object` during iteration.=0A=
 *   * `key`: local variable which will refer to a property name in =
`object` during iteration.=0A=
 *   * `label`: The result of this expression will be the label for =
`&lt;option&gt;` element. The=0A=
 *     `expression` will most likely refer to the `value` variable (e.g. =
`value.propertyName`).=0A=
 *   * `select`: The result of this expression will be bound to the =
model of the parent `&lt;select&gt;`=0A=
 *      element. If not specified, `select` expression will default to =
`value`.=0A=
 *   * `group`: The result of this expression will be used to group =
options using the `&lt;optgroup&gt;`=0A=
 *      DOM element.=0A=
 *   * `trackexpr`: Used when working with an array of objects. The =
result of this expression will be=0A=
 *      used to identify the objects in the array. The `trackexpr` will =
most likely refer to the=0A=
 *     `value` variable (e.g. `value.propertyName`). With this the =
selection is preserved=0A=
 *      even when the options are recreated (e.g. reloaded from the =
server).=0A=
 *=0A=
 * @example=0A=
    &lt;example module=3D"selectExample"&gt;=0A=
      &lt;file name=3D"todoList.html"&gt;=0A=
        &lt;script&gt;=0A=
        angular.module('selectExample', [])=0A=
          .controller('ExampleController', ['$scope', function($scope) {=0A=
            $scope.colors =3D [=0A=
              {name:'black', shade:'dark'},=0A=
              {name:'white', shade:'light'},=0A=
              {name:'red', shade:'dark'},=0A=
              {name:'blue', shade:'dark'},=0A=
              {name:'yellow', shade:'light'}=0A=
            ];=0A=
            $scope.myColor =3D $scope.colors[2]; // red=0A=
          }]);=0A=
        &lt;/script&gt;=0A=
        &lt;div ng-controller=3D"ExampleController"&gt;=0A=
          &lt;ul&gt;=0A=
            &lt;li ng-repeat=3D"color in colors"&gt;=0A=
              Name: &lt;input ng-model=3D"color.name"&gt;=0A=
              [&lt;a href ng-click=3D"colors.splice($index, =
1)"&gt;X&lt;/a&gt;]=0A=
            &lt;/li&gt;=0A=
            &lt;li&gt;=0A=
              [&lt;a href ng-click=3D"colors.push({})"&gt;add&lt;/a&gt;]=0A=
            &lt;/li&gt;=0A=
          &lt;/ul&gt;=0A=
          &lt;hr/&gt;=0A=
          Color (null not allowed):=0A=
          &lt;select ng-model=3D"myColor" ng-options=3D"color.name for =
color in colors"&gt;&lt;/select&gt;&lt;br&gt;=0A=
=0A=
          Color (null allowed):=0A=
          &lt;span  class=3D"nullable"&gt;=0A=
            &lt;select ng-model=3D"myColor" ng-options=3D"color.name for =
color in colors"&gt;=0A=
              &lt;option value=3D""&gt;-- choose color --&lt;/option&gt;=0A=
            &lt;/select&gt;=0A=
          &lt;/span&gt;&lt;br/&gt;=0A=
=0A=
          Color grouped by shade:=0A=
          &lt;select ng-model=3D"myColor" ng-options=3D"color.name group =
by color.shade for color in colors"&gt;=0A=
          &lt;/select&gt;&lt;br/&gt;=0A=
=0A=
=0A=
          Select &lt;a href ng-click=3D"myColor =3D { name:'not in =
list', shade: 'other' }"&gt;bogus&lt;/a&gt;.&lt;br&gt;=0A=
          &lt;hr/&gt;=0A=
          Currently selected: {{ {selected_color:myColor} }}=0A=
          &lt;div style=3D"border:solid 1px black; height:20px"=0A=
               ng-style=3D"{'background-color':myColor.name}"&gt;=0A=
          &lt;/div&gt;=0A=
        &lt;/div&gt;=0A=
      &lt;/file&gt;=0A=
      &lt;file name=3D"protractor.js" type=3D"protractor"&gt;=0A=
         it('should check ng-options', function() {=0A=
           =
expect(element(by.binding('{selected_color:myColor}')).getText()).toMatch=
('red');=0A=
           element.all(by.model('myColor')).first().click();=0A=
           element.all(by.css('select[ng-model=3D"myColor"] =
option')).first().click();=0A=
           =
expect(element(by.binding('{selected_color:myColor}')).getText()).toMatch=
('black');=0A=
           element(by.css('.nullable =
select[ng-model=3D"myColor"]')).click();=0A=
           element.all(by.css('.nullable select[ng-model=3D"myColor"] =
option')).first().click();=0A=
           =
expect(element(by.binding('{selected_color:myColor}')).getText()).toMatch=
('null');=0A=
         });=0A=
      &lt;/file&gt;=0A=
    &lt;/example&gt;=0A=
 */=0A=
=0A=
var ngOptionsDirective =3D valueFn({=0A=
  restrict: 'A',=0A=
  terminal: true=0A=
});=0A=
=0A=
// jshint maxlen: false=0A=
var selectDirective =3D ['$compile', '$parse', function($compile,   =
$parse) {=0A=
                         =
//00001111111111000000000002222222222000000000000000000000333333333300000=
0000000004444444444444440000000005555555555555550000000666666666666666000=
000000000000777777777700000000000000000008888888888=0A=
  var NG_OPTIONS_REGEXP =3D =
/^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?\s+f=
or\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\=
)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/,=0A=
      nullModelCtrl =3D {$setViewValue: noop};=0A=
// jshint maxlen: 100=0A=
=0A=
  return {=0A=
    restrict: 'E',=0A=
    require: ['select', '?ngModel'],=0A=
    controller: ['$element', '$scope', '$attrs', function($element, =
$scope, $attrs) {=0A=
      var self =3D this,=0A=
          optionsMap =3D {},=0A=
          ngModelCtrl =3D nullModelCtrl,=0A=
          nullOption,=0A=
          unknownOption;=0A=
=0A=
=0A=
      self.databound =3D $attrs.ngModel;=0A=
=0A=
=0A=
      self.init =3D function(ngModelCtrl_, nullOption_, unknownOption_) {=0A=
        ngModelCtrl =3D ngModelCtrl_;=0A=
        nullOption =3D nullOption_;=0A=
        unknownOption =3D unknownOption_;=0A=
      };=0A=
=0A=
=0A=
      self.addOption =3D function(value, element) {=0A=
        assertNotHasOwnProperty(value, '"option value"');=0A=
        optionsMap[value] =3D true;=0A=
=0A=
        if (ngModelCtrl.$viewValue =3D=3D value) {=0A=
          $element.val(value);=0A=
          if (unknownOption.parent()) unknownOption.remove();=0A=
        }=0A=
        // Workaround for =
https://code.google.com/p/chromium/issues/detail?id=3D381459=0A=
        // Adding an &lt;option selected=3D"selected"&gt; element to a =
&lt;select required=3D"required"&gt; should=0A=
        // automatically select the new element=0A=
        if (element &amp;&amp; element[0].hasAttribute('selected')) {=0A=
          element[0].selected =3D true;=0A=
        }=0A=
      };=0A=
=0A=
=0A=
      self.removeOption =3D function(value) {=0A=
        if (this.hasOption(value)) {=0A=
          delete optionsMap[value];=0A=
          if (ngModelCtrl.$viewValue =3D=3D value) {=0A=
            this.renderUnknownOption(value);=0A=
          }=0A=
        }=0A=
      };=0A=
=0A=
=0A=
      self.renderUnknownOption =3D function(val) {=0A=
        var unknownVal =3D '? ' + hashKey(val) + ' ?';=0A=
        unknownOption.val(unknownVal);=0A=
        $element.prepend(unknownOption);=0A=
        $element.val(unknownVal);=0A=
        unknownOption.prop('selected', true); // needed for IE=0A=
      };=0A=
=0A=
=0A=
      self.hasOption =3D function(value) {=0A=
        return optionsMap.hasOwnProperty(value);=0A=
      };=0A=
=0A=
      $scope.$on('$destroy', function() {=0A=
        // disable unknown option so that we don't do work when the =
whole select is being destroyed=0A=
        self.renderUnknownOption =3D noop;=0A=
      });=0A=
    }],=0A=
=0A=
    link: function(scope, element, attr, ctrls) {=0A=
      // if ngModel is not defined, we don't need to do anything=0A=
      if (!ctrls[1]) return;=0A=
=0A=
      var selectCtrl =3D ctrls[0],=0A=
          ngModelCtrl =3D ctrls[1],=0A=
          multiple =3D attr.multiple,=0A=
          optionsExp =3D attr.ngOptions,=0A=
          nullOption =3D false, // if false, user will not be able to =
select it (used by ngOptions)=0A=
          emptyOption,=0A=
          renderScheduled =3D false,=0A=
          // we can't just jqLite('&lt;option&gt;') since jqLite is not =
smart enough=0A=
          // to create it in &lt;select&gt; and IE barfs otherwise.=0A=
          optionTemplate =3D jqLite(document.createElement('option')),=0A=
          optGroupTemplate =3DjqLite(document.createElement('optgroup')),=0A=
          unknownOption =3D optionTemplate.clone();=0A=
=0A=
      // find "null" option=0A=
      for(var i =3D 0, children =3D element.children(), ii =3D =
children.length; i &lt; ii; i++) {=0A=
        if (children[i].value =3D=3D=3D '') {=0A=
          emptyOption =3D nullOption =3D children.eq(i);=0A=
          break;=0A=
        }=0A=
      }=0A=
=0A=
      selectCtrl.init(ngModelCtrl, nullOption, unknownOption);=0A=
=0A=
      // required validator=0A=
      if (multiple) {=0A=
        ngModelCtrl.$isEmpty =3D function(value) {=0A=
          return !value || value.length =3D=3D=3D 0;=0A=
        };=0A=
      }=0A=
=0A=
      if (optionsExp) setupAsOptions(scope, element, ngModelCtrl);=0A=
      else if (multiple) setupAsMultiple(scope, element, ngModelCtrl);=0A=
      else setupAsSingle(scope, element, ngModelCtrl, selectCtrl);=0A=
=0A=
=0A=
      ////////////////////////////=0A=
=0A=
=0A=
=0A=
      function setupAsSingle(scope, selectElement, ngModelCtrl, =
selectCtrl) {=0A=
        ngModelCtrl.$render =3D function() {=0A=
          var viewValue =3D ngModelCtrl.$viewValue;=0A=
=0A=
          if (selectCtrl.hasOption(viewValue)) {=0A=
            if (unknownOption.parent()) unknownOption.remove();=0A=
            selectElement.val(viewValue);=0A=
            if (viewValue =3D=3D=3D '') emptyOption.prop('selected', =
true); // to make IE9 happy=0A=
          } else {=0A=
            if (isUndefined(viewValue) &amp;&amp; emptyOption) {=0A=
              selectElement.val('');=0A=
            } else {=0A=
              selectCtrl.renderUnknownOption(viewValue);=0A=
            }=0A=
          }=0A=
        };=0A=
=0A=
        selectElement.on('change', function() {=0A=
          scope.$apply(function() {=0A=
            if (unknownOption.parent()) unknownOption.remove();=0A=
            ngModelCtrl.$setViewValue(selectElement.val());=0A=
          });=0A=
        });=0A=
      }=0A=
=0A=
      function setupAsMultiple(scope, selectElement, ctrl) {=0A=
        var lastView;=0A=
        ctrl.$render =3D function() {=0A=
          var items =3D new HashMap(ctrl.$viewValue);=0A=
          forEach(selectElement.find('option'), function(option) {=0A=
            option.selected =3D isDefined(items.get(option.value));=0A=
          });=0A=
        };=0A=
=0A=
        // we have to do it on each watch since ngModel watches =
reference, but=0A=
        // we need to work of an array, so we need to see if anything =
was inserted/removed=0A=
        scope.$watch(function selectMultipleWatch() {=0A=
          if (!equals(lastView, ctrl.$viewValue)) {=0A=
            lastView =3D shallowCopy(ctrl.$viewValue);=0A=
            ctrl.$render();=0A=
          }=0A=
        });=0A=
=0A=
        selectElement.on('change', function() {=0A=
          scope.$apply(function() {=0A=
            var array =3D [];=0A=
            forEach(selectElement.find('option'), function(option) {=0A=
              if (option.selected) {=0A=
                array.push(option.value);=0A=
              }=0A=
            });=0A=
            ctrl.$setViewValue(array);=0A=
          });=0A=
        });=0A=
      }=0A=
=0A=
      function setupAsOptions(scope, selectElement, ctrl) {=0A=
        var match;=0A=
=0A=
        if (!(match =3D optionsExp.match(NG_OPTIONS_REGEXP))) {=0A=
          throw ngOptionsMinErr('iexp',=0A=
            "Expected expression in form of " +=0A=
            "'_select_ (as _label_)? for (_key_,)?_value_ in =
_collection_'" +=0A=
            " but got '{0}'. Element: {1}",=0A=
            optionsExp, startingTag(selectElement));=0A=
        }=0A=
=0A=
        var displayFn =3D $parse(match[2] || match[1]),=0A=
            valueName =3D match[4] || match[6],=0A=
            selectAs =3D / as /.test(match[0]) &amp;&amp; match[1],=0A=
            selectAsFn =3D selectAs ? $parse(selectAs) : null,=0A=
            keyName =3D match[5],=0A=
            groupByFn =3D $parse(match[3] || ''),=0A=
            valueFn =3D $parse(match[2] ? match[1] : valueName),=0A=
            valuesFn =3D $parse(match[7]),=0A=
            track =3D match[8],=0A=
            trackFn =3D track ? $parse(match[8]) : null,=0A=
            // This is an array of array of existing option groups in =
DOM.=0A=
            // We try to reuse these if possible=0A=
            // - optionGroupsCache[0] is the options with no option group=0A=
            // - optionGroupsCache[?][0] is the parent: either the =
SELECT or OPTGROUP element=0A=
            optionGroupsCache =3D [[{element: selectElement, label:''}]],=0A=
            //re-usable object to represent option's locals=0A=
            locals =3D {};=0A=
=0A=
        if (nullOption) {=0A=
          // compile the element since there might be bindings in it=0A=
          $compile(nullOption)(scope);=0A=
=0A=
          // remove the class, which is added automatically because we =
recompile the element and it=0A=
          // becomes the compilation root=0A=
          nullOption.removeClass('ng-scope');=0A=
=0A=
          // we need to remove it before calling selectElement.empty() =
because otherwise IE will=0A=
          // remove the label from the element. wtf?=0A=
          nullOption.remove();=0A=
        }=0A=
=0A=
        // clear contents, we'll add what's needed based on the model=0A=
        selectElement.empty();=0A=
=0A=
        selectElement.on('change', selectionChanged);=0A=
=0A=
        ctrl.$render =3D render;=0A=
=0A=
        scope.$watchCollection(valuesFn, scheduleRendering);=0A=
        scope.$watchCollection(getLabels, scheduleRendering);=0A=
=0A=
        if (multiple) {=0A=
          scope.$watchCollection(function() { return ctrl.$modelValue; =
}, scheduleRendering);=0A=
        }=0A=
=0A=
        // =
------------------------------------------------------------------ //=0A=
=0A=
        function callExpression(exprFn, key, value) {=0A=
          locals[valueName] =3D value;=0A=
          if (keyName) locals[keyName] =3D key;=0A=
          return exprFn(scope, locals);=0A=
        }=0A=
=0A=
        function selectionChanged() {=0A=
          scope.$apply(function() {=0A=
            var optionGroup,=0A=
                collection =3D valuesFn(scope) || [],=0A=
                key, value, optionElement, index, groupIndex, length, =
groupLength, trackIndex;=0A=
            var viewValue;=0A=
            if (multiple) {=0A=
              viewValue =3D [];=0A=
              forEach(selectElement.val(), function(selectedKey) {=0A=
                viewValue.push(getViewValue(selectedKey, =
collection[selectedKey]));=0A=
              });=0A=
            } else {=0A=
              var selectedKey =3D selectElement.val();=0A=
              viewValue =3D getViewValue(selectedKey, =
collection[selectedKey]);=0A=
            }=0A=
            ctrl.$setViewValue(viewValue);=0A=
            render();=0A=
          });=0A=
        }=0A=
=0A=
        function getViewValue(key, value) {=0A=
          if (key =3D=3D=3D '?') {=0A=
            return undefined;=0A=
          } else if (key =3D=3D=3D '') {=0A=
            return null;=0A=
          } else {=0A=
            var viewValueFn =3D selectAsFn ? selectAsFn : valueFn;=0A=
            return callExpression(viewValueFn, key, value);=0A=
          }=0A=
        }=0A=
=0A=
        function getLabels() {=0A=
          var values =3D valuesFn(scope);=0A=
          var toDisplay;=0A=
          if (values &amp;&amp; isArray(values)) {=0A=
            toDisplay =3D new Array(values.length);=0A=
            for (var i =3D 0, ii =3D values.length; i &lt; ii; i++) {=0A=
              toDisplay[i] =3D callExpression(displayFn, i, values[i]);=0A=
            }=0A=
            return toDisplay;=0A=
          } else if (values) {=0A=
            // TODO: Add a test for this case=0A=
            toDisplay =3D {};=0A=
            for (var prop in values) {=0A=
              if (values.hasOwnProperty(prop)) {=0A=
                toDisplay[prop] =3D callExpression(displayFn, prop, =
values[prop]);=0A=
              }=0A=
            }=0A=
          }=0A=
          return toDisplay;=0A=
        }=0A=
=0A=
        function createIsSelectedFn(viewValue) {=0A=
          var selectedSet;=0A=
          if (multiple) {=0A=
            if (trackFn &amp;&amp; isArray(viewValue)) {=0A=
=0A=
              selectedSet =3D new HashMap([]);=0A=
              for (var trackIndex =3D 0; trackIndex &lt; =
viewValue.length; trackIndex++) {=0A=
                // tracking by key=0A=
                selectedSet.put(callExpression(trackFn, null, =
viewValue[trackIndex]), true);=0A=
              }=0A=
            } else {=0A=
              selectedSet =3D new HashMap(viewValue);=0A=
            }=0A=
          } else if (trackFn) {=0A=
            viewValue =3D callExpression(trackFn, null, viewValue);=0A=
          }=0A=
=0A=
          return function isSelected(key, value) {=0A=
            var compareValueFn;=0A=
            if (trackFn) {=0A=
              compareValueFn =3D trackFn;=0A=
            } else if (selectAsFn) {=0A=
              compareValueFn =3D selectAsFn;=0A=
            } else {=0A=
              compareValueFn =3D valueFn;=0A=
            }=0A=
=0A=
            if (multiple) {=0A=
              return =
isDefined(selectedSet.remove(callExpression(compareValueFn, key, =
value)));=0A=
            } else {=0A=
              return viewValue =3D=3D callExpression(compareValueFn, =
key, value);=0A=
            }=0A=
          };=0A=
        }=0A=
=0A=
        function scheduleRendering() {=0A=
          if (!renderScheduled) {=0A=
            scope.$$postDigest(render);=0A=
            renderScheduled =3D true;=0A=
          }=0A=
        }=0A=
=0A=
        /**=0A=
         * A new labelMap is created with each render.=0A=
         * This function is called for each existing option with =
added=3Dfalse,=0A=
         * and each new option with added=3Dtrue.=0A=
         * - Labels that are passed to this method twice,=0A=
         * (once with added=3Dtrue and once with added=3Dfalse) will end =
up with a value of 0, and=0A=
         * will cause no change to happen to the corresponding option.=0A=
         * - Labels that are passed to this method only once with =
added=3Dfalse will end up with a=0A=
         * value of -1 and will eventually be passed to =
selectCtrl.removeOption()=0A=
         * - Labels that are passed to this method only once with =
added=3Dtrue will end up with a=0A=
         * value of 1 and will eventually be passed to =
selectCtrl.addOption()=0A=
        */=0A=
        function updateLabelMap(labelMap, label, added) {=0A=
          labelMap[label] =3D labelMap[label] || 0;=0A=
          labelMap[label] +=3D (added ? 1 : -1);=0A=
        }=0A=
=0A=
        function render() {=0A=
          renderScheduled =3D false;=0A=
=0A=
          // Temporary location for the option groups before we render =
them=0A=
          var optionGroups =3D {'':[]},=0A=
              optionGroupNames =3D [''],=0A=
              optionGroupName,=0A=
              optionGroup,=0A=
              option,=0A=
              existingParent, existingOptions, existingOption,=0A=
              viewValue =3D ctrl.$viewValue,=0A=
              values =3D valuesFn(scope) || [],=0A=
              keys =3D keyName ? sortedKeys(values) : values,=0A=
              key,=0A=
              value,=0A=
              groupLength, length,=0A=
              groupIndex, index,=0A=
              labelMap =3D {},=0A=
              selected,=0A=
              isSelected =3D createIsSelectedFn(viewValue),=0A=
              anySelected =3D false,=0A=
              lastElement,=0A=
              element,=0A=
              label;=0A=
=0A=
          // We now build up the list of options we need (we merge later)=0A=
          for (index =3D 0; length =3D keys.length, index &lt; length; =
index++) {=0A=
            key =3D index;=0A=
            if (keyName) {=0A=
              key =3D keys[index];=0A=
              if ( key.charAt(0) =3D=3D=3D '$' ) continue;=0A=
            }=0A=
            value =3D values[key];=0A=
=0A=
            optionGroupName =3D callExpression(groupByFn, key, value) || =
'';=0A=
            if (!(optionGroup =3D optionGroups[optionGroupName])) {=0A=
              optionGroup =3D optionGroups[optionGroupName] =3D [];=0A=
              optionGroupNames.push(optionGroupName);=0A=
            }=0A=
=0A=
            selected =3D isSelected(key, value);=0A=
            anySelected =3D anySelected || selected;=0A=
=0A=
            label =3D callExpression(displayFn, key, value); // what =
will be seen by the user=0A=
=0A=
            // doing displayFn(scope, locals) || '' overwrites zero =
values=0A=
            label =3D isDefined(label) ? label : '';=0A=
            optionGroup.push({=0A=
              // either the index into array or key from object=0A=
              id: (keyName ? keys[index] : index),=0A=
              label: label,=0A=
              selected: selected                   // determine if we =
should be selected=0A=
            });=0A=
          }=0A=
          if (!multiple) {=0A=
            if (nullOption || viewValue =3D=3D=3D null) {=0A=
              // insert null option if we have a placeholder, or the =
model is null=0A=
              optionGroups[''].unshift({id:'', label:'', =
selected:!anySelected});=0A=
            } else if (!anySelected) {=0A=
              // option could not be found, we have to insert the =
undefined item=0A=
              optionGroups[''].unshift({id:'?', label:'', =
selected:true});=0A=
            }=0A=
          }=0A=
=0A=
          // Now we need to update the list of DOM nodes to match the =
optionGroups we computed above=0A=
          for (groupIndex =3D 0, groupLength =3D optionGroupNames.length;=0A=
               groupIndex &lt; groupLength;=0A=
               groupIndex++) {=0A=
            // current option group name or '' if no group=0A=
            optionGroupName =3D optionGroupNames[groupIndex];=0A=
=0A=
            // list of options for that group. (first item has the =
parent)=0A=
            optionGroup =3D optionGroups[optionGroupName];=0A=
=0A=
            if (optionGroupsCache.length &lt;=3D groupIndex) {=0A=
              // we need to grow the optionGroups=0A=
              existingParent =3D {=0A=
                element: optGroupTemplate.clone().attr('label', =
optionGroupName),=0A=
                label: optionGroup.label=0A=
              };=0A=
              existingOptions =3D [existingParent];=0A=
              optionGroupsCache.push(existingOptions);=0A=
              selectElement.append(existingParent.element);=0A=
            } else {=0A=
              existingOptions =3D optionGroupsCache[groupIndex];=0A=
              existingParent =3D existingOptions[0];  // either SELECT =
(no group) or OPTGROUP element=0A=
=0A=
              // update the OPTGROUP label if not the same.=0A=
              if (existingParent.label !=3D optionGroupName) {=0A=
                existingParent.element.attr('label', =
existingParent.label =3D optionGroupName);=0A=
              }=0A=
            }=0A=
=0A=
            lastElement =3D null;  // start at the beginning=0A=
            for(index =3D 0, length =3D optionGroup.length; index &lt; =
length; index++) {=0A=
              option =3D optionGroup[index];=0A=
              if ((existingOption =3D existingOptions[index+1])) {=0A=
                // reuse elements=0A=
                lastElement =3D existingOption.element;=0A=
                if (existingOption.label !=3D=3D option.label) {=0A=
                  updateLabelMap(labelMap, existingOption.label, false);=0A=
                  updateLabelMap(labelMap, option.label, true);=0A=
                  lastElement.text(existingOption.label =3D =
option.label);=0A=
                }=0A=
                if (existingOption.id !=3D=3D option.id) {=0A=
                  lastElement.val(existingOption.id =3D option.id);=0A=
                }=0A=
                // lastElement.prop('selected') provided by jQuery has =
side-effects=0A=
                if (lastElement[0].selected !=3D=3D option.selected) {=0A=
                  lastElement.prop('selected', (existingOption.selected =
=3D option.selected));=0A=
                  if (msie) {=0A=
                    // See #7692=0A=
                    // The selected item wouldn't visually update on IE =
without this.=0A=
                    // Tested on Win7: IE9, IE10 and IE11. Future IEs =
should be tested as well=0A=
                    lastElement.prop('selected', =
existingOption.selected);=0A=
                  }=0A=
                }=0A=
              } else {=0A=
                // grow elements=0A=
=0A=
                // if it's a null option=0A=
                if (option.id =3D=3D=3D '' &amp;&amp; nullOption) {=0A=
                  // put back the pre-compiled element=0A=
                  element =3D nullOption;=0A=
                } else {=0A=
                  // jQuery(v1.4.2) Bug: We should be able to chain the =
method calls, but=0A=
                  // in this version of jQuery on some browser the =
.text() returns a string=0A=
                  // rather then the element.=0A=
                  (element =3D optionTemplate.clone())=0A=
                      .val(option.id)=0A=
                      .prop('selected', option.selected)=0A=
                      .attr('selected', option.selected)=0A=
                      .text(option.label);=0A=
                }=0A=
=0A=
                existingOptions.push(existingOption =3D {=0A=
                    element: element,=0A=
                    label: option.label,=0A=
                    id: option.id,=0A=
                    selected: option.selected=0A=
                });=0A=
                updateLabelMap(labelMap, option.label, true);=0A=
                if (lastElement) {=0A=
                  lastElement.after(element);=0A=
                } else {=0A=
                  existingParent.element.append(element);=0A=
                }=0A=
                lastElement =3D element;=0A=
              }=0A=
            }=0A=
            // remove any excessive OPTIONs in a group=0A=
            index++; // increment since the existingOptions[0] is parent =
element not OPTION=0A=
            while(existingOptions.length &gt; index) {=0A=
              option =3D existingOptions.pop();=0A=
              updateLabelMap(labelMap, option.label, false);=0A=
              option.element.remove();=0A=
            }=0A=
            forEach(labelMap, function (count, label) {=0A=
              if (count &gt; 0) {=0A=
                selectCtrl.addOption(label);=0A=
              } else if (count &lt; 0) {=0A=
                selectCtrl.removeOption(label);=0A=
              }=0A=
            });=0A=
          }=0A=
          // remove any excessive OPTGROUPs from select=0A=
          while(optionGroupsCache.length &gt; groupIndex) {=0A=
            optionGroupsCache.pop()[0].element.remove();=0A=
          }=0A=
        }=0A=
      }=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
var optionDirective =3D ['$interpolate', function($interpolate) {=0A=
  var nullSelectCtrl =3D {=0A=
    addOption: noop,=0A=
    removeOption: noop=0A=
  };=0A=
=0A=
  return {=0A=
    restrict: 'E',=0A=
    priority: 100,=0A=
    compile: function(element, attr) {=0A=
      if (isUndefined(attr.value)) {=0A=
        var interpolateFn =3D $interpolate(element.text(), true);=0A=
        if (!interpolateFn) {=0A=
          attr.$set('value', element.text());=0A=
        }=0A=
      }=0A=
=0A=
      return function (scope, element, attr) {=0A=
        var selectCtrlName =3D '$selectController',=0A=
            parent =3D element.parent(),=0A=
            selectCtrl =3D parent.data(selectCtrlName) ||=0A=
              parent.parent().data(selectCtrlName); // in case we are in =
optgroup=0A=
=0A=
        if (!selectCtrl || !selectCtrl.databound) {=0A=
          selectCtrl =3D nullSelectCtrl;=0A=
        }=0A=
=0A=
        if (interpolateFn) {=0A=
          scope.$watch(interpolateFn, function =
interpolateWatchAction(newVal, oldVal) {=0A=
            attr.$set('value', newVal);=0A=
            if (oldVal !=3D=3D newVal) {=0A=
              selectCtrl.removeOption(oldVal);=0A=
            }=0A=
            selectCtrl.addOption(newVal, element);=0A=
          });=0A=
        } else {=0A=
          selectCtrl.addOption(attr.value, element);=0A=
        }=0A=
=0A=
        element.on('$destroy', function() {=0A=
          selectCtrl.removeOption(attr.value);=0A=
        });=0A=
      };=0A=
    }=0A=
  };=0A=
}];=0A=
=0A=
var styleDirective =3D valueFn({=0A=
  restrict: 'E',=0A=
  terminal: false=0A=
});=0A=
=0A=
  if (window.angular.bootstrap) {=0A=
    //AngularJS is already loaded, so we can return here...=0A=
    console.log('WARNING: Tried to load angular more than once.');=0A=
    return;=0A=
  }=0A=
=0A=
  //try to bind to jquery now so that one can write =
jqLite(document).ready()=0A=
  //but we will rebind on bootstrap again.=0A=
  bindJQuery();=0A=
=0A=
  publishExternalAPI(angular);=0A=
=0A=
  jqLite(document).ready(function() {=0A=
    angularInit(document, bootstrap);=0A=
  });=0A=
=0A=
})(window, document);=0A=
=0A=
!window.angular.$$csp() &amp;&amp; =
window.angular.element(document).find('head').prepend('&lt;style =
type=3D"text/css"&gt;@charset =
"UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x=
-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none =
!important;}ng\\:form{display:block;}&lt;/style&gt;');</PRE></BODY></HTML=
>
